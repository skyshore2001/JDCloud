<html>
<head>
<meta charset="utf-8">
<title>API参考 - 筋斗云前端（移动Web版）</title>
<style>
h3,h4,h5,h6 {
	font-size: 1em;
}

pre {
	border-left: 1px solid #ccc;
	margin: 0 1em;
	padding: 0 0.5em;
	tab-size:4;
}

code {
	font-family: "Courier New";
    padding: 0px 3px;
    display: inline-block;
}

.toc {
	margin: 2em;
}

.toc p {
	margin: 0.3em 0;
}

.block {
	border-bottom: 1px solid #ccc;
}

</style>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="doc.css" />
<script src="refdoc.js"></script>
</head>

<body>
<h1>API参考 - 筋斗云前端（移动Web版）</h1>
<div>最后更新：2021-03-01</div>
<div id="menu">
<h2>Modules</h2>
<div class="toc">
<p><a href="#MUI">MUI (module)</a></p>
</div><hr>
<h2>Keywords</h2>
<div class="toc">
<p><a href="##footer">#footer (key)</a></p>
<p><a href="##muiAlert">#muiAlert (key)</a></p>
<p><a href="#$.Deferred">$.Deferred (fn)</a></p>
<p><a href="#$.ajax">$.ajax (key)</a></p>
<p><a href="#.bd">.bd (key)</a></p>
<p><a href="#.btn-icon">.btn-icon (key)</a></p>
<p><a href="#.ft">.ft (key)</a></p>
<p><a href="#.hd">.hd (key)</a></p>
<p><a href="#.mui-android">.mui-android (key)</a></p>
<p><a href="#.mui-container">.mui-container (key)</a></p>
<p><a href="#.mui-cordova">.mui-cordova (key)</a></p>
<p><a href="#.mui-dialog">.mui-dialog (key)</a></p>
<p><a href="#.mui-ios">.mui-ios (key)</a></p>
<p><a href="#.mui-menu">.mui-menu (key)</a></p>
<p><a href="#.mui-navbar">.mui-navbar (key)</a></p>
<p><a href="#.mui-navbar.noactive">.mui-navbar.noactive (key)</a></p>
<p><a href="#.mui-noPull">.mui-noPull (key)</a></p>
<p><a href="#.mui-page">.mui-page (key)</a></p>
<p><a href="#.mui-pullHint">.mui-pullHint (key)</a></p>
<p><a href="#.mui-weixin">.mui-weixin (key)</a></p>
<p><a href="#.noSwipe">.noSwipe (key)</a></p>
<p><a href="#Date.add">Date.add (fn)</a></p>
<p><a href="#Date.addDay">Date.addDay (fn)</a></p>
<p><a href="#Date.addHours">Date.addHours (fn)</a></p>
<p><a href="#Date.addMin">Date.addMin (fn)</a></p>
<p><a href="#Date.addMonth">Date.addMonth (fn)</a></p>
<p><a href="#Date.diff">Date.diff (fn)</a></p>
<p><a href="#Date.format">Date.format (fn)</a></p>
<p><a href="#DirectReturn">DirectReturn (class)</a></p>
<p><a href="#FormMode">FormMode (var)</a></p>
<p><a href="#MUI">MUI (module)</a></p>
<p><a href="#MUI.UploadPic">MUI.UploadPic (class)</a></p>
<p><a href="#MUI.setTopbarColor">MUI.setTopbarColor (fn)</a></p>
<p><a href="#Plugins">Plugins (class)</a></p>
<p><a href="#Plugins.exists">Plugins.exists (fn)</a></p>
<p><a href="#Plugins.list">Plugins.list (fn)</a></p>
<p><a href="#Promise">Promise (alias)</a></p>
<p><a href="#Q">Q (fn)</a></p>
<p><a href="#STORAGE_PREFIX">STORAGE_PREFIX (var)</a></p>
<p><a href="#WUI.getTmRange">WUI.getTmRange (fn)</a></p>
<p><a href="#activePage">activePage (var)</a></p>
<p><a href="#ajaxOpt.jdFilter">ajaxOpt.jdFilter (key)</a></p>
<p><a href="#app_abort">app_abort (fn)</a></p>
<p><a href="#app_alert">app_alert (fn)</a></p>
<p><a href="#appendParam">appendParam (fn)</a></p>
<p><a href="#applyTpl">applyTpl (fn)</a></p>
<p><a href="#assert">assert (fn)</a></p>
<p><a href="#autoLogin">autoLogin (event)</a></p>
<p><a href="#batchCall">batchCall (class)</a></p>
<p><a href="#callSvr">callSvr (fn)</a></p>
<p><a href="#callSvr.noex">callSvr.noex (key)</a></p>
<p><a href="#callSvrExt">callSvrExt (key)</a></p>
<p><a href="#callSvrExt['default']">callSvrExt['default'] (key)</a></p>
<p><a href="#callSvrExt[].beforeSend">callSvrExt[].beforeSend (key)</a></p>
<p><a href="#callSvrExt[].dataFilter">callSvrExt[].dataFilter (key)</a></p>
<p><a href="#callSvrExt[].makeUrl">callSvrExt[].makeUrl (key)</a></p>
<p><a href="#callSvrSync">callSvrSync (fn)</a></p>
<p><a href="#changepic">changepic (event)</a></p>
<p><a href="#closeDialog">closeDialog (fn)</a></p>
<p><a href="#compressImg">compressImg (fn)</a></p>
<p><a href="#container">container (var)</a></p>
<p><a href="#data-options">data-options (key)</a></p>
<p><a href="#defDataProc">defDataProc (fn)</a></p>
<p><a href="#defaultFormItems">defaultFormItems (key)</a></p>
<p><a href="#delCookie">delCookie (fn)</a></p>
<p><a href="#delStorage">delStorage (fn)</a></p>
<p><a href="#delayDo">delayDo (fn)</a></p>
<p><a href="#deleteParam">deleteParam (fn)</a></p>
<p><a href="#deleteUrlParam">deleteUrlParam (fn)</a></p>
<p><a href="#deviceready">deviceready (key)</a></p>
<p><a href="#disableBatch">disableBatch (var)</a></p>
<p><a href="#doSpecial">doSpecial (fn)</a></p>
<p><a href="#enhanceWithin">enhanceWithin (fn)</a></p>
<p><a href="#enterWaiting">enterWaiting (fn)</a></p>
<p><a href="#evalAttr">evalAttr (fn)</a></p>
<p><a href="#example-list-choose">example-list-choose (key)</a></p>
<p><a href="#example-upload">example-upload (key)</a></p>
<p><a href="#filterCordovaModule">filterCordovaModule (fn)</a></p>
<p><a href="#formItems">formItems (fn)</a></p>
<p><a href="#formatField">formatField (fn)</a></p>
<p><a href="#g_args">g_args (var)</a></p>
<p><a href="#g_args.enableSwitchApp">g_args.enableSwitchApp (key)</a></p>
<p><a href="#g_cordova">g_cordova (var)</a></p>
<p><a href="#g_data">g_data (var)</a></p>
<p><a href="#g_data.initClient">g_data.initClient (key)</a></p>
<p><a href="#g_data.serverRev">g_data.serverRev (key)</a></p>
<p><a href="#g_data.testMode,g_data.mockMode">g_data.testMode,g_data.mockMode (key)</a></p>
<p><a href="#g_data.userInfo">g_data.userInfo (key)</a></p>
<p><a href="#getAncestor">getAncestor (fn)</a></p>
<p><a href="#getBaseUrl">getBaseUrl (fn)</a></p>
<p><a href="#getCookie">getCookie (fn)</a></p>
<p><a href="#getDataOptions">getDataOptions (fn)</a></p>
<p><a href="#getFormData">getFormData (fn)</a></p>
<p><a href="#getFormData_vf">getFormData_vf (fn)</a></p>
<p><a href="#getOptions">getOptions (fn)</a></p>
<p><a href="#getQueryCond">getQueryCond (fn)</a></p>
<p><a href="#getQueryParam">getQueryParam (fn)</a></p>
<p><a href="#getStorage">getStorage (fn)</a></p>
<p><a href="#getTimeDiffDscr">getTimeDiffDscr (fn)</a></p>
<p><a href="#getToPageId">getToPageId (fn)</a></p>
<p><a href="#handleLogin">handleLogin (fn)</a></p>
<p><a href="#hd_back">hd_back (fn)</a></p>
<p><a href="#hideLoading">hideLoading (fn)</a></p>
<p><a href="#initClient">initClient (fn)</a></p>
<p><a href="#initNavbarAndList">initNavbarAndList (alias)</a></p>
<p><a href="#initPageDetail">initPageDetail (fn)</a></p>
<p><a href="#initPageList">initPageList (fn)</a></p>
<p><a href="#initPageList.options">initPageList.options (key)</a></p>
<p><a href="#initPullList">initPullList (fn)</a></p>
<p><a href="#intSort">intSort (fn)</a></p>
<p><a href="#isAndroid">isAndroid (fn)</a></p>
<p><a href="#isBusy">isBusy (var)</a></p>
<p><a href="#isIOS">isIOS (fn)</a></p>
<p><a href="#isWeixin">isWeixin (fn)</a></p>
<p><a href="#jQuery.fn.jdata">jQuery.fn.jdata (fn)</a></p>
<p><a href="#jdModule">jdModule (fn)</a></p>
<p><a href="#kvList2Str">kvList2Str (fn)</a></p>
<p><a href="#lastError">lastError (var)</a></p>
<p><a href="#leaveWaiting">leaveWaiting (fn)</a></p>
<p><a href="#list2varr">list2varr (fn)</a></p>
<p><a href="#loadCss">loadCss (fn)</a></p>
<p><a href="#loadJson">loadJson (fn)</a></p>
<p><a href="#loadScript">loadScript (fn)</a></p>
<p><a href="#logout">logout (fn)</a></p>
<p><a href="#m_curBatch">m_curBatch (var)</a></p>
<p><a href="#m_enhanceFn">m_enhanceFn (var)</a></p>
<p><a href="#m_pageStack">m_pageStack (var)</a></p>
<p><a href="#makeUrl">makeUrl (fn)</a></p>
<p><a href="#mockData">mockData (var)</a></p>
<p><a href="#mui-ani">mui-ani (key)</a></p>
<p><a href="#mui-deferred">mui-deferred (key)</a></p>
<p><a href="#mui-initfn">mui-initfn (key)</a></p>
<p><a href="#mui-loadPrompt">mui-loadPrompt (key)</a></p>
<p><a href="#mui-nofix">mui-nofix (key)</a></p>
<p><a href="#mui-origin">mui-origin (key)</a></p>
<p><a href="#mui-pullPrompt">mui-pullPrompt (key)</a></p>
<p><a href="#mui-script">mui-script (key)</a></p>
<p><a href="#mui-swipenav">mui-swipenav (key)</a></p>
<p><a href="#muiInit">muiInit (event)</a></p>
<p><a href="#nextShowPageOpt">nextShowPageOpt (var)</a></p>
<p><a href="#numberSort">numberSort (fn)</a></p>
<p><a href="#objarr2list">objarr2list (fn)</a></p>
<p><a href="#options">options (var)</a></p>
<p><a href="#options.PAGE_SZ">options.PAGE_SZ (var)</a></p>
<p><a href="#options.appName">options.appName (var)</a></p>
<p><a href="#options.disableFastClick">options.disableFastClick (var)</a></p>
<p><a href="#options.enableSwitchApp">options.enableSwitchApp (var)</a></p>
<p><a href="#options.enableWxLogin">options.enableWxLogin (var)</a></p>
<p><a href="#options.fixTopbarColor">options.fixTopbarColor (var)</a></p>
<p><a href="#options.homePage">options.homePage (var)</a></p>
<p><a href="#options.logAction">options.logAction (var)</a></p>
<p><a href="#options.loginPage">options.loginPage (var)</a></p>
<p><a href="#options.manualSplash">options.manualSplash (var)</a></p>
<p><a href="#options.mockDelay">options.mockDelay (var)</a></p>
<p><a href="#options.onAutoLogin">options.onAutoLogin (var)</a></p>
<p><a href="#options.onShowPage">options.onShowPage (var)</a></p>
<p><a href="#options.pageFolder">options.pageFolder (var)</a></p>
<p><a href="#options.pluginFolder">options.pluginFolder (var)</a></p>
<p><a href="#options.serverUrl">options.serverUrl (var)</a></p>
<p><a href="#options.serverUrlAc">options.serverUrlAc (var)</a></p>
<p><a href="#options.showHash">options.showHash (var)</a></p>
<p><a href="#options.showLoadingDelay">options.showLoadingDelay (var)</a></p>
<p><a href="#options.skipErrorRegex">options.skipErrorRegex (var)</a></p>
<p><a href="#options.statusBarColor">options.statusBarColor (var)</a></p>
<p><a href="#pagebeforeshow">pagebeforeshow (event)</a></p>
<p><a href="#pagecreate">pagecreate (event)</a></p>
<p><a href="#pagehide">pagehide (event)</a></p>
<p><a href="#pageshow">pageshow (event)</a></p>
<p><a href="#parseDate">parseDate (fn)</a></p>
<p><a href="#parseKvList">parseKvList (fn)</a></p>
<p><a href="#parseQuery">parseQuery (fn)</a></p>
<p><a href="#parseTime">parseTime (fn)</a></p>
<p><a href="#parseValue">parseValue (fn)</a></p>
<p><a href="#popPageStack">popPageStack (fn)</a></p>
<p><a href="#prevPageId">prevPageId (var)</a></p>
<p><a href="#queryHint">queryHint (var)</a></p>
<p><a href="#randInt">randInt (fn)</a></p>
<p><a href="#randInt">randInt (fn)</a></p>
<p><a href="#reloadPage">reloadPage (fn)</a></p>
<p><a href="#reloadSite">reloadSite (fn)</a></p>
<p><a href="#rgb">rgb (fn)</a></p>
<p><a href="#rgb2hex">rgb2hex (fn)</a></p>
<p><a href="#rs2Array">rs2Array (fn)</a></p>
<p><a href="#rs2Hash">rs2Hash (fn)</a></p>
<p><a href="#rs2MultiHash">rs2MultiHash (fn)</a></p>
<p><a href="#setCookie">setCookie (fn)</a></p>
<p><a href="#setDateBox">setDateBox (fn)</a></p>
<p><a href="#setDocTitle">setDocTitle (fn)</a></p>
<p><a href="#setFormData">setFormData (fn)</a></p>
<p><a href="#setFormSubmit">setFormSubmit (fn)</a></p>
<p><a href="#setOnError">setOnError (fn)</a></p>
<p><a href="#setStorage">setStorage (fn)</a></p>
<p><a href="#setTimeBox">setTimeBox (fn)</a></p>
<p><a href="#setUrl">setUrl (fn)</a></p>
<p><a href="#setUrlParam">setUrlParam (fn)</a></p>
<p><a href="#setupCallSvrViaForm">setupCallSvrViaForm (fn)</a></p>
<p><a href="#setupDialog">setupDialog (fn)</a></p>
<p><a href="#showByFormMode">showByFormMode (fn)</a></p>
<p><a href="#showDialog">showDialog (fn)</a></p>
<p><a href="#showFirstPage">showFirstPage (var)</a></p>
<p><a href="#showHome">showHome (fn)</a></p>
<p><a href="#showLoading">showLoading (fn)</a></p>
<p><a href="#showLogin">showLogin (fn)</a></p>
<p><a href="#showPage">showPage (fn)</a></p>
<p><a href="#slideIn">slideIn (key)</a></p>
<p><a href="#slideOut">slideOut (key)</a></p>
<p><a href="#syslog">syslog (fn)</a></p>
<p><a href="#text2html">text2html (fn)</a></p>
<p><a href="#title">title (var)</a></p>
<p><a href="#tobool">tobool (fn)</a></p>
<p><a href="#topic-iosStatusBar">topic-iosStatusBar (key)</a></p>
<p><a href="#topic-splashScreen">topic-splashScreen (key)</a></p>
<p><a href="#triggerAsync">triggerAsync (fn)</a></p>
<p><a href="#tryAutoLogin">tryAutoLogin (fn)</a></p>
<p><a href="#unloadPage">unloadPage (fn)</a></p>
<p><a href="#useBatchCall">useBatchCall (fn)</a></p>
<p><a href="#validateEntry">validateEntry (fn)</a></p>
<p><a href="#waitFor">waitFor (fn)</a></p>
</div><hr>
</div>
<div class="block">
<h2 id="MUI">@module MUI</h2><div class="toc"><p style="margin-left:0em"><a href="#MUI-1 基于逻辑页面的单网页应用">1 基于逻辑页面的单网页应用</a></p>
<p style="margin-left:2em"><a href="#MUI-1.1 应用容器">1.1 应用容器</a></p>
<p style="margin-left:2em"><a href="#MUI-1.2 逻辑页面">1.2 逻辑页面</a></p>
<p style="margin-left:4em"><a href="#MUI-1.2.1 逻辑页内嵌style">1.2.1 逻辑页内嵌style</a></p>
<p style="margin-left:4em"><a href="#MUI-1.2.2 逻辑页内嵌script">1.2.2 逻辑页内嵌script</a></p>
<p style="margin-left:4em"><a href="#MUI-1.2.3 进入应用时动态显示初始逻辑页">1.2.3 进入应用时动态显示初始逻辑页</a></p>
<p style="margin-left:4em"><a href="#MUI-1.2.4 在showPage过程中再显示另一个逻辑页">1.2.4 在showPage过程中再显示另一个逻辑页</a></p>
<p style="margin-left:4em"><a href="#MUI-1.2.5 逻辑页声明依赖库">1.2.5 逻辑页声明依赖库</a></p>
<p style="margin-left:2em"><a href="#MUI-1.3 页面路由">1.3 页面路由</a></p>
<p style="margin-left:0em"><a href="#MUI-2 服务端交互API">2 服务端交互API</a></p>
<p style="margin-left:0em"><a href="#MUI-3 登录与退出">3 登录与退出</a></p>
<p style="margin-left:0em"><a href="#MUI-4 常用组件">4 常用组件</a></p>
<p style="margin-left:2em"><a href="#MUI-4.1 导航栏">4.1 导航栏</a></p>
<p style="margin-left:2em"><a href="#MUI-4.2 对话框">4.2 对话框</a></p>
<p style="margin-left:2em"><a href="#MUI-4.3 弹出菜单">4.3 弹出菜单</a></p>
<p style="margin-left:2em"><a href="#MUI-4.4 底部导航">4.4 底部导航</a></p>
<p style="margin-left:0em"><a href="#MUI-5 图片按需加载">5 图片按需加载</a></p>
<p style="margin-left:0em"><a href="#MUI-6 原生应用支持">6 原生应用支持</a></p>
<p style="margin-left:0em"><a href="#MUI-7 系统类标识">7 系统类标识</a></p>
<p style="margin-left:0em"><a href="#MUI-8 手势支持">8 手势支持</a></p>
<p style="margin-left:0em"><a href="#MUI-9 跨域前端开发支持">9 跨域前端开发支持</a></p>
<p style="margin-left:0em"><a href="#MUI-10 参考文档说明">10 参考文档说明</a></p>
</div>
<p>筋斗云移动UI框架 - JDCloud Mobile UI framework</p>
<h4 id="MUI-1 基于逻辑页面的单网页应用">1 基于逻辑页面的单网页应用</h4>
<p>亦称“变脸式应用”。应用程序以逻辑页面（page）为基本单位，每个页面的html/js可完全分离。主要特性：</p>
<ul>
<li>基于缺页中断思想的页面路由。异步无刷新页面切换。支持浏览器前进后退操作。</li>
<li>支持页面对象模型(POM)，方便基于逻辑页面的模块化开发。支持页面html片段和js片段。</li>
<li>统一对待内部页面和外部页面（同样的方式访问，同样的行为）。开发时推荐用外部页面，发布时可打包常用页面成为内部页面。<br />
访问任何页面都是index.html#page1的方式，如果page1已存在则使用（内部页面），不存在则动态加载（如找到fragment/page1.html）</li>
<li>页面栈管理。可自行pop掉一些页面控制返回行为。</li>
</ul>
<p class="see"><strong>@see <a href="#showPage">showPage</a></strong> </p>
<p class="see"><strong>@see <a href="#popPageStack">popPageStack</a></strong> </p>
<h5 id="MUI-1.1 应用容器">1.1 应用容器</h5>
<p class="key"><strong>@key <a id=".mui-container">.mui-container</a></strong>  应用容器。</p>
<p class="event"><strong>@event <a id="muiInit">muiInit</a></strong> () DOM事件。this为当前应用容器。</p>
<p>先在主应用html中，用.mui-container类标识应用容器，在运行时，所有逻辑页面都将在该对象之下。如：</p>
<pre><code>&lt;body class="mui-container"&gt;</code></pre>
<p>应用初始化时会发出muiInit事件，该事件在页面加载完成($.ready)后，显示首页前调用。在这里调用MUI.showPage可动态显示首页。</p>
<h5 id="MUI-1.2 逻辑页面">1.2 逻辑页面</h5>
<p>每个逻辑页面(page)以及它对应的脚本(js)均可以独立出一个文件开发，也可以直接嵌在主页面的应用容器中。</p>
<p class="key"><strong>@key <a id=".mui-page">.mui-page</a></strong>  逻辑页面。</p>
<p class="key"><strong>@key <a id="mui-script">mui-script</a></strong>  DOM属性。逻辑页面对应的JS文件。</p>
<p class="key"><strong>@key <a id="mui-initfn">mui-initfn</a></strong>  DOM属性。逻辑页面对应的初始化函数，一般包含在mui-script指定的JS文件中。</p>
<p>如添加一个订单页，使用外部页面，可以添加一个order.html (html片段):</p>
<pre><code>&lt;div mui-initfn="initPageOrder" mui-script="order.js"&gt;
    ...
&lt;/div&gt;</code></pre>
<p>如果使用内部页面，则可以写为：</p>
<pre><code>&lt;script type="text/html" id="tpl_order"&gt;
    &lt;div mui-initfn="initPageOrder" mui-script="order.js"&gt;
        ...
    &lt;/div&gt;
&lt;/script&gt;</code></pre>
<p class="key"><strong>@key <a id=".hd">.hd</a></strong>  页面顶栏</p>
<p class="key"><strong>@key <a id=".bd">.bd</a></strong>  页面主体</p>
<p class="key"><strong>@key <a id=".ft">.ft</a></strong>  页面底栏</p>
<p class="key"><strong>@key <a id=".btn-icon">.btn-icon</a></strong>  顶栏图标按钮</p>
<p>页面中常常包含hd, bd等结构，如</p>
<pre><code>&lt;div mui-initfn="initPageMe"&gt;
    &lt;div class="hd"&gt;
        &lt;a href="javascript:hd_back();" class="btn-icon"&gt;&lt;i class="icon icon-back"&gt;&lt;/i&gt;&lt;/a&gt;
        &lt;h2&gt;个人信息&lt;/h2&gt;
    &lt;/div&gt;

    &lt;div class="bd"&gt;
    this is the body
    &lt;/div&gt;

    &lt;div class="ft"&gt;
    this is the footer
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>(v5.2)<br />
hd和ft可以有多个, bd只能有一个。框架将自动为它们计算和设置位置。<br />
hd一般用于显示页面标题、返回和菜单。在hd中出现的第一个h1或h2标签的文字将自动设置为当前文档标题。<br />
在微信中（如公众号或小程序），第一个hd会自动隐藏，以避免与微信的标题栏重复。</p>
<p>app.css中定义了<code>btn-icon</code>为顶栏图标按钮类，如果在<code>hd</code>中有多个<code>btn-icon</code>，则依次为左一，右一，左二，右二按钮，例如：</p>
<pre><code>&lt;div class="hd"&gt;
    &lt;!-- 左一: 返回按钮 --&gt;
    &lt;a href="javascript:hd_back();" class="btn-icon"&gt;&lt;i class="icon icon-back"&gt;&lt;/i&gt;&lt;/a&gt;
    &lt;!-- 右一: 更多选项按钮 --&gt;
    &lt;a href="#dlgMenu" class="btn-icon"&gt;&lt;i class="icon icon-menu"&gt;&lt;/i&gt;&lt;/a&gt;
    &lt;!-- 左二: 无 --&gt;
    &lt;a /&gt;
    &lt;!-- 右二: 编辑按钮 --&gt;
    &lt;a class="btn-icon"&gt;&lt;i class="icon icon-edit"&gt;&lt;/i&gt;&lt;/a&gt;
    &lt;h2&gt;标题&lt;/h2&gt;
&lt;/div&gt;</code></pre>
<p>该页面代码模块（即初始化函数）可以放在一个单独的文件order.js:</p>
<pre><code>function initPageOrder() 
{
    var jpage = this;
    jpage.on("pagebeforeshow", onBeforeShow);
    jpage.on("pageshow", onShow);
    jpage.on("pagehide", onHide);
    ...
}</code></pre>
<p>逻辑页面加载过程，以加载页面&quot;#order&quot;为例: </p>
<pre><code>MUI.showPage("#order");</code></pre>
<ul>
<li>检查是否已加载该页面，如果已加载则显示该页并跳到&quot;pagebeforeshow&quot;事件这一步。</li>
<li>检查内部模板页。如果内部页面模板中有名为&quot;tpl_{页面名}&quot;的对象，有则将其内容做为页面代码加载，然后跳到initPage步骤。</li>
<li>加载外部模板页。加载 {pageFolder}/{页面名}.html 作为逻辑页面，如果加载失败则报错。页面所在文件夹可通过<code>MUI.options.pageFolder</code>指定。</li>
<li>initPage页面初始化. 框架自动为页面添加.mui-page类。如果逻辑页面上指定了mui-script属性，则先加载该属性指定的JS文件。然后如果设置了mui-initfn属性，则将其作为页面初始化函数调用。</li>
<li>发出pagecreate事件。</li>
<li>发出pagebeforeshow事件。</li>
<li>动画完成后，发出pageshow事件。</li>
<li>如果之前有其它页面在显示，则触发之前页面的pagehide事件。</li>
</ul>
<p>（v3.3）页面初始化函数可返回一个新的jpage对象，从而便于与vue等库整合，如：</p>
<pre><code>function initPageOrder() 
{
    // vue将this当作模板，创建新的DOM对象vm.$el.
    var vm = new Vue({
        el: this[0],
        data: {},
        method: {}
    });

    var jpage = $(vm.$el);
    jpage.on("pagebeforeshow", onBeforeShow);
    ...
    return jpage;
}</code></pre>
<p class="event"><strong>@event <a id="pagecreate">pagecreate</a></strong> (ev) DOM事件。this为当前页面，习惯名为jpage。</p>
<p class="event"><strong>@event <a id="pagebeforeshow">pagebeforeshow</a></strong> (ev, opt) DOM事件。this为当前页面。opt参数为`MUI.showPage(pageRef, opt?)`中的opt，如未指定则为`{}`。(v5.4) 设置backNoRefresh选项会忽略此事件，这时可用pagebeforeshow.always替代。</p>
<p class="event"><strong>@event <a id="pageshow">pageshow</a></strong> (ev, opt)  DOM事件。this为当前页面。opt参数与pagebeforeshow事件的opt参数一样。</p>
<p class="event"><strong>@event <a id="pagehide">pagehide</a></strong> (ev) DOM事件。this为当前页面。</p>
<h6 id="MUI-1.2.1 逻辑页内嵌style">1.2.1 逻辑页内嵌style</h6>
<p>逻辑页代码片段允许嵌入style，例如：</p>
<pre><code>&lt;div mui-initfn="initPageOrder" mui-script="order.js"&gt;
&lt;style&gt;
.p-list {
    color: blue;
}
.p-list div {
    color: red;
}
&lt;/style&gt;
&lt;/div&gt;</code></pre>
<p class="key"><strong>@key <a id="mui-origin">mui-origin</a></strong> </p>
<p>style将被插入到head标签中，并自动添加属性<code>mui-origin={pageId}</code>.</p>
<p>（版本v3.2)<br />
框架在加载页面时，会将style中的内容自动添加逻辑页前缀，以便样式局限于当前页使用，相当于：</p>
<pre><code>&lt;style&gt;
#order .p-list {
    color: blue;
}
#order .p-list div {
    color: red;
}
&lt;/style&gt;</code></pre>
<p>为兼容旧版本，如果css选择器以&quot;#{pageId} &quot;开头，则不予处理。</p>
<p class="key"><strong>@key <a id="mui-nofix">mui-nofix</a></strong> </p>
<p>如果不希望框架自动处理，可以为style添加属性<code>mui-nofix</code>:</p>
<pre><code>&lt;style mui-nofix&gt;
&lt;/style&gt;</code></pre>
<h6 id="MUI-1.2.2 逻辑页内嵌script">1.2.2 逻辑页内嵌script</h6>
<p>逻辑页中允许但不建议内嵌script代码，js代码应在mui-script对应的脚本中。非要使用时，注意将script放到div标签内：</p>
<pre><code>&lt;div mui-initfn="initPageOrder" mui-script="order.js"&gt;
&lt;script&gt;
// js代码
&lt;/script&gt;
    ...
&lt;/div&gt;</code></pre>
<p>（版本v3.2)<br />
如果逻辑页嵌入在script模板中，这时要使用<code>script</code>, 应换用<code>__script__</code>标签，如：</p>
<pre><code>&lt;script type="text/html" id="tpl_order"&gt;
    &lt;div mui-initfn="initPageOrder" mui-script="order.js"&gt;
        ...
    &lt;/div&gt;
    &lt;__script__&gt;
    // js代码，将在逻辑页加载时执行
    &lt;/__script__&gt;
&lt;/script&gt;</code></pre>
<h6 id="MUI-1.2.3 进入应用时动态显示初始逻辑页">1.2.3 进入应用时动态显示初始逻辑页</h6>
<p>默认进入应用时的主页为 MUI.options.homePage. 如果要根据参数动态显示页面，可在muiInit事件中操作，示例：</p>
<pre><code>$(document).on("muiInit", myInit);

function myInit()
{
    if (g_args.initPage) {
        MUI.showPage(g_args.initPage);
    }
}</code></pre>
<p>访问<code>http://server/app/?initPage=me</code>则默认访问页面&quot;#me&quot;.</p>
<p class="see"><strong>@see <a href="#muiInit">muiInit</a></strong> </p>
<h6 id="MUI-1.2.4 在showPage过程中再显示另一个逻辑页">1.2.4 在showPage过程中再显示另一个逻辑页</h6>
<p>例如，进入页面后，发现如果未登录，则自动转向登录页：</p>
<pre><code>function onPageBeforeShow(ev)
{
    // 登录成功后一般会设置g_data.userInfo, 如果未设置，则当作未登录
    if (g_data.userInfo == null) {
        MUI.showLogin();
        return;
    }
    // 显示该页面...
}</code></pre>
<p>在pagebeforeshow事件中做页面切换，框架保证不会产生闪烁，且在新页面上点返回按钮，不会返回到旧页面。</p>
<p>(v5.4) 如果想在页面加载前添加处理逻辑，请参考 MUI.options.onShowPage 回调，可处理检测是否登录这类需求。</p>
<p>除此之外如果多次调用showPage（包括在pageshow事件中调用），一般最终显示的是最后一次调用的页面，过程中可能产生闪烁，且可能会丢失一些pageshow/pagehide事件，应尽量避免。</p>
<h6 id="MUI-1.2.5 逻辑页声明依赖库">1.2.5 逻辑页声明依赖库</h6>
<p class="key"><strong>@key <a id="mui-deferred">mui-deferred</a></strong> </p>
<p>（版本v4.2）<br />
如果逻辑页依赖某一个或多个库，这些库不想在主页面中用script默认加载，这时可以使用<code>mui-deferred</code>属性。<br />
逻辑页初始化函数mui-initfn将在该deferred对象操作成功后执行。</p>
<p>示例：某逻辑页依赖百度地图的js库，该js库使用动态加载：</p>
<pre><code>// 主逻辑中定义返回Deferred对象
window.dfdBaiduMap = MUI.loadScript("http://api.map.baidu.com/getscript?v=2.0&amp;ak=YOUR-APP-KEY");

// map.html 逻辑页中声明依赖该对象
&lt;div mui-initfn="initPageMap" mui-script="map.js" mui-deferred="dfdBaiduMap"&gt;
    ...
&lt;/div&gt;

// map.js
function initPageMap()
{
    var jpage = this;
    // 这时可以安全依赖库的对象，如BMap对象
}</code></pre>
<p>如果不使用mui-deferred属性，则需要在initPageMap中小心的来写异步逻辑，比如：</p>
<pre><code>// map.js
function initPageMap()
{
    var jpage = this;
    // 可以安全使用BMap对象
    dfdBaiduMap.then(init);

    function init() { ... }
}</code></pre>
<p>一般会将加载依赖库包装成一个函数，比如要使用百度echarts显示统计图的页面，可定义函数：</p>
<pre><code>var dfdStatLib_;
function loadStatLib()
{
    if (dfdStatLib_ == null) {
        dfdStatLib_ = $.when(
            MUI.loadScript("../web/lib/echarts.min.js"),
            MUI.loadScript("../web/lib/jdcloud-wui-stat.js")
        );
    }
    return dfdStatLib_;
}</code></pre>
<p>依赖echarts的页面，可以设置：</p>
<pre><code>&lt;div mui-deferred="loadStatLib()"&gt;
    ...
&lt;/div&gt;</code></pre>
<h5 id="MUI-1.3 页面路由">1.3 页面路由</h5>
<p>框架支持hash路由（默认方式）和文件路由（逻辑页面文件）两种方式。</p>
<ul>
<li>hash路由URL示例: <a href="http://server/app/index.html#home">http://server/app/index.html#home</a> 切换页面后为 <a href="http://server/app/index.html#order">http://server/app/index.html#order</a> </li>
<li>文件路由URL示例: <a href="http://server/app/page/home.html">http://server/app/page/home.html</a> 切换页面后为 <a href="http://server/app/page/order.html">http://server/app/page/order.html</a></li>
</ul>
<p>默认hash路由：</p>
<ul>
<li>一般只用一级目录：<code>http://server/app/index.html#order</code>对应<code>{pageFolder=page}/order.html</code>，一般为<code>page/order.html</code></li>
<li>也支持多级目录：<code>http://server/app/index.html#order-list</code>对应<code>page/order/list.html</code></li>
<li>与筋斗云后端框架一起使用时，支持插件目录：<code>http://server/app/index.html#order-list</code>在存在插件'order'时，对应<code>{pluginFolder=../plugin}/order/m2/page/list.html</code>，一般为<code>../plugin/order/m2/page/list.html</code></li>
</ul>
<p>文件路由：在主页面中head标签中应添加：</p>
<pre><code>&lt;base href="./" mui-showHash="no"&gt;</code></pre>
<p>之后，上面两个例子中，URL会显示为 <code>http://server/app/page/order.html</code> 和 <code>http://server/app/page/order/list.html</code></p>
<p class="see"><strong>@see <a href="#options.showHash">options.showHash</a></strong> </p>
<p>注意：使用文件路由时，如果刷新页面将无法显示。必须在web服务器中设置URL重写规则来解决。apache请参考和修改m2/page/.htaccess文件，nginx请参考和修改m2/.ht.nginx文件。</p>
<p>特别地，还可以通过<code>MUI.setUrl(url)</code>或<code>MUI.showPage(pageRef, {url: url})</code>来定制URL，例如将订单id=100的逻辑页显示为RESTful风格：<code>http://server/app/order/100</code></p>
<p class="see"><strong>@see <a href="#setUrl">setUrl</a></strong> </p>
<p>为了刷新时仍能正常显示页面，应将页面设置为入口页，并在WEB服务器配置好URL重写规则。</p>
<h4 id="MUI-2 服务端交互API">2 服务端交互API</h4>
<p class="see"><strong>@see <a href="#callSvr">callSvr</a></strong>  系列调用服务端接口的方法。</p>
<h4 id="MUI-3 登录与退出">3 登录与退出</h4>
<p>框架提供MUI.showLogin/MUI.logout操作.<br />
调用MUI.tryAutoLogin可以支持自动登录.</p>
<p>登录后显示的主页，登录页，应用名称等应通过MUI.options.homePage/loginPage/appName等选项设置。</p>
<p class="see"><strong>@see <a href="#tryAutoLogin">tryAutoLogin</a></strong> </p>
<p class="see"><strong>@see <a href="#showLogin">showLogin</a></strong> </p>
<p class="see"><strong>@see <a href="#logout">logout</a></strong> </p>
<p class="see"><strong>@see <a href="#options">options</a></strong> </p>
<h4 id="MUI-4 常用组件">4 常用组件</h4>
<p>框架提供导航栏、对话框、弹出框、弹出菜单等常用组件。</p>
<h5 id="MUI-4.1 导航栏">4.1 导航栏</h5>
<p class="key"><strong>@key <a id=".mui-navbar">.mui-navbar</a></strong>  导航栏，Tab页</p>
<p class="key"><strong>@key <a id=".mui-navbar.noactive">.mui-navbar.noactive</a></strong> </p>
<p>默认行为是点击后添加active类（比如字体发生变化），如果不需要此行为，可再添加noactive类。<br />
示例：</p>
<pre><code>&lt;div class="mui-navbar"&gt;
    &lt;a mui-linkto="#lst1"&gt;待服务&lt;/a&gt;
    &lt;a mui-linkto="#lst2"&gt;已完成&lt;/a&gt;
&lt;/div&gt;</code></pre>
<h5 id="MUI-4.2 对话框">4.2 对话框</h5>
<p class="key"><strong>@key <a id=".mui-dialog">.mui-dialog</a></strong>  对话框</p>
<p>对话框与页面(.mui-page)类似，可以包含hd, bd等部分。<br />
它一般包含在一个页面中，id以&quot;dlg&quot;开头。示例：</p>
<pre><code>&lt;div id="dlgAddPerson" class="mui-dialog"&gt;
    &lt;div class="hd"&gt;
        &lt;h2&gt;添加人物&lt;/h2&gt;
    &lt;/div&gt;

    &lt;div class="bd weui-cells"&gt;
        &lt;div class="weui-cell weui-cell_access"&gt;
            &lt;label class="weui-cell_hd weui-label"&gt;添加:&lt;/label&gt;
            &lt;select id="cboRelation" class="weui-cell__bd weui-select right" style="min-width:90px"&gt;
                &lt;option value="parent"&gt;父亲&lt;/option&gt;
                &lt;option value="child"&gt;子女&lt;/option&gt;
            &lt;/select&gt;
            &lt;div class="weui-cell__ft"&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="ft"&gt;
        &lt;a id="btnCancel" class="mui-btn"&gt;取消&lt;/a&gt;
        &lt;a id="btnOK" class="mui-btn primary"&gt;确定&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>要弹出这个对话框：</p>
<pre><code>MUI.showDialog(jpage.find("#dlgAddPerson"));</code></pre>
<p>或者用a标签链接打开：</p>
<pre><code>&lt;a href="#dlgAddPerson"&gt;添加人物&lt;/a&gt;</code></pre>
<p class="see"><strong>@see <a href="#showDialog">showDialog</a></strong>  弹出对话框</p>
<p class="see"><strong>@see <a href="##muiAlert">#muiAlert</a> <a href="#MUI.app_alert">MUI.app_alert</a></strong>  提示框(app_alert)是一个id为`muiAlert`的特别对话框。</p>
<p class="see"><strong>@see <a href="#.mui-menu">.mui-menu</a></strong>  弹出菜单，也是一类特别的对话框。</p>
<h5 id="MUI-4.3 弹出菜单">4.3 弹出菜单</h5>
<p>菜单是特殊的一类对话框。因而id以&quot;dlg&quot;开头，以便a标签通过href链接时，可直接弹出菜单（即打开对话框）。</p>
<p class="key"><strong>@key <a id=".mui-menu">.mui-menu</a></strong>  菜单</p>
<p>示例：添加右上角菜单（习惯上左上角为返回按钮，右上角为菜单按钮）</p>
<pre><code>&lt;!-- btn-icon依次标识左一，右一，左二，右二图标按钮 --&gt;
&lt;div class="hd"&gt;
    &lt;a href="javascript:hd_back();" class="btn-icon"&gt;&lt;i class="icon icon-back"&gt;&lt;/i&gt;&lt;/a&gt;
    &lt;a href="#dlgMenu" class="btn-icon"&gt;&lt;i class="icon icon-menu"&gt;&lt;/i&gt;&lt;/a&gt;
    &lt;h2&gt;谱系图&lt;/h2&gt;
&lt;/div&gt;

&lt;!-- 左上角弹出菜单，用top类标识 --&gt;
&lt;ul id="dlgMenu" class="mui-menu top"&gt;
    &lt;a href="javascript:PagePerson.showForAdd();"&gt;&lt;li&gt;&lt;i class="icon icon-add"&gt;&lt;/i&gt;添加人物&lt;/li&gt;&lt;/a&gt;
    &lt;li id="mnuQueryPerson"&gt;&lt;i class="icon icon-search"&gt;&lt;/i&gt;查找人物&lt;/li&gt;
    &lt;a href="#dlgMenuShare"&gt;&lt;li&gt;&lt;i class="icon icon-viewfav"&gt;&lt;/i&gt;分享到&lt;/li&gt;&lt;/a&gt;
&lt;/ul&gt;

&lt;!-- 弹出菜单 --&gt;
&lt;ul id="dlgMenuShare" class="mui-menu"&gt;
    &lt;li id="li1"&gt;微信好友&lt;/li&gt;
    &lt;li id="li2"&gt;微信朋友圈&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<h5 id="MUI-4.4 底部导航">4.4 底部导航</h5>
<p class="key"><strong>@key <a id="#footer">#footer</a></strong>  底部导航栏</p>
<p>设置id为&quot;footer&quot;的导航, 框架会对此做些设置: 如果当前页面为导航栏中的一项时, 就会自动显示导航栏.<br />
例: 在html中添加底部导航:</p>
<pre><code>&lt;div id="footer"&gt;
    &lt;a href="#home"&gt;订单&lt;/a&gt;
    &lt;a href="#me"&gt;我&lt;/a&gt;
&lt;/div&gt;</code></pre>
<p>如果要添加其它底部导航，可以用ft类加mui-navbar类，例如下例显示一个底部工具栏：</p>
<pre><code>&lt;div class="ft mui-navbar noactive"&gt;
    &lt;a href="javascript:;"&gt;添加&lt;/a&gt;
    &lt;a href="javascript:;"&gt;更新&lt;/a&gt;
    &lt;a href="javascript:;"&gt;删除&lt;/a&gt;
&lt;/div&gt;</code></pre>
<h4 id="MUI-5 图片按需加载">5 图片按需加载</h4>
<p>仅当页面创建时才会加载。</p>
<pre><code>&lt;img src="../m/images/ui/carwash.png"&gt;</code></pre>
<h4 id="MUI-6 原生应用支持">6 原生应用支持</h4>
<p>使用MUI框架的Web应用支持被安卓/苹果原生应用加载（通过cordova技术）。</p>
<p>设置说明：</p>
<ul>
<li>在Web应用中指定正确的应用程序名(MUI.options.appName).</li>
<li>App加载Web应用时在URL中添加cordova={ver}参数，就可自动加载cordova插件(m/cordova或m/cordova-ios目录下的cordova.js文件)，从而可以调用原生APP功能。</li>
<li>在App打包后，将apk包或ipa包其中的cordova.js/cordova_plugins.js/plugins文件或目录拷贝出来，合并到 cordova 或 cordova-ios目录下。<br />
其中，cordova_plugins.js文件应手工添加所需的插件，并根据应用名(MUI.options.appName)及版本(g_args.cordova)设置filter. 可通过 cordova.require(&quot;cordova/plugin_list&quot;) 查看应用究竟使用了哪些插件。</li>
<li>在部署Web应用时，建议所有cordova相关的文件合并成一个文件（通过Webcc打包）</li>
</ul>
<p>不同的app大版本(通过URL参数cordova=?识别)或不同平台加载的插件是不一样的，要查看当前加载了哪些插件，可以在Web控制台中执行：</p>
<pre><code>cordova.require('cordova/plugin_list')</code></pre>
<p>对原生应用的额外增强包括：</p>
<p class="key"><strong>@key <a id="topic-splashScreen">topic-splashScreen</a></strong> </p>
<p class="see"><strong>@see <a href="#options.manualSplash">options.manualSplash</a></strong> </p>
<ul>
<li>
<p>应用加载完成后，自动隐藏启动画面(SplashScreen)。如果需要自行隐藏启动画面，可以设置</p>
<pre><code>MUI.options.manualSplash = true; // 可以放在H5应用的主js文件中，如index.js</code></pre>
<p>然后开发者自己加载完后隐藏SplashScreen:</p>
<pre><code>if (navigator.splashscreen &amp;&amp; navigator.splashscreen.hide)
    navigator.splashscreen.hide();</code></pre>
</li>
</ul>
<p class="key"><strong>@key <a id="topic-iosStatusBar">topic-iosStatusBar</a></strong> </p>
<p class="see"><strong>@see <a href="#options.statusBarColor">options.statusBarColor</a></strong> </p>
<p>可通过MUI.options.statusBarColor设置状态栏前景和背景色。</p>
<pre><code>statusBarColor: "#,light" // 默认，背景与MUI.container（即.mui-container类）背景一致，白字。
statusBarColor: "#000000,light" // 黑底白字。
statusBarColor: "#ffffff,dark" // 白底黑字
statusBarColor: "none" // 不显示状态栏。</code></pre>
<p>如果不同页面有不同颜色，可以设置切换页面时自动按照页面头颜色来设置:</p>
<pre><code>WUI.options.fixTopbarColor=true</code></pre>
<p>注意此时要设置顶栏颜色，页面必须有页头即hd类并设置好颜色，若不需要页头可以设置隐藏.</p>
<p class="see"><strong>@see <a href="#options.fixTopbarColor">options.fixTopbarColor</a></strong> </p>
<p>如果希望自行设置状态栏，可以设置statusBarColor为null:</p>
<pre><code>MUI.options.statusBarColor = null;</code></pre>
<p>然后在deviceready事件中自行设置样式, 如</p>
<pre><code>function muiInit() {
    $(document).on("deviceready", onSetStatusBar);
    function onSetStatusBar()
    {
        var bar = window.StatusBar;
        if (bar) {
            bar.styleLightContent();
            bar.backgroundColorByHexString("#ea8010");
        }
    }
}</code></pre>
<p class="key"><strong>@key <a id="deviceready">deviceready</a></strong>  APP初始化后回调事件</p>
<p>APP初始化成功后，回调该事件。如果deviceready事件未被回调，则出现启动页无法消失、插件调用无效、退出程序时无提示等异常。<br />
其可能的原因是：</p>
<ul>
<li>m/cordova/cordova.js文件版本不兼容，如创建插件cordova平台是5.0版本，而相应的cordova.js文件或接口文件版本不同。</li>
<li>在编译原生程序时未设置 <allow-navigation href="*">，或者html中CSP设置不正确。</li>
<li>主页中有跨域的script js文件无法下载。如 <code>&lt;script type="text/javascript" src="http://3.3.3.3/1.js"&gt;&lt;/script&gt;</code></li>
<li>某插件的初始化过程失败（需要在原生环境下调试）</li>
</ul>
<h4 id="MUI-7 系统类标识">7 系统类标识</h4>
<p>框架自动根据系统环境为应用容器(.mui-container类)增加以下常用类标识：</p>
<p class="key"><strong>@key <a id=".mui-android">.mui-android</a></strong>  安卓系统</p>
<p class="key"><strong>@key <a id=".mui-ios">.mui-ios</a></strong>  苹果IOS系统</p>
<p class="key"><strong>@key <a id=".mui-weixin">.mui-weixin</a></strong>  微信浏览器</p>
<p class="key"><strong>@key <a id=".mui-cordova">.mui-cordova</a></strong>  原生环境</p>
<p>在css中可以利用它们做针对系统的特殊设置。</p>
<h4 id="MUI-8 手势支持">8 手势支持</h4>
<p>如果使用了 jquery.touchSwipe 库，则默认支持手势：</p>
<ul>
<li>右划：页面后退</li>
<li>左划：页面前进</li>
</ul>
<p class="key"><strong>@key <a id="mui-swipenav">mui-swipenav</a></strong>  DOM属性</p>
<p>如果页面中某组件上的左右划与该功能冲突，可以设置属性mui-swipenav=&quot;no&quot;来禁用页面前进后退功能，以确保组件自身的左右划功能正常：</p>
<pre><code>&lt;div id="div1" mui-swipenav="no"&gt;&lt;/div&gt;

jpage.find("#div1").swipe({
    swipeLeft: swipeH,
    swipeRight: swipeH
});

function swipeH(ev, direction, distance, duration, fingerCnt, fingerData, currentDirection) {
    if (direction == 'left') {
        console.log("next");
    }
    else if (direction == 'right') {
        console.log("prev");
    }
}</code></pre>
<p class="key"><strong>@key <a id=".noSwipe">.noSwipe</a></strong>  CSS-class</p>
<p>左右划前进后退功能会导致横向滚动失效。可以通过添加noSwipe类（注意大小写）的方式禁用swipe事件恢复滚动功能：</p>
<pre><code>&lt;div class="noSwipe"&gt;&lt;/div&gt;</code></pre>
<h4 id="MUI-9 跨域前端开发支持">9 跨域前端开发支持</h4>
<p>典型应用是, 在开发前端页面时, 本地无须运行任何后端服务器(如apache/iis/php等), 直接跨域连接远程接口进行开发.</p>
<p>支持直接在浏览器中打开html/js文件运行应用.<br />
需要浏览器支持CORS相关设置. 以下以chrome为例介绍.<br />
例如, 远程接口的基础URL地址为 <a href="http://oliveche.com/jdcloud/">http://oliveche.com/jdcloud/</a></p>
<ul>
<li>
<p>为chrome安装可设置CORS的插件(例如ForceCORS), 并设置:</p>
<pre><code>添加URL: http://oliveche.com/*
Access-Control-Allow-Origin: file://
Access-Control-Allow-Credentials: true</code></pre>
</li>
<li>打开chrome时设置参数 --allow-file-access-from-files 以允许ajax取本地文件.</li>
<li>
<p>在app.js中正确设置接口URL，如</p>
<pre><code>$.extend(MUI.options, {
    serverUrl: "http://oliveche.com/jdcloud/api.php"
    // serverUrlAc: "ac"
});</code></pre>
</li>
</ul>
<p>这时直接在chrome中打开html文件即可连接远程接口运行起来.</p>
<h4 id="MUI-10 参考文档说明">10 参考文档说明</h4>
<p>以下参考文档介绍MUI模块提供的方法/函数(fn)、属性/变量(var)等，示例如下：</p>
<pre><code>@fn showPage(pageName, title?, paramArr?)  一个函数。参数说明中问号表示参数可缺省。
@var options 一个属性。
@class batchCall(opt?={useTrans?=0}) 一个JS类。
@key topic-splashScreen key表示一般关键字。前缀为"topic-"用于某专题
@key .wui-page 一个CSS类名"wui-page"，关键字以"."开头。
@key #wui-pages 一个DOM对象，id为"wui-pages"，关键字以"#"开头。</code></pre>
<p>对于模块下的fn,var,class这些类别，如非特别说明，调用时应加MUI前缀，如</p>
<pre><code>MUI.showPage("#order");
var opts = MUI.options;
var batch = new MUI.batchCall();
batch.commit();</code></pre>
<p>以下函数可不加MUI前缀：</p>
<pre><code>intSort
numberSort
callSvr
callSvrSync
app_alert</code></pre>
<p>参考mui-name.js模块。</p></div>
<div class="block">
<h2 id="assert">@fn assert(cond, dscr?)</h2></div>
<div class="block">
<h2 id="randInt">@fn randInt(from, to)</h2>
<p>生成指定区间的随机整数。示例：</p>
<pre><code>var i = randInt(1, 10); // 1-10之间的整数，包含1或10</code></pre></div>
<div class="block">
<h2 id="randInt">@fn randInt(from, to)</h2>
<p>生成随机字符串，包含字母或数字，不包含易混淆的0或O。示例：</p>
<pre><code>var dynCode = randChr(4); // e.g. "9BZ3"</code></pre></div>
<div class="block">
<h2 id="parseQuery">@fn parseQuery(str)</h2>
<p>解析url编码格式的查询字符串，返回对应的对象。</p>
<pre><code>if (location.search) {
    var queryStr = location.search.substr(1); // "?id=100&amp;name=abc&amp;val=3.14"去掉"?"号
    var args = parseQuery(queryStr); // {id: 100, name: "abc", val: 3.14}
}</code></pre>
<p>注意：</p>
<p>如果值为整数或小数，则会转成相应类型。如上例中 id为100,不是字符串&quot;100&quot;.</p></div>
<div class="block">
<h2 id="tobool">@fn tobool(v)</h2>
<p>将字符串转成boolean值。除&quot;0&quot;, &quot;1&quot;外，还可以支持字符串 &quot;on&quot;/&quot;off&quot;, &quot;true&quot;/&quot;false&quot;等。</p></div>
<div class="block">
<h2 id="reloadSite">@fn reloadSite()</h2>
<p>重新加载当前页面，但不要#hash部分。</p></div>
<div class="block">
<h2 id="Date.format">@fn Date.format(fmt?=L)</h2>
<p>日期对象格式化字符串。</p>
<p class="param"><strong>@param fmt</strong>  格式字符串。由以下组成：</p>
<pre><code>yyyy - 四位年，如2008, 1999
yy - 两位年，如 08, 99
mm - 两位月，如 02, 12
dd - 两位日，如 01, 30
HH - 两位小时，如 00, 23
MM - 两位分钟，如 00, 59
SS - 两位秒，如 00, 59

支持这几种常用格式：
L - 标准日期时间，相当于 "yyyy-mm-dd HH:MM:SS"
D - 标准日期，相当于 "yyyy-mm-dd"
T - 标准时间，相当于 "HH:MM:SS"</code></pre>
<p>示例：</p>
<pre><code>var dt = new Date();
var dtStr1 = dt.format("D"); // "2009-10-20"
var dtStr2 = dt.format("yyyymmdd-HHMM"); // "20091020-2038"</code></pre></div>
<div class="block">
<h2 id="Date.addDay">@fn Date.addDay(n)</h2></div>
<div class="block">
<h2 id="Date.addHours">@fn Date.addHours(n)</h2></div>
<div class="block">
<h2 id="Date.addMin">@fn Date.addMin(n)</h2></div>
<div class="block">
<h2 id="Date.addMonth">@fn Date.addMonth(n)</h2></div>
<div class="block">
<h2 id="parseTime">@fn parseTime(s)</h2>
<p>将纯时间字符串生成一个日期对象。</p>
<pre><code>var dt1 = parseTime("10:10:00");
var dt2 = parseTime("10:11");</code></pre></div>
<div class="block">
<h2 id="parseDate">@fn parseDate(dateStr)</h2>
<p>将日期字符串转为日期时间格式。其效果相当于<code>new Date(Date.parse(dateStr))</code>，但兼容性更好（例如在safari中很多常见的日期格式无法解析）</p>
<p>示例：</p>
<pre><code>var dt1 = parseDate("2012-01-01");
var dt2 = parseDate("2012/01/01 20:00:09");
var dt3 = parseDate("2012.1.1 20:00");</code></pre>
<p>支持时区，时区格式可以是&quot;+8&quot;, &quot;+08&quot;, &quot;+0800&quot;, &quot;Z&quot;这些，如</p>
<pre><code>parseDate("2012-01-01T09:10:20.328+0800");
parseDate("2012-01-01T09:10:20Z");</code></pre></div>
<div class="block">
<h2 id="Date.add">@fn Date.add(sInterval, n)</h2>
<p>为日期对象加几天/小时等。参数n为整数，可以为负数。</p>
<p class="param"><strong>@param sInterval</strong>  Enum. 间隔单位. d-天; m-月; y-年; h-小时; n-分; s-秒</p>
<p>示例：</p>
<pre><code>var dt = new Date();
dt.add("d", 1); // 1天后
dt.add("m", 1); // 1个月后
dt.add("y", -1); // 1年前
dt.add("h", 3); // 3小时后
dt.add("n", 30); // 30分钟后
dt.add("s", 30); // 30秒后</code></pre>
<p class="see"><strong>@see <a href="#Date.diff">Date.diff</a></strong> </p></div>
<div class="block">
<h2 id="Date.diff">@fn Date.diff(sInterval, dtEnd)</h2>
<p>计算日期到另一日期间的间隔，单位由sInterval指定(具体值列表参见Date.add).</p>
<pre><code>var dt = new Date();
...
var dt2 = new Date();
var days = dt.diff("d", dt2); // 相隔多少天</code></pre>
<p class="see"><strong>@see <a href="#Date.add">Date.add</a></strong> </p></div>
<div class="block">
<h2 id="getTimeDiffDscr">@fn getTimeDiffDscr(tm, tm1)</h2>
<p>从tm到tm1的时间差描述，如&quot;2分钟前&quot;, &quot;3天前&quot;等。</p>
<p>tm和tm1可以为时间对象或时间字符串</p></div>
<div class="block">
<h2 id="WUI.getTmRange">@fn WUI.getTmRange(dscr, now?)</h2>
<p>根据时间段描述得到<code>[起始时间，结束时间)</code>，注意结束时间是开区间（即不包含）。<br />
假设今天是2015-9-9 周三：</p>
<pre><code>getTmRange("本周", "2015-9-9") -&gt; ["2015-9-7"(本周一), "2015-9-14")
getTmRange("上周") -&gt; ["2015-8-31", "2015-9-7")  // 或"前1周"

getTmRange("本月") -&gt; ["2015-9-1", "2015-10-1")
getTmRange("上月") -&gt; ["2015-8-1", "2015-9-1")

getTmRange("今年") -&gt; ["2015-1-1", "2016-1-1") // 或"本年"
getTmRange("去年") -&gt; ["2014-1-1", "2015-1-1") // 或"上年"

getTmRange("本季度") -&gt; ["2015-7-1", "2015-10-1") // 7,8,9三个月
getTmRange("上季度") -&gt; ["2015-4-1", "2015-7-1")

getTmRange("上半年") -&gt; ["2015-1-1", "2015-7-1")
getTmRange("下半年") -&gt; ["2015-7-1", "2016-1-1")

getTmRange("今天") -&gt; ["2015-9-9", "2015-9-10") // 或"本日"
getTmRange("昨天") -&gt; ["2015-9-8", "2015-9-9") // 或"昨日"

getTmRange("前1周") -&gt; ["2015-8-31"(上周一)，"2015-9-7"(本周一))
getTmRange("前3月") -&gt; ["2015-6-1", "2015-9-1")
getTmRange("前3天") -&gt; ["2015-9-6", "2015-9-9")

getTmRange("近1周") -&gt; ["2015-9-3"，"2015-9-10")
getTmRange("近3月") -&gt; ["2015-6-10", "2015-9-10")
getTmRange("近3天") -&gt; ["2015-9-6", "2015-9-10")  // "前3天"+今天</code></pre>
<p>dscr可以是 </p>
<pre><code>"近|前|上" N "个"? "小时|日|周|月|年|季度"
"本|今" "小时|日/天|周|月|年|季度"</code></pre>
<p>注意：&quot;近X周&quot;包括今天（即使尚未过完）。</p>
<p>示例：快捷填充</p>
<pre><code>    &lt;td&gt;
        &lt;select class="cboTmRange"&gt;
            &lt;option value ="本月"&gt;本月&lt;/option&gt;
            &lt;option value ="上月"&gt;上月&lt;/option&gt;
            &lt;option value ="本周"&gt;本周&lt;/option&gt;
            &lt;option value ="上周"&gt;上周&lt;/option&gt;
            &lt;option value ="今年"&gt;今年&lt;/option&gt;
            &lt;option value ="去年"&gt;去年&lt;/option&gt;
        &lt;/select&gt;
    &lt;/td&gt;

var txtTmRange = jdlg.find(".cboTmRange");
txtTmRange.change(function () {
    var range = WUI.getTmRange(this.value);
    if (range) {
        WUI.setFormData(jfrm, {tm1: range[0], tm2: range[1]}, {setOnlyDefined: true});
    }
});
// 初始选中
setTimeout(function () {
    txtTmRange.change();
});</code></pre></div>
<div class="block">
<h2 id="setCookie">@fn setCookie(name, value, days?=30)</h2>
<p>设置cookie值。如果只是为了客户端长时间保存值，一般建议使用 setStorage.</p>
<p class="see"><strong>@see <a href="#getCookie">getCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#delCookie">delCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#setStorage">setStorage</a></strong> </p></div>
<div class="block">
<h2 id="getCookie">@fn getCookie(name)</h2>
<p>取cookie值。</p>
<p class="see"><strong>@see <a href="#setCookie">setCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#delCookie">delCookie</a></strong> </p></div>
<div class="block">
<h2 id="delCookie">@fn delCookie(name)</h2>
<p>删除一个cookie项。</p>
<p class="see"><strong>@see <a href="#getCookie">getCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#setCookie">setCookie</a></strong> </p></div>
<div class="block">
<h2 id="setStorage">@fn setStorage(name, value, useSession?=false)</h2>
<p>使用localStorage存储(或使用sessionStorage存储, 如果useSession=true)。<br />
value可以是简单类型，也可以为数组，对象等，后者将自动在序列化后存储。 </p>
<p>如果设置了window.STORAGE_PREFIX, 则键值(name)会加上该前缀.</p>
<p>示例：</p>
<pre><code>setStorage("id", "100");
var id = getStorage("id");
delStorage("id");</code></pre>
<p>示例2：存储对象:</p>
<pre><code>window.STORAGE_PREFIX = "jdcloud_"; // 一般在app.js中全局设置
var obj = {id:10, name:"Jason"};
setStorage("obj", obj);   // 实际存储键值为 "jdcloud_obj"
var obj2 = getStorage("obj");
alert(obj2.name);</code></pre>
<p class="var"><strong>@var <a id="STORAGE_PREFIX">STORAGE_PREFIX</a></strong>  本地存储的键值前缀</p>
<p>如果指定, 则调用setStorage/getStorage/delStorage时都将自动加此前缀, 避免不同项目的存储项冲突.</p>
<p class="see"><strong>@see <a href="#getStorage">getStorage</a></strong> </p>
<p class="see"><strong>@see <a href="#delStorage">delStorage</a></strong> </p></div>
<div class="block">
<h2 id="getStorage">@fn getStorage(name, useSession?=false)</h2>
<p>取storage中的一项。<br />
默认使用localStorage存储，如果useSession=true，则使用sessionStorage存储。</p>
<p>如果浏览器不支持Storage，则使用cookie实现.</p>
<p class="see"><strong>@see <a href="#setStorage">setStorage</a></strong> </p>
<p class="see"><strong>@see <a href="#delStorage">delStorage</a></strong> </p></div>
<div class="block">
<h2 id="delStorage">@fn delStorage(name)</h2>
<p>删除storage中的一项。</p>
<p class="see"><strong>@see <a href="#getStorage">getStorage</a></strong> </p>
<p class="see"><strong>@see <a href="#setStorage">setStorage</a></strong> </p></div>
<div class="block">
<h2 id="rs2Array">@fn rs2Array(rs)</h2>
<p class="param"><strong>@param rs=</strong> {h=[header], d=[ @row ]} rs对象(RowSet)</p>
<p class="return"><strong>@return arr=[</strong>  %obj ]</p>
<p>rs对象用于传递表格，包含表头与表内容。<br />
函数用于将服务器发来的rs对象转成数组。</p>
<p>示例：</p>
<pre><code>var rs = {
    h: ["id", "name"], 
    d: [ [100, "Tom"], [101, "Jane"] ] 
};
var arr = rs2Array(rs); 

// 结果为
arr = [
    {id: 100, name: "Tom"},
    {id: 101, name: "Jane"} 
];</code></pre>
<p class="see"><strong>@see <a href="#rs2Hash">rs2Hash</a></strong> </p>
<p class="see"><strong>@see <a href="#rs2MultiHash">rs2MultiHash</a></strong> </p></div>
<div class="block">
<h2 id="rs2Hash">@fn rs2Hash(rs, key)</h2>
<p class="param"><strong>@param rs=</strong> {h, d}  rs对象(RowSet)</p>
<p class="return"><strong>@return hash=</strong> {key => %obj}</p>
<p>示例：</p>
<pre><code>var rs = {
    h: ["id", "name"], 
    d: [ [100, "Tom"], [101, "Jane"] ] 
};
var hash = rs2Hash(rs, "id"); 

// 结果为
hash = {
    100: {id: 100, name: "Tom"},
    101: {id: 101, name: "Jane"}
};</code></pre>
<p>key可以为一个函数，返回实际key值，示例：</p>
<pre><code>var hash = rs2Hash(rs, function (o) {
    return "USER-" + o.id;
}); 

// 结果为
hash = {
    "USER-100": {id: 100, name: "Tom"},
    "USER-101": {id: 101, name: "Jane"}
};</code></pre>
<p>key函数也可以返回[key, value]数组：</p>
<pre><code>var hash = rs2Hash(rs, function (o) {
    return ["USER-" + o.id, o.name];
}); 

// 结果为
hash = {
    "USER-100": "Tom",
    "USER-101": "Jane"
};</code></pre>
<p class="see"><strong>@see <a href="#rs2Array">rs2Array</a></strong> </p></div>
<div class="block">
<h2 id="rs2MultiHash">@fn rs2MultiHash(rs, key)</h2>
<p>数据分组(group by).</p>
<p class="param"><strong>@param rs=</strong> {h, d}  rs对象(RowSet)</p>
<p class="return"><strong>@return hash=</strong> {key => [ %obj ]}</p>
<p>示例：</p>
<pre><code>var rs = {
    h: ["id", "name"], 
    d: [ [100, "Tom"], [101, "Jane"], [102, "Tom"] ] 
};
var hash = rs2MultiHash(rs, "name");  

// 结果为
hash = {
    "Tom": [{id: 100, name: "Tom"}, {id: 102, name: "Tom"}],
    "Jane": [{id: 101, name: "Jane"}]
};</code></pre>
<p>key也可以是一个函数，返回实际的key值，示例，按生日年份分组：</p>
<pre><code>var rs = {
    h: ["id", "name", "birthday"], 
    d: [ [100, "Tom", "1998-10-1"], [101, "Jane", "1999-1-10"], [102, "Tom", "1998-3-8"] ] 
};
// 按生日年份分组
var hash = rs2MultiHash(rs, function (o) {
    var m = o.birthday.match(/^\d+/);
    return m &amp;&amp; m[0];
});

// 结果为
hash = {
    "1998": [{id: 100, name: "Tom", birthday: "1998-10-1"}, {id: 102, name: "Tom", birthday:"1998-3-8"}],
    "1999": [{id: 101, name: "Jane", birthday: "1999-1-10"}]
};</code></pre>
<p>key作为函数，也可返回[key, value]:</p>
<pre><code>var hash = rs2MultiHash(rs, function (o) {
    return [o.name, [o.id, o.birthday]];
});

// 结果为
hash = {
    "Tom": [[100, "1998-10-1"], [102, "1998-3-8"]],
    "Jane": [[101, "1999-1-10"]]
};</code></pre>
<p class="see"><strong>@see <a href="#rs2Hash">rs2Hash</a></strong> </p>
<p class="see"><strong>@see <a href="#rs2Array">rs2Array</a></strong> </p></div>
<div class="block">
<h2 id="list2varr">@fn list2varr(ls, colSep=':', rowSep=',')</h2>
<ul>
<li>ls: 代表二维表的字符串，有行列分隔符。</li>
<li>colSep, rowSep: 列分隔符，行分隔符。</li>
</ul>
<p>将字符串代表的压缩表(&quot;v1:v2:v3,...&quot;)转成对象数组。</p>
<p>e.g.</p>
<pre><code>var users = "101:andy,102:beddy";
var varr = list2varr(users);
// varr = [["101", "andy"], ["102", "beddy"]];
var arr = rs2Array({h: ["id", "name"], d: varr});
// arr = [ {id: 101, name: "andy"}, {id: 102, name: "beddy"} ];

var cmts = "101\thello\n102\tgood";
var varr = list2varr(cmts, "\t", "\n");
// varr=[["101", "hello"], ["102", "good"]]</code></pre></div>
<div class="block">
<h2 id="objarr2list">@fn objarr2list(objarr, fields, sep=':', sep2=',')</h2>
<p>将对象数组转成字符串代表的压缩表(&quot;v1:v2:v3,...&quot;)。</p>
<p>示例：</p>
<pre><code>var objarr = [
    {id:100, name:'name1', qty:2},
    {id:101, name:'name2', qty:3}
];
var list = objarr2list(objarr, ["id","qty"]);
// 返回"100:2,101:3"

var list2 = objarr2list(objarr, function (e, i) { return e.id + ":" + e.qty; });
// 结果同上</code></pre></div>
<div class="block">
<h2 id="intSort">@fn intSort(a, b)</h2>
<p>整数排序. 用于datagrid column sorter:</p>
<pre><code>&lt;th data-options="field:'id', sortable:true, sorter:intSort"&gt;编号&lt;/th&gt;</code></pre></div>
<div class="block">
<h2 id="numberSort">@fn numberSort(a, b)</h2>
<p>小数排序. 用于datagrid column sorter:</p>
<pre><code>&lt;th data-options="field:'score', sortable:true, sorter:numberSort"&gt;评分&lt;/th&gt;</code></pre></div>
<div class="block">
<h2 id="getAncestor">@fn getAncestor(o, fn)</h2>
<p>取符合条件(fn)的对象，一般可使用$.closest替代</p></div>
<div class="block">
<h2 id="appendParam">@fn appendParam(url, param)</h2>
<p>示例:</p>
<pre><code>var url = "http://xxx/api.php";
if (a)
    url = appendParam(url, "a=" + a);
if (b)
    url = appendParam(url, "b=" + b);

appendParam(url, $.param({a:1, b:3}));</code></pre>
<p>支持url中带有&quot;?&quot;或&quot;#&quot;，如</p>
<pre><code>var url = "http://xxx/api.php?id=1#order";
appendParam(url, "pay=1"); // "http://xxx/api.php?id=1&amp;pay=1#order";</code></pre></div>
<div class="block">
<h2 id="deleteParam">@fn deleteParam(url, paramName)</h2>
<p>示例:</p>
<pre><code>var url = "http://xxx/api.php?a=1&amp;b=3&amp;c=2";
var url1 = deleteParam(url, "b"); // "http://xxx/api.php?a=1&amp;c=2";

var url = "http://server/jdcloud/m2/?logout#me";
var url1 = deleteParam(url, "logout"); // "http://server/jdcloud/m2/?#me"</code></pre></div>
<div class="block">
<h2 id="isWeixin">@fn isWeixin()</h2>
<p>当前应用运行在微信中。</p></div>
<div class="block">
<h2 id="isIOS">@fn isIOS()</h2>
<p>当前应用运行在IOS平台，如iphone或ipad中。</p></div>
<div class="block">
<h2 id="isAndroid">@fn isAndroid()</h2>
<p>当前应用运行在安卓平台。</p></div>
<div class="block">
<h2 id="parseValue">@fn parseValue(str)</h2>
<p>如果str符合整数或小数，则返回相应类型。</p></div>
<div class="block">
<h2 id="applyTpl">@fn applyTpl(tpl, data)</h2>
<p>对模板做字符串替换</p>
<pre><code>var tpl = "&lt;li&gt;&lt;p&gt;{name}&lt;/p&gt;&lt;p&gt;{dscr}&lt;/p&gt;&lt;/li&gt;";
var data = {name: 'richard', dscr: 'hello'};
var html = applyTpl(tpl, data);
// &lt;li&gt;&lt;p&gt;richard&lt;/p&gt;&lt;p&gt;hello&lt;/p&gt;&lt;/li&gt;</code></pre></div>
<div class="block">
<h2 id="delayDo">@fn delayDo(fn, delayCnt?=3)</h2>
<p>设置延迟执行。当delayCnt=1时与setTimeout效果相同。<br />
多次置于事件队列最后，一般3次后其它js均已执行完毕，为idle状态</p></div>
<div class="block">
<h2 id="kvList2Str">@fn kvList2Str(kv, sep, sep2)</h2>
<p>e.g.</p>
<pre><code>var str = kvList2Str({"CR":"Created", "PA":"Paid"}, ';', ':');
// str="CR:Created;PA:Paid"</code></pre></div>
<div class="block">
<h2 id="parseKvList">@fn parseKvList(kvListStr, sep, sep2) -> kvMap</h2>
<p>解析key-value列表字符串，返回kvMap。<br />
示例：</p>
<pre><code>var map = parseKvList("CR:新创建;PA:已付款", ";", ":");
// map: {"CR": "新创建", "PA":"已付款"}</code></pre></div>
<div class="block">
<h2 id="Q">@fn Q(str, q?="'")</h2>
<pre><code>Q("abc") -&gt; 'abc'
Q("a'bc") -&gt; 'a\'bc'</code></pre></div>
<div class="block">
<h2 id="text2html">@fn text2html(str, pics)</h2>
<p>将文本或图片转成html，常用于将筋斗云后端返回的图文内容转成html在网页中显示。示例：</p>
<pre><code>var item = {id: 1, name: "商品1", content: "商品介绍内容", pics: "100,102"};
var html = MUI.text2html(item.content, item.pics);
jpage.find("#content").html(html);</code></pre>
<p>文字转html示例：</p>
<pre><code>var html = MUI.text2html("hello\nworld");</code></pre>
<p>生成html为</p>
<pre><code>&lt;p&gt;hello&lt;/p&gt;
&lt;p&gt;world&lt;/p&gt;</code></pre>
<p>支持简单的markdown格式，如&quot;# &quot;,&quot;## &quot;分别表示一二级标题, &quot;- &quot;表示列表（注意在&quot;#&quot;或&quot;-&quot;后面有英文空格）：</p>
<pre><code># 标题1
内容1
# 标题2
内容2

- 列表1
- 列表2</code></pre>
<p>函数可将图片编号列表转成img列表，如：</p>
<pre><code>var html = MUI.text2html(null, "100,102");</code></pre>
<p>生成</p>
<pre><code>&lt;img src="../api.php/att?thumbId=100"&gt;
&lt;img src="../api.php/att?thumbId=102"&gt;</code></pre></div>
<div class="block">
<h2 id="jdModule">@fn jdModule(name?, fn?)</h2>
<p>定义JS模块。这是一个全局函数。</p>
<p>定义一个模块:</p>
<pre><code>jdModule("jdcloud.common", JdcloudCommon);
function JdcloudCommon() {
    var self = this;

    // 对外提供一个方法
    self.rs2Array = rs2Array;
    function rs2Array(rs)
    {
        return ...;
    }
}</code></pre>
<p>获取模块对象:</p>
<pre><code>var mCommon = jdModule("jdcloud.common");
var arr = mCommon.rs2Array(rs);</code></pre>
<p>返回模块映射列表。</p>
<pre><code>var moduleMap = jdModule(); // 返回 { "jdcloud.common": JdcloudCommon, ... }</code></pre></div>
<div class="block">
<h2 id="getFormData">@fn getFormData(jo)</h2>
<p>取DOM对象中带name属性的子对象的内容, 放入一个JS对象中, 以便手工调用callSvr.</p>
<p>注意: </p>
<ul>
<li>这里Form不一定是Form标签, 可以是一切DOM对象.</li>
<li>如果DOM对象有disabled属性, 则会忽略它, 这也与form提交时的规则一致.</li>
</ul>
<p>与setFormData配合使用时, 可以只返回变化的数据.</p>
<pre><code>jf.submit(function () {
    var ac = jf.attr("action");
    callSvr(ac, fn, getFormData(jf));
});</code></pre>
<p>如果在jo对象中存在有name属性的file组件(input[type=file][name])，或指定了属性enctype=&quot;multipart/form-data&quot;，则调用getFormData会返回FormData对象而非js对象，<br />
再调用callSvr时，会以&quot;multipart/form-data&quot;格式提交数据。一般用于上传文件。<br />
示例：</p>
<pre><code>&lt;div&gt;
    课程文档
    &lt;input name="pdf" type="file" accept="application/pdf"&gt;
&lt;/div&gt;</code></pre>
<p>或传统地：</p>
<pre><code>&lt;form method="POST" enctype='multipart/form-data'&gt;
    课程文档
    &lt;input name="pdf" type="file" accept="application/pdf"&gt;
&lt;/form&gt;</code></pre>
<p class="see"><strong>@see <a href="#setFormData">setFormData</a></strong> </p></div>
<div class="block">
<h2 id="getFormData_vf">@fn getFormData_vf(jo)</h2>
<p>专门取虚拟字段的值。例如：</p>
<pre><code>&lt;select name="whId" class="my-combobox" data-options="url:..., jd_vField:'whName'"&gt;&lt;/select&gt;</code></pre>
<p>用WUI.getFormData可取到<code>{whId: xxx}</code>，而WUI.getFormData_vf遍历带name属性且设置了jd_vField选项的控件，调用接口getValue_vf(ji)来取其显示值。<br />
因而，为支持取虚拟字段值，控件须定义getValue_vf接口。</p>
<pre><code>&lt;input name="orderType" data-options="jd_vField:'orderType'" disabled&gt;</code></pre>
<p>注意：与getFormData不同，它不忽略有disabled属性的控件。</p>
<p class="see"><strong>@see <a href="#defaultFormItems">defaultFormItems</a></strong> </p></div>
<div class="block">
<h2 id="formItems">@fn formItems(jo, cb)</h2>
<p>表单对象遍历。对表单jo（实际可以不是form标签）下带name属性的控件，交给回调cb处理。<br />
可通过扩展<code>WUI.formItems[sel]</code>来为表单扩展其它类型控件，参考 <code>WUI.defaultFormItems</code>来查看要扩展的接口方法。</p>
<p>注意:</p>
<ul>
<li>通过取getDisabled接口判断，可忽略有disabled属性的控件以及未选中的checkbox/radiobutton。</li>
</ul>
<p>对于checkbox，设置时根据val确定是否选中；取值时如果选中取value属性否则取value-off属性。<br />
缺省value为&quot;on&quot;, value-off为空(非标准属性，本框架支持)，可以设置：</p>
<pre><code>&lt;input type="checkbox" name="flag" value="1"&gt;
&lt;input type="checkbox" name="flag" value="1" value-off="0"&gt;</code></pre>
<p class="param"><strong>@param cb</strong> (ji, name, it) it.getDisabled/setDisabled/getValue/setValue/getShowbox</p>
<p>当cb返回false时可中断遍历。</p>
<p>示例：</p>
<pre><code>WUI.formItems(jdlg.find(".my-fixedField"), function (ji, name, it) {
    var fixedVal = ...
    if (fixedVal || fixedVal == '') {
        it.setReadonly(ji, true);
        var forAdd = beforeShowOpt.objParam.mode == FormMode.forAdd;
        if (forAdd) {
            it.setValue(ji, fixedVal);
        }
    }
    else {
        it.setReadonly(ji, false);
    }
});</code></pre>
<p class="key"><strong>@key <a id="defaultFormItems">defaultFormItems</a></strong> </p></div>
<div class="block">
<h2 id="setFormData">@fn setFormData(jo, data?, opt?)</h2>
<p>用于为带name属性的DOM对象设置内容为data[name].<br />
要清空所有内容, 可以用 setFormData(jo), 相当于增强版的 form.reset().</p>
<p>注意:</p>
<ul>
<li>DOM项的内容指: 如果是input/textarea/select等对象, 内容为其value值; 如果是div组件, 内容为其innerHTML值.</li>
<li>当data[name]未设置(即值为undefined, 注意不是null)时, 对于input/textarea等组件, 行为与form.reset()逻辑相同,<br />
即恢复为初始化值。（特别地，form.reset无法清除input[type=hidden]对象的内容, 而setFormData可以)<br />
对div等其它对象, 会清空该对象的内容.</li>
<li>如果对象设置有属性&quot;noReset&quot;, 则不会对它进行设置.</li>
</ul>
<p class="param"><strong>@param opt</strong>  {setOrigin?=false, setOnlyDefined?=false}</p>
<p class="param"><strong>@param opt.setOrigin</strong>  为true时将data设置为数据源, 这样在getFormData时, 只会返回与数据源相比有变化的数据.</p>
<p>缺省会设置该DOM对象数据源为空.</p>
<p class="param"><strong>@param opt.setOnlyDefined</strong>  设置为true时，只设置form中name在data中存在的项，其它项保持不变；而默认是其它项会清空。</p>
<p>对象关联的数据源, 可以通过 jo.data(&quot;origin<em>&quot;) 来获取, 或通过 jo.data(&quot;origin</em>&quot;, newOrigin) 来设置.</p>
<p>示例：</p>
<pre><code>&lt;div id="div1"&gt;
    &lt;p&gt;订单描述：&lt;span name="dscr"&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;状态为：&lt;input type=text name="status"&gt;&lt;/p&gt;
    &lt;p&gt;金额：&lt;span name="amount"&gt;&lt;/span&gt;元&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>Javascript:</p>
<pre><code>var data = {
    dscr: "筋斗云教程",
    status: "已付款",
    amount: "100"
};
var jo = $("#div1");
var data = setFormData(jo, data); 
$("[name=status]").html("已完成");
var changedData = getFormData(jo); // 返回 { dscr: "筋斗云教程", status: "已完成", amount: "100" }

var data = setFormData(jo, data, {setOrigin: true}); 
$("[name=status]").html("已完成");
var changedData = getFormData(jo); // 返回 { status: "已完成" }
$.extend(jo.data("origin_"), changedData); // 合并变化的部分到数据源.</code></pre>
<p class="see"><strong>@see <a href="#getFormData">getFormData</a></strong> </p></div>
<div class="block">
<h2 id="loadScript">@fn loadScript(url, fnOK?, ajaxOpt?)</h2>
<p class="param"><strong>@param fnOK</strong>  加载成功后的回调函数</p>
<p class="param"><strong>@param ajaxOpt</strong>  传递给$.ajax的额外选项。</p>
<p>默认未指定ajaxOpt时，简单地使用添加script标签机制异步加载。如果曾经加载过，可以重用cache。</p>
<p>如果指定ajaxOpt，且非跨域，则通过ajax去加载，可以支持同步调用。如果是跨域，仍通过script标签方式加载，注意加载完成后会自动删除script标签。</p>
<p>返回defered对象(与$.ajax类似)，可以用 dfd.then() / dfd.fail() 异步处理。</p>
<p>常见用法：</p>
<ul>
<li>
<p>动态加载一个script，异步执行其中内容：</p>
<pre><code>loadScript("1.js", onload); // onload中可使用1.js中定义的内容
loadScript("http://otherserver/path/1.js"); // 跨域加载</code></pre>
</li>
<li>
<p>加载并立即执行一个script:</p>
<pre><code>loadScript("1.js", {async: false});
// 可立即使用1.js中定义的内容</code></pre>
<p>注意：如果是跨域加载，不支持同步调用（$.ajax的限制），如：</p>
<pre><code>loadScript("http://oliveche.com/1.js", {async: false});
// 一旦跨域，选项{async:false}指定无效，不可立即使用1.js中定义的内容。</code></pre>
</li>
</ul>
<p>如果要动态加载script，且使用后删除标签（里面定义的函数会仍然保留），建议直接使用<code>$.getScript</code>，它等同于：</p>
<pre><code>loadScript("1.js", {cache: false});</code></pre></div>
<div class="block">
<h2 id="loadJson">@fn loadJson(url, fnOK, options)</h2>
<p>从远程获取JSON结果.<br />
注意: 与$.getJSON不同, 本函数不直接调用JSON.parse解析结果, 而是将返回当成JS代码使用eval执行得到JSON结果再回调fnOK.</p>
<p>示例:</p>
<pre><code>WUI.loadJson("1.js", function (data) {
    // handle json value `data`
});</code></pre>
<p>1.js可以是返回任意JS对象的代码, 如:</p>
<pre><code>{
    a: 2 * 3600,
    b: "hello",
    // c: {}
}</code></pre>
<p>如果不处理结果, 则该函数与$.getScript效果类似.</p></div>
<div class="block">
<h2 id="loadCss">@fn loadCss(url)</h2>
<p>动态加载css文件, 示例:</p>
<pre><code>WUI.loadCss("lib/bootstrap.min.css");</code></pre></div>
<div class="block">
<h2 id="setDateBox">@fn setDateBox(jo, defDateFn?)</h2>
<p>设置日期框, 如果输入了非法日期, 自动以指定日期(如未指定, 用当前日期)填充.</p>
<pre><code>setDateBox($("#txtComeDt"), function () { return genDefVal()[0]; });</code></pre></div>
<div class="block">
<h2 id="setTimeBox">@fn setTimeBox(jo, defTimeFn?)</h2>
<p>设置时间框, 如果输入了非法时间, 自动以指定时间(如未指定, 用当前时间)填充.</p>
<pre><code>setTimeBox($("#txtComeTime"), function () { return genDefVal()[1]; });</code></pre></div>
<div class="block">
<h2 id="waitFor">@fn waitFor(deferredObj)</h2>
<p>用于简化异步编程. 可将不易读的回调方式改写为易读的顺序执行方式.</p>
<pre><code>var dfd = $.getScript("http://...");
function onSubmit()
{
    dfd.then(function () {
        foo();
        bar();
    });
}</code></pre>
<p>可改写为:</p>
<pre><code>function onSubmit()
{
    if (waitFor(dfd)) return;
    foo();
    bar();
}</code></pre></div>
<div class="block">
<h2 id="rgb">@fn rgb(r,g,b)</h2>
<p>生成&quot;#112233&quot;形式的颜色值.</p>
<pre><code>rgb(255,255,255) -&gt; "#ffffff"</code></pre></div>
<div class="block">
<h2 id="rgb2hex">@fn rgb2hex(rgb)</h2>
<p>将jquery取到的颜色转成16进制形式，如：&quot;rgb(4, 190, 2)&quot; -&gt; &quot;#04be02&quot;</p>
<p>示例：</p>
<pre><code>var color = rgb2hex( $(".mui-container").css("backgroundColor") );</code></pre></div>
<div class="block">
<h2 id="jQuery.fn.jdata">@fn jQuery.fn.jdata(val?)</h2>
<p>和使用$.data()差不多，更好用一些. 例：</p>
<pre><code>$(o).jdata().hello = 100;
$(o).jdata({hello:100, world:200});</code></pre></div>
<div class="block">
<h2 id="compressImg">@fn compressImg(img, cb, opt)</h2>
<p>通过限定图片大小来压缩图片，用于图片预览和上传。<br />
不支持IE8及以下版本。</p>
<ul>
<li>img: Image对象</li>
<li>cb: Function(picData) 回调函数</li>
<li>opt: {quality=0.8, maxSize=1280, mimeType?=&quot;image/jpeg&quot;}</li>
<li>opt.maxSize: 压缩完后宽、高不超过该值。为0表示不压缩。</li>
<li>opt.quality: 0.0-1.0之间的数字。</li>
<li>opt.mimeType: 输出MIME格式。</li>
</ul>
<p>函数cb的回调参数: picData={b64src,blob,w,h,w0,h0,quality,name,mimeType,size0,size,b64size,info}</p>
<p>b64src为base64格式的Data URL, 如 &quot;data:image/jpeg;base64,/9j/4AAQSk...&quot;, 用于给image或background-image赋值显示图片；</p>
<p>可以赋值给Image.src:</p>
<pre><code>var img = new Image();
img.src = picData.b64src;</code></pre>
<p>或</p>
<pre><code>$("&lt;div&gt;").css("background-image", "url(" + picData.b64src + ")");</code></pre>
<p>blob用于放到FormData中上传：</p>
<pre><code>fd.append('file', picData.blob, picData.name);</code></pre>
<p>其它picData属性：</p>
<ul>
<li>w0,h0,size0分别为原图宽、高、大小; w,h,size为压缩后图片的宽、高、大小。</li>
<li>quality: jpeg压缩质量,0-1之间。</li>
<li>mimeType: 输出的图片格式</li>
<li>info: 提示信息，会在console中显示。用于调试。</li>
</ul>
<p><strong>[预览和上传示例]</strong></p>
<p>HTML:</p>
<pre><code>&lt;form action="upfile.php"&gt;
    &lt;div class="img-preview"&gt;&lt;/div&gt;
    &lt;input type="file" /&gt;&lt;br/&gt;
    &lt;input type="submit" &gt;
&lt;/form&gt;</code></pre>
<p>用picData.b64src来显示预览图，并将picData保存在img.picData_属性中，供后面上传用。</p>
<pre><code>var jfrm = $("form");
var jpreview = jfrm.find(".img-preview");
var opt = {maxSize:1280};
jfrm.find("input[type=file]").change(function (ev) {
    $.each(this.files, function (i, fileObj) {
        compressImg(fileObj, function (picData) {
            $("&lt;img&gt;").attr("src", picData.b64src)
                .prop("picData_", picData)
                .appendTo(jpreview);
            //$("&lt;div&gt;").css("background-image", "url("+picData.b64src+")").appendTo(jpreview);
        }, opt);
    });
    this.value = "";
});</code></pre>
<p>上传picData.blob到服务器</p>
<pre><code>jfrm.submit(function (ev) {
    ev.preventDefault();

    var fd = new FormData();
    var idx = 1;
    jpreview.find("img").each(function () {
        // 名字要不一样，否则可能会覆盖
        fd.append('file' + idx, this.picData_.blob, this.picData_.name);
        ++idx;
    });

    $.ajax({
        url: jfrm.attr("action"),
        data: fd,
        processData: false,
        contentType: false,
        type: 'POST',
        // 允许跨域调用
        xhrFields: {
            withCredentials: true
        },
        success: cb
    });
    return false;
});</code></pre>
<p>参考：JIC.js (<a href="https://github.com/brunobar79/J-I-C">https://github.com/brunobar79/J-I-C</a>)</p>
<p>TODO: 用完后及时释放内存，如调用revokeObjectURL等。</p></div>
<div class="block">
<h2 id="getDataOptions">@fn getDataOptions(jo, defVal?)</h2>
<p class="key"><strong>@key <a id="data-options">data-options</a></strong> </p>
<p>读取jo上的data-options属性，返回JS对象。例如：</p>
<pre><code>&lt;div data-options="a:1,b:'hello',c:true"&gt;&lt;/div&gt;</code></pre>
<p>上例可返回 <code>{a:1, b:'hello', c:true}</code>.</p>
<p>也支持各种表达式及函数调用，如：</p>
<pre><code>&lt;div data-options="getSomeOption()"&gt;&lt;/div&gt;</code></pre>
<p class="see"><strong>@see <a href="#getOptions">getOptions</a></strong> </p></div>
<div class="block">
<h2 id="triggerAsync">@fn triggerAsync(jo, ev, paramArr)</h2>
<p>触发含有异步操作的事件，在异步事件完成后继续。兼容同步事件处理函数，或多个处理函数中既有同步又有异步。<br />
返回Deferred对象，或false表示要求取消之后操作。</p>
<p class="param"><strong>@param ev</strong>  事件名，或事件对象$.Event()</p>
<p>示例：以事件触发方式调用jo的异步方法submit:</p>
<pre><code>var dfd = WUI.triggerAsync(jo, 'submit');
if (dfd === false)
    return;
dfd.then(doNext);

function doNext() { }</code></pre>
<p>jQuery对象这样提供异步方法：triggerAsync会用事件对象ev创建一个dfds数组，将Deferred对象存入即可支持异步调用。</p>
<pre><code>jo.on('submit', function (ev) {
    var dfd = $.ajax("upload", ...);
    if (ev.dfds)
        ev.dfds.push(dfd);
});</code></pre></div>
<div class="block">
<h2 id="$.Deferred">@fn $.Deferred</h2>
<p class="alias"><strong>@alias <a id="Promise">Promise</a></strong> </p>
<p>兼容Promise的接口，如then/catch/finally</p></div>
<div class="block">
<h2 id="evalAttr">@fn evalAttr(jo, name)</h2>
<p>返回一个属性做eval后的js值。</p>
<p>示例：读取一个对象值：</p>
<pre><code>var opt = evalAttr(jo, "data-opt");

&lt;div data-opt="{id:1, name:\"data1\"}"&gt;&lt;div&gt;</code></pre>
<p>考虑兼容性，也支持忽略括号的写法，</p>
<pre><code>&lt;div data-opt="id:1, name:\"data1\""&gt;&lt;div&gt;</code></pre>
<p>读取一个数组：</p>
<pre><code>var arr = evalAttr(jo, "data-arr");

&lt;div data-arr="['aa', 'bb']"&gt;&lt;div&gt;</code></pre>
<p>读取一个函数名（或变量）:</p>
<pre><code>var fn = evalAttr(jo, "mui-initfn");

&lt;div mui-initfn="initMyPage"&gt;&lt;div&gt;</code></pre></div>
<div class="block">
<h2 id="app_abort">@fn app_abort()</h2>
<p>中止之后的调用, 直接返回.</p></div>
<div class="block">
<h2 id="DirectReturn">@class DirectReturn</h2>
<p>直接返回. 用法:</p>
<pre><code>throw new DirectReturn();</code></pre>
<p>可直接调用app_abort();</p></div>
<div class="block">
<h2 id="setOnError">@fn setOnError()</h2>
<p>一般框架自动设置onerror函数；如果onerror被其它库改写，应再次调用该函数。<br />
allow throw(&quot;abort&quot;) as abort behavior.</p></div>
<div class="block">
<h2 id="m_enhanceFn">@var m_enhanceFn</h2></div>
<div class="block">
<h2 id="enhanceWithin">@fn enhanceWithin(jparent)</h2></div>
<div class="block">
<h2 id="getOptions">@fn getOptions(jo, defVal?)</h2>
<p>第一次调用，根据jo上设置的data-options属性及指定的defVal初始化，或为<code>{}</code>。<br />
存到jo.prop(&quot;muiOptions&quot;)上。之后调用，直接返回该属性。</p>
<p class="see"><strong>@see <a href="#getDataOptions">getDataOptions</a></strong> </p></div>
<div class="block">
<h2 id="getQueryCond">@fn getQueryCond(kvList)</h2>
<p class="var"><strong>@var <a id="queryHint">queryHint</a></strong>  查询用法提示</p>
<p class="param"><strong>@param kvList</strong>  {key=>value}, 键值对，值中支持操作符及通配符。也支持格式 [ [key, value] ], 这时允许key有重复。</p>
<p>根据kvList生成BPQ协议定义的{obj}.query的cond参数。</p>
<p>例如:</p>
<pre><code>var kvList = {phone: "13712345678", id: "&gt;100", addr: "上海*", picId: "null"};
WUI.getQueryCond(kvList);</code></pre>
<p>有多项时，每项之间以&quot;AND&quot;相连，以上定义将返回如下内容：</p>
<pre><code>"phone='13712345678' AND id&gt;100 AND addr LIKE '上海*' AND picId IS NULL"</code></pre>
<p>示例二：</p>
<pre><code>var kvList = [ ["phone", "13712345678"], ["id", "&gt;100"], ["addr", "上海*"], ["picId", "null"] ];
WUI.getQueryCond(kvList); // 结果同上。</code></pre>
<p>设置值时，支持以下格式：</p>
<ul>
<li>{key: &quot;value&quot;} - 表示&quot;key=value&quot;</li>
<li>{key: &quot;&gt;value&quot;} - 表示&quot;key&gt;value&quot;, 类似地，可以用 &gt;=, &lt;, &lt;=, <>(或! / != 都是不等于) 这些操作符。</li>
<li>{key: &quot;value<em>&quot;} - 值中带通配符，表示&quot;key like 'value%'&quot; (以value开头), 类似地，可以用 &quot;</em>value&quot;, &quot;<em>value</em>&quot;, &quot;<em>val</em>ue&quot;等。</li>
<li>{key: &quot;null&quot; } - 表示 &quot;key is null&quot;。要表示&quot;key is not null&quot;，可以用 &quot;<>null&quot;.</li>
<li>{key: &quot;empty&quot; } - 表示 &quot;key=''&quot;.</li>
</ul>
<p>支持and/or查询，但不支持在其中使用括号:</p>
<ul>
<li>{key: &quot;&gt;value and &lt;=value&quot;}  - 表示&quot;key&gt;'value' and key&lt;='value'&quot;</li>
<li>{key: &quot;null or 0 or 1&quot;}  - 表示&quot;key is null or key=0 or key=1&quot;</li>
<li>{key: &quot;null,0,1,9-100&quot;} - 表示&quot;key is null or key=0 or key=1 or (key&gt;=9 and key&lt;=100)&quot;，即逗号表示or，a-b的形式只支持数值。</li>
<li>{key: &quot;2017-9-1~2017-10-1&quot;} 条件等价于 &quot;&gt;=2017-9-1 and &lt;2017-10-1&quot;<br />
可指定时间，如条件&quot;2017-9-1 10:00~2017-10-1&quot;等价于&quot;&gt;=2017-9-1 10:00 and &lt;2017-10-1&quot;</li>
<li>符号&quot;,&quot;及&quot;~&quot;前后允许有空格，如&quot;已付款, 已完成&quot;, &quot;2017-1-1 ~ 2018-1-1&quot;</li>
<li>可以使用中文逗号</li>
<li>日期区间也可以用&quot;2017/10/01&quot;或&quot;2017.10.01&quot;这些格式，仅用于字段是文本类型，这时输入格式必须与保存的日期格式一致，并且&quot;2017/10/1&quot;应输入&quot;2017/10/01&quot;才能正确比较字符串大小。</li>
</ul>
<p>以下表示的范围相同：</p>
<pre><code>{k1:'1-5,7-10', k2:'1-10 and &lt;&gt;6'}</code></pre>
<p>符号优先级依次为：&quot;-&quot;(类似and) &quot;,&quot;(类似or) and or</p>
<p>在详情页对话框中，切换到查找模式，在任一输入框中均可支持以上格式。</p>
<p>(v5.5) value支持用数组表示范围（前闭后开区间），主要内部使用：</p>
<pre><code>var cond = getQueryCond({tm: ["2019-1-1", "2020-1-1"]}); // 生成 "tm&gt;='2019-1-1' AND tm&lt;'2020-1-1'"
var cond = getQueryCond({tm: [null, "2020-1-1"]}); // 生成 "tm&lt;'2020-1-1'"
var cond = getQueryCond({tm: [null, null]); // 返回null</code></pre>
<p class="see"><strong>@see <a href="#getQueryParam">getQueryParam</a></strong> </p>
<p class="see"><strong>@see <a href="#getQueryParamFromTable">getQueryParamFromTable</a></strong>  获取datagrid的当前查询参数</p>
<p class="see"><strong>@see <a href="#doFind">doFind</a></strong> </p>
<p>(v5.5) 支持在key中包含查询提示。如&quot;code/s&quot;表示不要自动猜测数值区间或日期区间。<br />
比如输入'126231-191024'时不会当作查询126231到191024的区间。</p>
<p class="see"><strong>@see <a href="#wui-find-hint">wui-find-hint</a></strong> </p></div>
<div class="block">
<h2 id="getQueryParam">@fn getQueryParam(kvList)</h2>
<p>根据键值对生成BQP协议中{obj}.query接口需要的cond参数.<br />
即 <code>{cond: WUI.getQueryCond(kvList) }</code></p>
<p>示例：</p>
<pre><code>WUI.getQueryParam({phone: '13712345678', id: '&gt;100'})
返回
{cond: "phone='13712345678' AND id&gt;100"}</code></pre>
<p class="see"><strong>@see <a href="#getQueryCond">getQueryCond</a></strong> </p>
<p class="see"><strong>@see <a href="#getQueryParamFromTable">getQueryParamFromTable</a></strong>  获取datagrid的当前查询参数</p></div>
<div class="block">
<h2 id="doSpecial">@fn doSpecial(jo, filter, fn, cnt=5, interval=2s)</h2>
<p>连续5次点击某处，每次点击间隔不超过2s, 执行隐藏动作。</p>
<p>例：<br />
// 连续5次点击当前tab标题，重新加载页面. ev为最后一次点击事件.<br />
var self = WUI;<br />
self.doSpecial(self.tabMain.find(&quot;.tabs-header&quot;), &quot;.tabs-selected&quot;, function (ev) {<br />
self.reloadPage();<br />
self.reloadDialog(true);</p>
<pre><code>    // 弹出菜单
    //jmenu.menu('show', {left: ev.pageX, top: ev.pageY});
    return false;
});</code></pre>
<p>连续3次点击对话框中的字段标题，触发查询：</p>
<pre><code>WUI.doSpecial(jdlg, ".wui-form-table td", fn, 3);</code></pre></div>
<div class="block">
<h2 id="lastError">@var lastError = ctx</h2>
<p>出错时，取出错调用的上下文信息。</p>
<p>ctx: {ac, tm, tv, ret}</p>
<ul>
<li>ac: action 调用接口名</li>
<li>tm: start time 开始调用时间</li>
<li>tv: time interval 从调用到返回的耗时</li>
<li>ret: return value 调用返回的原始数据</li>
</ul></div>
<div class="block">
<h2 id="disableBatch">@var disableBatch ?= false</h2>
<p>设置为true禁用batchCall, 仅用于内部测试。</p></div>
<div class="block">
<h2 id="m_curBatch">@var m_curBatch</h2>
<p>当前batchCall对象，用于内部调试。</p></div>
<div class="block">
<h2 id="mockData">@var mockData  模拟调用后端接口。</h2>
<p>在后端接口尚无法调用时，可以配置MUI.mockData做为模拟接口返回数据。<br />
调用callSvr时，会直接使用该数据，不会发起ajax请求。</p>
<p>mockData={ac =&gt; data/fn}  </p>
<p>mockData中每项可以直接是数据，也可以是一个函数：fn(param, postParam)-&gt;data</p>
<p>例：模拟&quot;User.get(id)&quot;和&quot;User.set()(key=value)&quot;接口：</p>
<pre><code>var user = {
    id: 1001,
    name: "孙悟空",
};
MUI.mockData = {
    // 方式1：直接指定返回数据
    "User.get": [0, user],

    // 方式2：通过函数返回模拟数据
    "User.set": function (param, postParam) {
        $.extend(user, postParam);
        return [0, "OK"];
    }
}

// 接口调用：
var user = callSvrSync("User.get");
callSvr("User.set", {id: user.id}, function () {
    alert("修改成功！");
}, {name: "大圣"});</code></pre>
<p>实例详见文件 mockdata.js。</p>
<p>在mockData的函数中，可以用this变量来取ajax调用参数。<br />
要取HTTP动词可以用<code>this.type</code>，值为GET/POST/PATCH/DELETE之一，从而可模拟RESTful API.</p>
<p>可以通过MUI.options.mockDelay设置模拟调用接口的网络延时。</p>
<p class="see"><strong>@see <a href="#options.mockDelay">options.mockDelay</a></strong> </p>
<p>模拟数据可直接返回[code, data]格式的JSON数组，框架会将其序列化成JSON字符串，以模拟实际场景。<br />
如果要查看调用与返回数据日志，可在浏览器控制台中设置 MUI.options.logAction=true，在控制台中查看日志。</p>
<p>如果设置了MUI.callSvrExt，调用名(ac)中应包含扩展(ext)的名字，例：</p>
<pre><code>MUI.callSvrExt['zhanda'] = {...};
callSvr(['token/get-token', 'zhanda'], ...);</code></pre>
<p>要模拟该接口，应设置</p>
<pre><code>MUI.mockData["zhanda:token/get-token"] = ...;</code></pre>
<p class="see"><strong>@see <a href="#callSvrExt">callSvrExt</a></strong> </p>
<p>也支持&quot;default&quot;扩展，如：</p>
<pre><code>MUI.callSvrExt['default'] = {...};
callSvr(['token/get-token', 'default'], ...);
或
callSvr('token/get-token', ...);</code></pre>
<p>要模拟该接口，可设置</p>
<pre><code>MUI.mockData["token/get-token"] = ...;</code></pre></div>
<div class="block">
<h2 id="$.ajax">@key $.ajax</h2>
<p class="key"><strong>@key <a id="ajaxOpt.jdFilter">ajaxOpt.jdFilter</a></strong>  禁用返回格式合规检查.</p>
<p>以下调用, 如果1.json符合<code>[code, data]</code>格式, 则只返回处理data部分; 否则将报协议格式错误:</p>
<pre><code>$.ajax("1.json", {dataType: "json"})
$.get("1.json", null, console.log, "json")
$.getJSON("1.json", null, console.log)</code></pre>
<p>对于ajax调用($.ajax,$.get,$.post,$.getJSON等), 若明确指定dataType为&quot;json&quot;或&quot;text&quot;, 且未指定jdFilter为false,<br />
则框架按筋斗云返回格式即<code>[code, data]</code>来处理只返回data部分, 不符合该格式, 则报协议格式错误.</p>
<p>以下调用未指定dataType, 或指定了jdFilter=false, 则不会应用筋斗云协议格式:</p>
<pre><code>$.ajax("1.json")
$.get("1.json", null, console.log)
$.ajax("1.json", {jdFilter: false}) // jdFilter选项明确指定了不应用筋斗云协议格式</code></pre></div>
<div class="block">
<h2 id="enterWaiting">@fn enterWaiting(ctx?)</h2>
<p class="param"><strong>@param ctx</strong>  {ac, tm, tv?, tv2?, noLoadingImg?}</p></div>
<div class="block">
<h2 id="leaveWaiting">@fn leaveWaiting(ctx?)</h2></div>
<div class="block">
<h2 id="defDataProc">@fn defDataProc(rv)</h2>
<p class="param"><strong>@param rv</strong>  BQP协议原始数据，如 "[0, {id: 1}]"，一般是字符串，也可以是JSON对象。</p>
<p class="return"><strong>@return data</strong>  按接口定义返回的数据对象，如 {id: 1}. 如果返回值===RV_ABORT，调用函数应直接返回，不回调应用层。</p>
<p>注意：如果callSvr设置了<code>noex:1</code>选项，则当调用失败时返回false。</p></div>
<div class="block">
<h2 id="getBaseUrl">@fn getBaseUrl()</h2>
<p>取服务端接口URL对应的目录。可用于拼接其它服务端资源。<br />
相当于dirname(MUI.options.serverUrl);</p>
<p>例如：</p>
<p>serverUrl为&quot;../jdcloud/api.php&quot; 或 &quot;../jdcloud/&quot;，则MUI.baseUrl返回 &quot;../jdcloud/&quot;<br />
serverUrl为&quot;<a href="http://myserver/myapp/api.php">http://myserver/myapp/api.php</a>&quot; 或 &quot;<a href="http://myserver/myapp/"，则MUI.baseUrl返回">http://myserver/myapp/"，则MUI.baseUrl返回</a> &quot;<a href="http://myserver/myapp/">http://myserver/myapp/</a>&quot;</p></div>
<div class="block">
<h2 id="makeUrl">@fn makeUrl(action, params?)</h2>
<p>生成对后端调用的url. </p>
<pre><code>var params = {id: 100};
var url = MUI.makeUrl("Ordr.set", params);</code></pre>
<p>注意：函数返回的url是字符串包装对象，可能含有这些属性：{makeUrl=true, action?, params?}<br />
这样可通过url.action得到原始的参数。</p>
<p>支持callSvr扩展，如：</p>
<pre><code>var url = MUI.makeUrl('zhanda:login');</code></pre>
<p>(deprecated) 为兼容旧代码，action可以是一个数组，在WUI环境下表示对象调用:</p>
<pre><code>WUI.makeUrl(['Ordr', 'query']) 等价于 WUI.makeUrl('Ordr.query');</code></pre>
<p>在MUI环境下表示callSvr扩展调用:</p>
<pre><code>MUI.makeUrl(['login', 'zhanda']) 等价于 MUI.makeUrl('zhanda:login');</code></pre>
<p>特别地, 如果action是相对路径, 或是'.php'文件, 则不会自动拼接WUI.options.serverUrl:</p>
<pre><code>callSvr("./1.json"); // 如果是callSvr("1.json") 则url可能是 "../api.php/1.json"这样.
callSvr("./1.php");</code></pre>
<p class="see"><strong>@see <a href="#callSvrExt">callSvrExt</a></strong> </p></div>
<div class="block">
<h2 id="callSvr">@fn callSvr(ac, [params?], fn?, postParams?, userOptions?) -> deferredObject</h2><div class="toc"><p style="margin-left:0em"><a href="#callSvr-1 调用监控">1 调用监控</a></p>
<p style="margin-left:0em"><a href="#callSvr-2 文件上传支持(FormData)">2 文件上传支持(FormData)</a></p>
<p style="margin-left:0em"><a href="#callSvr-3 callSvr扩展">3 callSvr扩展</a></p>
<p style="margin-left:0em"><a href="#callSvr-4 适配RESTful API">4 适配RESTful API</a></p>
<p style="margin-left:0em"><a href="#callSvr-5 jQuery的$.Deferred兼容Promise接口">5 jQuery的$.Deferred兼容Promise接口</a></p>
<p style="margin-left:0em"><a href="#callSvr-6 直接取json类文件">6 直接取json类文件</a></p>
</div>
<p class="param"><strong>@param ac</strong>  String. action, 交互接口名. 也可以是URL(比如由makeUrl生成)</p>
<p class="param"><strong>@param params</strong>  Object. URL参数（或称HTTP GET参数）</p>
<p class="param"><strong>@param postParams</strong>  Object. POST参数. 如果有该参数, 则自动使用HTTP POST请求(postParams作为POST内容), 否则使用HTTP GET请求.</p>
<p class="param"><strong>@param fn</strong>  Function(data). 回调函数, data参考该接口的返回值定义。</p>
<p class="param"><strong>@param userOptions</strong>  用户自定义参数, 会合并到$.ajax调用的options参数中.可在回调函数中用"this.参数名"引用. </p>
<p>常用userOptions: </p>
<ul>
<li>指定{async:0}来做同步请求, 一般直接用callSvrSync调用来替代.</li>
<li>指定{noex:1}用于忽略错误处理。</li>
<li>指定{noLoadingImg:1} 静默调用，忽略loading图标，不设置busy状态。</li>
</ul>
<p>指定contentType和设置自定义HTTP头(headers)示例:</p>
<pre><code>var opt = {
    contentType: "text/xml",
    headers: {
        Authorization: "Basic aaa:bbb"
    }
};
callSvr("hello", $.noop, "&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;return&gt;&lt;code&gt;0&lt;/code&gt;&lt;/return&gt;", opt);</code></pre>
<p>想为ajax选项设置缺省值，可以用callSvrExt中的beforeSend回调函数，也可以用$.ajaxSetup，<br />
但要注意：ajax的dataFilter/beforeSend选项由于框架已用，最好不要覆盖。</p>
<p class="see"><strong>@see <a href="#callSvrExt[].beforeSend">callSvrExt[].beforeSend</a></strong> (opt) 为callSvr选项设置缺省值</p>
<p class="return"><strong>@return deferred对象，在Ajax调用成功后回调。</strong> </p>
<p>例如，</p>
<pre><code>var dfd = callSvr(ac, fn1);
dfd.then(fn2);

function fn1(data) {}
function fn2(data) {}</code></pre>
<p>在接口调用成功后，会依次回调fn1, fn2. 在回调函数中this表示ajax参数。例如：</p>
<pre><code>callSvr(ac, function (data) {
    // 可以取到传入的参数。
    console.log(this.key1);
}, null, {key1: 'val1'});</code></pre>
<p>(v5.4) 支持失败时回调：</p>
<pre><code>var dfd = callSvr(ac);
dfd.fail(function (data) {
    console.log('error', data);
    console.log(this.ctx_.ret); // 和设置选项{noex:1}时回调中取MUI.lastError.ret 或 this.lastError相同。
});</code></pre>
<p class="key"><strong>@key <a id="callSvr.noex">callSvr.noex</a></strong>  调用接口时忽略出错，可由回调函数fn自己处理错误。</p>
<p>当后端返回错误时, 回调<code>fn(false)</code>（参数data=false）. 可通过 MUI.lastError.ret 或 this.lastError 取到返回的原始数据。</p>
<p>示例：</p>
<pre><code>callSvr("logout");
callSvr("logout", api_logout);
function api_logout(data) {}

callSvr("login", api_login);
function api_login(data) {}

callSvr("info/hotline.php", {q: '大众'}, api_hotline);
function api_hotline(data) {}

// 也可使用makeUrl生成的URL如:
callSvr(MUI.makeUrl("logout"), api_logout);
callSvr(MUI.makeUrl("logout", {a:1}), api_logout);

callSvr("User.get", function (data) {
    if (data === false) { // 仅当设置noex且服务端返回错误时可返回false
        // var originalData = MUI.lastError.ret; 或
        // var originalData = this.lastError;
        return;
    }
    foo(data);
}, null, {noex:1});</code></pre>
<p class="see"><strong>@see <a href="#lastError">lastError</a></strong>  出错时的上下文信息</p>
<h4 id="callSvr-1 调用监控">1 调用监控</h4>
<p>框架会自动在ajaxOption中增加ctx_属性，它包含 {ac, tm, tv, tv2, ret} 这些信息。<br />
当设置MUI.options.logAction=1时，将输出这些信息。</p>
<ul>
<li>ac: action</li>
<li>tm: start time</li>
<li>tv: time interval (从发起请求到服务器返回数据完成的时间, 单位是毫秒)</li>
<li>tv2: 从接到数据到完成处理的时间，毫秒(当并发处理多个调用时可能不精确)</li>
</ul>
<h4 id="callSvr-2 文件上传支持(FormData)">2 文件上传支持(FormData)</h4>
<p>callSvr支持FormData对象，可用于上传文件等场景。示例如下：</p>
<p class="key"><strong>@key <a id="example-upload">example-upload</a></strong> </p>
<p>HTML:</p>
<pre><code>file: &lt;input id="file1" type="file" multiple&gt;
&lt;button type="button" id="btn1"&gt;upload&lt;/button&gt;</code></pre>
<p>JS:</p>
<pre><code>jpage.find("#btn1").on('click', function () {
    var fd = new FormData();
    $.each(jpage.find('#file1')[0].files, function (i, e) {
        fd.append('file' + (i+1), e);
    });
    callSvr('upload', api_upload, fd);

    function api_upload(data) { ... }
});</code></pre>
<h4 id="callSvr-3 callSvr扩展">3 callSvr扩展</h4>
<p class="key"><strong>@key <a id="callSvrExt">callSvrExt</a></strong> </p>
<p>当调用第三方API时，也可以使用callSvr扩展来代替$.ajax调用以实现：</p>
<ul>
<li>调用成功时直接可操作数据，不用每次检查返回码；</li>
<li>调用出错时可以统一处理。</li>
</ul>
<p>例：合作方接口使用HTTP协议，格式如（以生成token调用为例）</p>
<pre><code>http://&lt;Host IP Address&gt;:&lt;Host Port&gt;/lcapi/token/get-token?user=用户名&amp;password=密码</code></pre>
<p>返回格式为：{code, msg, data}</p>
<p>成功返回：</p>
<pre><code>{
    "code":"0",
    "msg":"success",
    "data":[ { "token":"xxxxxxxxxxxxxx" } ]
}</code></pre>
<p>失败返回：</p>
<pre><code>{
    "code":"4001",
    "msg":"invalid username or password",
    "data":[]
}</code></pre>
<p>callSvr扩展示例：</p>
<pre><code>MUI.callSvrExt['zhanda'] = {
    makeUrl: function(ac, param) {
        // 只需要返回接口url即可，不必拼接param
        return 'http://hostname/lcapi/' + ac;
    },
    dataFilter: function (data) {
        if ($.isPlainObject(data) &amp;&amp; data.code !== undefined) {
            if (data.code == 0)
                return data.data;
            if (this.noex)
                return false;
            app_alert("操作失败：" + data.msg, "e");
        }
        else {
            app_alert("服务器通讯协议异常!", "e"); // 格式不对
        }
    }
};</code></pre>
<p>在调用时，ac参数使用&quot;{扩展名}:{调用名}&quot;的格式：</p>
<pre><code>callSvr('zhanda:token/get-token', {user: 'test', password: 'test123'}, function (data) {
    console.log(data);
});</code></pre>
<p>旧的调用方式ac参数使用数组，现在已不建议使用：</p>
<pre><code>callSvr(['token/get-token', 'zhanda'], ...);</code></pre>
<p class="key"><strong>@key <a id="callSvrExt[].makeUrl">callSvrExt[].makeUrl</a></strong> (ac, param)</p>
<p>根据调用名ac生成url, 注意无需将param放到url中。</p>
<p>注意：<br />
对方接口应允许JS跨域调用，或调用方支持跨域调用。</p>
<p class="key"><strong>@key <a id="callSvrExt[].dataFilter">callSvrExt[].dataFilter</a></strong> (data) = null/false/data</p>
<p>对调用返回数据进行通用处理。返回值决定是否调用callSvr的回调函数以及参数值。</p>
<pre><code>callSvr(ac, callback);</code></pre>
<ul>
<li>返回data: 回调应用层的实际有效数据: <code>callback(data)</code>.</li>
<li>返回null: 一般用于报错后返回。不会回调<code>callback</code>.</li>
<li>返回false: 一般与callSvr的noex选项合用，如<code>callSvr(ac, callback, postData, {noex:1})</code>，表示由应用层回调函数来处理出错: <code>callback(false)</code>。</li>
</ul>
<p>当返回false时，应用层可以通过<code>MUI.lastError.ret</code>来获取服务端返回数据。</p>
<p class="see"><strong>@see <a href="#lastError">lastError</a></strong>  出错时的上下文信息</p>
<p class="key"><strong>@key <a id="callSvrExt['default']">callSvrExt['default']</a></strong> </p>
<p>(支持版本: v3.1)<br />
如果要修改callSvr缺省调用方法，可以改写 MUI.callSvrExt['default']。示例：</p>
<pre><code>MUI.callSvrExt['default'] = {
    makeUrl: function(ac) {
        return '../api.php/' + ac;
    },
    dataFilter: function (data) {
        var ctx = this.ctx_ || {};
        if (data &amp;&amp; $.isArray(data) &amp;&amp; data.length &gt;= 2 &amp;&amp; typeof data[0] == "number") {
            if (data[0] == 0)
                return data[1];

            if (this.noex)
            {
                return false;
            }

            if (data[0] == E_NOAUTH) {
                // 如果支持自动重登录
                //if (MUI.tryAutoLogin()) {
                //  $.ajax(this);
                //}
                // 不支持自动登录，则跳转登录页
                MUI.popPageStack(0);
                MUI.showLogin();
                return;
            }
            else if (data[0] == E_AUTHFAIL) {
                app_alert("验证失败，请检查输入是否正确!", "e");
                return;
            }
            else if (data[0] == E_ABORT) {
                console.log("!!! abort call");
                return;
            }
            logError();
            app_alert("操作失败：" + data[1], "e");
        }
        else {
            logError();
            app_alert("服务器通讯协议异常!", "e"); // 格式不对
        }

        function logError()
        {
            console.log("failed call");
            console.log(ctx);
        }
    }
};</code></pre>
<p class="key"><strong>@key <a id="callSvrExt[].beforeSend">callSvrExt[].beforeSend</a></strong> (opt) 为callSvr或$.ajax选项设置缺省值</p>
<p>如果有ajax选项想设置，可以使用beforeSend回调，例如POST参数使用JSON格式：</p>
<pre><code>MUI.callSvrExt['default'] = {
    beforeSend: function (opt) {
        // 示例：设置contentType
        if (opt.contentType == null) {
            opt.contentType = "application/json;charset=utf-8";
        }
        // 示例：添加HTTP头用于认证
        if (g_data.auth) {
            if (opt.headers == null)
                opt.headers = {};
            opt.headers["Authorization"] = "Basic " + g_data.auth;
        }
    }
}</code></pre>
<p>可以从opt.ctx<em>中取到{ac, ext, noex, dfd}等值（如opt.ctx</em>.ac），可以从opt.url中取到{ac, params}值。</p>
<p>如果要设置请求的HTTP headers，可以用<code>opt.headers = {header1: "value1", header2: "value2"}</code>.<br />
更多选项参考jquery文档：jQuery.ajax的选项。</p>
<h4 id="callSvr-4 适配RESTful API">4 适配RESTful API</h4>
<p>接口示例：更新订单</p>
<pre><code>PATCH /orders/{ORDER_ID}

调用成功仅返回HTTP状态，无其它内容："200 OK" 或 "204 No Content"
调用失败返回非2xx的HTTP状态及错误信息，无其它内容，如："400 bad id"</code></pre>
<p>为了处理HTTP错误码，应设置：</p>
<pre><code>MUI.callSvrExt["default"] = {
    beforeSend: function (opt) {
        opt.handleHttpError = true;
    },
    dataFilter: function (data) {
        var ctx = this.ctx_;
        if (ctx &amp;&amp; ctx.status) {
            if (this.noex)
                return false;
            app_alert(ctx.statusText, "e");
            return;
        }
        return data;
    }
}</code></pre>
<ul>
<li>在beforeSend回调中，设置handleHttpError为true，这样HTTP错误会由dataFilter处理，而非框架自动处理。</li>
<li>在dataFilter回调中，如果this.ctx<em>.status非空表示是HTTP错误，this.ctx</em>.statusText为错误信息。</li>
<li>如果操作成功但无任何返回数据，回调函数fn(data)中data值为undefined（当HTTP状态码为204）或空串（非204返回）</li>
<li>不要设置ajax调用失败的回调，如<code>$.ajaxSetup({error: fn})</code>，<code>$.ajax({error: fn})</code>，它会覆盖框架的处理.</li>
</ul>
<p>如果接口在出错时，返回固定格式的错误对象如{code, message}，可以这样处理：</p>
<pre><code>MUI.callSvrExt["default"] = {
    beforeSend: function (opt) {
        opt.handleHttpError = true;
    },
    dataFilter: function (data) {
        var ctx = this.ctx_;
        if (ctx &amp;&amp; ctx.status) {
            if (this.noex)
                return false;
            if (data &amp;&amp; data.message) {
                app_alert(data.message, "e");
            }
            else {
                app_alert("操作失败: 服务器错误. status=" + ctx.status + "-" + ctx.statusText, "e");
            }
            return;
        }
        return data;
    }
}</code></pre>
<p>调用接口时，HTTP谓词可以用callSvr的userOptions中给定，如：</p>
<pre><code>callSvr("orders/" + orderId, fn, postParam, {type: "PATCH"});</code></pre>
<p>这种方式简单，但因调用名ac是变化的，不易模拟接口。<br />
如果要模拟接口，可以保持调用名ac不变，像这样调用：</p>
<pre><code>callSvr("orders/{id}", {id: orderId}, fn, postParam, {type: "PATCH"});</code></pre>
<p>于是可以这样做接口模拟：</p>
<pre><code>MUI.mockData = {
    "orders/{id}": function (param, postParam) {
        var ret = "OK";
        // 获取资源
        if (this.type == "GET") {
            ret = orders[param.id];
        }
        // 更新资源
        else if (this.type == "PATCH") {
            $.extend(orders[param.id], postParam);
        }
        // 删除资源
        else if (this.type == "DELETE") {
            delete orders[param.id];
        }
        return [0, ret];
    }
};</code></pre>
<p>不过这种写法需要适配，以生成正确的URL，示例：</p>
<pre><code>MUI.callSvrExt["default"] = {
    makeUrl: function (ac, param) {
        ac = ac.replace(/\{(\w+)\}/g, function (m, m1) {
            var ret = param[m1];
            assert(ret != null, "缺少参数");
            delete param[m1];
            return ret;
        });
        return "./api.php/" + ac;
    }
}</code></pre>
<h4 id="callSvr-5 jQuery的$.Deferred兼容Promise接口">5 jQuery的$.Deferred兼容Promise接口</h4>
<pre><code>var dfd = callSvr("...");
dfd.then(function (data) {
    console.log(data);
})
.catch(function (err) {
    app_alert(err);
})
.finally(...)</code></pre>
<p>支持catch/finally等Promise类接口。接口逻辑失败时，dfd.reject()触发fail/catch链。</p>
<h4 id="callSvr-6 直接取json类文件">6 直接取json类文件</h4>
<p>(v5.5) 如果ac是调用相对路径, 则直接当成最终路径, 不做url拼接处理:</p>
<pre><code>callSvr("./1.json"); // 如果是callSvr("1.json") 则实际url可能是 "../api.php/1.json"这样.
callSvr("../1.php");</code></pre>
<p>相当于调用</p>
<pre><code>$.ajax("../1.php", {dataType: "json", success: callback})
或
$.getJSON("../1.php", callback);</code></pre>
<p>注意下面调用未指定dataType, 不会按筋斗云协议格式处理:</p>
<pre><code>$.ajax("../1.php", {success: callback})</code></pre>
<p class="see"><strong>@see <a href="#$.ajax">$.ajax</a></strong> </p></div>
<div class="block">
<h2 id="callSvrSync">@fn callSvrSync(ac, [params?], fn?, postParams?, userOptions?)</h2>
<p class="return"><strong>@return data</strong>  原型规定的返回数据</p>
<p>同步模式调用callSvr.</p>
<p class="see"><strong>@see <a href="#callSvr">callSvr</a></strong> </p></div>
<div class="block">
<h2 id="setupCallSvrViaForm">@fn setupCallSvrViaForm($form, $iframe, url, fn, callOpt)</h2>
<p>该方法已不建议使用。上传文件请用FormData。</p>
<p class="see"><strong>@see <a href="#example-upload">example-upload</a> <a href="#callSvr">callSvr</a></strong> </p>
<p class="param"><strong>@param $iframe</strong>  一个隐藏的iframe组件.</p>
<p class="param"><strong>@param callOpt</strong>  用户自定义参数. 参考callSvr的同名参数. e.g. {noex: 1}</p>
<p>一般对后端的调用都使用callSvr函数, 但像上传图片等操作不方便使用ajax调用, 因为要自行拼装multipart/form-data格式的请求数据.<br />
这种情况下可以使用form的提交和一个隐藏的iframe来实现类似的调用.</p>
<p>先定义一个form, 在其中放置文件上传控件和一个隐藏的iframe. form的target属性设置为iframe的名字:</p>
<pre><code>&lt;form data-role="content" action="upload" method=post enctype="multipart/form-data" target="ifrUpload"&gt;
    &lt;input type=file name="file[]" multiple accept="image/*"&gt;
    &lt;input type=submit value="上传"&gt;
    &lt;iframe id='ifrUpload' name='ifrUpload' style="display:none"&gt;&lt;/iframe&gt;
&lt;/form&gt;</code></pre>
<p>然后就像调用callSvr函数一样调用setupCallSvrViaForm:</p>
<pre><code>var url = MUI.makeUrl("upload", {genThumb: 1});
MUI.setupCallSvrViaForm($frm, $frm.find("iframe"), url, onUploadComplete);
function onUploadComplete(data) 
{
    alert("上传成功");
}</code></pre></div>
<div class="block">
<h2 id="batchCall">@class batchCall(opt?={useTrans?=0})</h2>
<p>批量调用。将若干个调用打包成一个特殊的batch调用发给服务端。<br />
注意：</p>
<ul>
<li>同步调用callSvrSync不会加入批处理。</li>
<li>对特别几个不符合BPQ协议输出格式规范的接口不可使用批处理，如upload, att等接口。</li>
<li>如果MUI.disableBatch=true, 表示禁用批处理。</li>
</ul>
<p>示例：</p>
<pre><code>var batch = new MUI.batchCall();
callSvr("Family.query", {res: "id,name"}, api_FamilyQuery);
callSvr("User.get", {res: "id,phone"}, api_UserGet);
batch.commit();</code></pre>
<p>以上两条调用将一次发送到服务端。<br />
在批处理中，默认每条调用是一个事务，如果想把批处理中所有调用放到一个事务中，可以用useTrans选项：</p>
<pre><code>var batch = new MUI.batchCall({useTrans: 1});
callSvr("Attachment.add", api_AttAdd, {path: "path-1"});
callSvr("Attachment.add", api_AttAdd, {path: "path-2"});
batch.commit();</code></pre>
<p>在一个事务中，所有调用要么成功要么都取消。<br />
任何一个调用失败，会导致它后面所有调用取消执行，且所有已执行的调用会回滚。</p>
<p>参数中可以引用之前结果中的值，引用部分需要用&quot;{}&quot;括起来，且要在opt.ref参数中指定哪些参数使用了引用：</p>
<pre><code>MUI.useBatchCall();
callSvr("..."); // 这个返回值的结果将用于以下调用
callSvr("Ordr.query", {
    res: "id,dscr",
    status: "{$-1.status}",  // 整体替换，结果可以是一个对象
    cond: "id&gt;{$-1.id}" // 部分替换，其结果只能是字符串
}, api_OrdrQuery, {
    ref: ["status", "cond"] // 须在ref中指定需要处理的key
});</code></pre>
<p>特别地，当get/post整个是一个字符串时，直接整体替换，无须在ref中指定，如：</p>
<pre><code>callSvr("Ordr.add", $.noop, "{$-1}", {contentType:"application/json"});</code></pre>
<p>以下为引用格式示例：</p>
<pre><code>{$1} // 第1次调用的结果。
{$-1} // 前1次调用的结果。
{$-1.path} // 取前一次调用结果的path属性
{$1[0]} // 取第1次调用结果（是个数组）的第0个值。
{$1[0].amount}
{$-1.price * $-1.qty} // 可以做简单的数值计算</code></pre>
<p>如果值计算失败，则当作&quot;null&quot;填充。</p>
<p>综合示例：</p>
<pre><code>MUI.useBatchCall();
callSvr("Ordr.completeItem", $.noop, {itemId:1})
callSvr("Ordr.completeItem", $.noop, {itemId:2, qty:2})
callSvr("Ordr.calc", $.noop, {items:["{$1}", "{$2}"]}, {contentType:"application/json", ref:["items"] });
callSvr("Ordr.add", $.noop, "{$3}", {contentType:"application/json"});</code></pre>
<p class="see"><strong>@see <a href="#useBatchCall">useBatchCall</a></strong> </p>
<p class="see"><strong>@see <a href="#disableBatch">disableBatch</a></strong> </p>
<p class="see"><strong>@see <a href="#m_curBatch">m_curBatch</a></strong> </p></div>
<div class="block">
<h2 id="useBatchCall">@fn useBatchCall(opt?={useTrans?=0}, tv?=0)</h2>
<p>之后的callSvr调用都加入批量操作。例：</p>
<pre><code>MUI.useBatchCall();
callSvr("Family.query", {res: "id,name"}, api_FamilyQuery);
callSvr("User.get", {res: "id,phone"}, api_UserGet);</code></pre>
<p>可指定多少毫秒以内的操作都使用批处理，如10ms内：</p>
<pre><code>MUI.useBatchCall(null, 10);</code></pre>
<p>如果MUI.disableBatch=true, 该函数不起作用。</p>
<p class="see"><strong>@see <a href="#batchCall">batchCall</a></strong> </p>
<p class="see"><strong>@see <a href="#disableBatch">disableBatch</a></strong> </p></div>
<div class="block">
<h2 id="activePage">@var activePage</h2>
<p>当前页面。</p>
<p>注意：</p>
<ul>
<li>在初始化过程中，值可能为null;</li>
<li>调用MUI.showPage后，该值在新页面加载之后，发出pageshow事件之前更新。因而在pagebeforeshow事件中，MUI.activePage尚未更新。</li>
</ul>
<p>要查看从哪个页面来，可以用 MUI.prevPageId。<br />
要查看最近一次调用MUI.showPage转向的页面，可以用 MUI.getToPageId().</p>
<p class="see"><strong>@see <a href="#prevPageId">prevPageId</a></strong> </p>
<p class="see"><strong>@see <a href="#getToPageId">getToPageId</a></strong> ()</p></div>
<div class="block">
<h2 id="prevPageId">@var prevPageId</h2>
<p>上一个页面的id, 首次进入时为空.</p></div>
<div class="block">
<h2 id="container">@var container</h2>
<p>应用容器，一般就是<code>$(document.body)</code></p>
<p class="see"><strong>@see <a href="#.mui-container">.mui-container</a></strong> </p></div>
<div class="block">
<h2 id="showFirstPage">@var showFirstPage?=true</h2>
<p>如果为false, 则必须手工执行 MUI.showPage 来显示第一个页面。</p></div>
<div class="block">
<h2 id="nextShowPageOpt">@var nextShowPageOpt</h2>
<p>如果指定, 则在下次showPage时生效.<br />
初次进入App时无动画效果.</p>
<p>示例: 在返回上一页时指定不要动画效果:</p>
<pre><code>MUI.nextShowPageOpt = {ani: 'none'};
history.back();</code></pre>
<p>因为未直接调用MUI.showPage, 可以用nextShowPageOpt来传递参数. 此参数用后即焚.</p></div>
<div class="block">
<h2 id="setUrl">@fn setUrl(url)</h2>
<p>设置当前地址栏显示的URL. 如果url中不带hash部分，会自动加上当前的hash.</p>
<pre><code>MUI.setUrl("page/home.html"); // 设置url
MUI.setUrl("?a=1&amp;b=2"); // 设置url参数
MUI.setUrl("?"); // 清除url参数部分。</code></pre>
<p>如果要设置或删除参数，建议使用：</p>
<pre><code>MUI.setUrlParam("a", 1); // 如果参数存在，则会自动覆盖。
MUI.deleteUrlParam("a"); // 从url中删除参数a部分，如果g_args中有参数a，也同时删除。</code></pre>
<p>一般用于将应用程序内部参数显示到URL中，以便在刷新页面时仍然可显示相同的内容，或用于分享链接给别人。</p>
<p>例如订单页的URL为<code>http://server/app/#order</code>，现在希望：</p>
<ul>
<li>要显示<code>id=100</code>的订单，在URL中显示<code>http://server/app/?orderId=100#order</code></li>
<li>刷新该URL或分享给别人，均能正确打开<code>id=100</code>的订单。</li>
</ul>
<p>示例：在逻辑页<code>order</code>的<code>pagebeforeshow</code>回调函数中，处理内部参数<code>opt</code>或URL参数<code>g_args</code>：</p>
<pre><code>function initPageOrder()
{
    var jpage = this;
    var orderId_;
    jpage.on("pagebeforeshow", onPageBeforeShow);

    function onPageBeforeShow(ev, opt)
    {
        // 如果orderId_未变，不重新加载
        var skip = false;
        if (g_args.orderId) {
            orderId_ = g_args.orderId;
            // 只在初始进入时使用一次，用后即焚
            delete g_args.orderId;
        }
        else if (opt.orderId) {
            orderId_ = opt.orderId;
        }
        else {
            skip = true;
        }
        if (! orderId_) { // 参数不合法时跳回主页。
            MUI.showHome();
            return;
        }
        if (skip)
            return;
        MUI.setUrl("?orderId=" + orderId_);
        app_alert("show order " + orderId_);
    }
}</code></pre>
<p>在例子中，<code>opt</code>为<code>MUI.showPage()</code>时指定的参数，如调用<code>MUI.showPage("#order", {orderId: 100});</code>时，<code>opt.orderId=100</code>.<br />
而<code>g_args</code>为全局URL参数，如打开 <code>http://server/app/index.html?orderId=100#order</code>时，<code>g_args.orderId=100</code>.</p>
<p>注意逻辑页<code>#order</code>应允许作为入口页进入，否则刷新时会跳转回主页。可在index.js中的validateEntry参数中加上逻辑页：</p>
<pre><code>MUI.validateEntry([
    ...,
    "#order"
]);</code></pre>
<p>注意setUrl中以&quot;?&quot;开头，表示添加到URL参数中，保持URL主体部分不变。</p>
<p>如果<code>MUI.options.showHash=false</code>，则<code>MUI.setUrl("?orderId=100")</code>会将URL设置为<code>http://server/app/page/order.html?orderId=100</code>.<br />
我们甚至可以设置RESTful风格的URL: <code>MUI.setUrl("order/100")</code> 会将URL设置为 <code>http://server/app/order/100</code>.</p>
<p>在上面两个例子中，为了确保刷新URL时能正常显示，必须在Web服务器上配置URL重写规则，让它们都重定向到 <code>http://server/app/?orderId=100#order</code>.</p></div>
<div class="block">
<h2 id="deleteUrlParam">@fn deleteUrlParam(param)</h2>
<p>自动修改g_args全局变量和当前url（会调用MUI.setUrl方法）。</p>
<pre><code>MUI.deleteUrlParam("wxpay");
// 原先url为 http://myserver/myapp/index.html?wxpay=ORDR-11&amp;storeId=1
// 调用后为 http://myserver/myapp/index.html?storeId=1</code></pre></div>
<div class="block">
<h2 id="setUrlParam">@fn setUrlParam(param, val)</h2>
<p>修改当前url，添加指定参数。<br />
e.g. </p>
<pre><code>MUI.setUrlParam("wxauth", 1);</code></pre>
<p class="see"><strong>@see <a href="#deleteUrlParam">deleteUrlParam</a> <a href="#MUI.appendParam">MUI.appendParam</a></strong> </p></div>
<div class="block">
<h2 id="showPage">@fn showPage(pageId/pageRef?, opt?)</h2>
<p class="param"><strong>@param pageId</strong>  String. 页面名字. 仅由字母、数字、"_"等字符组成。</p>
<p class="param"><strong>@param pageRef</strong>  String. 页面引用（即location.hash），以"#"开头，后面可以是一个pageId（如"#home"）或一个相对页的地址（如"#info.html", "#emp/info.html"）。</p>
<p>如果未指定，则使用当前URL的hash或指定的主页(MUI.options.homePage). &quot;#&quot;表示主页。</p>
<p class="param"><strong>@param opt</strong>  {ani, url, backNoRefresh}  (v3.3) 该参数会传递给pagebeforeshow/pageshow回调函数。</p>
<p>opt.ani:: String. 动画效果。设置为&quot;none&quot;禁用动画。默认页面由右向左进入，设置为&quot;up&quot;表示由下向上进入（常用于popup页面）。</p>
<p>opt.url:: String. 指定在地址栏显示的地址。如 <code>showPage("#order", {url: "?id=100"})</code> 可设置显示的URL为 <code>page/order.html?id=100</code>.</p>
<p class="see"><strong>@see <a href="#setUrl">setUrl</a></strong> </p>
<p>在应用内无刷新地显示一个页面。</p>
<p>例：</p>
<pre><code>MUI.showPage("#order");</code></pre>
<p>显示order页，先在已加载的DOM对象中找id=&quot;order&quot;的对象，如果找不到，则尝试找名为&quot;tpl_home&quot;的模板DOM对象，如果找不到，则以ajax方式动态加载页面&quot;page/order.html&quot;。</p>
<p>注意：</p>
<ul>
<li>在加载页面时，只会取第一个DOM元素作为页面。</li>
</ul>
<p>加载成功后，会将该页面的id设置为&quot;order&quot;，然后依次：</p>
<pre><code>调用 mui-initfn中指定的初始化函数，如 initPageOrder
触发pagecreate事件
触发pagebeforeshow事件
触发pageshow事件</code></pre>
<p>动态加载页面时，缺省目录名为<code>page</code>，如需修改，应在初始化时设置pageFolder选项：</p>
<pre><code>MUI.options.pageFolder = "mypage";</code></pre>
<p>也可以显示一个指定路径的页面：</p>
<pre><code>MUI.showPage("#page/order.html");</code></pre>
<p>由于它对应的id是order, 在显示时，先找id=&quot;order&quot;的对象是否存在，如果不存在，则动态加载页面&quot;page/order.html&quot;并为该对象添加id=&quot;order&quot;.</p>
<p>在HTML中, 如果<a>标签的href属性以&quot;#&quot;开头，则会自动以showPage方式无刷新显示，如：</p>
<pre><code>&lt;a href="#order"&gt;order&lt;/a&gt;
&lt;a href="#emp/empinfo.html"&gt;empinfo&lt;/a&gt;</code></pre>
<p>可以通过<code>mui-opt</code>属性设置showPage的参数(若有多项，以逗号分隔)，如：</p>
<pre><code>&lt;a href="#me" mui-opt="ani:'none'"&gt;me&lt;/a&gt;</code></pre>
<p>如果不想在应用内打开页面，只要去掉链接中的&quot;#&quot;即可：</p>
<pre><code>&lt;a href="emp/empinfo.html"&gt;empinfo&lt;/a&gt;</code></pre>
<p>特别地，如果href属性以&quot;#dlg&quot;开头，则会自动以showDialog方式显示对话框，如</p>
<pre><code>&lt;a href="#dlgSetUserInfo"&gt;set user info&lt;/a&gt;</code></pre>
<p>点击后相当于调用：</p>
<pre><code>MUI.showDialog(MUI.activePage.find("#dlgSetUserInfo"));</code></pre>
<p>(v3.3) opt参数会传递到pagebeforeshow/pageshow参数中，如</p>
<pre><code>MUI.showPage("order", {orderId: 100});

function initPageOrder()
{
    var jpage = this;
    jpage.on("pagebeforeshow", function (ev, opt) {
        // opt={orderId: 100}
    });
    jpage.on("pageshow", function (ev, opt) {
        // opt={orderId: 100}
    });
}</code></pre>
<p>(v5.2)</p>
<p class="param"><strong>@param opt.backNoRefresh</strong>  ?=false 从新页面返回后，不要刷新当前页</p>
<p>实际为A-&gt;B页面跳转后，此后若有B-&gt;A跳转，不触发A页面的pagebeforeshow事件。<br />
在initPage时，也可直接在页面上设置: <code>jpage.prop("backNoRefresh", ["page1", "page2"])</code>, 表示从page1, page2转到当前页面，不触发pagebeforeshow事件。注意，数组中保存的是pageId，不是pageRef.</p>
<p>(v5.4) 设置backNoRefresh选项会导致pagebeforeshow事件不触发，对于必须依赖pagebeforeshow事件的逻辑，可以监听<code>pagebeforeshow.always</code>事件。</p>
<p>(v5.3)<br />
支持一个页面模板可创建多个页面实例。</p>
<pre><code>MUI.showPage("udt__费用");
MUI.showPage("udt__供应商");</code></pre>
<p>两者用同一套html/js，但数据不会干扰。</p>
<p>(v5.4)</p>
<p class="key"><strong>@key <a id="mui-ani">mui-ani</a></strong>  指定本页面进入时的动画效果. 支持"up"(由下向上), "pop"(fade展开)。</p>
<p class="key"><strong>@key <a id="slideIn">slideIn</a></strong> </p>
<p class="key"><strong>@key <a id="slideOut">slideOut</a></strong> </p>
<p>支持扩展动画效果。例如新动画名为&quot;xx&quot;，请参考mui.css定义slideIn_xx, slideOut_xx类，即可使用：</p>
<p>在page上指定进入动画：</p>
<pre><code>&lt;div mui-initfn="initSynopsis" mui-script="doctorSynopsis.js" mui-ani="up"&gt;</code></pre>
<p>在显示页面时指定动画：</p>
<pre><code>MUI.showPage("#doctorSynopsis", {ani: "up"});
或
&lt;a href="#doctorSynopsis" mui-opt="ani:'up'"&gt;页面1&lt;a&gt;</code></pre></div>
<div class="block">
<h2 id="setDocTitle">@fn setDocTitle(title)</h2>
<p>设置文档标题。默认在切换页面时，会将文档标题设置为逻辑页的标题(<code>hd</code>块中的<code>h1</code>或<code>h2</code>标签)。</p>
<p>文档原始标题可通过<code>MUI.title</code>获得。</p></div>
<div class="block">
<h2 id="unloadPage">@fn unloadPage(pageRef?)</h2>
<p class="param"><strong>@param pageRef</strong>  如未指定，表示当前页。</p>
<p>删除一个页面。</p></div>
<div class="block">
<h2 id="reloadPage">@fn reloadPage(pageRef?, opt?)</h2>
<p class="param"><strong>@param pageRef</strong>  如未指定，表示当前页。</p>
<p class="param"><strong>@param opt</strong>  传递给MUI.showPage的opt参数。参考MUI.showPage.</p>
<p>重新加载指定页面。不指定pageRef时，重加载当前页。</p></div>
<div class="block">
<h2 id="m_pageStack">@var m_pageStack</h2>
<p>页面栈，MUI.popPageStack对它操作</p></div>
<div class="block">
<h2 id="popPageStack">@fn popPageStack(n?=1) </h2>
<p>n=0: 退到首层, &gt;0: 指定pop几层</p>
<p>常用场景：</p>
<p>添加订单并进入下个页面后, 点击后退按钮时避免再回到添加订单页面, 应调用</p>
<pre><code>MUI.popPageStack(); // 当前页（提交订单页）被标记poped
MUI.showPage("#xxx"); // 进入下一页。之后回退时，可跳过被标记的前一页</code></pre>
<p>如果添加订单有两步（两个页面），希望在下个后面后退时跳过前两个页面, 可以调用</p>
<pre><code>MUI.popPageStack(2);
MUI.showPage("#xxx");</code></pre>
<p>如果想在下个页面后退时直接回到初始进入应用的逻辑页（不一定是首页）, 可以调用：（注意顺序！）</p>
<pre><code>MUI.showPage("#xxx");
MUI.popPageStack(0); // 标记除第一页外的所有页为poped, 所以之后回退时直接回到第一页。</code></pre>
<p>如果只是想立即跳回两页，不用调用popPageStack，而应调用：</p>
<pre><code>history.go(-2);</code></pre></div>
<div class="block">
<h2 id="getToPageId">@fn getToPageId()</h2>
<p>返回最近一次调用MUI.showPage时转向页面的Id.</p>
<p class="see"><strong>@see <a href="#prevPageId">prevPageId</a></strong> </p></div>
<div class="block">
<h2 id="showDialog">@fn showDialog(jdlg)</h2></div>
<div class="block">
<h2 id="closeDialog">@fn closeDialog(jdlg, remove=false)</h2></div>
<div class="block">
<h2 id="setupDialog">@fn setupDialog(jdlg, initfn)</h2>
<p class="return"><strong>@return 可以不返回,</strong>  或返回一个回调函数beforeShow, 在每次Dialog显示前调用.</p>
<p>使用该函数可设置dialog的初始化回调函数和beforeShow回调.</p>
<p>使用方法:</p>
<pre><code>MUI.setupDialog(jdlg, function () {
    var jdlg = this;
    jdlg.find("#btnOK").click(btnOK_click);

    function btnOK_click(ev) { }

    function beforeShow() {
        // var jdlg = this;
        var jtxt = jdlg.find("#txt1");
        callSvr("getxxx", function (data) {
            jtxt.val(data);
        });
    }
    return beforeShow;
});</code></pre></div>
<div class="block">
<h2 id="app_alert">@fn app_alert(msg, [type?=i], [fn?], opt?={timeoutInterval, defValue, onCancel(), keep})</h2>
<p class="key"><strong>@key <a id="#muiAlert">#muiAlert</a></strong> </p>
<p class="param"><strong>@param type</strong>  对话框类型: "i": info, 信息提示框; "e": error, 错误框; "w": warning, 警告框; "q": question, 确认框(会有"确定"和"取消"两个按钮); "p": prompt, 输入框</p>
<p class="param"><strong>@param fn</strong>  Function(text?) 回调函数，当点击确定按钮时调用。当type="p" (prompt)时参数text为用户输入的内容。</p>
<p class="param"><strong>@param opt</strong>  Object. 可选项。 timeoutInterval表示几秒后自动关闭对话框。defValue用于输入框(type=p)的缺省值.</p>
<p>opt.onCancel: 用于&quot;q&quot;, 点取消时回调.</p>
<p>示例:</p>
<pre><code>// 信息框，3s后自动点确定
app_alert("操作成功", function () {
    MUI.showPage("#orders");
}, {timeoutInterval: 3000});

// 错误框
app_alert("操作失败", "e");

// 确认框(确定/取消)
app_alert("立即付款?", "q", function () {
    MUI.showPage("#pay");
});

// 输入框
app_alert("输入要查询的名字:", "p", function (text) {
    callSvr("Book.query", {cond: "name like '%" + text + "%'});
});</code></pre>
<p>可自定义对话框，接口如下：</p>
<ul>
<li>对象id为muiAlert, class包含mui-dialog.</li>
<li>.p-title用于设置标题; .p-msg用于设置提示文字</li>
<li>两个按钮 #btnOK, #btnCancel，仅当type=q (question)时显示btnCancel.</li>
<li>输入框 #txtInput，仅当type=p (prompt)时显示。</li>
</ul>
<p>示例：</p>
<pre><code>&lt;div id="muiAlert" class="mui-dialog"&gt;
    &lt;h3 class="p-title"&gt;&lt;/h3&gt;
    &lt;div class="p-msg"&gt;&lt;/div&gt;
    &lt;input type="text" id="txtInput"&gt; &lt;!-- 当type=p时才会显示 --&gt;
    &lt;div&gt;
        &lt;a href="javascript:;" id="btnOK" class="mui-btn primary"&gt;确定&lt;/a&gt;
        &lt;a href="javascript:;" id="btnCancel" class="mui-btn"&gt;取消&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>app_alert一般会复用对话框 muiAlert, 除非层叠开多个alert, 这时将clone一份用于显示并在关闭后删除。</p>
<p>(v5.2)</p>
<p class="param"><strong>@param opt.keep</strong> ?=false 如果设置为true，则如果已经有弹出框，重用这个框而非重新弹出一个新框。</p>
<p>常用于显示进度，如：</p>
<pre><code>app_alert("正在处理: 0/1...");
app_alert("正在处理: 1/1...", {keep:true});
app_alert("处理完成!", {keep:true});</code></pre></div>
<div class="block">
<h2 id="showLoading">@fn showLoading()</h2></div>
<div class="block">
<h2 id="hideLoading">@fn hideLoading()</h2></div>
<div class="block">
<h2 id="title">@var title</h2>
<p>文档原始标题保存在<code>MUI.title</code>，在切换逻辑页面时，document.title会自动变更为当前页标题。</p>
<p class="see"><strong>@see <a href="#setDocTitle">setDocTitle</a></strong> </p></div>
<div class="block">
<h2 id="isBusy">@var isBusy</h2>
<p>标识应用当前是否正在与服务端交互。一般用于自动化测试。<br />
也常用于防止重复提交，示例：</p>
<pre><code>jpage.find(".btnUpload").click(btnUpload_click);
function btnUpload_click() {
    // 防止重复点击提交
    if (MUI.isBusy)
        return;
    callSvr("upload", ...);
}</code></pre></div>
<div class="block">
<h2 id="g_args">@var g_args</h2>
<p>应用参数。</p>
<p>URL参数会自动加入该对象，例如URL为 <code>http://{server}/{app}/index.html?orderId=10&amp;dscr=上门洗车</code>，则该对象有以下值：</p>
<pre><code>g_args.orderId=10; // 注意：如果参数是个数值，则自动转为数值类型，不再是字符串。
g_args.dscr="上门洗车"; // 对字符串会自动进行URL解码。</code></pre>
<p>框架会自动处理一些参数：</p>
<ul>
<li>g_args._debug: 在测试模式下，指定后台的调试等级，有效值为1-9. 参考：后端测试模式 P_TEST_MODE，调试等级 P_DEBUG.</li>
<li>g_args.cordova: 用于在手机APP应用中加载H5应用，参考“原生应用支持”。示例：<a href="http://server/jdcloud/m2/index.html?cordova=1">http://server/jdcloud/m2/index.html?cordova=1</a></li>
<li>g_args.wxCode: 用于在微信小程序中加载H5应用，并自动登录。参考：options.enableWxLogin 微信认证登录</li>
<li>g_args.enableSwitchApp: 允许多应用自动切换功能。参考：options.enableSwitchApp</li>
<li>g_args.logout: 退出登录后再进入应用。示例：<a href="http://server/jdcloud/m2/index.html?logout">http://server/jdcloud/m2/index.html?logout</a></li>
</ul>
<p class="see"><strong>@see <a href="#parseQuery">parseQuery</a></strong>  URL参数通过该函数获取。</p></div>
<div class="block">
<h2 id="g_cordova">@var g_cordova</h2>
<p>值是一个整数，默认为0. 可用它来判断WEB应用是否在APP容器中运行。<br />
如果非0，表示WEB应用在苹果或安卓APP中运行，且数值代表原生应用容器的版本号。</p>
<p>示例：检查用户APP版本是否可以使用某些插件。</p>
<pre><code>if (g_cordova) { // 在原生APP中。可以使用插件。
    // 假如在IOS应用的大版本3中，加入了某插件，如果用户未升级，可提示他升级：
    if (g_cordova &lt; 3 &amp;&amp; isIOS()) {
        app_alert("您的版本太旧，XX功能无法使用，请升级到最新版本");
    }
}</code></pre>
<p>WEB应用容器应在URL中传递cordova参数，表示容器版本号。该版本号会保存在ApiLog的ver字段中。</p>
<p>如果容器不支持上述约定，可在WEB应用初始化时设置g_cordova变量来做兼容，示例：</p>
<pre><code>// UserAgent for infiniti app
// android example: Mozilla/5.0 ... AppVersion/1.2.4 ... AppName/dafengche+infiniti
// iphone example: Mozilla/5.0 ... Souche/Dafengche/spartner/infiniti/InfinitiInhouse/1.2.4
function initApp() {
    var ua = navigator.userAgent;
    var m;
    if ((m = ua.match(/android.*appversion\/([\d.]+)/i)) || (m = ua.match(/iphone.*infinitiInhouse\/([\d.]+)/i))) {
        MUI.options.appName = "emp-m";
        var ver = m[1];
        if (m = ver.match(/(\d+)\.(\d+)\.(\d+)/)) {
            window.g_cordova = parseInt(m[1]) * 10000 + parseInt(m[2]) * 100 + parseInt(m[3]);
        }
    }
}
initApp();</code></pre>
<p class="see"><strong>@see <a href="#原生应用支持">原生应用支持</a></strong> </p></div>
<div class="block">
<h2 id="g_data">@var g_data = {userInfo?, serverRev?, initClient?}</h2>
<p>应用全局共享数据。</p>
<p>在登录时，会自动设置userInfo属性为个人信息。所以可以通过 g_data.userInfo==null 来判断是否已登录。</p>
<p>serverRev用于标识服务端版本，如果服务端版本升级，则应用可以实时刷新以更新到最新版本。</p>
<p class="key"><strong>@key <a id="g_data.userInfo">g_data.userInfo</a></strong> </p>
<p class="key"><strong>@key <a id="g_data.serverRev">g_data.serverRev</a></strong> </p>
<p class="key"><strong>@key <a id="g_data.initClient">g_data.initClient</a></strong> </p>
<p>应用初始化时，调用initClient接口得到的返回值，通常为{plugins, ...}</p>
<p class="key"><strong>@key <a id="g_data.testMode,g_data.mockMode">g_data.testMode,g_data.mockMode</a></strong>  测试模式和模拟模式</p>
<p>TODO: MUI.data</p></div>
<div class="block">
<h2 id="options">@var options</h2>
<p>可用的选项如下。</p>
<p class="var"><strong>@var <a id="options.appName">options.appName</a></strong> ?=user  应用名称</p>
<p>用于与后端通讯时标识app.</p>
<p class="var"><strong>@var <a id="options.loginPage">options.loginPage</a></strong> ?="#login"  login逻辑页面的地址</p>
<p class="var"><strong>@var <a id="options.homePage">options.homePage</a></strong> ?="#home"  首页地址</p>
<p class="var"><strong>@var <a id="options.pageFolder">options.pageFolder</a></strong> ?="page" 逻辑页面文件(html及js)所在文件夹</p>
<p class="var"><strong>@var <a id="options.statusBarColor">options.statusBarColor</a></strong> ?="#,light" 设置状态栏颜色，默认为应用程序背景色和白字。</p>
<p class="see"><strong>@see <a href="#topic-iosStatusBar">topic-iosStatusBar</a></strong> </p>
<p>（版本v5.0）</p>
<p>利用statusbar插件设置标题栏。<br />
其中背景设置使用&quot;#000&quot;或&quot;#000000&quot;这种形式，特别地，只用&quot;#&quot;可表示使用当前应用程序的背景色（.mui-container背景颜色）。<br />
前景设置使用&quot;light&quot;(白色)或&quot;dark&quot;(黑色)。<br />
设置为&quot;none&quot;表示隐藏标题栏。<br />
设置为空(&quot;&quot;)表示禁止框架设置状态栏。</p>
<p class="var"><strong>@var <a id="options.fixTopbarColor">options.fixTopbarColor</a></strong> ?=false</p>
<p>如果为true, 则自动根据页面第一个hd的背景色设置手机顶栏颜色.<br />
适合每个页面头部颜色不同的情况. 更复杂的情况, 可使用<code>MUI.setTopbarColor</code>手工设置顶栏颜色.</p>
<p class="var"><strong>@var <a id="options.manualSplash">options.manualSplash</a></strong> ?=false</p>
<p class="see"><strong>@see <a href="#topic-splashScreen">topic-splashScreen</a></strong> </p>
<p class="var"><strong>@var <a id="options.logAction">options.logAction</a></strong> ?=false  Boolean. 是否显示详细日志。</p>
<p>可用于交互调用的监控。</p>
<p class="var"><strong>@var <a id="options.PAGE_SZ">options.PAGE_SZ</a></strong> ?=20  分页大小，下拉列表每次取数据的缺省条数。</p>
<p class="var"><strong>@var <a id="options.mockDelay">options.mockDelay</a></strong> ?=50  模拟调用后端接口的延迟时间，单位：毫秒。仅对异步调用有效。</p>
<p class="see"><strong>@see <a href="#mockData">mockData</a></strong>  模拟调用后端接口</p>
<p class="var"><strong>@var <a id="options.serverUrl">options.serverUrl</a></strong> ?="./"  服务端接口地址设置。</p>
<p class="var"><strong>@var <a id="options.serverUrlAc">options.serverUrlAc</a></strong>   表示接口名称的URL参数。</p>
<p>示例：</p>
<pre><code>$.extend(MUI.options, {
    serverUrl: "http://myserver/myapp/api.php",
    serverUrlAc: "ac"
});</code></pre>
<p>接口&quot;getuser(id=10)&quot;的HTTP请求为：</p>
<pre><code>http://myserver/myapp/api.php?ac=getuser&amp;id=10</code></pre>
<p>如果不设置serverUrlAc（默认为空），则HTTP请求为：</p>
<pre><code>http://myserver/myapp/api.php/getuser?id=10</code></pre>
<p>支持上面这种URL的服务端，一般配置过pathinfo机制。<br />
再进一步，如果服务端设置了rewrite规则可以隐藏api.php，则可设置：</p>
<pre><code>$.extend(MUI.options, {
    serverUrl: "http://myserver/myapp/", // 最后加一个"/"
});</code></pre>
<p>这样发起的HTTP请求为：</p>
<pre><code>http://myserver/myapp/getuser?id=10</code></pre>
<p class="var"><strong>@var <a id="options.pluginFolder">options.pluginFolder</a></strong> ?="../plugin" 指定筋斗云插件目录</p>
<p>筋斗云插件提供具有独立接口的应用功能模块，包括前端、后端实现。</p>
<p class="var"><strong>@var <a id="options.showHash">options.showHash</a></strong> ?=true</p>
<p>默认访问逻辑页面时，URL地址栏显示为: &quot;index.html#me&quot;</p>
<p>只读，如果值为false, 则地址栏显示为: &quot;index.html/page/me.html&quot;.</p>
<p>注意：该选项不可通过js设置为false，而应在主页面中设置：</p>
<pre><code>&lt;base href="./" mui-showHash="no"&gt;</code></pre>
<p>在showHash=false时，必须设置base标签, 否则逻辑页将无法加载。</p>
<p class="var"><strong>@var <a id="options.disableFastClick">options.disableFastClick</a></strong> ?=false</p>
<p>在IOS+cordova环境下，点击事件会有300ms延迟，默认会加载lib/fastclick.min.js解决。</p>
<p>该库会导致部分场景下点击失效问题。这时可以通过在关键点击元素上设置&quot;needsclick&quot;类来解决。</p>
<p>例如：fastclick库与图片裁切库image-process-tool有些冲突, ios手机APP中点修改头像无法弹出图片选择框. JS初始化配置如下：</p>
<pre><code>var zxImageProcess = new ZxImageProcess({
    // 触发文件选择的元素
    selector: jpage.find(".downSelect-btn[value=1]")[0],
    ...
});</code></pre>
<p>最终将绑定用于点击的元素 <code>&lt;div class='downSelect-btn'&gt;&lt;/div&gt;</code>改为 <code>&lt;div class='downSelect-btn needsclick'&gt;&lt;/div&gt;</code>解决。<br />
发现IOS上点击失效问题，可先设置<code>options.disableFastClick=true</code>检查问题是否消失来判定。</p>
<p>TODO: cordova-ios未来将使用WkWebView作为容器（目前仍使用UIWebView），将不再有点击延迟问题，到时将去除FastClick库。</p>
<p class="var"><strong>@var <a id="options.onAutoLogin">options.onAutoLogin</a></strong>  自动登录</p>
<p class="event"><strong>@event <a id="autoLogin">autoLogin</a></strong>  自动登录事件(v5.4)</p>
<p>设置如何自动登录系统，进入应用后，一般会调用tryAutoLogin，其中会先尝试重用已有会话，如果当前没有会话则回调onAutoLogin自动登录系统。<br />
返回true则跳过后面系统默认的登录过程，包括使用本地保存的token自动登录以及调用login接口。</p>
<p>一般用于微信认证后绑定用户身份，示例：</p>
<pre><code>$.extend(MUI.options, {
    ...
    onAutoLogin: onAutoLogin
});

function onAutoLogin()
{
    // 发起微信认证
    var param = {state: location.href};
    location.href = "../weixin/auth.php?" + $.param(param);
    // 修改了URL后直接跳出即可。不用返回true
    MUI.app_abort();
}</code></pre>
<p>(v5.4)也可以用autoLogin事件：</p>
<pre><code>$(document).on("autoLogin", onAutoLogin);</code></pre>
<p class="var"><strong>@var <a id="options.enableWxLogin">options.enableWxLogin</a></strong>  微信认证登录</p>
<p>设置enableWxLogin为true，或者appName为&quot;user&quot;，则如果URL中有参数wxCode, 就调用后端&quot;login2(wxCode)&quot;接口登录认证。<br />
一般用于从微信小程序调用H5应用。<br />
要求后端已实现login2接口。</p>
<pre><code>$.extend(MUI.options, {
    ...
    enableWxLogin: true
});</code></pre>
<p class="var"><strong>@var <a id="options.enableSwitchApp">options.enableSwitchApp</a></strong>  自动保存和切换应用</p>
<p class="key"><strong>@key <a id="g_args.enableSwitchApp">g_args.enableSwitchApp</a></strong>  =1 应用自动切换</p>
<p>同一个目录下的多个应用，支持自动切换。<br />
例如原生APP（或微信小程序中）的URL为用户端，但在登录页或个人中心页可切换到员工端。<br />
当进入员工端并登录成功后，希望下次打开APP后直接进入员工端，做法如下：</p>
<p>在H5应用中设置选项options.enableSwitchApp=true。(例如在app.js中设置，这样所有应用都允许跳转）<br />
应用登录后将自动记录当前URL。</p>
<p>在APP中初次打开H5应用(history.length&lt;=1)时，会在进入应用后自动检查和切换应用（将在MUI.validateEntry函数中检查，一般H5应用的主JS文件入口处默认会调用它）。<br />
最好在URL中添加参数enableSwitchApp=1强制检查，例如在chrome中初次打开页面history.length为2，不加参数就无法自动切换H5应用。</p>
<p class="var"><strong>@var <a id="options.onShowPage">options.onShowPage</a></strong> (pageRef, opt) 显示页面前回调</p>
<p>(v5.4) 在调用MUI.showPage时触发调用，参数与MUI.showPage相同，用于显示任何页面前通用的操作。<br />
此回调在页面加载或显示之前（先于目的页面的pagecreate/pagebeforeshow等事件）。<br />
如果返回false，则取消本次showPage调用。</p>
<p>示例1：允许用户未登录使用，但除了home页面，进入其它页面均要求登录。<br />
注意：系统默认要求登录才能进入，若要修改，可在muiInit事件中修改调用<code>MUI.tryAutoLogin(..., allowNoLogin=true)</code>来实现允许未登录进入。<br />
此需求如果放在每个页面的pagebeforeshow中处理则非常麻烦，可在onShowPage中统一处理。</p>
<pre><code>$.extend(MUI.options, {
    ...
    onShowPage: onShowPage
});

...
// MUI.tryAutoLogin(handleLogin, "User.get");
MUI.tryAutoLogin(handleLogin, "User.get", true); // 允许未登录进入。

// 如果未登录，跳转login。
function onShowPage(pageRef, opt) {
    if (pageRef == "#home" || pageRef == "#setUserInfo" || pageRef.substr(0, 6) == "#login")
        return;

    // 如果是未登录进入，则跳转登录页。
    if (!g_data.userInfo) {
        MUI.showLogin();
        return false;
    }
}</code></pre>
<p>示例2：接上例，当系统在微信中使用时，允许用户使用微信身份自动登录，并可以查看home页面。<br />
但如果用户尚未绑定过手机号，在进入其它页面时，必须先绑定手机号。</p>
<pre><code>$.extend(MUI.options, {
    ...
    onShowPage: onShowPage
});

// 如果手机号没有填写，则要求填写并返回false。
function onShowPage(pageRef, opt) {
    if (pageRef == "#home" || pageRef == "#setUserInfo" || pageRef.substr(0, 6) == "#login")
        return;

    // 如果是未登录进入，则跳转登录页。
    if (!g_data.userInfo) {
        MUI.showLogin(pageRef);
        return false;
    }
    if (g_data.userInfo &amp;&amp; !g_data.userInfo.phone) {
        PageSetUserInfo.userInit = true;
        PageSetUserInfo.fromPageRef = pageRef;
        MUI.showPage("#setUserInfo");
        return false;
    }
}</code></pre>
<p class="var"><strong>@var <a id="options.showLoadingDelay">options.showLoadingDelay</a></strong>  ?= 500  延迟显示加载图标</p>
<p>(v5.4) 默认如果在500ms内如果远程调用成功, 则不显示加载图标.</p>
<p class="var"><strong>@var <a id="options.skipErrorRegex">options.skipErrorRegex</a></strong>  定义要忽略的错误</p>
<p>示例：有video标签时，缩小窗口或全屏预览时，有时会报一个错（见下例），暂不清楚解决方案，也不影响执行，可以先安全忽略它不要报错：</p>
<pre><code>$.extend(MUI.options, {
    skipErrorRegex: /ResizeObserver loop limit exceeded/i,
});</code></pre></div>
<div class="block">
<h2 id="setFormSubmit">@fn setFormSubmit(jf, fn?, opt?={validate?, onNoAction?})</h2>
<p class="param"><strong>@param fn</strong>  Function(data); 与callSvr时的回调相同，data为服务器返回的数据。</p>
<p>函数中可以使用this[&quot;userPost&quot;] 来获取post参数。</p>
<p class="param"><strong>@param opt.validate:</strong>  Function(jf, queryParam={ac?,...}). </p>
<p>如果返回false, 则取消submit. queryParam为调用参数，可以修改。<br />
(v5.3) 支持异步提交，返回Deferred对象时，表示在Deferred.resolve之后再提交。</p>
<p>form提交时的调用参数, 如果不指定, 则以form的action属性作为queryParam.ac发起callSvr调用.<br />
form提交时的POST参数，由带name属性且不带disabled属性的组件决定, 可在validate回调中设置．</p>
<p>设置POST参数时，固定参数可以用<code>&lt;input type="hidden"&gt;</code>标签来设置，自动计算的参数可以先放置一个隐藏的input组件，然后在validate回调中来设置。<br />
示例：</p>
<pre><code>&lt;form action="fn1"&gt;
    &lt;input name="name" value=""&gt;
    &lt;input name="type" value="" style="display:none"&gt;
    &lt;input type="hidden" name="wantAll" value="1"&gt;
&lt;/form&gt;

MUI.setFormSubmit(jf, api_fn1, {
    validate: function(jf, queryParam) {
        // 检查字段合法性
        if (! isValidName(jf[0].name.value)) {
            app_alert("bad name");
            return false;
        }
        // 设置GET参数字段"cond"示例
        queryParam.cond = "id=1";

        // 设置POST参数字段"type"示例
        jf[0].type.value = ...;
    }
});</code></pre>
<p>如果之前调用过setFormData(jo, data, {setOrigin:true})来展示数据, 则提交时，只会提交被修改过的字段，否则提交所有字段。</p>
<p class="param"><strong>@param opt.onNoAction:</strong>  Function(jf). 当form中数据没有变化时, 不做提交. 这时可调用该回调函数.</p>
<p>(v5.3)<br />
异步提交示例：点击提交后，先上传照片，照片传完获取到picId，然后做之后提交动作</p>
<pre><code>MUI.setFormSubmit(jf, api_fn1, {
    validate: function(jf, queryParam) {
        var dfd = $.Deferred();
        uploadPic.submit().then(function (picId) {
            jf[0].picId.value = picId;
            dfd.resolve();
        });
        return dfd;
    }
});</code></pre></div>
<div class="block">
<h2 id="MUI.setTopbarColor">@fn MUI.setTopbarColor(colorHex, style?)</h2>
<p class="param"><strong>@param colorHex</strong>  颜色值,格式如 "#fafafa", 可用MUI.rgb2hex函数转换.</p>
<p class="param"><strong>@param style</strong>  dark|light</p>
<p>设置顶栏颜色和字体黑白风格.</p></div>
<div class="block">
<h2 id="showLogin">@fn showLogin(page?)</h2>
<p class="param"><strong>@param page=pageRef/jpage</strong>  如果指定, 则登录成功后转向该页面; 否则转向登录前所在的页面.</p>
<p>显示登录页. 注意: 登录页地址通过MUI.options.loginPage指定, 缺省为&quot;#login&quot;.</p>
<pre><code>&lt;div data-role="page" id="login"&gt;
...
&lt;/div&gt;</code></pre>
<p>注意：</p>
<ul>
<li>登录成功后，会自动将login页面清除出页面栈，所以登录成功后，点返回键，不会回到登录页。</li>
<li>如果有多个登录页（如动态验证码登录，用户名密码登录等），其它页的id起名时，应以app.loginPage指定内容作为前缀，<br />
如loginPage=&quot;#login&quot;, 则登录页面名称可以为：#login(缺省登录页), #login1, #loginByPwd等；否则无法被识别为登录页，导致登录成功后按返回键仍会回到登录页</li>
</ul></div>
<div class="block">
<h2 id="showHome">@fn showHome()</h2>
<p>显示主页。主页是通过 MUI.options.homePage 来指定的，默认为&quot;#home&quot;.</p>
<p>要取主页名可以用：</p>
<pre><code>var jpage = $(MUI.options.homePage);</code></pre>
<p class="see"><strong>@see <a href="#options.homePage">options.homePage</a></strong> </p></div>
<div class="block">
<h2 id="logout">@fn logout(dontReload?)</h2>
<p class="param"><strong>@param dontReload</strong>  如果非0, 则注销后不刷新页面.</p>
<p>注销当前登录, 成功后刷新页面(除非指定dontReload=1)</p></div>
<div class="block">
<h2 id="validateEntry">@fn validateEntry(@allowedEntries) 入口页检查</h2>
<p>设置入口页，allowedEntries是一个数组, 如果初始页面不在该数组中, 则URL中输入该逻辑页时，会自动转向主页。</p>
<p>示例：</p>
<pre><code>MUI.validateEntry([
    "#home",
    "#me",
    /^#udt__/  # (v5.3) 支持正则式
]);</code></pre></div>
<div class="block">
<h2 id="tryAutoLogin">@fn tryAutoLogin(onHandleLogin, reuseCmd?, allowNoLogin?=false)</h2>
<p>尝试自动登录，如果失败则转到登录页（除非allowNoLogin=true）。</p>
<p class="param"><strong>@param onHandleLogin</strong>  Function(data). 调用后台login()成功后的回调函数(里面使用this为ajax options); 可以直接使用MUI.handleLogin</p>
<p class="param"><strong>@param reuseCmd</strong>  String. 当session存在时替代后台login()操作的API, 如"User.get", "Employee.get"等, 它们在已登录时返回与login相兼容的数据. 因为login操作比较重, 使用它们可减轻服务器压力. </p>
<p class="param"><strong>@param allowNoLogin</strong>  Boolean. 缺省未登录时会自动跳转登录页面, 如果设置为true, 如不会自动跳转登录框, 表示该应用允许未登录时使用.</p>
<p class="return"><strong>@return Boolean.</strong>  true=登录成功; false=登录失败.</p>
<p>该函数应该在muiInit事件中执行, 以避免框架页面打开主页。</p>
<pre><code>$(document).on("muiInit", myInit);

function myInit()
{
    // redirect to login if auto login fails
    MUI.tryAutoLogin(handleLogin, "User.get");
}

function handleLogin(data)
{
    MUI.handleLogin(data);
    // g_data.userInfo已赋值
}</code></pre></div>
<div class="block">
<h2 id="handleLogin">@fn handleLogin(data)</h2>
<p class="param"><strong>@param data</strong>  调用API "login"成功后的返回数据.</p>
<p>处理login相关的操作, 如设置g_data.userInfo, 保存自动登录的token等等.<br />
可以根据用户属性在此处定制home页，例如：</p>
<pre><code>if(role == "SA"){
    MUI.options.homePage = "#sa-home";
}
else if (role == "MA") {
    MUI.options.homePage = "#ma-home";
}</code></pre></div>
<div class="block">
<h2 id="initClient">@fn initClient(param?)</h2></div>
<div class="block">
<h2 id="Plugins">@class Plugins</h2></div>
<div class="block">
<h2 id="Plugins.exists">@fn Plugins.exists(pluginName)</h2></div>
<div class="block">
<h2 id="Plugins.list">@fn Plugins.list()</h2></div>
<div class="block">
<h2 id="filterCordovaModule">@fn filterCordovaModule(module)</h2>
<p>原生插件与WEB接口版本匹配。<br />
在cordova_plugins.js中使用，用于根据APP版本与当前应用标识，过滤当前Web可用的插件。</p>
<p>例如，从客户端（应用标识为user）版本2.0，商户端（应用标识为store）版本3.0开始，添加插件 geolocation，可配置filter如下：</p>
<pre><code>module.exports = [
    ...
    {
        "file": "plugins/cordova-plugin-geolocation/www/android/geolocation.js",
        "id": "cordova-plugin-geolocation.geolocation",
        "clobbers": [
            "navigator.geolocation"
        ],
        "filter": [ ["user",2], ["store",3] ] // 添加filter
    }
];

filterCordovaModule(module); // 过滤模块</code></pre>
<p>配置后，尽管WEB已更新，但旧版本应用程序不会具有该接口。</p>
<p>filter格式: [ [app1, minVer?=1, maxVer?=9999], ...], 仅当app匹配且版本在minVer/maxVer之间才使用<br />
如果未指定filter, 表示总是使用<br />
app标识由应用定义，常用如: &quot;user&quot;-客户端;&quot;store&quot;-商户端</p></div>
<div class="block">
<h2 id="formatField">@fn formatField(obj) -> obj</h2>
<p>对obj中的以字符串表示的currency/date等类型进行转换。<br />
判断类型的依据是属性名字，如以Tm结尾的属性（也允许带数字后缀）为日期属性，如&quot;tm&quot;, &quot;tm2&quot;, &quot;createTm&quot;都会被当作日期类型转换。</p>
<p>注意：它将直接修改传入的obj，并最终返回该对象。</p>
<pre><code>obj = {id: 1, amount: "15.0000", payAmount: "10.0000", createTm: "2016-01-11 11:00:00"}
var order = MUI.formatField(obj); // obj会被修改，最终与order相同
// order = {id: 1, amount: 15, payAmount: 10, createTm: (datetime类型)}</code></pre></div>
<div class="block">
<h2 id="hd_back">@fn hd_back(pageRef?)</h2>
<p>返回操作，类似history.back()，但如果当前页是入口页时，即使没有前一页，也可转向pageRef页（未指定时为首页）。<br />
一般用于顶部返回按钮：</p>
<pre><code>&lt;div class="hd"&gt;
    &lt;a href="javascript:hd_back();" class="btn-icon"&gt;&lt;i class="icon icon-back"&gt;&lt;/i&gt;&lt;/a&gt;
    &lt;h2&gt;个人信息&lt;/h2&gt;
&lt;/div&gt;</code></pre></div>
<div class="block">
<h2 id="syslog">@fn syslog(module, pri, content)</h2>
<p>向后端发送日志。后台必须已添加syslog插件。<br />
日志可在后台Syslog表中查看，客户端信息可查看ApiLog表。</p>
<p class="param"><strong>@param module</strong>  app,fw(framework),page</p>
<p class="param"><strong>@param pri</strong>  ERR,INF,WARN</p>
<p>示例：</p>
<pre><code>MUI.syslog("app", "ERR", "fail to pay: " + err.msg);</code></pre>
<p>注意：如果操作失败，本函数不报错。</p></div>
<div class="block">
<h2 id="initPullList">@fn initPullList(container, opt)</h2>
<p>为列表添加下拉刷新和上拉加载功能。</p>
<p>例：页面元素如下：</p>
<pre><code>&lt;div mui-initfn="initPageOrders" mui-script="orders.js"&gt;
    &lt;div class="bd"&gt;
        &lt;div class="p-list"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>设置下拉列表的示例代码如下：</p>
<pre><code>var pullListOpt = {
    onLoadItem: showOrderList
};
var container = jpage.find(".bd")[0];
initPullList(container, pullListOpt);

var nextkey;
function showOrderList(isRefresh)
{
    var jlst = jpage.find(".p-list");
    var param = {res: "id desc", cond: "status=1"};
    if (nextkey == null)
        isRefresh = true;
    if (isRefresh)
        jlst.empty();
    param.pagekey = nextkey;

    callSvr("Ordr.query", param, function (data) {
        // create items and append to jlst
        // ....
        if (data.nextkey)
            nextkey = data.nextkey;
        // TODO: 处理分页结束即nextkey为空的情况。
    });
}</code></pre>
<p>注意：</p>
<ul>
<li>由于page body的高度自动由框架设定，所以可以作为带滚动条的容器；如果是其它容器，一定要确保它有限定的宽度，以便可以必要时出现滚动条。</li>
<li>
<p>*** 由于处理分页的逻辑比较复杂，请调用 initPageList替代, 即使只有一个list；它会屏蔽nextkey, refresh等细节，并做一些优化。像这样调用：</p>
<pre><code>initPageList(jpage, {
    pageItf: PageOrders,
    navRef: null,
    listRef: jlst,
    onGetQueryParam: ...
    onAddItem: ...
});</code></pre>
</li>
</ul>
<p>本函数参数如下：</p>
<p class="param"><strong>@param container</strong>  容器，它的高度应该是限定的，因而当内部内容过长时才可出现滚动条</p>
<p class="param"><strong>@param opt</strong>  {onLoadItem, autoLoadMore?=true, threshold?=180, onHint?, onPull?}</p>
<p class="param"><strong>@param opt.onLoadItem</strong>  function(isRefresh)</p>
<p>在合适的时机，它调用 onLoadItem(true) 来刷新列表，调用 onLoadItem(false) 来加载列表的下一页。在该回调中this为container对象（即容器）。实现该函数时应当自行管理当前的页号(pagekey)</p>
<p class="param"><strong>@param opt.autoLoadMore</strong>  当滑动到页面下方时（距离底部TRIGGER_AUTOLOAD=30px以内）自动加载更多项目。</p>
<p class="param"><strong>@param threshold</strong>  像素值。</p>
<p>手指最少下划或上划这些像素后才会触发实际加载动作。</p>
<p class="param"><strong>@param opt.onHint</strong>  function(ac, dy, threshold)</p>
<pre><code>ac  动作。"D"表示下拉(down), "U"表示上拉(up), 为null时应清除提示效果.
dy,threshold  用户移动偏移及临界值。dy&gt;threshold时，认为触发加载动作。</code></pre>
<p>提供提示用户刷新或加载的动画效果. 缺省实现是下拉或上拉时显示提示信息。</p>
<p class="param"><strong>@param opt.onHintText</strong>  function(ac, uptoThreshold)</p>
<p>修改用户下拉/上拉时的提示信息。仅当未设置onHint时有效。onHint会生成默认提示，如果onHintText返回非空，则以返回内容替代默认内容。<br />
内容可以是一个html字符串，所以可以加各种格式。</p>
<pre><code>ac:: String. 当前动作，"D"或"U".
uptoThreshold:: Boolean. 是否达到阈值</code></pre>
<p class="param"><strong>@param opt.onPull</strong>  function(ev)</p>
<p>如果返回false，则取消上拉加载或下拉刷新行为，采用系统默认行为。</p></div>
<div class="block">
<h2 id="initPageList">@fn initPageList(jpage, opt) -> PageListInterface</h2><div class="toc"><p style="margin-left:0em"><a href="#initPageList-1 例：一个navbar与若干list的组合">1 例：一个navbar与若干list的组合</a></p>
<p style="margin-left:0em"><a href="#initPageList-2 例：若干button与若干list的组合">2 例：若干button与若干list的组合</a></p>
<p style="margin-left:0em"><a href="#initPageList-3 例：只有一个list">3 例：只有一个list</a></p>
<p style="margin-left:0em"><a href="#initPageList-4 框架基本原理">4 框架基本原理</a></p>
<p style="margin-left:0em"><a href="#initPageList-5 参数说明">5 参数说明</a></p>
<p style="margin-left:0em"><a href="#initPageList-6 css类">6 css类</a></p>
<p style="margin-left:0em"><a href="#initPageList-7 列表页用于选择">7 列表页用于选择</a></p>
<p style="margin-left:0em"><a href="#initPageList-8 分页机制与后端接口适配">8 分页机制与后端接口适配</a></p>
<p style="margin-left:0em"><a href="#initPageList-9 下拉刷新提示信息">9 下拉刷新提示信息</a></p>
<p style="margin-left:0em"><a href="#initPageList-10 禁止下拉和上拉行为">10 禁止下拉和上拉行为</a></p>
<p style="margin-left:0em"><a href="#initPageList-11 仅自动加载，禁止下拉刷新行为">11 仅自动加载，禁止下拉刷新行为</a></p>
<p style="margin-left:0em"><a href="#initPageList-12 本地分页">12 本地分页</a></p>
</div>
<p class="alias"><strong>@alias <a id="initNavbarAndList">initNavbarAndList</a></strong> </p>
<p>列表页逻辑框架.</p>
<p>对一个导航栏(class=&quot;mui-navbar&quot;)及若干列表(class=&quot;p-list&quot;)的典型页面进行逻辑封装；也可以是若干button对应若干div-list区域，一次只显示一个区域；<br />
特别地，也可以是只有一个list，并没有button或navbar对应。</p>
<p>它包括以下功能：</p>
<ol>
<li>首次进入页面时加载默认列表</li>
<li>任一列表支持下拉刷新，上拉加载（自动管理刷新和分页）</li>
<li>点击导航栏自动切换列表，仅当首次显示列表时刷新数据</li>
<li>支持强制刷新所有列表的控制，一般定义在page接口中，如 PageOrders.refresh</li>
</ol>
<h4 id="initPageList-1 例：一个navbar与若干list的组合">1 例：一个navbar与若干list的组合</h4>
<p>基本页面结构如下：</p>
<pre><code>&lt;div mui-initfn="initPageOrders" mui-script="orders.js"&gt;
    &lt;div class="hd"&gt;
        &lt;h2&gt;订单列表&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class="hd"&gt;
        &lt;div class="mui-navbar"&gt;
            &lt;a href="javascript:;" class="active" mui-linkto="#lst1"&gt;待服务&lt;/a&gt;
            &lt;a href="javascript:;" mui-linkto="#lst2"&gt;已完成&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="bd"&gt;
        &lt;div id="lst1" class="p-list active" data-cond="status='PA'"&gt;&lt;/div&gt;
        &lt;div id="lst2" class="p-list" data-cond="status='RE'"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>上面页面应注意：</p>
<ul>
<li>navbar一般放在header(hd)中，不随着滚动条移动而改变位置。(v5.2)hd可以有多个，第一个用作页面标题和导航，在微信中不显示。</li>
<li>默认要显示的list应加上active类，否则自动取第一个显示列表。</li>
<li>mui-navbar在点击一项时，会在对应的div组件（通过被点击的<a>按钮上mui-linkto属性指定链接到哪个div）添加class=&quot;active&quot;。非active项会自动隐藏。</li>
</ul>
<p>js调用逻辑示例：</p>
<pre><code>var lstItf = initPageList(jpage, {
    pageItf: PageOrders,

    //以下两项是缺省值：
    //navRef: "&gt;.hd .mui-navbar",
    //listRef: "&gt;.bd .p-list",

    // 设置查询参数，静态值一般通过在列表对象上设置属性 data-ac, data-cond以及data-queryParam等属性来指定更方便。
    onGetQueryParam: function (jlst, queryParam) {
        queryParam.ac = "Ordr.query";
        queryParam.orderby = "id desc";
        // queryParam.cond 已在列表data-cond属性中指定
    },
    onAddItem: function (jlst, itemData) {
        var ji = $("&lt;li&gt;" + itemData.title + "&lt;/li&gt;");
        ji.appendTo(jlst);
    }
});</code></pre>
<p>由于指定了pageItf属性，当外部页面设置了 PageOrders.refresh = true后，再进入本页面，所有关联的列表会在展现时自动刷新。且PageOrders.refresh会被自动重置为false.</p>
<h4 id="initPageList-2 例：若干button与若干list的组合">2 例：若干button与若干list的组合</h4>
<p>一个button对应一个list; 打开页面时只展现一个列表，点击相应按钮显示相应列表。</p>
<p>如果没有用navbar组件，而是一组button对应一组列表，点一个button显示对应列表，也可以使用本函数。页面如下：</p>
<pre><code>&lt;div mui-initfn="initPageOrders" mui-script="orders.js"&gt;
    &lt;div class="hd"&gt;
        &lt;h2&gt;订单列表&lt;/h2&gt;
    &lt;/div&gt;

    &lt;div class="bd"&gt;
        &lt;div class="p-panelHd"&gt;待服务&lt;/div&gt;
        &lt;div class="p-panel"&gt;
            &lt;div id="lst1" class="p-list active"&gt;&lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="p-panelHd"&gt;已完成&lt;/div&gt;
        &lt;div class="p-panel"&gt;
            &lt;div id="lst2" class="p-list"&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>js调用逻辑示例：</p>
<pre><code>jpage.find(".p-panel").height(500); // !!! 注意：必须为list container指定高度，否则无法出现下拉列表。一般根据页高自动计算。

var lstItf = initPageList(jpage, {
    pageItf: PageOrders,
    navRef: ".p-panelHd", // 点标题栏，显示相应列表区
    listRef: ".p-panel .p-list", // 列表区
    ...
});</code></pre>
<p>注意：navRef与listRef中的组件数目一定要一一对应。除了使用选择器，也可以直接用jQuery对象为navRef和listRef赋值。</p>
<h4 id="initPageList-3 例：只有一个list">3 例：只有一个list</h4>
<p>只有一个list 的简单情况，也可以调用本函数简化分页处理.<br />
仍考虑上例，假如那两个列表需要进入页面时就同时显示，那么可以分开一一设置如下：</p>
<pre><code>jpage.find(".p-panel").height(500); // 一定要为容器设置高度

var lstItf = initPageList(jpage, {
    pageItf: PageOrders,
    navRef: "", // 置空，表示不需要button链接到表，下面listRef中的多表各自显示不相关。
    listRef: ".p-panel .p-list", // 列表区
    ...
});</code></pre>
<p>上例中，listRef参数也可以直接使用jQuery对象赋值。<br />
navRef是否为空的区别是，如果非空，则表示listRef是一组互斥的列表，点击哪个button，就会设置哪个列表为active列表。当切到当前页时，只显示或刷新active列表。</p>
<p>如果是只包含一个列表的简单页面：</p>
<pre><code>&lt;div mui-initfn="initPageOrders" mui-script="orders.js"&gt;
    &lt;div class="hd"&gt;
        &lt;h2&gt;订单列表&lt;/h2&gt;
    &lt;/div&gt;

    &lt;div class="bd"&gt;
        &lt;div class="p-list"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>由于bd对象的高度已自动设置，要设置p-list对象支持上下拉加载，可以简单调用：</p>
<pre><code>var lstItf = initPageList(jpage, {
    pageItf: PageOrders,
    navRef: "", // 一定置空，否则默认值是取mui-navbar
    listRef: ".p-list"
    ...
});</code></pre>
<h4 id="initPageList-4 框架基本原理">4 框架基本原理</h4>
<p>原理是在合适的时机，自动调用类似这样的逻辑：</p>
<pre><code>var queryParam = {ac: "Ordr.query"};
opt.onGetQueryParam(jlst, queryParam);
callSvr(queryParam.ac, queryParam, function (data) {
    $.each(rs2Array(data), function (i, itemData) {
        opt.onAddItem(jlst, itemData);
    });
    if (data.d.length == 0)
        opt.onNoItem(jlst);
});</code></pre>
<h4 id="initPageList-5 参数说明">5 参数说明</h4>
<p class="param"><strong>@param opt</strong>  {onGetQueryParam?, onAddItem?, onNoItem?, pageItf?, navRef?=">.hd .mui-navbar", listRef?=">.bd .p-list", onBeforeLoad?, onLoad?, onGetData?, canPullDown?=true, onRemoveAll?, jContainer?}</p>
<p class="param"><strong>@param opt</strong>  分页相关 { pageszName?="pagesz", pagekeyName?="pagekey", localPageSize? }</p>
<p class="param"><strong>@param opt.onGetQueryParam</strong>  Function(jlst, queryParam/o)</p>
<p>queryParam: {ac?, res?, cond?, ...}</p>
<p>框架在调用callSvr之前，先取列表对象jlst上的data-queryParam属性作为queryParam的缺省值，再尝试取data-ac, data-res, data-cond, data-orderby属性作为queryParam.ac等参数的缺省值，<br />
最后再回调 onGetQueryParam。</p>
<pre><code>&lt;ul data-queryParam="{q: 'famous'}" data-ac="Person.query" data-res="*,familyName" data-cond="status='PA' and name like '王%'"&gt;
&lt;/ul&gt;</code></pre>
<p>此外，框架将自动管理 queryParam.pagekey/pagesz 参数。</p>
<p class="param"><strong>@param opt.onAddItem</strong>  (jlst, itemData, param)</p>
<p>param={idx, arr, isFirstPage}</p>
<p>框架调用callSvr之后，处理每条返回数据时，通过调用该函数将itemData转换为DOM item并添加到jlst中。<br />
判断首页首条记录，可以用</p>
<pre><code>param.idx == 0 &amp;&amp; param.isFirstPage</code></pre>
<p>这里无法判断是否最后一页（可在onLoad回调中判断），因为有可能最后一页为空，这时无法回调onAddItem.</p>
<p class="param"><strong>@param opt.onNoItem</strong>  (jlst)</p>
<p>当没有任何数据时，可以插入提示信息。缺省会添加&quot;没有数据&quot;提示, 可由CSS类noData来定制样式.<br />
一般可全局设置 initPageList.onNoItem 回调函数.</p>
<p class="param"><strong>@param opt.pageItf</strong>  - page interface {refresh?/io}</p>
<p>在订单页面(PageOrder)修改订单后，如果想进入列表页面(PageOrders)时自动刷新所有列表，可以设置 PageOrders.refresh = true。<br />
设置opt.pageItf=PageOrders, 框架可自动检查和管理refresh变量。</p>
<p class="param"><strong>@param opt.navRef,opt.listRef</strong>   指定navbar与list，可以是选择器，也可以是jQuery对象；或是一组button与一组div，一次显示一个div；或是navRef为空，而listRef为一个或多个不相关联的list.</p>
<p class="param"><strong>@param opt.onBeforeLoad</strong> (jlst, isFirstPage)->Boolean  如果返回false, 可取消load动作。参数isFirstPage=true表示是分页中的第一页，即刚刚加载数据。</p>
<p class="param"><strong>@param opt.onLoad</strong> (jlst, isLastPage)  参数isLastPage=true表示是分页中的最后一页, 即全部数据已加载完。</p>
<p class="param"><strong>@param opt.onGetData</strong> (data, pagesz, pagekey?) 每次请求获取到数据后回调。pagesz为请求时的页大小，pagekey为页码（首次为null）. this为当前jlst</p>
<p class="param"><strong>@param opt.onRemoveAll</strong> (jlst) 清空列表操作，默认为 jlst.empty()</p>
<p class="return"><strong>@return PageListInterface=</strong> {refresh, markRefresh, loadMore}</p>
<ul>
<li>refresh: Function(), 刷新当前列表</li>
<li>markRefresh: Function(jlst?), 刷新指定列表jlst或所有列表(jlst=null), 下次浏览该列表时刷新。</li>
<li>loadMore: Function(), 加载下一页数据</li>
</ul>
<p class="param"><strong>@param opt.jContainer</strong>  设置列表所有的容器，默认为页面body(".bd")对象。</p>
<p>注意jContainer必须有固定高度(.bd会由框架自动设置高度)，否则会造成无法上下拉动，除非设置了 opt.canPullDown=false。</p>
<h4 id="initPageList-6 css类">6 css类</h4>
<p>可以对以下两个CSS class指定样式：</p>
<p class="key"><strong>@key <a id="mui-pullPrompt">mui-pullPrompt</a></strong>  CSS-class 下拉刷新提示块</p>
<p class="key"><strong>@key <a id="mui-loadPrompt">mui-loadPrompt</a></strong>  CSS-class 自动加载提示块</p>
<h4 id="initPageList-7 列表页用于选择">7 列表页用于选择</h4>
<p class="key"><strong>@key <a id="example-list-choose">example-list-choose</a></strong> </p>
<p>常见需求：在一个页面上，希望进入另一个列表页，选择一项后返回。</p>
<p>可定义页面接口如下（主要是choose方法和onChoose回调）：</p>
<pre><code>var PageOrders = {
    ...
    // onChoose(order={id,dscr,...})
    choose: function (onChoose) {
        this.chooseOpt_ = {
            onChoose: onChoose
        }
        MUI.showPage('#orders');
    },

    chooseOpt_: null // {onChoose}
};</code></pre>
<p>在被调用页面上：</p>
<ul>
<li>点击一个列表项时，调用onChoose回调</li>
<li>页面隐藏时，清空chooseOpt_参数。</li>
</ul>
<p>示例：</p>
<pre><code>function initPageOrders()
{
    jpage.on("pagehide", onPageHide);

    function li_click(ev)
    {
        var order = $(this).data('obj');
        if (PageOrders.chooseOpt_) {
            PageOrders.chooseOpt_.onChoose(order);
            return false;
        }

        // 正常点击操作 ...
    }

    function onPageHide()
    {
        PageOrders.chooseOpt_ = null;
    }
}</code></pre>
<p>在调用时：</p>
<pre><code>PageOrders.choose(onChoose);

function onChoose(order)
{
    // 处理order
    history.back(); // 由于进入列表选择时会离开当前页面，这时应返回
}</code></pre>
<h4 id="initPageList-8 分页机制与后端接口适配">8 分页机制与后端接口适配</h4>
<p>默认按BQP协议的分页机制访问服务端，其规则是：</p>
<ul>
<li>请求通过 pagesz 参数指定页大小</li>
<li>
<p>如果不是最后一页，服务端应返回nextkey字段；返回列表的格式可以是 table格式如 </p>
<pre><code>{
    h: [ "field1","field2" ],
    d: [ ["val1","val2"], ["val3","val4"], ... ]
    nextkey: 2
}</code></pre>
<p>也可以用list参数指定列表，如</p>
<pre><code>{
    list: [
        {field1: "val1", field2: "val2"},
        {field1: "val3", field2: "val4"},
    ],
    nextkey: 2
}</code></pre>
</li>
<li>请求下一页时，设置参数pagekey = nextkey，直到服务端不返回 nextkey 字段为止。</li>
</ul>
<p>例1：假定后端分页机制为(jquery-easyui datagrid分页机制):</p>
<ul>
<li>请求时通过参数page, rows分别表示页码，页大小，如 <code>page=1&amp;rows=20</code></li>
<li>返回数据通过字段total表示总数, rows表示列表数据，如 <code>{ total: 83, rows: [ {...}, ... ] }</code></li>
</ul>
<p>适配方法为：</p>
<pre><code>var listItf = initPageList(jpage, {
    ...

    pageszName: 'rows',
    pagekeyName: 'page',

    // 设置 data.list, data.nextkey (如果是最后一页则不要设置); 注意pagekey可以为空
    onGetData: function (data, pagesz, pagekey) {
        data.list = data.rows;
        if (pagekey == null)
            pagekey = 1;
        if (data.total &gt;  pagesz * pagekey)
            data.nextkey = pagekey + 1;
    }
});</code></pre>
<p class="key"><strong>@key <a id="initPageList.options">initPageList.options</a></strong>  initPageList默认选项</p>
<p>如果需要作为全局默认设置可以这样：</p>
<pre><code>$.extend(MUI.initPageList.options, {
    pageszName: 'rows', 
    onNoItem: function (jlst) { ... }
    ...
});</code></pre>
<p>例2：假定后端分页机制为：</p>
<ul>
<li>请求时通过参数curPage, maxLine分别表示页码，页大小，如 <code>curPage=1&amp;maxLine=20</code></li>
<li>
<p>返回数据通过字段curPage, countPage, investList 分别表示当前页码, 总页数，列表数据，如 <code>{ curPage:1, countPage: 5, investList: [ {...}, ... ] }</code></p>
<p>var listItf = initPageList(jpage, {<br />
...</p>
<pre><code>pageszName: 'maxLine',
pagekeyName: 'curPage',

// 设置 data.list, data.nextkey (如果是最后一页则不要设置); 注意pagekey可以为空
onGetData: function (data, pagesz, pagekey) {
    data.list = data.investList;
    if (data.curPage &lt; data.countPage)
        data.nextkey = data.curPage + 1;
}</code></pre>
<p>});</p>
</li>
</ul>
<p>例3：假定后端就返回一个列表如<code>[ {...}, {...} ]</code>，不支持分页。<br />
什么都不用设置，仍支持下拉刷新，因为刚好会当成最后一页处理，上拉不再加载。</p>
<h4 id="initPageList-9 下拉刷新提示信息">9 下拉刷新提示信息</h4>
<p class="key"><strong>@key <a id=".mui-pullHint">.mui-pullHint</a></strong>  指定下拉提示显示位置</p>
<p>显示下拉刷新提示时，默认是在列表所在容器的最上端位置显示的。如果需要指定显示位置，可使用css类&quot;mui-pullHint&quot;，示例如下：</p>
<pre><code>&lt;div class="bd"&gt;
    &lt;div&gt;下拉列表演示&lt;/div&gt;
    &lt;div class="mui-pullHint"&gt;&lt;/div&gt; &lt;!-- 如果没有这行，则下拉提示会在容器最上方，即"下拉列表演示"这行文字的上方--&gt;
    &lt;div id="lst1"&gt;&lt;/div&gt;
    &lt;div id="lst2"&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
<h4 id="initPageList-10 禁止下拉和上拉行为">10 禁止下拉和上拉行为</h4>
<p>例：在多页列表中，有一些页只做静态展示使用，不需要上拉或下拉：</p>
<pre><code>&lt;div mui-initfn="initPageOrders" mui-script="orders.js"&gt;
    &lt;div class="hd"&gt;
        &lt;h2&gt;订单列表&lt;/h2&gt;
    &lt;/div&gt;
    &lt;div class="hd"&gt;
        &lt;div class="mui-navbar"&gt;
            &lt;a href="javascript:;" class="active" mui-linkto="#lst1"&gt;待服务&lt;/a&gt;
            &lt;a href="javascript:;" mui-linkto="#lst2"&gt;已完成&lt;/a&gt;
            &lt;a href="javascript:;" mui-linkto="#lst3"&gt;普通页&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="bd"&gt;
        &lt;div id="lst1" class="p-list active" data-cond="status='PA'"&gt;&lt;/div&gt;
        &lt;div id="lst2" class="p-list" data-cond="status='RE'"&gt;&lt;/div&gt;
        &lt;div id="lst3" class="mui-noPull"&gt;
            &lt;p&gt;本页面没有下拉加载或上拉刷新功能&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>例子中使用了类&quot;mui-noPull&quot;来标识一个TAB页不是列表页，无需分页操作。</p>
<p class="key"><strong>@key <a id=".mui-noPull">.mui-noPull</a></strong>  如果一个列表页项的class中指定了此项，则显示该列表页时，不允许下拉。</p>
<p>还可以通过设置onPull选项来灵活设置，例：</p>
<pre><code>var listItf = initPageList(jpage, ...,
    onPull(ev, jlst) {
        if (jlst.attr("id") == "lst3")
            return false;
    }
);</code></pre>
<p class="param"><strong>@param opt.onPull</strong>  function(ev, jlst)</p>
<p>jlst:: 当前活动页。函数如果返回false，则取消所有上拉加载或下拉刷新行为，使用系统默认行为。</p>
<h4 id="initPageList-11 仅自动加载，禁止下拉刷新行为">11 仅自动加载，禁止下拉刷新行为</h4>
<p>只上拉加载，不需要下拉刷新行为。随着列表增长而自动向下滚动，在滚动到底时自动加载下一页。<br />
这时容器允许没有固定高度，而是可禁止下拉刷新行为：</p>
<pre><code>var listItf = initPageList(jpage, 
    ...,
    canPullDown: false,
);</code></pre>
<p class="param"><strong>@param opt.canPullDown</strong> ?=true  是否允许下拉刷新</p>
<p>设置为false时，当列表到底部时，可以自动加载下一页，但没有下拉刷新行为，这时页面容器也不需要确定高度。</p>
<h4 id="initPageList-12 本地分页">12 本地分页</h4>
<p class="param"><strong>@param opt.localPageSize</strong> </p>
<p>服务器一次性返回所有数据，在前端不想一次性全部显示，比如也按10条一页分页显示，下拉加载下一页，称为本地分页.<br />
这个场景下可以设置<code>opt.localPageSize=10</code>，示例：</p>
<pre><code>var lstIf = MUI.initPageList(jpage, {
    ...
    localPageSize: 10, // 设置本地分页
    onGetQueryParam: function (jlst, queryParam) {
        queryParam.ac = "Ordr.query";
        ...
        queryParam.pagesz = -1; // 服务端不分页
    },
    onAddItem: onAddItem
});</code></pre>
<p>也支持是远程分页+本地分页混用, 但没有意义, 容易造成错乱, 故请匆混用.</p></div>
<div class="block">
<h2 id="FormMode">@var FormMode</h2>
<p>FormMode.forAdd/forSet/forFind.</p>
<p>TODO: example</p></div>
<div class="block">
<h2 id="showByFormMode">@fn showByFormMode(jo, formMode)</h2>
<p>根据当前formMode自动显示或隐藏jo下的DOM对象.</p>
<p>示例: 对以下DOM对象</p>
<pre><code>&lt;div id="div1"&gt;
    &lt;div id="div2"&gt;&lt;/div&gt;
    &lt;div id="div3" class="forAdd"&gt;&lt;/div&gt;
    &lt;div id="div4" class="forSet"&gt;&lt;/div&gt;
    &lt;div id="div5" class="forSet forAdd"&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>调用showByFormMode(jo, FormMode.forAdd)时, 显示 div2, div3, div5;<br />
调用showByFormMode(jo, FormMode.forSet)时, 显示 div2, div4, div5;</p></div>
<div class="block">
<h2 id="initPageDetail">@fn initPageDetail(jpage, opt) -> PageDetailInterface={refresh(), del()}</h2>
<p>详情页框架. 用于对象的添加/查看/更新/删除多合一页面.<br />
form.action为对象名.</p>
<p class="param"><strong>@param opt</strong>  {pageItf, jform?=jpage.find("form:first"), onValidate?, onGetData?, onNoAction?=history.back, onAdd?, onSet?, onGet?, onDel?}</p>
<p>pageItf: {formMode, formData}; formData用于forSet模式下显示数据, 它必须有属性id.<br />
Form将则以pageItf.formData作为源数据, 除非它只有id一个属性(这时将则调用callSvr获取源数据)</p>
<p>onValidate: Function(jform, queryParam); 提交前的验证, 或做字段补全的工作, 或补全调用参数。queryParam是查询参数，它可能包含{ac?, res?, ...}，可以进行修改。(v5.3)支持返回Deferred对象做异步提交。<br />
onGetData: Function(jform, queryParam); 在forSet模式下，如果需要取数据，则回调该函数，获取get调用的参数。<br />
onNoAction: Function(jform); 一般用于更新模式下，当没有任何数据更改时，直接点按钮提交，其实不做任何调用, 这时将回调 onNoAction，缺省行为是返回上一页。<br />
onAdd: Function(id); 添加完成后的回调. id为新加数据的编号.<br />
onSet: Function(data); 更新完成后的回调, data为更新后的数据.<br />
onGet: Function(data); 获取数据后并调用setFormData将数据显示到页面后，回调该函数, 可用于显示特殊数据.<br />
onDel: Function(); 删除对象后回调.</p>
<p>示例：制作一个人物详情页PagePerson：</p>
<ul>
<li>在page里面包含form，form的action属性标明对象名称，method属性不用。form下包含各展示字段，各字段以name属性标识。</li>
<li>可以用 forAdd, forSet 等class标识对象只在添加或更新时显示。</li>
<li>一个或多个提交按钮，触发提交事件。</li>
<li>对于不想展示但需要提交的字段，可以用设置为隐藏的input[type=text]对象，或是input[type=hidden]对象；如果字段会变化应使用前者，type=hidden对象内容设置后不会变化(如调用setFormData不修改hidden对象)</li>
</ul>
<p>逻辑页面（html片段）示例如下：</p>
<pre><code>&lt;div mui-initfn="initPagePerson" mui-script="person.js"&gt;
    ...
    &lt;div class="bd"&gt;
        &lt;form action="Person"&gt;
            编号：&lt;input name="id" class="forSet"&gt; 
            &lt;input name="name" required placeholder="输入名称"&gt;
            &lt;textarea name="dscr" placeholder="写点简介"&gt;&lt;/textarea&gt;
            &lt;div class="forSet"&gt;人物标签&lt;/div&gt;

            &lt;button type="submit" id="btnOK"&gt;确定&lt;/button&gt;
            &lt;button type="button" id="btnDel"&gt;删除&lt;/button&gt;
            &lt;input type="text" style="display:none" name="familyId"&gt;

        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>注意：支持设置CSS类forSet,forAdd，用于标识只在更新或添加模式下使用。上例中编号id在添加时不出现，在更新时才显示。</p>
<p>调用initPageDetail使它成为支持添加、查看和更新的详情页：</p>
<pre><code>var PagePerson = {
    showForAdd: function (formData) ...
    showForSet: function (formData) ...
};

function initPagePerson()
{
    var jpage = this;
    var pageItf = PagePerson;
    var detailItf = MUI.initPageDetail(jpage, {
        pageItf: pageItf, // 需要页面接口提供 formMode, formData等属性。
        onValidate: function (jf) {
            // 补足字段和验证字段，返回false则取消form提交。
            if (pageItf.formMode == FormMode.forAdd) {
                ...
            }
        },
        onAdd: function (id) {
            PagePersons.show({refresh: true}); // 添加成功后跳到列表页并刷新。
        },
        onSet: function (data) {
            app_alert("更新成功!", history.back); // 更新成功后提示信息，然后返回前一页。
        },
        onDel: function () {
            PagePersons.show({refresh: true});
        },
    });

    jpage.find("#btnDel").click(btnDel_click);

    function btnDel_click(ev) {
        app_alert("删除记录？", "q", detailItf.del.bind(detailItf));
    }
}

// 其它页调用它：
PagePerson.showForAdd({familyId: 1}); // 添加人物，已设置familyId为1
PagePerson.showForSet(person); // 以person对象内容显示人物，可更新。
PagePerson.showForSet({id: 3}); // 以id=3查询人物并显示，可更新。</code></pre>
<p>页面接口常常实现如下：</p>
<pre><code>var PagePerson = {
    // @fn PagePerson.showForAdd(formData?)
    // formData={familyId, parentId?, parentOf?}
    showForAdd: function(formData) {
        this.formMode = FormMode.forAdd;
        this.formData = formData;
        MUI.showPage("#person");
    },
    // @fn PagePerson.showForSet(formData)
    // formData={id,...}
    showForSet: function (formData) {
        this.formMode = FormMode.forSet;
        this.formData = formData;
        MUI.showPage("#person");
    },

    formMode: null,
    formData: null,
};</code></pre>
<p>对于forSet模式，框架先检查formData中是否只有id属性，如果是，则在进入页面时会自动调用{obj}.get获取数据.</p>
<pre><code>&lt;form action="Person"&gt;
    &lt;div name=familyName&gt;&lt;/div&gt;
    ...
&lt;/form&gt;</code></pre>
<p>如果formData中有多个属性，则自动以formData的内容作为数据源显示页面，不再发起查询。</p>
<p>(v5.3) 在onValidate中返回Deferred对象，可支持异步提交。<br />
示例：先上传完照片获得picId后，再添加或保存。</p>
<pre><code>initPageDetail(jpage, {
    ...,
    onValidate: function (jf) {
        var dfd = $.Deferred();
        // 上传照片完成后再提交
        uploadPic.submit().then(function (picId) {
            jf[0].picId.value = picId;
            dfd.resolve();
        });
        return dfd;
    },
    onGet: function (data) {
        // 显示照片
        jpage.find(".uploadpic").attr("data-atts", data.picId);
        uploadPic.reset();
    },
}</code></pre>
<p class="see"><strong>@see <a href="#setFormSubmit">setFormSubmit</a></strong> </p></div>
<div class="block">
<h2 id="MUI.UploadPic">@class MUI.UploadPic(jo, opt/optfn)</h2><div class="toc"><p style="margin-left:0em"><a href="#MUI.UploadPic-1 清空与重置">1 清空与重置</a></p>
<p style="margin-left:0em"><a href="#MUI.UploadPic-2 设置只读，不可添加删除图片">2 设置只读，不可添加删除图片</a></p>
<p style="margin-left:0em"><a href="#MUI.UploadPic-3 获取图片数">3 获取图片数</a></p>
<p style="margin-left:0em"><a href="#MUI.UploadPic-4 指定上传区操作">4 指定上传区操作</a></p>
</div>
<p class="param"><strong>@param jo</strong>  jQuery DOM对象, 它是uploadpic类，或是包含一个或多个uploadpic类（上传区）的DOM对象。</p>
<p class="param"><strong>@param opt</strong>  {uploadParam?} 兼容MUI.compressImg函数opt参数，如 {quality=0.8, maxSize=1280, ...}</p>
<p>opt也可以是一个函数: optfn(jo) - jo为上传区, 返回该区的设置，这样就支持为每个上传区定义不同的选项。</p>
<p>初始化之后也可以这样为每一个上传区指定option:</p>
<pre><code>var opt = MUI.getOptions(jo);
opt.xx =xxx;</code></pre>
<p class="param"><strong>@param opt.uploadParam</strong>  调用upload接口的额外参数。</p>
<p>目前调用筋斗云upload接口，使用参数<code>{genThumb:1, autoResize:0}</code>，可以通过uploadParam指定额外参数。</p>
<p>注意：</p>
<ul>
<li>加载 jdcloud-uploadpic.js</li>
<li>以uploadpic开头的类所需CSS，目前放在app.css中。</li>
<li>预览大图依赖weui库中的样式。</li>
</ul>
<p>引入库：由于要上传功能的页面不多，建议只在逻辑页面用到的时候引入，像这样：</p>
<pre><code>&lt;div mui-initfn="initPagePic" mui-script="pic.js" mui-deferred="loadUploadLib()"&gt;</code></pre>
<p>loadUploadLib在app.js中有示例。在预览图片时，它自动检查和调用photoswipe库，优先用该库来预览。</p>
<p>示例HTML</p>
<pre><code>&lt;!-- 单图上传区: 比如上传用户头像。这里把预览图和文件按钮合一了，点预览图即可再选择文件 --&gt;
&lt;div class="uploadpic" id="userPic"&gt;
  &lt;div class="uploadpic-btn uploadpic-item"&gt;
    &lt;input type="file"&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;!-- 多图上传区：比如上传产品明细图片。 --&gt;
&lt;div class="uploadpic" id="itemPics"&gt;
  &lt;div class="uploadpic-btn"&gt;
    &lt;input type="file" multiple&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>类uploadpic为上传区。</li>
<li>类uploadpic-btn为文件选择区，其中包含的input[type=file]组件，如果没有multiple属性，则是单图上传区，只允许选择一张图预览和上传，否则为多图上传区，允许选择和上传多图。</li>
<li>类uploadpic-item为预览位，每张图片对应一个预览位。点击预览位可以查看大图（Gallery页面）<br />
如果当前没有预览位，则会在uploadpic内创建一个预览位；否则，在单图上传区中则会覆盖已有预览位，在多图上传区中会有已有上传位后再创建一个新的预览位。</li>
<li>如果在uploadpic中预先定义了uploadpic-item类对象，称为固定预览位，常用于自行指定预览位位置或样式。程序自动创建的预览位称为动态预览位。<br />
选择图片后，如果有空闲的固定预览位，则在该预览位显示预览，否则动态创建新的预览位（clone第一个固定预览位）</li>
<li>在删除图片时，如果图片在动态预览位，则会删除预览位，否则只是清空预览位的背景。</li>
</ul>
<p>JS</p>
<pre><code>// 如果已有图片需要预览，将缩略图ID列表传入data-atts属性，在new UploadPic时会根据Id在图片预览区加上已经存在的图片
jpage.find("#userPic").attr("data-atts", "208");
jpage.find("#itemPics").attr("data-atts", "210,212,214");</code></pre>
<p>也可以在上传区内放置一个带name属性的input, 框架将优先从它取值或设置值, 这样就不用手工取值和赋值了, 比如:</p>
<pre><code>&lt;div class="uploadpic"&gt;
    // 这个input的value将与data-atts一致.
    &lt;input name="itemPics" style="display:none"&gt;
    &lt;div class="uploadpic-btn"&gt;
        &lt;input type="file" multiple&gt;
    &lt;/div&gt;
&lt;/div&gt;

// 初始化，显示预览图
var uploadPic = new MUI.UploadPic(jpage); // 可直接传uploadpic类的jQuery对象或包含它的jQuery DOM对象
// var uploadPic = new MUI.UploadPic(jpage, {maxSize:1600, uploadParam:{type:"task"}} ); // 指定选项

// 如果重新设置了data-atts属性，可调用
// uploadPic.reset();

// 点击提交时调用submit，当上传完成后，
uploadPic.submit().then(function (userPic, itemPics) {

});

// 如果要精细控制上传进度：
var dfd = uploadPic.submit(onUpload, onUploadProgress, onNoWork);
dfd.then(onUploadDone);</code></pre>
<p>onUpload回调仅当需要上传照片或删除照片时调用，在照片上传完成后触发。一般用于将照片列表更新到相应对象上。如果有多个上传区更新，则会分别调用。<br />
attIds为上传后返回的缩略图Id数组，this为当前上传区的jQuery对象。<br />
如果函数返回一个Deferred对象（如callSvr调用），则onUploadDone（以及onUploadProgress的最后一次progress.done=true的回调）会在所有这些调用完成之后才触发。</p>
<pre><code>// 每个上传区一旦有图片更新，则调用Task1.set更新图片列表。
function onUpload(attIds) {
    // this对象为当前uploadpic
    var pics = attIds.join(',');
    var task = this.data("task_");
    // 如果返回一个Deferred对象，则progress.done会等待该事件结束才发生
    return callSvr("Task1.set", {id: task.id}, $.noop, {pics: pics});
}</code></pre>
<p>onUploadProgress用于显示上传进度。如果未指定，框架使用默认的进度提示，同时会在console中显示上传进度。如下所示：</p>
<pre><code>// progress: {curPicCnt/已上传照片数, picCnt/总共需上传的照片数, curAreaCnt/已完成的上传区数, areaCnt/总共需更新的上传区数, curSize/当前已完成的上传大小, size/总上传大小, done/是否全部完成, percent/上传完成百分数0-100}
// 示例：利用app_alert显示进度。
function onUploadProgress(progress)
{
    var info = progress.picCnt&gt;0? "正在上传... " + progress.percent + "% - " + progress.curPicCnt + "/" + progress.picCnt + "张照片": "更新照片";
    var alertOpt = {keep: true};
    if (progress.done) {
        info += " - &lt;b&gt;完成!&lt;/b&gt;";
        alertOpt.timeoutInterval = 500;
    }
    else {
        info += "...";
    }
    app_alert(info, alertOpt);
}</code></pre>
<p>onNoWork在无任何更新时回调。这时onUpload和onUploadProgress都不会被调用到。</p>
<pre><code>function onNoWork() {
    app_alert("都保存好了。");
}</code></pre>
<p>onUploadDone在全部上传完成后调用，参数分别为每个上传区的图片编号数组（不论该上传区是否需要更新）。</p>
<pre><code>function onUploadDone(attIds, attIds1) {
    // arguments
}</code></pre>
<p>在预览位uploadpic-item对象上，设置了以下属性：</p>
<ul>
<li>ji.prop(&quot;picData_&quot;) -&gt; {b64src,blob,w,h,size,...} (参考compressImg的回调函数cb的参数)<br />
当选择的图片进行压缩后，数据存储在picData_中。b64src字段可作为url显示图片。在上传服务端后该数据被清空。</li>
<li>ji.prop(&quot;attId_&quot;) -&gt; 对应的图片（缩略图）编号。仅当在服务器上已有才显示。</li>
<li>ji.prop(&quot;isFixed_&quot;) -&gt; true表示固定预览位，只能清空，不可被删除。</li>
<li>ji.css(&quot;background-image&quot;); -&gt; 缩略图片的url。如果是待上传或刚刚上传的图片，则是大图的base64编码url。</li>
</ul>
<p>在上传区uploadpic对象上，私有数据存储在MUI.getOptions(jo)中：</p>
<ul>
<li>isMul: 标识是多图上传区。在安卓手机上，由于对文件选择框的multiple属性支持不好，常常去掉和禁用它。所以内部使用isMul属性来区分。</li>
<li>delMark_: 标识是否有删除图片操作。在submit后恢复为null.</li>
</ul>
<p class="see"><strong>@see <a href="#compressImg">compressImg</a></strong> </p>
<p class="event"><strong>@event <a id="changepic">changepic</a></strong>  uploadpic对应的jquery对象事件，在添加或删除图片时触发</p>
<p>示例：在选择图片后显示预览区，无图片则不显示</p>
<pre><code>&lt;div class="" v-show='uploadObjNum&gt;0'&gt;
    &lt;div class="uploadpic"&gt;...&lt;/div&gt;
&lt;/div&gt;

// 注意：添加多张图片时，会连续触发多次
jpage.find("#addMsg").on("changepic", function (ev) {
    console.log('changepic');
    vm.uploadObjNum = uploadPic.countPic();
});</code></pre>
<h4 id="MUI.UploadPic-1 清空与重置">1 清空与重置</h4>
<p>清空全部图片：</p>
<pre><code>uploadPic.empty();
// 等价于 uploadPic.reset(true);</code></pre>
<p>修改了data-atts属性后重新刷新显示：</p>
<pre><code>uploadPic.reset();</code></pre>
<h4 id="MUI.UploadPic-2 设置只读，不可添加删除图片">2 设置只读，不可添加删除图片</h4>
<pre><code>uploadPic.readonly(true);
var isReadonly = uploadPic.readonly();</code></pre>
<h4 id="MUI.UploadPic-3 获取图片数">3 获取图片数</h4>
<p>要判断预览区有几张图，可以用：</p>
<pre><code>var cnt = uploadPic.countPic(); // 总图片数
var oldCnt = uploadPic.countPic(1); // 已有图片数
var newCnt = uploadPic.countPic(2); // 新选择的图片数</code></pre>
<h4 id="MUI.UploadPic-4 指定上传区操作">4 指定上传区操作</h4>
<p>当uploadPic包含多个上传区时，可以用filter指定之后的方法是针对哪一个区。注意filter只对下一次调用有效。</p>
<pre><code>uploadPic.filter(idx).其它方法(); // idx为下标或jQuery的filter</code></pre>
<p>示例：</p>
<pre><code>var cnt = uploadPic.filter(0).countPic();
// 等价于 var cnt = uploadPic.filter(":eq(0)").countPic;
uploadPic.filter(".storePics").empty();</code></pre></div>
<div style="text-align:center">Generated by jdcloud-gendoc</div>
</body>

</html>

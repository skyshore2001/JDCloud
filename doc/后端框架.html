<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Web接口服务框架设计</title>
  <style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="doc.css" />
<script src="doc.js"></script>

</head>
<body>
<h1 id="web接口服务框架设计">Web接口服务框架设计</h1>
<p>需求和设计目标：</p>
<ul>
<li>提供REST-RPC风格的服务端接口API, 可方便的添加函数形式(如queryLog)和对象操作形式(如log.query)的API.</li>
<li>提供数据库设计、部署工具</li>
<li>提供手工测试及回归测试工具</li>
<li>提供Web部署工具</li>
</ul>

<div id="TOC" class="toc">
<ul>
<li><a href="#web接口服务框架设计">Web接口服务框架设计</a><ul>
<li><a href="#概要设计"><span class="toc-section-number">1</span> 概要设计</a><ul>
<li><a href="#文件结构"><span class="toc-section-number">1.1</span> 文件结构</a></li>
<li><a href="#运行环境"><span class="toc-section-number">1.2</span> 运行环境</a></li>
<li><a href="#配置项"><span class="toc-section-number">1.3</span> 配置项</a></li>
<li><a href="#命名规范"><span class="toc-section-number">1.4</span> 命名规范</a></li>
</ul></li>
<li><a href="#数据库设计"><span class="toc-section-number">2</span> 数据库设计</a></li>
<li><a href="#通讯协议设计"><span class="toc-section-number">3</span> 通讯协议设计</a><ul>
<li><a href="#通用原则"><span class="toc-section-number">3.1</span> 通用原则</a><ul>
<li><a href="#常用返回类型描述"><span class="toc-section-number">3.1.1</span> 常用返回类型描述</a></li>
<li><a href="#分页机制"><span class="toc-section-number">3.1.2</span> 分页机制</a></li>
<li><a href="#分页机制实现原理"><span class="toc-section-number">3.1.3</span> 分页机制实现原理</a></li>
<li><a href="#https服务"><span class="toc-section-number">3.1.4</span> HTTPS服务</a></li>
<li><a href="#调试等级_debug"><span class="toc-section-number">3.1.5</span> 调试等级(_debug)</a></li>
<li><a href="#应用标识_app"><span class="toc-section-number">3.1.6</span> 应用标识(_app)</a></li>
<li><a href="#使用path_info模式的url"><span class="toc-section-number">3.1.7</span> 使用PATH_INFO模式的URL</a></li>
<li><a href="#客户端版本_ver"><span class="toc-section-number">3.1.8</span> 客户端版本(_ver)</a></li>
<li><a href="#权限说明"><span class="toc-section-number">3.1.9</span> 权限说明</a></li>
</ul></li>
<li><a href="#通用对象接口"><span class="toc-section-number">3.2</span> 通用对象接口</a><ul>
<li><a href="#通用查询导出与分组统计"><span class="toc-section-number">3.2.1</span> 通用查询、导出与分组统计</a></li>
<li><a href="#批量更新与删除"><span class="toc-section-number">3.2.2</span> 批量更新与删除</a></li>
<li><a href="#批量添加导入"><span class="toc-section-number">3.2.3</span> 批量添加（导入）</a></li>
<li><a href="#通用子表对象操作"><span class="toc-section-number">3.2.4</span> 通用子表对象操作</a></li>
</ul></li>
<li><a href="#api调用监控"><span class="toc-section-number">3.3</span> API调用监控</a></li>
<li><a href="#批量请求"><span class="toc-section-number">3.4</span> 批量请求</a></li>
<li><a href="#服务端信息反馈x-daca头"><span class="toc-section-number">3.5</span> 服务端信息反馈/X-Daca头</a></li>
</ul></li>
<li><a href="#前端应用接口"><span class="toc-section-number">4</span> 前端应用接口</a><ul>
<li><a href="#移动端应用"><span class="toc-section-number">4.1</span> 移动端应用</a><ul>
<li><a href="#客户端appuser"><span class="toc-section-number">4.1.1</span> 客户端(app=user)</a></li>
</ul></li>
<li><a href="#桌面应用"><span class="toc-section-number">4.2</span> 桌面应用</a><ul>
<li><a href="#管理端应用appemp-adm"><span class="toc-section-number">4.2.1</span> 管理端应用(app=emp-adm)</a></li>
<li><a href="#超级管理端应用appadmin"><span class="toc-section-number">4.2.2</span> 超级管理端应用(app=admin)</a></li>
<li><a href="#桌面应用查询用法"><span class="toc-section-number">4.2.3</span> 桌面应用查询用法</a></li>
<li><a href="#通用参数"><span class="toc-section-number">4.2.4</span> 通用参数</a></li>
<li><a href="#全局变量"><span class="toc-section-number">4.2.5</span> 全局变量</a></li>
<li><a href="#管理端用法技巧"><span class="toc-section-number">4.2.6</span> 管理端用法技巧</a></li>
</ul></li>
</ul></li>
<li><a href="#测试设计"><span class="toc-section-number">5</span> 测试设计</a><ul>
<li><a href="#手工测试"><span class="toc-section-number">5.1</span> 手工测试</a></li>
<li><a href="#回归测试"><span class="toc-section-number">5.2</span> 回归测试</a><ul>
<li><a href="#使用方法"><span class="toc-section-number">5.2.1</span> 使用方法</a></li>
<li><a href="#api测试和用例测试"><span class="toc-section-number">5.2.2</span> API测试和用例测试</a></li>
</ul></li>
<li><a href="#单元测试"><span class="toc-section-number">5.3</span> 单元测试</a></li>
</ul></li>
<li><a href="#登录类型与权限管理"><span class="toc-section-number">6</span> 登录类型与权限管理</a></li>
<li><a href="#服务端部署与升级"><span class="toc-section-number">7</span> 服务端部署与升级</a><ul>
<li><a href="#初始化配置"><span class="toc-section-number">7.1</span> 初始化配置</a></li>
<li><a href="#升级管理"><span class="toc-section-number">7.2</span> 升级管理</a><ul>
<li><a href="#用法"><span class="toc-section-number">7.2.1</span> 用法</a><ul>
<li><a href="#交互命令"><span class="toc-section-number">7.2.1.1</span> 交互命令</a></li>
<li><a href="#非交互命令"><span class="toc-section-number">7.2.1.2</span> 非交互命令</a></li>
</ul></li>
<li><a href="#todo-写升级脚本"><span class="toc-section-number">7.2.2</span> TODO: 写升级脚本</a></li>
</ul></li>
<li><a href="#版本发布"><span class="toc-section-number">7.3</span> 版本发布</a><ul>
<li><a href="#直接源码部署"><span class="toc-section-number">7.3.1</span> 直接源码部署</a></li>
</ul></li>
<li><a href="#客户端自动升级"><span class="toc-section-number">7.4</span> 客户端自动升级</a></li>
</ul></li>
<li><a href="#工具接口"><span class="toc-section-number">8</span> 工具接口</a><ul>
<li><a href="#toollog.php"><span class="toc-section-number">8.1</span> tool/log.php</a></li>
<li><a href="#toolinit.php"><span class="toc-section-number">8.2</span> tool/init.php</a></li>
<li><a href="#tooltool.php"><span class="toc-section-number">8.3</span> tool/tool.php</a></li>
<li><a href="#toolupgrade"><span class="toc-section-number">8.4</span> tool/upgrade/</a></li>
</ul></li>
<li><a href="#定期任务"><span class="toc-section-number">9</span> 定期任务</a></li>
<li><a href="#数据安全"><span class="toc-section-number">10</span> 数据安全</a><ul>
<li><a href="#通讯加密"><span class="toc-section-number">10.1</span> 通讯加密</a><ul>
<li><a href="#编码算法"><span class="toc-section-number">10.1.1</span> 编码算法</a></li>
</ul></li>
<li><a href="#数据备份"><span class="toc-section-number">10.2</span> 数据备份</a></li>
</ul></li>
<li><a href="#插件机制"><span class="toc-section-number">11</span> 插件机制</a><ul>
<li><a href="#安装与卸载插件"><span class="toc-section-number">11.1</span> 安装与卸载插件</a></li>
<li><a href="#创建插件"><span class="toc-section-number">11.2</span> 创建插件</a></li>
</ul></li>
<li><a href="#插件机制旧"><span class="toc-section-number">12</span> 插件机制（旧）</a><ul>
<li><a href="#插件目录结构"><span class="toc-section-number">12.1</span> 插件目录结构</a></li>
<li><a href="#插件安装"><span class="toc-section-number">12.2</span> 插件安装</a></li>
<li><a href="#接口"><span class="toc-section-number">12.3</span> 接口</a><ul>
<li><a href="#后端php-api"><span class="toc-section-number">12.3.1</span> 后端PHP API</a></li>
<li><a href="#前端js-api"><span class="toc-section-number">12.3.2</span> 前端JS API</a></li>
<li><a href="#交互接口"><span class="toc-section-number">12.3.3</span> 交互接口</a></li>
</ul></li>
<li><a href="#发布与上线"><span class="toc-section-number">12.4</span> 发布与上线</a></li>
</ul></li>
</ul></li>
</ul></div>

<h2 id="概要设计"><span class="header-section-number">1</span> 概要设计</h2>
<h3 id="文件结构"><span class="header-section-number">1.1</span> 文件结构</h3>
<p>概念：</p>
<ul>
<li>产品：如“小鳄养车”，包括前端、后端等子系统，每个子系统包括多个应用，如前端包括客户端、管理端等应用，后端包括API接口、某工具、定时任务等应用。</li>
<li>应用：一个可独立执行的应用程序（或网页入口）。</li>
<li>工具：应用的一种，有的不发布（只用于开发过程），有的发布但做内部使用或被其它应用调用。</li>
<li>库：被应用包含，提供共享数据和操作。</li>
<li>框架：库的一种，一般成型后很少修改。被应用或其它库包含使用。</li>
</ul>
<p>注：以下标记<code>*</code>表示不需要开发者修改的框架实现源文件或工具。</p>
<p><strong>[根目录]</strong></p>
<dl>
<dt>DESIGN.wiki</dt>
<dd>主设计文档。其它文档在doc目录下。
</dd>
<dt>build_web.sh</dt>
<dd>Web部署工具。
</dd>
</dl>
<p>产品设计文档包括：</p>
<ul>
<li>框架设计文档：含后台框架文档（框架提供功能的说明，后台函数接口等）及前台框架文档（前台框架的基本使用方法与接口描述）。</li>
<li>主设计文档: 包括产品的需求、概要设计（运行环境、系统建模、主要用例）、详细设计。 其中详细设计包括：数据库表设计（表、字段类型），通讯协议设计（函数、对象或页面调用），客户端接口设计（页面、参数等）</li>
<li>专题设计文档，与详细设计内容类似，但将数据库、通讯协议及客户端接口放在一个专题中描述。</li>
</ul>
<p><strong>[后端应用 - server目录]</strong></p>
<dl>
<dt>api.php</dt>
<dd>接口应用程序，提供Web服务接口。例如调用接口<code>Ordr.query</code>可访问<code>http://myserver/mysvc/api.php/Ordr.query</code>；该文件包含其它实现文件，以及应用内共享的数据。其它应用可包含它从而直接以内部调用方式访问API接口。
</dd>
<dt>app.php</dt>
<dd>应用共享库。存放所有应用或工具共享的数据和函数。所有应用一般都应包含它。它包含common.php,app_fw.php,conf.php,conf.user.php等。
</dd>
<dt>php/conf.user.php</dt>
<dd>产品配置文件，一般不加入代码库（指git等版本控制系统），在部署时根据实际环境配置。被app.php包含，因而所有应用或工具都间接包含它。
</dd>
<dt>conf.php</dt>
<dd>被api.php包含，保存易变的程序逻辑。
</dd>
<dt>php/api_functions.php</dt>
<dd>API接口应用中的函数实现部分。被api.php包含。
</dd>
<dt>php/api_objects.php</dt>
<dd>API接口应用中的对象访问实现部分。被api.php包含。
</dd>
</dl>
<p>框架实现部分：</p>
<dl>
<dt>php/common.php*</dt>
<dd>通用共享库。基础公共函数部分，可适用一切php项目。
</dd>
<dt>php/app_fw.php*</dt>
<dd>应用框架库。为所有应用提供框架支持（以app_开头表示适用于所有应用，fw表示framework），被app.php包含。
</dd>
<dt>php/api_fw.php*</dt>
<dd>API接口应用的框架实现（以api_开头表示属于API接口应用）。被api.php包含。
</dd>
</dl>
<p><strong>[工具 - tool目录]</strong></p>
<dl>
<dt>upgrade.php*</dt>
<dd>数据部署工具。创建或更新数据库表，导入数据等。
</dd>
<dt>webcc.php*</dt>
<dd>Web部署工具。用户上传或更新线上Web产品目录。
</dd>
<dt>cmdtool.template.php</dt>
<dd>使用app.php创建数据操作工具的示例，如用于特殊数据导入等。
</dd>
</dl>
<p><strong>[回归测试 - rtest目录]</strong></p>
<dl>
<dt>rtest.php</dt>
<dd>回归测试内容。（TODO: 类似api应用，可拆分为 rtest.php, php/rtest_fw.php, php/rtest_group1.php, php/rtest_group.php等)
</dd>
<dt>run_rtest.pl*</dt>
<dd>回归测试执行工具。
</dd>
<dt>client.php*</dt>
<dd>手工测试工具。模拟前端调用API接口。
</dd>
</dl>
<p>内部实现部分：</p>
<dl>
<dt>WebAPI.php</dt>
<dd>测试应用框架库。
</dd>
</dl>
<p><strong>[前端应用]</strong></p>
<p>如果有筋斗云前端应用，一般放置在以下目录：</p>
<dl>
<dt>m2/</dt>
<dd>移动端H5应用，如用户端、员工端应用。
</dd>
<dt>web/</dt>
<dd>桌面版H5应用，如后台管理端应用。
</dd>
</dl>
<h3 id="运行环境"><span class="header-section-number">1.2</span> 运行环境</h3>
<p><strong>[部署环境]</strong></p>
<ul>
<li>Linux CentOS5 以上版本 x64，可使用阿里云平台</li>
<li>Apache 2.4+</li>
<li>php 5.4+</li>
<li>Mysql 5+</li>
</ul>
<p><strong>[开发环境]</strong></p>
<ul>
<li>Windows或Linux</li>
<li>php5.4 (5.4.31)</li>
<li>Apache/IIS/nginx</li>
<li>数据库mysql5</li>
</ul>
<p><strong>[演示版]</strong></p>
<p>演示版用于快速开发原型及测试演示，对运行环境低要求，部署极其简单。</p>
<ul>
<li>Windows/Linux/Mac (一般在Windows环境开发，最终在Linux环境运行，支持在Mac上运行以便开发iphone应用时搭建本地环境)</li>
<li>php5.4+</li>
<li>phpunit4.2+用于回归测试。</li>
<li>无需mysql等数据库服务。（使用内置sqlite3以方便测试或演示。）</li>
<li>无需Apache等web服务器。(直接用php开服务以方便测试或演示。）</li>
</ul>
<h3 id="配置项"><span class="header-section-number">1.3</span> 配置项</h3>
<p>在应用设计时，一般使用前缀名为&quot;P_&quot;的环境变量供使用时扩展。</p>
<p>一般用在浏览器中打开URL <code>tool/init.php</code>进行配置。之后，可手工修改配置文件<code>php/conf.user.php</code>。一般使用putenv设置环境变量。</p>
<p><strong>[数据库连接]</strong></p>
<p>例：</p>
<pre><code>putenv(&quot;P_DB=localhost/mysvc&quot;);
putenv(&quot;P_DBCRED=bGo6aWhxZ19VR0xH&quot;);</code></pre>
<p><strong>[URL路径]</strong></p>
<p>如部署路径为 http://myserver.com/mysvc/ ，则应设置</p>
<pre><code>putenv(&quot;P_URL_PATH=/mysvc&quot;);</code></pre>
<p>如果不设置，应用将自动判断（但如果服务器上使用了符号链接，则会判断失误）。</p>
<p>注意：</p>
<ul>
<li>使用绝对路径，一定以要&quot;/&quot;开头；设置错误将导致cookie及会话无法使用，出现登录后仍当作未登录等异常。</li>
</ul>
<p>常用环境变量如下：</p>
<ul>
<li>P_DB 指定数据库。MySQL数据库示例: &quot;{主机名}/{数据库名}&quot; 或 &quot;{主机名}:{端口号}/{数据库名}&quot;</li>
<li>P_DBCRED 指定数据库登录用户名及密码。格式为&quot;{user}:{pwd}&quot;，或其base64编码形式，一般使用base64编码。</li>
<li>P_URL_PATH 指定应用的URL绝对路径(以&quot;/&quot;开头)。用于拼出正确的完整url路径。</li>
<li>P_ADMIN_CRED 指定超级管理员帐号。格式与P_DBCRED相同。</li>
<li>P_TEST_MODE 值为1表示测试模式，2为回归测试模式</li>
<li>P_MOCK_MODE 值为1表示模拟模式</li>
<li>P_DEBUG 调试日志输出等级，0-9</li>
<li>P_SESSION_DIR 指定session文件保存位置，缺省是应用目录下。注意：测试模式的session是分开保存的，在该目录下子目录&quot;t&quot;中。</li>
</ul>
<p><strong>[测试模式 - TEST_MODE]</strong></p>
<ul>
<li>输出的HTTP头中包含：<code>X-Daca-Test-Mode: 1</code></li>
<li>输出的JSON格式经过美化更易读，且可以显示更多调试信息。前端可通过在接口中添加<code>_debug</code>参数设置调试等级。 如果想要查看本次调用涉及的SQL语句，可以用<code>_debug=9</code>。</li>
<li>某些用于测试的接口可以调用，例如execSql。因而十分危险，生产模式下一定不可误设置为测试模式。</li>
<li>支持跨域</li>
<li>可以使用模拟模式</li>
</ul>
<p><strong>[模拟模式 - MOCK_MODE]</strong></p>
<p>这时，对外部系统的依赖（如短信模块，微信接口，支付宝支付等）都将模拟运行，只生成日志到 ext.log 中。</p>
<p>可通过工具 tool/log.php 查看日志。</p>
<h3 id="命名规范"><span class="header-section-number">1.4</span> 命名规范</h3>
<p>变量/函数名/数据库表的字段名使用驼峰式(首个单词小写，其余单词首字母大写)，如getCarModel, svcId。</p>
<p>WebAPI的调用名和传入参数也采用驼峰式，由于目前实现时不区分大小写, 所以调用时也可以用全部小写（习惯上，url里常常只用小写字母，且不带下划线。) 例如，调用接口名queryOrder，传入参数为modelId, storeId等。</p>
<p>类名，或数据库表名，用大驼峰式（或叫Pascal命名，所有单词首字母大写）, 如OrderStatus.</p>
<h2 id="数据库设计"><span class="header-section-number">2</span> 数据库设计</h2>
<p>根据[系统建模]设计数据库表结构。</p>
<p><strong>[通用规则]</strong></p>
<ul>
<li>每个表均有整型字段id作为主键；关联表也不例外。</li>
<li>外键一般以xxxId表示，除非特殊说明，一般该字段非空；</li>
</ul>
<p>字段名的类型可在字段后标示，例如：<code>status(2)</code>表示2字符长度的字符串(nvarchar(2)), <code>创建时间(dt)</code>表示date类型。</p>
<table>
<thead>
<tr class="header">
<th align="left">标记</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">s</td>
<td align="left">small string(20)</td>
</tr>
<tr class="even">
<td align="left">l</td>
<td align="left">long string(255)</td>
</tr>
<tr class="odd">
<td align="left">t</td>
<td align="left">text(64K)</td>
</tr>
<tr class="even">
<td align="left">tt</td>
<td align="left">mediumtext(16M)</td>
</tr>
<tr class="odd">
<td align="left">i</td>
<td align="left">int</td>
</tr>
<tr class="even">
<td align="left">n</td>
<td align="left">numeric(decimal)</td>
</tr>
<tr class="odd">
<td align="left">date</td>
<td align="left">date</td>
</tr>
<tr class="even">
<td align="left">tm</td>
<td align="left">datetime</td>
</tr>
<tr class="odd">
<td align="left">flag</td>
<td align="left">tiny int</td>
</tr>
<tr class="even">
<td align="left">数字</td>
<td align="left">指定长度的string</td>
</tr>
<tr class="odd">
<td align="left">不指定</td>
<td align="left">自动判断</td>
</tr>
</tbody>
</table>
<p>如果未指定类型，则根据命名规范自动判断，比如以id结尾的字段会被自动作为整型创建，以tm结尾会被当作日期时间类型创建，其它默认是字符串（长度50），规则如下：</p>
<table>
<thead>
<tr class="header">
<th align="left">规则</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">以&quot;Id&quot;/&quot;Cnt&quot;结尾</td>
<td align="left">Integer</td>
</tr>
<tr class="even">
<td align="left">以&quot;Price&quot;/&quot;Total&quot;/&quot;Qty&quot;/&quot;Amount&quot;结尾</td>
<td align="left">Currency</td>
</tr>
<tr class="odd">
<td align="left">以&quot;Tm&quot;/&quot;Dt&quot;结尾</td>
<td align="left">Datetime/Date</td>
</tr>
<tr class="even">
<td align="left">以&quot;Flag&quot;结尾</td>
<td align="left">TinyInt(1B) NOT NULL</td>
</tr>
</tbody>
</table>
<p>例如，&quot;total&quot;, &quot;docTotal&quot;, &quot;total2&quot;, &quot;docTotal2&quot;都被认为是Currency类型（字段名后面有数字的，判断类型时数字会被忽略）。</p>
<p>也可以用一个类型后缀表示，如 <code>retval&amp;</code>表示整型，规则如下：</p>
<table>
<thead>
<tr class="header">
<th align="left">后缀</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">&amp;</td>
<td align="left">Integer</td>
</tr>
<tr class="even">
<td align="left">@</td>
<td align="left">Currency</td>
</tr>
<tr class="odd">
<td align="left">#</td>
<td align="left">Double</td>
</tr>
<tr class="even">
<td align="left">!</td>
<td align="left">Float</td>
</tr>
</tbody>
</table>
<p>注意： - 一些名字由于与某些数据库系统关键字冲突应避免，如不使用&quot;desc&quot;, 改用&quot;dscr&quot; (description).</p>
<p class="todo">TODO: define unique-key, index, not null, default value</p>
<h2 id="通讯协议设计"><span class="header-section-number">3</span> 通讯协议设计</h2>
<h3 id="通用原则"><span class="header-section-number">3.1</span> 通用原则</h3>
<p>客户端通过HTTP协议与服务端交互，调用服务端WebAPI。</p>
<ul>
<li><p>Request一般使用HTTP GET/POST方法，如方法描述&quot;fn(p1, p2)&quot;可以用HTTP GET请求(通过URL传参)实现: <code>GET /api.php/fn?p1=value1&amp;p2=value2</code>, 也可以用POST请求实现:</p>
<pre><code>POST /api.php/fn
Content-Type: application/x-www-form-urlencoded

p2=value2&amp;p1=value1</code></pre></li>
</ul>
<p>参数未加说明的, 可以选择通过URL或POST传参.</p>
<ul>
<li><p>少数方法描述为&quot;fn(p1)(p2,p3)&quot;, 它表示后一个括号中的参数表示必须通过POST传参, 而前一个括号的参数必须用URL传参数, 如:</p>
<pre><code>POST /api.php/fn?p1=value1
Content-Type: application/x-www-form-urlencoded

p2=value2&amp;p3=value3</code></pre></li>
</ul>
<p>注意Content-Type需要设置正确, 少数例外情况会特别指出，比如upload方法，它使用&quot;Content-type: multipart/form-data&quot;。</p>
<ul>
<li>只要服务端正确收到请求并处理，均返回code为HTTP 200的Response，其内容使用json格式，为一个至少含有2元素的数组。</li>
<li>在WebAPI请求成功时返回内容为 <code>[0, data]</code>，其中<code>data</code>的类型由WebAPI返回类型所定义。</li>
<li>在请求失败时返回内容为 <code>[非0错误码, 错误信息]</code>.</li>
<li><p>从返回数组的第3个元素起, 为调试信息, 仅用于问题诊断, 不适合显示给用户看.</p></li>
<li><p>所有交互内容采用UTF-8编码。</p></li>
</ul>
<p>以下面的WebAPI描述为例：</p>
<pre><code>根据id取车型信息：
getModel(id) -&gt; {id, name, dscr}</code></pre>
<p>它包含以下信息：</p>
<ul>
<li><p>WebAPI名称是getModel，参数为id，对应的Request URL为 <code>GET /api.php/getModel?id=100</code> URL参数<code>ac</code>表示WebAPI名称，一般用全小写。 为防止服务端缓冲，一般请求时还应加上一个随机参数，如 <code>GET /api.php/getModel?id=100&amp;rnd=5234762234</code>. 之后的请求示例中, HTTP请求将被简化描述为:</p>
<pre><code>getModel(id=100)</code></pre></li>
<li><p>处理成功返回类型为<code>{id, name, dscr}</code>，例如<code>{id: 100, name: &quot;myname&quot;, dscr:&quot;mydscr&quot;}</code>，关于返回类型表述方式详见下节描述。完整的返回内容为</p>
<pre><code>HTTP/1.1 200 OK

[0, {id: 100, name: &quot;myname&quot;, dscr:&quot;mydscr&quot;}]</code></pre></li>
</ul>
<p>之后的示例中，返回内容将被简化描述为：</p>
<pre><code>    {id: 100, name: &quot;myname&quot;, dscr:&quot;mydscr&quot;}</code></pre>
<ul>
<li><p>处理失败时返回信息如</p>
<pre><code>HTTP/1.1 200 OK

[1, &quot;未认证&quot;]</code></pre></li>
</ul>
<p><strong>[错误码定义]</strong></p>
<p>常用错误码如下：</p>
<pre><code>const E_OK=0;
const E_PARAM=1;
const E_AUTH=2;
const E_DB=3;
const E_SERVER=4;
const E_FORBIDDEN=5;

$ERRINFO = [
    E_PARAM =&gt; &quot;参数不正确&quot;,
    E_AUTH =&gt; &quot;未认证&quot;,
    E_DB =&gt; &quot;数据库错误&quot;,
    E_SERVER =&gt; &quot;服务器错误&quot;,
    E_FORBIDDEN =&gt; &quot;禁止操作&quot;
];</code></pre>
<p><strong>[关于空值]</strong></p>
<p>假如有参数&quot;a=1&amp;b=&amp;c=hello&quot;, 其中参数&quot;b&quot;值为空串。 一般情况下，被当作未赋值处理，即与&quot;a=1&amp;c=hello&quot;意义相同。</p>
<p>只有在对象保存上下文中（典型的是通用对象接口的set操作），且出现中POST内容的&quot;a=&quot;表示将该字段置null(与&quot;a=null&quot;语义相同), 注意：不是置空字符串。</p>
<h4 id="常用返回类型描述"><span class="header-section-number">3.1.1</span> 常用返回类型描述</h4>
<p><strong>{id, name}</strong></p>
<p>一个简单对象，有两个字段id和name。e.g. <code>{id: 100, name: &quot;name1&quot;}</code></p>
<p><strong>[id...] or [id]</strong></p>
<p>一个简单数组，元素为id。e.g. <code>[100, 200, 400]</code>, 每项为一个id</p>
<p><strong>[id, name]</strong></p>
<p>一个简单数组，e.g. <code>[100, &quot;liang&quot;]</code>，第一项为id, 第二项为name</p>
<p><strong>[ [id, name] ] 或 varr(id, name)</strong></p>
<p>简单二维数组，又称varr, 如 <code>[ [100, &quot;liang&quot;], [101, &quot;wang&quot;] ]</code>.</p>
<p><strong>[{id, name}] 或 objarr(id, name)</strong></p>
<p>一个数组，每项为一个对象，又称objarr。e.g. <code>[{id: 100, name: &quot;name1&quot;}, {id: 101, name: &quot;name2&quot;}]</code></p>
<p><strong>tbl(id, name)</strong></p>
<p>table对象。其详细格式为 <code>{h: [header1, header2, ...], d:[row1, row2, ...]}</code>，例如</p>
<pre><code>{
  h: [&quot;id&quot;, &quot;name&quot;],
  d: [[100, &quot;myname1&quot;], [200, &quot;myname2&quot;]]
}</code></pre>
<p>table对象支持分页机制(paging)，返回字段中包含&quot;nextkey&quot;等。 详情请参考下一章节&quot;分页机制&quot;.</p>
<p>注意：</p>
<ul>
<li>目前的json返回内容不区分整形或字符串型, 大多都用引号括起来</li>
<li>不论哪种类型，都可能返回null。客户端必须能够处理null，将其转为相应类型正确的值。</li>
</ul>
<p><strong>[可选参数]</strong></p>
<p>如果API的参数表示为:</p>
<pre><code>fn(p1, p2?, p3?=1)</code></pre>
<p>它表示：</p>
<ul>
<li>p1是必选参数</li>
<li>p2,p3是可选参数，p3的缺省值是1，p2缺省值是0/&quot;&quot;/null(取决于它的类型)</li>
</ul>
<p><strong>[复杂类型序列化为字符串描述]</strong></p>
<p>有时用一个字符串字段表示复杂的结构，这时常以下类型描述方式：</p>
<ul>
<li><p>逗号分隔的简单字符串序列，如</p>
<pre><code>&quot;经度,纬度&quot;
或
&quot;经度/Double,纬度/Double&quot;</code></pre>
<p>可表示<code>121.233543,31.345457</code><br />
特别地，Coord类型: Coord=&quot;经度/Double,纬度/Double&quot;.</p></li>
<li><p>逗号分隔行，冒号分隔列的表，简称list，如</p>
<pre><code>&quot;id:name?,&quot;
参数后加&quot;?&quot;表示是可选参数(逗号不可少，表示数组，即后面可有多个重复项)
或
list(id, name?)
或指定类型 
list(id/Integer, name?/String)</code></pre>
<p>每个元组用&quot;,&quot;分隔, 元组内每个字段用&quot;:&quot;分隔。每个字段内不能有这两个特殊符号(如果是日期，中间不可以有&quot;:&quot;, 如&quot;2015/11/20 1030&quot;或&quot;20151120 1030&quot;)。 例如</p>
<pre><code>10:liang,11:wang</code></pre>
<p>如果name字段省略，则可简化为<code>10,11</code>.</p>
<p class="todo">TODO: 也可以带表头信息（首字符&quot;@&quot;标明有表头），如 <code>@id:name,10:liang,11:wang</code> 或 <code>@id,10,11</code>.</p>
<p>这种格式一般用于传递简单的表。更加复杂的类型可使用json格式传递。</p></li>
<li><p>换行符&quot;&quot;分隔行, 制表符&quot;&quot;分隔列的表, 称为table，可表示为 <code>&quot;id \t name \n&quot;</code> 或 <code>table(id, name)</code></p></li>
</ul>
<h4 id="分页机制"><span class="header-section-number">3.1.2</span> 分页机制</h4>
<p>如果一个查询支持分页(paging), 则一般调用形式为</p>
<pre><code>Ordr.query(pagekey?, pagesz?=20) -&gt; {nextkey, total?, @h, @d}
或
Ordr.query(page, rows?=20) -&gt; {nextkey, total, @h, @d}</code></pre>
<p><strong>[参数]</strong></p>
<dl>
<dt>pagesz</dt>
<dd>Integer. 页大小，默认为20条数据。
</dd>
<dt>pagekey</dt>
<dd>String (目前是数值). 一般某次查询不填写（如需要返回总记录数即total字段，则应填写为0），而下次查询时应根据上次调用时返回数据的&quot;nextkey&quot;字段来填写。
</dd>
<dt>page/rows</dt>
<dd>为支持jquery-easyui而设置, 与pagekey/pagesz类似, 区别在于: 每次均返回total字段; 强制采用&quot;limit&quot;算法(默认如果没有用非主键排序,会采用&quot;部分查询&quot;算法), 意味着nextkey即下一页页码.
</dd>
</dl>
<p><strong>[返回值]</strong></p>
<dl>
<dt>nextkey</dt>
<dd>String. 一个字符串, 供取下一页时填写参数&quot;pagekey&quot;. 如果不存在该字段，则说明已经是最后一批数据。
</dd>
<dt>total</dt>
<dd>Integer. 返回总记录数，仅当pagekey指定为0时返回。
</dd>
<dt>h/d</dt>
<dd>实际数据表的头信息(header)和数据行(data)，符合table对象的格式，参考上一章节tbl(id,name)介绍。
</dd>
</dl>
<p><strong>[示例]</strong></p>
<p>第一次查询</p>
<pre><code>Ordr.query()</code></pre>
<p>返回</p>
<pre><code>{nextkey: 10800910, h: [id, ...], data: [...]}</code></pre>
<p>其中的nextkey将供下次查询时填写pagekey字段；首次查询还会返回total字段。由于缺省页大小为20，所以可估计总共有51/20=3页。</p>
<p>要在首次查询时返回总记录数，则用pagekey=0：</p>
<pre><code>Ordr.query(pagekey=0)</code></pre>
<p>这时返回</p>
<pre><code>{nextkey: 10800910, total: 51, h: [id, ...], data: [...]}</code></pre>
<p>第二次查询(下一页)</p>
<pre><code>Ordr.query(pagekey=10800910)</code></pre>
<p>返回</p>
<pre><code>{nextkey: 10800931, h: [...], d: [...]}</code></pre>
<p>仍返回nextkey字段说明还可以继续查询，</p>
<p>再查询下一页</p>
<pre><code>Ordr.query(pagekey=10800931)</code></pre>
<p>返回</p>
<pre><code>{h: [...], d: [...]}</code></pre>
<p>返回数据中不带&quot;nextkey&quot;属性，表示所有数据获取完毕。</p>
<h4 id="分页机制实现原理"><span class="header-section-number">3.1.3</span> 分页机制实现原理</h4>
<p>分页有两种实现方式：分段查询和传统分页。</p>
<p>分段查询性能高，更精确，不会丢失数据。但它仅适用于未指定排序字段（无orderby参数）或排序字段是id的情况（例如：orderby=&quot;id DESC&quot;）。 系统将根据orderby参数自动选择分段查询或传统分页。</p>
<p><strong>[分段查询]</strong></p>
<p>分段查询的原理是利用主键id进行查询条件控制（自动修改WHERE语句），pagekey字段实际是上次数据的最后一个id.</p>
<p>首次查询：</p>
<pre><code>Ordr.query()</code></pre>
<p>SQL样例如下：</p>
<pre><code>SELECT * FROM Ordr t0
...
ORDER BY t0.id
LIMIT {pagesz}</code></pre>
<p>再次查询</p>
<pre><code>Ordr.query(pagekey=10800910)</code></pre>
<p>SQL样例如下：</p>
<pre><code>SELECT * FROM Ordr t0
...
WHERE t0.id&gt;10800910
ORDER BY t0.id
LIMIT {pagesz}</code></pre>
<p><strong>[传统分页]</strong></p>
<p>传统分页只需要通过SQL语句的LIMIT关键字来实现。pagekey字段实际是页码。其原理是：</p>
<p>首次查询</p>
<pre><code>Ordr.query(orderby=&quot;comeTm DESC&quot;)</code></pre>
<p>（以comeTm作为排序字段，无法应用分段查询机制，只能使用传统分页。）</p>
<p>SQL样例如下：</p>
<pre><code>SELECT * FROM Ordr t0
...
ORDER BY comeTm DESC, t0.id
LIMIT 0,{pagesz}</code></pre>
<p>再次查询</p>
<pre><code>Ordr.query(pagekey=2)</code></pre>
<p>SQL样例如下：</p>
<pre><code>SELECT * FROM Ordr t0
...
ORDER BY comeTm DESC, t0.id
LIMIT ({pagekey}-1)*{pagesz}, {pagesz}</code></pre>
<h4 id="https服务"><span class="header-section-number">3.1.4</span> HTTPS服务</h4>
<p>服务端支持HTTPS服务。客户端默认应使用HTTP协议与服务器通信；对于个别敏感的API，如涉及用户密码的登录、注册、修改密码等操作，应使用HTTPS协议进行通信。</p>
<p>注意：</p>
<ul>
<li>服务器ssl证书如果采用自签证书，在浏览器中基本无法直接访问。必须使用经过认证的ssl证书。</li>
</ul>
<h4 id="调试等级_debug"><span class="header-section-number">3.1.5</span> 调试等级(_debug)</h4>
<p>在服务端配置为测试模式时，可用特殊的URL参数&quot;_debug&quot;定义调试等级, 默认为0. 如果为1-9的数字, 将添加调试信息到结果数组中.</p>
<p>_debug=9: 输出SQL</p>
<p>通过设置环境变量P_DEBUG, 可以让本系统使用的测试工具(如client.php及rtest.php)请求时指定调试等级. 如:</p>
<pre><code>set P_DEBUG=9
client.php callsvr usercar.query</code></pre>
<h4 id="应用标识_app"><span class="header-section-number">3.1.6</span> 应用标识(_app)</h4>
<p>特殊的URL参数&quot;_app&quot;用于定义当前应用. 缺省值为&quot;user&quot;(对应客户端应用). 注意: 每个请求都必须带此标识, 它决定session对应的cookie项的名字. 如果不加该参数, 则可能出现未预料的错误.</p>
<p>常用应用标识如下:</p>
<dl>
<dt>user</dt>
<dd>缺省值. 一般为用户端。
</dd>
<dt>emp</dt>
<dd>员工端。
</dd>
<dt>admin</dt>
<dd>超级管理端。开发者或IT管理员使用。
</dd>
</dl>
<p>由于不同应用(如客户端, 商户端与管理端)共用一个api.php页面, 当在同一浏览器中打开多个应用时可能相互影响, 比如商户端与管理端同时使用时, 商户端会自动以管理端的权限操作.</p>
<p>解决方法是, 为不同应用使用不同的sessionId以区分. 实现时有两种方式, 一是访问不同的服务端页面, 如商户端访问api.php, 管理端访问api0.php(其中指定一个不同的sessionId); 另一种是商户端所有的请求都带一个参数指定sessionId. 我们将采用后一种解决方法.</p>
<p>URL参数_app可用于指定所属应用, 如不指定默认值为&quot;user&quot;. 它隐含着session的名称为&quot;{_app}id&quot;如请求</p>
<pre><code>GET /api.php?_app=emp</code></pre>
<p>第一次访问将返回</p>
<pre><code>SetCookie: empid=xxxxxx</code></pre>
<h4 id="使用path_info模式的url"><span class="header-section-number">3.1.7</span> 使用PATH_INFO模式的URL</h4>
<p>以下URL等价：</p>
<pre><code>http://localhost/mysvc/api.php/login?phone=137&amp;pwd=1234
-&gt;
http://localhost/mysvc/api.php?ac=login&amp;phone=137&amp;pwd=1234</code></pre>
<p>对于对象的CRUD，URL像这样：</p>
<pre><code>http://localhost/mysvc/api.php/Ordr.query?res=id,dscr
-&gt;
http://localhost/mysvc/api.php?ac=Ordr.query&amp;res=id,dscr</code></pre>
<h4 id="客户端版本_ver"><span class="header-section-number">3.1.8</span> 客户端版本(_ver)</h4>
<p>URL参数&quot;_ver&quot;值为客户端版本。取值参考表ApiLog.ver字段。目前只有安卓客户端设置该参数为&quot;a/{ver}&quot; (如&quot;a/2&quot;), 其它客户端版本根据userAgent自动获取。</p>
<h4 id="权限说明"><span class="header-section-number">3.1.9</span> 权限说明</h4>
<p>要访问每个API，必须定义相应的权限。权限中包括登录类型一般用AUTH_XXX表示，一般权限用PERM_XXX表示。</p>
<ul>
<li>AUTH_GUEST: 任何人可用, 无权限限制。不用登录即可查看商户, 天气等.</li>
<li>AUTH_USER: 用户登录后可用. 可做下单, 查看订单等操作.</li>
<li>AUTH_EMP: 员工登录后，查看订单以及操作自己的订单.</li>
<li>AUTH_ADMIN: 可操作一切对象. 一般由程序内部使用。</li>
<li>AUTH_PARTNER: 用于系统集成的权限验证。不用登录（相当于AUTH_GUEST），但调用每个API时必须提供_pwd/_sign参数之一供验证。</li>
</ul>
<p>员工登录后可能获得以下一个或多个权限： - PERM_MGR: 操作商户的所有内容, 包括订单, 物料, 员工等(但不能设置员工权限).</p>
<p>其它权限: - PERM_TEST_MODE: 测试模式下可用。 - PERM_MOCK_MODE: 模拟模式下可用。</p>
<h3 id="通用对象接口"><span class="header-section-number">3.2</span> 通用对象接口</h3>
<p>以下接口提供对象的基本增删改查(CRUD)以及列表查询、统计分析、导出等服务，为通用对象接口原型，在设计时应以此为基础形式，再按业务逻辑定义专用接口，描述权限和业务逻辑等。 下面用Obj代指对象实际名称。</p>
<pre><code>添加：
Obj.add()(POST fields...) -&gt; id
Obj.add(res?)(POST fields...) -&gt; {fields...} (由res指定)

更新：
Obj.set(id)(POST fields...)

获取：
Obj.get(id, res?) -&gt; {fields...}

删除：
Obj.del(id, force?)

查询列表(默认压缩表格式)：
Obj.query(res?, cond?, distinct?=0, pagesz?=20, pagekey?, fmt?) -&gt; tbl(fields...) = {nextkey?, total?, @h, @d}

查询列表 - 对象列表格式：
Obj.query(fmt=list, ...) -&gt; {nextkey?, total?, @list=[obj1, obj2...]}

后端内部查询支持以下额外参数：@res2?, join?, @cond2?, union?, subobj

分组统计：
Obj.query(gres, pivot?, pivotCnt?...) -&gt; tbl(fields...)

导出文件：
Obj.query(fmt=csv/txt/excel, fname?...) -&gt; 文件内容

批量更新：
Obj.setIf(cond)(POST fields...)

批量删除：
Obj.delIf(cond)

批量添加(导入):
Obj.batchAdd(title?)(数据或文件)</code></pre>
<p>缺省这些操作只对超级管理员角色开放，其他角色默认无权操作。超级管理员可对所有对象的所有字段操作。</p>
<p>对象是否开放出来，或是开放哪些操作及字段，一般按用户角色进行权限控制，如用户登录后可操作某些对象，或员工登录后可操作另一些对象，请查阅设计文档中相应的专用接口定义。 在专用接口定义中应描述允许的角色、允许的操作类型(如只能get/set,不能add/del)、只读字段、隐藏字段等，以及应实现的业务逻辑。</p>
<p>系统中的表设计(表名, 字段等)参见&quot;数据库设计&quot;章节. 一般表都设计为使用整形字段id作为主键. 该字段创建后变只读, 不允许被修改.</p>
<p>对于add操作，默认返回id, 如果想多返回其它字段，可设置res参数，如</p>
<pre><code>Ordr.add()(status=&quot;CR&quot;, total=100) -&gt; 809
Ordr.add(res=&quot;id,status,total&quot;)(status=&quot;CR&quot;, total=100) -&gt; {id: 810, status:&quot;CR&quot;, total: 100}</code></pre>
<h4 id="通用查询导出与分组统计"><span class="header-section-number">3.2.1</span> 通用查询、导出与分组统计</h4>
<p>query可以用参数cond指定查询条件, 如</p>
<pre><code>cond=&quot;type=&#39;A&#39; and name like &#39;%hello%&#39;&quot; 

URL编码后为

cond=type%3d%27A%27+and+name+like+%27%25hello%25%27</code></pre>
<p>query返回支持多种形式, 缺省返回压缩表类型如：</p>
<pre><code>{
    &quot;h&quot;: [&quot;id&quot;, &quot;name&quot;],
    &quot;d&quot;: [[1, &quot;liang&quot;], [2, &quot;wang&quot;]]
}</code></pre>
<p>如果指定<code>fmt=list</code>则返回:</p>
<pre><code>{
    &quot;list&quot;: [{&quot;id&quot;: 1, &quot;name&quot;: &quot;liang&quot;}, {&quot;id&quot;: 2, &quot;name&quot;: &quot;wang&quot;}]
}</code></pre>
<p>注意:</p>
<ul>
<li>对于add/set方法, 使用HTTP POST请求; fields表示表中每个字段的key-value值, 通过POST字段传递(使用URL编码). set方法中的id字段通过URL传递.</li>
<li>对于set操作, 如果要将某字段置空, 可以用空串或&quot;null&quot; (小写). 如&quot;picId=&quot;或&quot;picId=null&quot;; 除了用在set操作的POST内容中，其它情况下字段设置为空串相当于没有设置该字段。</li>
<li>对于set操作，如果要将某字符串类型字段置空串(不建议使用)，可以用&quot;empty&quot;, 如&quot;sn=empty&quot;。但如果对数值等其它类型设置，会导致其值为0或0.0。</li>
<li>权限管理. 客户端或商户端可读写哪些对象详见其它章节. 管理员登录可操作所有表. 不同类型的登录进行的访问控制和返回结果是不一样的, 比如管理端登录没有任何限制和自动补全. 如果管理端, 客户端和商户端同时登录(使用同一session), 则管理端逻辑优先, 其次是客户端, 最后是商户端. (TODO: 商户端和客户端共用session可能会有冲突)</li>
<li class="todo">TODO: 如果有metadata, 后台可检查字段是否存在, 是否只读等.</li>
</ul>
<p><strong>[分页]</strong></p>
<dl>
<dt>pagesz</dt>
<dd>Integer. 指定页大小, 默认一次返回20条数据。
</dd>
<dt>pagekey</dt>
<dd>String. 指定从哪条数据开始，应根据上次调用时返回数据的&quot;nextkey&quot;字段来填写。
</dd>
</dl>
<p>分页只适用于query接口，详细请参考章节&quot;分页机制&quot;.</p>
<p><strong>[参数]</strong></p>
<dl>
<dt>fields</dt>
<dd>每个字段及其值.
</dd>
<dt>res, cond (get/query方法), orderby(query方法)</dt>
<dd>String. 指定返回字段及查询条件, 例如, res=&quot;field1,field2&quot;, cond=&quot;field1&gt;100 AND field2='hello'&quot;, orderby=&quot;id desc&quot;, 注意使用UTF8+URL编码, 目前格式参照SQL语法, 字符串值应加上单引号. 字段前不可加表名或别名(alias)，如&quot;t0.id&quot;; 在res中允许使用函数&quot;sum&quot;与&quot;count&quot;, 这时必须指定字段别名, 如&quot;count(id) cnt&quot;
</dd>
</dl>
<p>特别地，res支持枚举列表，即自动将枚举值转化为可读字符串，例如<code>res=id 编号,status 状态=CR:创建;PA:已付款</code>，这样返回的status字段会自动转换成相应的值。</p>
<dl>
<dt>distinct</dt>
<dd>Boolean. 如果为1, 生成&quot;SELECT DISTINCT ...&quot;查询.
</dd>
</dl>
<p><strong>[限程序内使用的参数]</strong></p>
<dl>
<dt>res2, join, cond2 (get/query方法)</dt>
<dd>这几个字段只由内部使用，没有安全限制. res2, cond2为额外的字段及条件, 必须为数组; join可以为字符串或字符串数组.注意增加join表后, 指定主表字段时最好加上主表的固定别名&quot;t0&quot;. 例如 res2=[&quot;b.name AS brandName&quot;, &quot;s.name as storeName&quot;], join=&quot;INNER JOIN CarBrand b ON b.id=t0.brandId&quot;, cond2=[&quot;t0.field1=100 and b.id IN (1,2,3)&quot;]
</dd>
<dt>subobj</dt>
<dd><p>目前仅限后端内部使用, 要求主对象必须有id字段(未指定res/res2参数或其中有id字段). 格式为数组, 每行指定一个子对象的查询, 每行格式为: {sql, wantOne?}. &quot;sql&quot;指定查询语句, 其中用&quot;%d&quot;表示主表id; &quot;wantOne&quot;表示返回对象而非对象集合(数组), 缺少是对象集合. 例:</p>
<p>$_REQUEST[&quot;subobj&quot;] = [ &quot;items&quot; =&gt; [&quot;sql&quot;=&gt;&quot;SELECT * FROM OrderItem WHERE orderId=%d&quot;, &quot;wantOne&quot;=&gt;false]];</p>
</dd>
<dt>union</dt>
<dd>仅限后端内部使用. 指定union查询内容, 该内容将会在以下位置影响SQL查询: &quot;SELECT ... FROM .. WHERE ... { UNION ... } ORDER BY ...&quot;. 注意: union的结果与res参数中字段指定必须匹配; where条件必须在union中自行指定, 不可通过cond/cond2参数; orderby参数可应用到union后的最终结果.
</dd>
</dl>
<p>对res, cond, orderby的安全限制：</p>
<ul>
<li>res, orderby只能是字段（或虚拟字段）列表，不能出现函数、子查询等，作为例外，res中可以用sum/count函数，如&quot;count(*) cnt&quot;。</li>
<li>cond不允许子查询（不可以有select等关键字）。</li>
</ul>
<p><strong>[导出文件]</strong></p>
<dl>
<dt>fmt</dt>
<dd>Enum(csv,txt,excel). 导出Query的内容为指定格式。其中，csv为逗号分隔UTF8编码文本；txt为制表分隔的UTF8文本；excel为逗号分隔的gb2312编码文本（因为默认excel打开Csv文件时不支持utf8编码）。注意，由于默认会有分页，要想导出所有数据，一般可指定pagesz=9999。
</dd>
<dt>fname</dt>
<dd>String. 导出文件名。默认为对象名。
</dd>
</dl>
<p><strong>[分组统计]</strong></p>
<dl>
<dt>gres</dt>
<dd>String. 用于groupby的字段列表。如果使用了gres字段，则res参数中每项应该带统计函数，如&quot;sum(cnt) sum, count(id) userCnt&quot;. 最终返回列数=gres参数指定的列+res参数指定的列; 如果res参数未指定，则默认值不再是&quot;*&quot;, 而是空（即只返回gres字段指定内容）。
</dd>
</dl>
<p>例：统计2015年2月，按状态分类（如已付款、已评价、已取消等）的各类订单的总数和总金额。</p>
<pre><code>Ordr.query(gres=&quot;status&quot;, res=&quot;count(&#39;A&#39;) totalCnt, sum(amount) totalAmount&quot;, cond=&quot;tm&gt;=&#39;2016-1-1&#39; and tm&lt;&#39;2016-2-1&#39;&quot;)</code></pre>
<p>返回内容示例：</p>
<pre><code>[
    h: [&quot;status&quot;, &quot;totalCnt&quot;, &quot;totalAmount&quot;],
    d: [
        [ &quot;PA&quot;, 130, 1420 ],  // 已付款，共130单，1420元
        [ &quot;CA&quot;, 29, 310 ], // 取消的订单
        [ &quot;RA&quot;, 1530, 15580 ], // 已评价的订单
    ]
]</code></pre>
<dl>
<dt>pivot</dt>
<dd>String. 指定转置列，将行值显示到列中。
</dd>
<dt>pivotCnt</dt>
<dd>Integer. 指定统计列的个数。默认值为1，即最后一列为统计列，若想最后两列为统计列，可设置pivotCnt=2。
</dd>
</dl>
<p>例：统计2015年2月，按状态分类（如已付款、已评价、已取消等）的各类订单的总金额，并将状态转置到列上。</p>
<pre><code>Ordr.query(gres=&quot;status&quot;, res=&quot;sum(amount) totalAmount&quot;, cond=&quot;tm&gt;=&#39;2016-1-1&#39; and tm&lt;&#39;2016-2-1&#39;&quot;, pivot: &quot;status&quot;)</code></pre>
<p>返回内容示例：</p>
<pre><code>[
    h: [&quot;PA&quot;, &quot;CA&quot;, &quot;RA&quot;],
    d: [
        [ 1420, 310, 15580 ]
    ]
]</code></pre>
<p>例：统计2015年2月，按状态分类（如已付款、已评价、已取消等）的各类订单的总数和总金额(两个统计列)，并将状态转置到列上。</p>
<pre><code>Ordr.query(gres=&quot;status&quot;, res=&quot;count(&#39;A&#39;) totalCnt, sum(amount) totalAmount&quot;, cond=&quot;tm&gt;=&#39;2016-1-1&#39; and tm&lt;&#39;2016-2-1&#39;&quot;, pivot: &quot;status&quot;, pivotCnt: 2)</code></pre>
<p>返回内容示例：</p>
<pre><code>[
    h: [&quot;PA&quot;, &quot;CA&quot;, &quot;RA&quot;],
    d: [
        [ [130, 1420], [29, 310], [1530, 15580] ]
    ]
]</code></pre>
<p><strong>[操作特殊属性flags和props]</strong></p>
<p>flags为单字母表示的标志位集合，如&quot;vg&quot;；props可以以多字母表示标志位，中间以空格分隔，如&quot;suv mpv&quot;. 一般flags由应用内部定义；而props扩展性更强。</p>
<p>query操作支持形如<code>flag_{flag}</code>或<code>prop_{prog}</code>的虚拟属性。</p>
<ul>
<li><code>flag_f=1</code> 相当于 <code>flags LIKE '%f%'</code></li>
<li><code>flag_f=0</code> 相当于 <code>flags IS NULL OR flags NOT LIKE '%f%'</code></li>
</ul>
<p>get/query操作中如果返回了flags/props，还会返回相应的虚拟属性；例如flags值为&quot;vg&quot;，则多返回虚拟属性<code>flag_v=1</code>及<code>flag_g=1</code></p>
<p>set操作支持以下方式设置flags/props属性：</p>
<ul>
<li><code>flag_f=1</code> 相当于 <code>set flags=concat(ifnull(flags, ''), 'f')</code></li>
<li><code>flag_f=0</code> 相当于 <code>set flags=replace(flags, 'f', '')</code></li>
</ul>
<p>注意：</p>
<ul>
<li>flag/prop的值只能为0/1</li>
<li class="todo">TODO: props属性类似。</li>
<li class="todo">TODO: flags/props应区分大小写(设置属性collation: utf8_bin)</li>
</ul>
<p><strong>[例: 添加商户]</strong></p>
<p>添加商户, 指定一些字段:</p>
<pre><code>Store.add()
    name=华莹汽车(张江店)
    addr=金科路88号
    tel=021-12345678</code></pre>
<p>注:</p>
<ul>
<li><p>Store是商户表名, 通过POST字段传递各字段内容. HTTP POST请求如下所示(实际发送时, 每个字段的值应使用UTF8+URL编码, 示例中未进行编码):</p>
<pre><code>POST /api.php/Store.add
Content-Type: application/x-www-form-urlencoded

name=华莹汽车(张江店)&amp;addr=金科路88号&amp;tel=021-12345678</code></pre></li>
<li><p>id这种主键或只读字段无须设置. 即使设置也应被忽略.</p></li>
</ul>
<p>操作成功时返回id值:</p>
<pre><code>8</code></pre>
<p><strong>[例: 获取商户]</strong></p>
<p>取刚添加的商户(id=8):</p>
<pre><code>Store.get(id=8)</code></pre>
<p>操作成功时返回该行内容:</p>
<pre><code>{id: 8, name: &quot;华莹汽车(张江店)&quot;, addr: &quot;金科路88号&quot;, tel: &quot;021-12345678&quot;, opentime: null, dscr: null}</code></pre>
<p>可以像query方法一样用POST参数res指定返回值, 如</p>
<pre><code>Store.get(id=8
    res=id,name as storeName,addr
)</code></pre>
<p>操作成功时返回该行内容:</p>
<pre><code>{id: 8, storeName: &quot;华莹汽车(张江店)&quot;, addr: &quot;金科路88号&quot;}</code></pre>
<p><strong>[例: 查询商户]</strong></p>
<p>查询&quot;华胜汽车&quot;在&quot;浦东&quot;的门店, 即查询名称含有&quot;华胜汽车&quot;且地址中含有&quot;浦东&quot;的商户, 只返回id, name, addr字段:</p>
<pre><code>Store.query()
    res=id,name,addr
    cond=name like &#39;%华胜%&#39; and addr like &#39;%浦东%&#39;</code></pre>
<p>操作成功时返回内容如下:</p>
<pre><code>{
    &quot;h&quot;: [
        &quot;id&quot;,
        &quot;name&quot;,
        &quot;addr&quot;
    ],
    &quot;d&quot;: [
        [
            &quot;100064&quot;,
            &quot;华胜汽车（金桥店）&quot;,
            &quot;上海市浦东区金桥路2622弄59号3号门&quot;
        ]
    ]
}</code></pre>
<p><strong>[导出商户]</strong></p>
<pre><code>Store.query()
    res=id,name,addr
    fmt=excel
    pagesz=9999</code></pre>
<p>可导出gb2312编码的csv文件。使用较大的pagesz以尽量返回所有数据。</p>
<p><strong>[例: 更新商户]</strong></p>
<p>为商户设置描述信息等:</p>
<pre><code>Store.set(id=8)
    opentime=8:00-18:00
    dscr=描述信息.</code></pre>
<p>操作成功时无返回内容.</p>
<p><strong>[例: 删除商户]</strong></p>
<pre><code>Store.del(id=8)</code></pre>
<p>操作成功时无返回内容.</p>
<h4 id="批量更新与删除"><span class="header-section-number">3.2.2</span> 批量更新与删除</h4>
<pre><code>Obj.setIf/delIf</code></pre>
<p>一般使用cond参数指定查询条件，允许使用虚拟字段；也可以使用与query接口相同的其它自定义参数。</p>
<p>示例，下面query接口定义了虚拟字段storeName和非标查询参数q:</p>
<pre><code>Item.query(q?, cond?) -&gt; tbl(id, ..., storeName?)

- q: &quot;my&quot;-表示我发布的商品. 默认返回所有商品。
- storeName: 商户名，关联到Store表。</code></pre>
<p>批量更新示例：</p>
<pre><code>Item.setIf(cond: &quot;status=&#39;CR&#39;)(status=ST)
Item.setIf(cond: &quot;t0.id IN (3,5,7)&quot;)(status=ST)
Item.setIf(q:&quot;my&quot;, cond:&quot;storeName LIKE &quot;上海%&quot;)(status=ST)</code></pre>
<p>批量删除示例：</p>
<pre><code>Item.delIf(cond: &quot;status=&#39;ST&#39;)
Item.delIf(cond: &quot;t0.id IN (3,5,7)&quot;)
Item.delIf(q: &quot;my&quot;, cond:&quot;storeName LIKE &quot;上海%&quot;)</code></pre>
<h4 id="批量添加导入"><span class="header-section-number">3.2.3</span> 批量添加（导入）</h4>
<p>批量添加（导入）。返回导入记录数cnt及编号列表idList</p>
<pre><code>Obj.batchAdd(title?)(...) -&gt; {cnt, @idList}</code></pre>
<p>在一个事务中执行，一行出错后立即失败返回，该行前面已导入的内容也会被取消（回滚）。</p>
<ul>
<li>title: List(fieldName). 指定标题行(即字段列表). 如果有该参数, 则忽略POST内容或文件中的标题行. 如&quot;title=name,-,addr&quot;表示导入第一列name和第三列addr, 其中&quot;-&quot;表示忽略该列，不导入。</li>
</ul>
<p>支持两种方式上传：</p>
<ol style="list-style-type: decimal">
<li><p>直接在HTTP POST中传输内容，数据格式为：首行为标题行(即字段名列表)，之后为实际数据行。 行使用&quot;&quot;分隔, 列使用&quot;&quot;分隔. 接口为：</p>
<p>{Obj}.batchAdd(title?)(标题行，数据行) (Content-Type=text/plain)</p></li>
</ol>
<p>前端JS调用示例：</p>
<pre><code>var data = &quot;name\taddr\n&quot; + &quot;门店1\t地址1\n门店2\t地址2\n&quot;;
callSvr(&quot;Store.batchAdd&quot;, function (ret) {
    app_alert(&quot;成功导入&quot; + ret.cnt + &quot;条数据！&quot;);
}, data, {contentType:&quot;text/plain&quot;});</code></pre>
<p>或指定title参数:</p>
<pre><code>var data = &quot;门店名\t地址\n&quot; + &quot;门店1\t地址1\n门店2\t地址2\n&quot;;
callSvr(&quot;Store.batchAdd&quot;, {title: &quot;name,addr&quot;}, function (ret) {
    app_alert(&quot;成功导入&quot; + ret.cnt + &quot;条数据！&quot;);
}, data, {contentType:&quot;text/plain&quot;});</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>标准csv/txt文件上传：</li>
</ol>
<p>上传的文件首行当作标题列，如果这一行不是后台要求的标题名称，可通过URL参数title重新定义。 一般使用excel csv文件（编码一般为gbk），或txt文件（以&quot;&quot;分隔列，一般为utf-8编码）。 接口为：</p>
<pre><code>{Obj}.batchAdd(title?)(csv/txt文件)
(Content-Type=multipart/form-data, 即html form默认传文件的格式)</code></pre>
<p>后端处理时, 将自动判断文本编码(utf-8或gbk).</p>
<p>前端HTML:</p>
<pre><code>&lt;input type=&quot;file&quot; name=&quot;f&quot; accept=&quot;.csv,.txt&quot;&gt;</code></pre>
<p>前端JS示例：</p>
<pre><code>var fd = new FormData();
fd.append(&quot;file&quot;, frm.f.files[0]);
callSvr(&quot;Store.batchAdd&quot;, {title: &quot;name,addr&quot;}, function (ret) {
    app_alert(&quot;成功导入&quot; + ret.cnt + &quot;条数据！&quot;);
}, fd);</code></pre>
<h4 id="通用子表对象操作"><span class="header-section-number">3.2.4</span> 通用子表对象操作</h4>
<p>详细可参考文档 <a href="子表对象设计.html">子表对象设计</a></p>
<p>假设有主表对象Ordr，一对多关联子表对象OrderItem，数据模型如下：</p>
<pre><code>订单：
@Ordr: id, dscr, amount

物料：
@Item: id, name, price

订单明细
@OrderItem: id, orderId, itemId, itemName, price, qty, amount</code></pre>
<p><strong>[在add接口中指定子表项]</strong></p>
<pre><code>Ordr.add()(dscr, amount, @items=[{itemId, price, qty}])</code></pre>
<p>示例：</p>
<pre><code>var items = [{itemId:1, price: 200, qty: 1.0}, {itemId:2, price:100, qty:3.0}];
callSvr(&quot;Ordr.add&quot;, $.noop, {dscr: &quot;订单1&quot;, amount: 500, items: items}, {contentType:&quot;application/json&quot;});</code></pre>
<p><strong>[在get接口中返回子表]</strong></p>
<pre><code>Ordr.get(id, res_items?) -&gt; {id, ..., @items?}</code></pre>
<p>接口返回的<code>items</code>为OrderItem子表数组内容。调用示例：</p>
<pre><code>var id = 1;
callSvr(&quot;Ordr.get&quot;, {id: id, res:&quot;*,items&quot;})</code></pre>
<p>返回示例:</p>
<pre><code>{id: 1, dscr: &quot;订单1&quot;, amount: 500, items: [
    {id: 100, itemId:1, orderId:1, price:200, qty:1, itemName:&quot;item 1&quot;, amount:200},
    {id: 101, itemId:2, orderId:1, price:100, qty:3, itemName:&quot;item 2&quot;, amount:300}
]}</code></pre>
<p>我们知道通过<code>res</code>参数可指定返回项，而对于通用子表接口，通过<code>res_{子表显示名}</code>可指定子表项的返回项，在本例中，用参数<code>res_items</code>可指定子表项<code>items</code>的返回项，调用示例：</p>
<pre><code>callSvr(&quot;Ordr.get&quot;, {id: id, res:&quot;id,items&quot;, res_items:&quot;id,itemName,amount&quot;})</code></pre>
<p>返回示例：</p>
<pre><code>{id: 1, items: [
    {id: 100, itemName:&quot;item 1&quot;, amount:200},
    {id: 101, itemName:&quot;item 2&quot;, amount:300}
]}</code></pre>
<p>示例2，指定字段显示名：</p>
<pre><code>callSvr(&quot;Ordr.get&quot;, {id: id, res:&quot;id 订单编号,items 订单明细&quot;, res_订单明细:&quot;id,itemName 物料,amount 金额&quot;})</code></pre>
<p>返回示例：</p>
<pre><code>{订单编号: 1, 订单明细: [
    {id: 100, 物料:&quot;item 1&quot;, 金额:200},
    {id: 101, 物料:&quot;item 2&quot;, 金额:300}
]}</code></pre>
<p><strong>[在set接口中追加、修改、删除子表项]</strong></p>
<pre><code>Ordr.set()(..., items={id?, itemId?, price?, qty?})</code></pre>
<p>注意更新时对子项采用PATCH机制，即不必传所有子项，如果在子项中指定了id，则做更新子项操作（特别地，如果有<code>_delete</code>参数，表示删除该子项），否则做追加子项操作。</p>
<p>更新子项示例：更新<code>id=100</code>子项的，数量设置为2，同时更新子表和主表的amount字段</p>
<pre><code>callSvr(&quot;Ordr.set&quot;, {id: id}, $.noop, {items:[{id:100, qty: 2, amount: 400}], amount:700} , {contentType:&quot;application/json&quot;})</code></pre>
<p>追加子项：追加<code>{itemId:1}</code>的子项，并更新相关字段</p>
<pre><code>callSvr(&quot;Ordr.set&quot;, {id: id}, $.noop, {items:[{itemId:1, qty:2, price:50, amount:100}], amount:800} , {contentType:&quot;application/json&quot;})</code></pre>
<p>删除子项：删除<code>id=100</code>子项，指定<code>_delete</code>为1</p>
<pre><code>callSvr(&quot;Ordr.set&quot;, {id: id}, $.noop, {items:[{id:100, _delete:1}], amount:300} , {contentType:&quot;application/json&quot;})</code></pre>
<h3 id="api调用监控"><span class="header-section-number">3.3</span> API调用监控</h3>
<p>所有对API的调用（请求与响应）均记录到表ApiLog中供分析。</p>
<p>对一个session, 监控其API调用是否有异常，避免自动化操作行为，这时将返回 E_FORBIDDEN 错误。安全类异常将记录到日志文件 secure.log</p>
<p>注意： - 自动化测试时，API监控不工作（这时_test参数值为2）。 - 应避免客户端一次取多张图片时有问题</p>
<h3 id="批量请求"><span class="header-section-number">3.4</span> 批量请求</h3>
<p>BQP协议支持批量请求，即在一次请求中，包含多条调用。 在创建批量请求时，可以指定这些调用是否在一个事务(transaction)中，一起成功提交或失败回滚。</p>
<p>前端接口示例：</p>
<pre><code>var batch = new MUI.batchCall();
// var batch = new MUI.batchCall({useTrans: true}); // 使用同一事务时，可指定useTrans=true

// 调用一
var param = {res: &quot;id,name,phone&quot;};
callSvr(&quot;User.get&quot;, param, function(data) {} )

// 调用二
var postParam = {page: &quot;home&quot;, ver: &quot;android&quot;, userId: &quot;{$1.id}&quot;};
callSvr(&quot;ActionLog.add&quot;, function(data) {}, postParam, {ref: [&quot;userId&quot;]} );

batch-&gt;commit();
// batch-&gt;cancel();</code></pre>
<p>还有一种方式更简单：</p>
<pre><code>MUI.useBatchCall(); // 在本次消息循环中执行所有的callSvr都加入批处理。
// MUI.useBatchCall({useTrans:1}, 20); // 表示20ms内所有callSvr都加入批处理, 且启用事务。
callSvr(...);
callSvr(...);
callSvr(..., {noBatch: 1}); // TODO:使用noBatch参数可以强制单独执行，不加入批处理。</code></pre>
<p>其中，调用二中参数userId引用了调用一的返回结果，通过在callSvr后指定参数ref标明。userId的值&quot;{<span class="math inline">$1.id}&quot;表示取第一次调用值的id属性。 注意：引用表达式应以&quot;{}&quot;包起来，&quot;$</span>n&quot;中n可以为正数或负数（但不能为0），表示对第n次或前n次调用结果的引用，以下为可能的格式：</p>
<pre><code>    &quot;{$1}&quot;
    &quot;id={$1.id}&quot;
    &quot;{$-1.d[0][0]}&quot;
    &quot;id in ({$1}, {$2})&quot;
    &quot;diff={$-2 - $-1}&quot;</code></pre>
<p>花括号中的内容将用计算后的结果替换。如果表达式非法，将使用&quot;null&quot;值替代。</p>
<p>数据传输格式:</p>
<p>提交使用JSON格式，示例如下</p>
<pre><code>POST api/batch

[
    {
        &quot;ac&quot;: &quot;User.get&quot;,
        &quot;get&quot;: {&quot;res&quot;: &quot;name,phone&quot;}
    },
    {
        &quot;ac&quot;: &quot;ActionLog.add&quot;,
        &quot;post&quot;: {&quot;page&quot;: &quot;home&quot;, &quot;ver&quot;: &quot;android&quot;, &quot;userId&quot;: &quot;{$-1.id}&quot;},
        &quot;ref&quot;: [&quot;userId&quot;]
    }
]</code></pre>
<p>数组中每一项为一个调用，其格式为: {ac, %get?, %post?, <span class="citation">@ref</span>?}, 只有ac参数必须，其它均可省略。</p>
<dl>
<dt>get</dt>
<dd>URL请求参数。
</dd>
<dt>post</dt>
<dd>POST请求参数。
</dd>
<dt>ref</dt>
<dd>使用了batch引用的参数列表。
</dd>
</dl>
<p>如果使用事务，只是URL上加个参数：</p>
<pre><code>POST api/batch?useTrans=1</code></pre>
<p>batch的返回内容是多条调用返回内容组成的数组，样例如下：</p>
<pre><code>[0, [
    [ 0, {id: 1, name: &quot;用户1&quot;, phone: &quot;13712345678&quot;} ],  // 调用User.get的返回结果
    [ 0, &quot;OK&quot; ]  // 调用ActionLog.add的返回结果
]]</code></pre>
<h3 id="服务端信息反馈x-daca头"><span class="header-section-number">3.5</span> 服务端信息反馈/X-Daca头</h3>
<p>BQP协议规定，以下服务端信息应通过HTTP头反馈给客户端。</p>
<p>服务端API版本号如果可以获取，应发送给客户端:</p>
<pre><code>X-Daca-Server-Rev: {value}</code></pre>
<p>其中value为最多6位的字符串。</p>
<p>如果服务运行于测试模式或模拟模式，应设置：</p>
<pre><code>X-Daca-Test-Mode: {value}
X-Daca-Mock-Mode: {value}</code></pre>
<p>其中value为非0，一般为1.</p>
<h2 id="前端应用接口"><span class="header-section-number">4</span> 前端应用接口</h2>
<p>在完整的APP设计文档中，应包括对前端应用接口的描述。</p>
<p>每一个筋斗云前端应用均应定义一个唯一的应用标识(app)，如&quot;emp&quot;, &quot;emp-store&quot;等。在调用交互接口时，框架会自动将应用标识作为参数传给后端。 应用标识中的主干部分称为应用类型(app type)，例如应用&quot;emp&quot;, &quot;emp-store&quot;, &quot;emp2&quot;的主干（字符&quot;-&quot;之前的部分，不包括尾部数字），都是相同的应用类型&quot;emp&quot;。 应用类型常用于登录类型与权限控制。</p>
<p>例如，定义客户端应用标识app=user，其应用类型也是&quot;user&quot;，在login交互接口中，对应用类型&quot;user&quot;将作用户登录处理（如查询用户表），登录成功后赋予其用户权限。 定义员工端应用标识为app=emp，它的应用类型是&quot;emp&quot;，在后端将作员工登录处理（比如查询的是员工表），登录成功后赋予其员工权限。 定义管理端应用app=emp-adm，它与应用emp-store是相同类型，因而登录方式和权限是相同的，即应使用员工信息登录。</p>
<p>可见，不同的应用可以是相同的应用类型。在实现交互接口时，不同的应用标识也会使用不同的cookie名称，以避免多个应用同时使用时相互干扰。</p>
<p>下面以筋斗云前端示例应用为例，介绍常见的前端应用接口描述方式。</p>
<h3 id="移动端应用"><span class="header-section-number">4.1</span> 移动端应用</h3>
<p>筋斗云的移动应用可做为Web应用在浏览器中运行, 也可以接入微信公众号或支付宝服务窗, 也可以通过cordova框架包装在应用容器中提供android/ios应用程序.</p>
<p>移动端应用按惯例放在m2目录下。以用户端为例，其相关文件有：</p>
<p>客户端：</p>
<ul>
<li>index.html/index.js 客户端应用的UI框架及通用逻辑，js文件中包含多个页面共享的全局函数、全局变量等。</li>
<li>index.css 客户端应用全局样式。</li>
<li>page/{xx}.html, page/{xx}.js 每个逻辑页面的UI和逻辑。页面私有的样式可以内嵌在html页面中。</li>
</ul>
<p>此外还有文件：</p>
<ul>
<li>app.js 所有移动应用共享的全局对象</li>
<li>app.css 所有移动应用共享的全局样式</li>
</ul>
<p>移动应用的对外接口包括页面URL，允许的入口页面(entry)，URL参数等。下面举例说明前端应用接口的描述方式：</p>
<h4 id="客户端appuser"><span class="header-section-number">4.1.1</span> 客户端(app=user)</h4>
<p>URL地址：</p>
<pre><code>m2/index.html</code></pre>
<p>应用标识为&quot;user&quot;。</p>
<p><strong>[进入移动客户端并显示指定订单]</strong></p>
<pre><code>m2/index.html#order(orderId)</code></pre>
<p>这表示可以请求这样的URL:</p>
<pre><code>m2/index.html?orderId=32#order</code></pre>
<p>其中: m2/index.html是页面地址, &quot;?&quot;后为参数(使用URL编码方式), &quot;#&quot;后为入口点, 表示允许进入的逻辑页面.</p>
<p>上例中的访问表示: 打开移动客户端的订单页面, 参数为orderId=32, 即显示32号订单.</p>
<h3 id="桌面应用"><span class="header-section-number">4.2</span> 桌面应用</h3>
<p>桌面应用按惯例放在web目录下。其常用文件与移动应用类似，以管理端应用为例：</p>
<ul>
<li>store.html 管理端应用。按需可拆分出 store.js, store.css等文件。</li>
<li>app.js / style.css 所有桌面应用共享的逻辑与全局样式。</li>
</ul>
<p>常见的桌面应用示例如下。</p>
<h4 id="管理端应用appemp-adm"><span class="header-section-number">4.2.1</span> 管理端应用(app=emp-adm)</h4>
<p>一般由商户员工使用，管理员工、订单等：</p>
<pre><code>web/store.html</code></pre>
<p>该应用的应用标识定义为&quot;emp-adm&quot;，它与员工端(emp-store)的应用类型是相同的，都是&quot;emp&quot;, 因而都用员工信息进行登录。</p>
<h4 id="超级管理端应用appadmin"><span class="header-section-number">4.2.2</span> 超级管理端应用(app=admin)</h4>
<p>一般由超级管理员使用，甚至可执行SQL语句：</p>
<pre><code>web/adm.html</code></pre>
<p>该应用的应用标识定义为&quot;admin&quot;，使用超级管理员帐号登录。注意：超级管理员帐号在用户配置文件<code>conf.user.php</code>中由<code>P_ADMIN_CRED</code>环境变量设定。</p>
<h4 id="桌面应用查询用法"><span class="header-section-number">4.2.3</span> 桌面应用查询用法</h4>
<p>在查找对象的对话框中，可支持多种灵活的匹配方式：</p>
<p>例如对字段a, 填写以下值：</p>
<ul>
<li><code>hello</code> (匹配) - 生成查询条件 <code>a='hello'</code></li>
<li><code>100</code> (纯数字匹配) - 生成 <code>a=100</code></li>
<li><code>*28*</code> 或 <code>%28%</code> (部分匹配) - 生成<code>a like '%28%'</code></li>
<li><code>&gt;100</code> / <code>&gt;=100</code> / <code>&lt;100</code> / <code>&lt;=100</code> / <code>&lt;&gt;100</code> - 生成 <code>a&gt;100</code>等</li>
<li><code>null</code> / <code>&lt;&gt;null</code> - 生成 <code>a is null</code> / <code>a is not null</code></li>
<li><code>empty</code> / <code>&lt;&gt;empty</code> - 生成 <code>a=''</code> / <code>a&lt;&gt;''</code></li>
<li>逗号表示or查询，如 <code>null,0,1</code>表示<code>a is null or a=0 or a=1</code></li>
<li>数值支持<code>a-b</code>方式指定范围，如<code>1-10,20-30,40</code>, 表示<code>(a&gt;=1 and a&lt;=10) or (a&gt;=20 and a&lt;=30) or a=40</code></li>
<li>支持and/or查询，如 <code>&gt;=100 and &lt;200</code>, <code>null or 0 or 1</code>, <code>1-100 and &lt;&gt;50</code>，不支持用括号组合条件。</li>
</ul>
<p>如果同时对多个字段填写了搜索值，则表示这些条件需要同时满足，即<code>AND</code>关系。</p>
<p>详细可参考文档 <a href="api_web.html#getQueryCond">API参考 -&gt; 筋斗云前端(桌面Web版) -&gt; WUI.getQueryCond</a></p>
<h4 id="通用参数"><span class="header-section-number">4.2.4</span> 通用参数</h4>
<p>移动应用和桌面应用的框架支持以下通用参数：</p>
<dl>
<dt>_debug?=0</dt>
<dd>Integer. 设置本次调用的服务端调试等级. 调试信息可在调用交互接口的返回内容中查看(返回内容的第三项): [code, ret, debugInfo]. 常用值：0-无额外信息; 1-基本信息, 9-所有信息, 包含数据库查询语句.
</dd>
</dl>
<p>以下参数适用于移动应用：</p>
<dl>
<dt>cordova?=0</dt>
<dd>Integer. 0表示普通Web应用. 当网页通过[应用容器]以原生android/ios应用方式运行时, 值为非0, 表示容器的版本号.
</dd>
</dl>
<p>注意: 一旦设置为非0, 则该值会被记住, 下次打开时即使未指定也会有值, 必须重新设置cordova=0清除(或在控制台中调用delStorage(&quot;cordova&quot;)).</p>
<p>以下参数适用于桌面应用：</p>
<dl>
<dt>autoLogin</dt>
<dd>Boolean. 如果为1, 则记住登录token, 下次打开时可以自动登录.
</dd>
</dl>
<h4 id="全局变量"><span class="header-section-number">4.2.5</span> 全局变量</h4>
<p>移动应用和桌面应用使用以下JS全局变量：</p>
<dl>
<dt>g_args</dt>
<dd>Object. 应用打开时的URL参数. 由框架自动设置.
</dd>
<dt>g_data</dt>
<dd>Object. 通用全局变量, 存储各项配置或应用数据. 常用项为userInfo, 表示登录后获取的用户信息.
</dd>
<dt>g_cfg</dt>
<dd>Object. 全局配置。
</dd>
</dl>
<p>以上变量可通过控制台手工调节部分参数.</p>
<h4 id="管理端用法技巧"><span class="header-section-number">4.2.6</span> 管理端用法技巧</h4>
<ul>
<li>查询对话框：要模糊查询，应使用通配符“<em>”，如“上海</em>”；更多的查询用法，可将鼠标停留在查询框上查看。</li>
<li>快速查询：表格中双击一行可以打开明细对话框，在字段标题上三击可快速查询。</li>
<li>清空查询条件：按住Ctrl键点击列表页上的“刷新”按钮，可清除之前的查询条件并显示所有数据。</li>
<li>批量修改或删除：在表格中，可按Ctrl或Shift多选行，之后可以批量修改或删除。</li>
<li>全部修改或删除：按住Ctrl键点“删除”按钮为全部删除；在对话框上修改字段后，按住Ctrl键点确定为全部修改。</li>
</ul>
<p>注：在Mac OS中一般用Command键替代Ctrl键。</p>
<p>其它隐含用法（一般用于调试）：</p>
<ul>
<li>TAB页面标题点击5次：重新加载当前页面和所有对话框。</li>
<li>下拉列表框双击：可立即刷新数据。</li>
<li>Ctrl-导出: 可选择导出格式。</li>
</ul>
<h2 id="测试设计"><span class="header-section-number">5</span> 测试设计</h2>
<p><strong>[测试需求]</strong></p>
<ul>
<li>对每个WebAPI及其集成业务场景有自动化回归测试(rtest - regression test)</li>
<li>提供工具可对每个API进行手工测试(test tool)</li>
<li>部分类提供单元测试(UT - unit test)</li>
<li>服务器提供测试模式，支持数据库清除等特殊操作。</li>
</ul>
<p>所有测试内容存放在<code>rtest</code>目录下。</p>
<p>环境变量&quot;SVC_URL&quot;可设置使用的URL, 如</p>
<pre><code>&gt; set SVC_URL=http://115.29.199.210/mysvc
&gt; run_rtest.pl all</code></pre>
<h3 id="手工测试"><span class="header-section-number">5.1</span> 手工测试</h3>
<p>除可通过浏览器(如Chrome插件Postman)等工具进行测试外，还提供client.php工具，可分别测试每个API，如</p>
<pre><code>&gt; client.php queryseries 100</code></pre>
<p>也可直接调用callsvr方法调用任意api, 例如以下调用等价于前面例子:</p>
<pre><code>&gt; client.php callsvr queryseries brandId=100</code></pre>
<p>再如通用的对表的查询: 格式<code>callsvr command [paramstr] [poststr]</code>, 其中<code>paramstr</code>和<code>poststr</code>应使用URL编码.</p>
<pre><code>(get item with id)
&gt; client.php callsvr item.get id=1 

(set item with id)
&gt; client.php callsvr item.set id=1 &quot;price=434&amp;dscr=hehe&quot;</code></pre>
<p>注意:</p>
<ul>
<li>直接运行<code>client.php</code>可查看支持的API.</li>
<li>任一参数设置为&quot;?&quot;表示查看帮助, 如<code>client.php api1 ?</code>表示显示api1的帮助.</li>
<li>用null表示该参数不赋值, 如<code>client.php api1 param1 null param3</code>.</li>
<li>该工具为回归测试的副产品。</li>
</ul>
<h3 id="回归测试"><span class="header-section-number">5.2</span> 回归测试</h3>
<h4 id="使用方法"><span class="header-section-number">5.2.1</span> 使用方法</h4>
<p><strong>[前提条件]</strong></p>
<ul>
<li>php version &gt;= 5.3.3 (required by phpunit 4.2)</li>
<li>配置php和phpunit使其可直接运行如 &quot;./php&quot; 和 &quot;./phpunit&quot;</li>
</ul>
<p>运行服务端和回归测试：</p>
<pre><code>&gt; cd rtest
&gt; run_server.bat

(设置服务URL，也可以手工设置)
&gt; setTestEnv.bat 
&gt; set SVC_URL=...

(运行所有case)
&gt; run_rtest.pl all

(运行一个case)
&gt; run_rtest.pl testcase1</code></pre>
<p>日志&quot;rtest.log&quot;记录所有HTTP request和response，用于分析业务逻辑失败的原因。</p>
<p>run_rtest是对phpunit进行了封装的工具，下面介绍。</p>
<p><strong>[run_rtest.pl]</strong></p>
<p>phpunit可以执行多个case, 不能自动分析依赖关系. run_rtest.pl工具就是用于简化对个别Case的测试, 它可运行一个多个或全部测试用例。</p>
<pre><code>(执行所有用例)
&gt; run_rtest.pl all

(执行一个用例, 用例名参考rtest.php中的test系列函数, 名称可忽略大小写; 工具将自动先执行依赖的用例)
&gt; run_rtest.pl testupload

(执行多个用例，工具将自动调整各用例执行顺序)
&gt; run_rtest.pl testatt testupload</code></pre>
<p>下面是一些特殊配置:</p>
<ul>
<li>P_DEBUG</li>
</ul>
<p>通过设置环境变量P_DEBUG, 可以让本系统使用的测试工具(如client.php及rtest.php)请求时指定调试等级. 如:</p>
<pre><code>set P_DEBUG=9
client.php callsvr usercar.query</code></pre>
<p>等级9将打出服务端SQL语句，并且通过自动设置URL参数&quot;XDEBUG_SESSION_START=netbeans-xdebug&quot;触发服务端php调试器(必须安装php-xdebug).</p>
<ul>
<li>P_APP</li>
</ul>
<p>指定app名称(间接指定session名). 对应系统URL参数&quot;_app&quot; (参考章节&quot;应用标识(_app)). 在多种客户端同时登录时用于区分每个会话.</p>
<ul>
<li>P_SHARE_COOKIE</li>
</ul>
<p>rtest缺省会在测试前后创建和删除cookie, 测试时会自动找一个用户测试, 测试用例中也包括创建新用户.</p>
<p>如果设置了环境变量P_SHARE_COOKIE, 则不会创建和删除新cookie, 而是用当前已登录的用户测试(其中会用到API whoami来确定当前用户).</p>
<p>例如, 你想借助rtest为特定的用户创建订单, 可以这样:</p>
<pre><code>&gt; set P_SHARE_COOKIE=1
&gt; client.php login 13712345678 1234
(登录用户为13712345678)

(用当前登录用户添加order)
&gt; run_rtest.pl testaddorder

(用当前登录用户运行所有测试, 将忽略注册, 登录等接口测试)
run_rtest.pl all</code></pre>
<p><strong>[phpunit用法]</strong></p>
<p>运行所有回归测试：</p>
<pre><code>phpunit rtest.php</code></pre>
<p>phpunit其它常用参数如下：</p>
<p>运行一个或多个Case(注意：名称大小写必须正确，被依赖的case必须先执行)</p>
<pre><code>    run_rtest --filter testGeneralQuery
    run_rtest --filter testUpload|testAtt</code></pre>
<p>just scenario test:</p>
<pre><code>    run_rtest --group scenario</code></pre>
<p>just sanity test:</p>
<pre><code>    run_rtest --exclude-group scenario</code></pre>
<h4 id="api测试和用例测试"><span class="header-section-number">5.2.2</span> API测试和用例测试</h4>
<p><strong>[原则]</strong></p>
<ul>
<li>API测试(sanity test): 对每个WEB API进行测试，注重每个API的各种成功和出错处理。</li>
<li><p>用例测试或场景测试(usecase/scenraio): 通过调用若干API完成一个有意义的场景。</p></li>
<li>API test and scenario cases in one file: rtest.php</li>
<li>if sanity test fails, ignore scenario tests</li>
<li><p>if any critical case fails, ignore the rest.</p></li>
</ul>
<p><strong>[实现]</strong></p>
<p>参考file rtest.php:</p>
<pre><code>static private $isIT =false;
static private $skipIT = false;
static private $skipAll = false;
private $isCritical = false; </code></pre>
<h3 id="单元测试"><span class="header-section-number">5.3</span> 单元测试</h3>
<p>必要时对某些类进行专门测试，存放在&quot;rtest/test&quot;目录，手工运行它们：</p>
<pre><code>cd test
phpunit xxxTest.php</code></pre>
<h2 id="登录类型与权限管理"><span class="header-section-number">6</span> 登录类型与权限管理</h2>
<p>我们使用的权限控制模型为: &quot;用户-权限(即角色/原子权限组)-原子权限(基本权限)&quot;. (注:权限组也称&quot;角色&quot;, 所以某些系统中也称为&quot;用户-角色-权限&quot;模型.)</p>
<p>在我们系统中, 用户主要有User和Employee两类.</p>
<p>权限有两类: authorization(或称permission), 以及data ownership. - 前者控制用户可以访问的表及列, 以及对该对象(甚至粒度到字段)可以有哪些操作(读/写). 例如, 在我们系统中, User登录后可以添加订单(Ordr.add, 且只允许设置指定的字段), 不可以删除订单. 实现时, 通过AC1_Ordr类控制了操作类型, 字段等. - 后者控制用户可以访问的行, 例如, 虽然用户可以访问订单对象, 但只能操作自己的订单, 但不能操作别人的订单. 实现时, 在AC1_Ordr类的onValidateId(检查set/del/get操作)/onQuery(检查query操作)中, 均做了控制.</p>
<p>在后台系统中, 对象操作类的原子权限定义是通过AccessControl类簇实现的, 每一个类(如AC1_Ordr)即是一个权限定义(包括了对象权限, 列权限及行权限). 而对于函数操作类权限是通过checkAuth(角色)显示定义: 只有指定角色的用户才能调用.</p>
<p>权限定义参考章节<a href="#权限说明">权限说明</a>.</p>
<h2 id="服务端部署与升级"><span class="header-section-number">7</span> 服务端部署与升级</h2>
<h3 id="初始化配置"><span class="header-section-number">7.1</span> 初始化配置</h3>
<p>项目初始化步骤：</p>
<ul>
<li>访问URL: <code>http://{server}/{app}/tool/init.php</code> 检查php环境是否满足需求。</li>
<li>为应用创建数据库和专用用户，进行初始化，生成指定数据库和配置文件 php/conf.user.php.</li>
<li>使用命令行工具 tool/upgrade.php 连接数据库进行表创建或更新。(详见下面章节) (v5.1: 可通过tool/init.php线上自动升级)</li>
<li>如果有initdata目录，查看该目录下相关文档，确定是否需要导入表内容或创建视图、函数等。</li>
</ul>
<p>如果需要重新配置，可删除配置文件 php/conf.user.php后再运行本工具。</p>
<p>在配置文件中，很多帐户口令、密码采用base64等方式保存，可以用在线工具 <code>http://{server}/{app}/tool/tool.php</code>进行编解码。</p>
<h3 id="升级管理"><span class="header-section-number">7.2</span> 升级管理</h3>
<p>tool/upgrade.php - 升级管理</p>
<p><strong>[原理]</strong></p>
<p>它根据主设计文档中（DESIGN.wiki）中的数据模型定义，创建或更新数据库表，定义数据模型示例：</p>
<pre><code>@ApiLog: id, tm, addr</code></pre>
<p>主设计文档中可以包含其它设计文档，指令如下： （支持版本: v3.1）</p>
<pre><code>@include sub/mydesign.wiki</code></pre>
<p>如果使用了插件，一般应包含所有插件文档，以便插件中的表也可被创建。在DESIGN.wiki中目前默认就有这样一行：</p>
<pre><code>@include server/plugin/*/DESIGN.wiki</code></pre>
<p>注意：</p>
<ul>
<li>对于MYSQL数据库, 升级工具只创建表, 不创建数据库本身。创建数据库以及设置权限可在线访问tool/init.php。</li>
<li><p>不会删除表或字段。如有需要请手工操作。通过</p>
<pre><code>upgrade.sh &#39;export(2)&#39;</code></pre>
<p>导出用于升级的SQL语句，然后使用SQL工具运行即可。或通过登录超级管理端，在其中运行SQL语句（注意非SELECT语句前面要加&quot;!&quot;强制执行）。</p></li>
<li><p>对已有的字段，不能修改字段类型。需要手工操作。</p></li>
</ul>
<p><strong>[数据库连接]</strong></p>
<p>upgrade.php与api.php配置方式相同，都是通过环境变量来指定，可以使用conf.user.php中的配置，数据库支持mysql和sqlite.</p>
<p>环境变量P_DB可为升级工具指定数据库. 如</p>
<ul>
<li>P_DB=&quot;carsvc.db&quot;表示本地的sqlite db (以.db结尾)</li>
<li>P_DB=&quot;../carsvc.db&quot;表示本地的sqlite db, 指定了准确的位置.</li>
<li>P_DB=&quot;carsvc&quot; 表示本地的的mysql db, 相当于&quot;localhost/carsvc&quot;.</li>
<li>P_DB=&quot;115.29.199.210/carsvc_test&quot; 表示位于IP=115.29.199.210的远程mysql db.</li>
</ul>
<p>环境变量P_DBCRED指定连接数据库的用户名密码。</p>
<h4 id="用法"><span class="header-section-number">7.2.1</span> 用法</h4>
<p>upgrade.php</p>
<p>缺省进入命令行交互.</p>
<h5 id="交互命令"><span class="header-section-number">7.2.1.1</span> 交互命令</h5>
<p>一般命令格式与函数调用类似, 也支持直接的sql语句, 如</p>
<pre><code>&gt; addtable(&quot;item&quot;)
&gt; addtable(&quot;item&quot;, true)
&gt; quit()

对于无参数命令可不加括号
&gt; quit

支持直接的sql语句
&gt; select * from item limit 10
&gt; update item set price=333 where id=8</code></pre>
<p><strong>[help]</strong></p>
<p>参数: [command]</p>
<p>显示帮助. 可以指定command名称, 全部或部分均可.</p>
<p>例:</p>
<pre><code>&gt; help
&gt; help(&quot;addtable&quot;)
&gt; help(&quot;table&quot;)</code></pre>
<p><strong>[initdb]</strong></p>
<p>自动添加所有表. 等同于updatedb命令.</p>
<p><strong>[updatedb]</strong></p>
<p>自动添加或更新所有表. 相当于对所有表调用addtable命令. 如果某张表已存在, 则检查是否有缺失的字段(注意: 只检查缺失, 不检查字段类型是否变化), 有则添加, 否则对该表不做更改.</p>
<p><strong>[execsql]</strong></p>
<p>参数: {sql} [silent=false]</p>
<p>对于select语句, 返回结果集内容; 对于其它语句, 返回affectedRows.</p>
<p>例:</p>
<pre><code>&gt; execsql(&quot;select * from item limit 10&quot;)
&gt; execsql(&quot;update item set price=10 where id=3&quot;)</code></pre>
<p>注: - 支持直接输入SQL语句, 会自动调用execsql()执行. 程序通过以select等关键字识别SQL, 如</p>
<pre><code>&gt; select * from item limit 10
&gt; update item set price=10 where id=3</code></pre>
<p><strong>[quit]</strong></p>
<p>退出交互. 可简写为&quot;q&quot;.</p>
<p>例:</p>
<pre><code>&gt; quit
或
&gt; q</code></pre>
<p><strong>[export]</strong></p>
<p>v5.1新增. 参数: {type?=0}</p>
<ul>
<li>type: 0-导出META；1-根据META导出SQL语句；2-检查META与数据库的实际差异，以SQL语句方式给出差异结果。</li>
</ul>
<p><strong>[TODO: upgrade]</strong></p>
<p>TODO 自动根据版本差异，执行升级脚本，升级数据库. 如果字段cinf.ver不存在, 则重建DB(但会忽略已有的表, 不会删除它再重新创建). 升级完成后设置cinf.ver字段.</p>
<p><strong>[showtable]</strong></p>
<p>参数: {table?=&quot;*&quot;, checkDb=false}</p>
<p>查看某表的metadata以及SQL创建语句. 参数{table}中可以包含通配符。</p>
<p>例:</p>
<pre><code>&gt; showtable(&quot;item&quot;)
&gt; showtable(&quot;*log&quot;)</code></pre>
<ul>
<li><p>checkDb: 根据META与数据库差异，显示用于升级的SQL语句。</p>
<blockquote>
<p>showtable(null, true)</p>
</blockquote></li>
</ul>
<p><strong>[addtable]</strong></p>
<p>参数: {table} [force=false]</p>
<p>根据metadata添加指定的表{table}. 未指定force参数时, 如果表已存在且未指定force=true, 则检查和添加缺失的字段; 如果指定了force=true, 则会删除表重建.</p>
<p>例:</p>
<pre><code>&gt; addtable(&quot;item&quot;)

(删除表item并重建)
&gt; addtable(&quot;item&quot;, true)</code></pre>
<p><strong>[TODO: reload]</strong></p>
<p>重新加载metadata. 当修改了DESIGN.wiki中的表结构定义时, 应调用该命令刷新metadata, 以便showtable/addtable等命令使用最新的metadata.</p>
<p><strong>[addcol]</strong></p>
<p>addcol {table} {col}</p>
<p>添加字段{table}.{col}</p>
<p><strong>[getver]</strong></p>
<p>取表定义的version.</p>
<p><strong>[getdbver]</strong></p>
<p>取数据库的version.</p>
<p><strong>[import]</strong></p>
<p>参数: {filename} {noPrompt=false} [encoding=utf8]</p>
<p>将文件内容导入表，如果表不存在，会自动创建表（根据metadata），如果表已存在，会删除重建。文件编码默认为utf8. (TODO: 支持指定编码）</p>
<dl>
<dt>noPrompt</dt>
<dd>默认导入表之前要求确认，如果指定该项为true，则不需要提示，直接导入。
</dd>
</dl>
<p>一个文件可以包含多个表，每张表的数据格式如下：</p>
<pre><code># table [CarBrand]
id  name    shortcut
110 奥迪  A
116 宝骏  B
103 宝马  B
...</code></pre>
<p>&quot;#&quot;开头为注释，一般被忽略；特别地，&quot;table [表名]&quot;会标识开始一个新表，然后接下去一行是header定义，以tab分隔，再下面是数据定义，以tab分隔。</p>
<p>这种文件一般可以在excel中直接编辑（但注意：excel默认用本地编码，也支持unicode即ucs-2le编码，但不直接支持utf-8编码）</p>
<p>注意: - 如果字段值为空, 直接写null.</p>
<p>例：导入车型测试数据 先生成测试数据：</p>
<pre><code>initdata\create_testdata.pl
(生成到文件brands.txt)</code></pre>
<p>再在upgrade.php中用import导入：</p>
<pre><code>&gt; import(&quot;../initdata/brands.txt&quot;)</code></pre>
<p>注意：如果列名以&quot;-&quot;开头，则忽略此列数据，如</p>
<pre><code># table [CarBrand]
id  name    -shortcut
110 奥迪  A
...</code></pre>
<p>将不会导入shortcut列。</p>
<p class="todo">TODO: 带关联字段导入：</p>
<pre><code># table [Figure]
name    bookId(Book.name)   ref
黄帝  史记  本纪-五帝</code></pre>
<p>上例数据中，表示根据Book.name查找Book.id，然后填入Figure.bookId。如果Book中找不到相应项，会自动添加一项。</p>
<p>关联表导入：</p>
<pre><code># table [Svc]
id  name    Svc_ItemType(ittId,svcId)
1   小保养 1,2,6
2   大保养 1,2,3,4,7</code></pre>
<p>上例有个字段表述为&quot;Svc_ItemType(ittId,svcId)&quot;, 它表示该字段关联到表 Svc_ItemType.ittId字段，而本表的id对应关联表字段svcId。其内容为以逗号分隔的一串值。以上描述相当于：</p>
<pre><code># table [Svc]
id  name
1   小保养
2   大保养

# table [Svc_ItemType]
ittId   svcId
1   1
2   1
6   1
...</code></pre>
<p>还可以这样设置：</p>
<pre><code># table [Svc]
id  name    Svc_ItemType(ittId,svcId,ItemType.name)
1   小保养 机油;机油滤清器</code></pre>
<p>上例中&quot;Svc_ItemType&quot;多了一个参数&quot;ItemType.name&quot;, 它表示下面内容是关联到ItemType.name字段，即需要先用&quot;SELECT id FROM ItemType WHERE name=?&quot;查询出Svc_ItemType.ittId(第一个参数)，再同上例进行添加。</p>
<h5 id="非交互命令"><span class="header-section-number">7.2.1.2</span> 非交互命令</h5>
<p>更新指定表（addtable命令）：</p>
<pre><code>upgrade.php car_brand car_series car_model</code></pre>
<p>更新所有表（initdb命令）：</p>
<pre><code>upgrade.php all</code></pre>
<p>版本差量升级（TODO：upgrade命令）：</p>
<pre><code>upgrade.php upgrade</code></pre>
<h4 id="todo-写升级脚本"><span class="header-section-number">7.2.2</span> TODO: 写升级脚本</h4>
<p>当表结构变化时,</p>
<ul>
<li>更新设计文档中的表设计(相当于更改meta data)</li>
<li>增加设计文档中的设计版本号(<span class="citation">@ver</span>)</li>
<li>在升级脚本中添加升级逻辑, 如添加字段(及设置默认值), 添加表, 修改字段等.</li>
<li>测试升级脚本后, 上传设计文档及升级脚本, 再通过API或登录服务器执行远程升级; 或直接在本地通过设置P_DB环境变量直接用升级工具连接远端数据库.</li>
</ul>
<p>upgrade.php</p>
<pre><code>ver = getver();
dbver = getdbver();
if (ver &lt;= dbver)
    return;

if (dbver == 0) {
    initdb();
    return;
}

if (dbver &lt; 1) {
    addcol(table, col);
    execsql(&#39;update table set col=col1+1&#39;);
}
if (dbver &lt; 2) {
    addtable(table);
    importdata(&#39;data.txt&#39;);
}
if (dbver &lt; 3) {
    addkey(key);
}
if (dbver &lt; 4) {
    altercol(table, col);
}

update cinf set ver, update_tm</code></pre>
<h3 id="版本发布"><span class="header-section-number">7.3</span> 版本发布</h3>
<p>版本发布又称“部署”或“版本上线”，是将开发版本进行构建和优化后，上传线上服务器的过程。</p>
<p>筋斗云框架使用webcc组件进行版本发布，对构建后的版本，也要求git进行代码库管理。 （注：v5.2起，常常使用另一种更简单的方式，不使用webcc也不创建online版本库，直接使用源码上线，参考下一小节介绍）</p>
<p>webcc提供的功能主要有：</p>
<ul>
<li>快速的差量热更新。只上传版本间有差异的文件到服务器。</li>
<li>构建优化。通过文件合并、最小化压缩等手段提高应用性能，通过文件指纹利用浏览器缓存等。</li>
</ul>
<p>版本发布的配置包括：</p>
<ul>
<li>配置构建过程：编写webcc的配置文件：server/webcc.conf.php，详见webcc文档。</li>
<li>创建发布代码库：创建一个新文件夹并用git进行项目初始化。习惯上该库命名为&quot;{project}-online&quot;，如项目名为&quot;jdcloud&quot;，则发布库的名称为&quot;jdcloud-online&quot;。</li>
<li>配置服务器上的ftp帐号或git帐号，然后配置项目根目录下的 build_web.sh。其中&quot;OUT_DIR&quot;为发布代码库的路径。</li>
</ul>
<p>发布或上线过程很简单，直接在git bash中运行 build_web.sh 即可。 （注意：它会用到curl, bash等工具，好在git工具包中已包含这些。）</p>
<p><strong>[开发版本号与发布版本号]</strong></p>
<p>在构建后，online文件夹中会自动生成文件<code>revision.txt</code>，代表当前开发版本号。下次构建时通过检查该版本与最新开发版本间的差异，可实现差量构建（注意：其中还包含依赖文件管理）。</p>
<p>在上传服务器后，会自动在服务器上生成文件<code>revision_rel.txt</code>, 代表当前发布版本号。下次上传时，只会进行差量上传。</p>
<h4 id="直接源码部署"><span class="header-section-number">7.3.1</span> 直接源码部署</h4>
<p>使用webcc可以对应用进行较好的打包与发布（类似webpack，但可以更灵活的处理打包的逻辑页数），其缺点是：</p>
<ul>
<li>必须创建一个单独的online发布库，每次上线需要运行build_web程序。</li>
<li>由于线上代码常常是压缩优化后的，线上直接修改源码来测试不太方便。</li>
</ul>
<p>源码部署指的是不使用webcc，直接将源码通过git push推送到服务器就实现上线，且可直接在线上修改或提交代码。</p>
<p><strong>[创建线上代码库和部署web目录]</strong></p>
<p>习惯上部署用户使用builder, web服务器用户(即apache用户)为www。注意以下操作中，应设置相关访问权限，实现两者创建的目录或文件相互可读或可写。 以builder用户在apache用户主目录下(一般是/var/www)创建src目录，使用git_clone.sh工具创建git代码库。 假设项目名为myproject:</p>
<pre><code>mkdir /var/www/src
cd /var/www/src
git_clone.sh myproject</code></pre>
<p>需要实现当推送新版本后，前端应可直接热更新（即自动重新刷新）。在使用webcc时，会自动生成源码版本文件revision.txt，框架会读该文件获取版本号实现热更新。 在使用源码部署后，应实现推送后创建和更新该文件。方法是在线上设置版本库：</p>
<pre><code>cd /var/www/src/myproject
vi .git/hooks/post_update</code></pre>
<p>找到下面一句打开注释：</p>
<pre><code>git log -1 --format=%H &gt; server/revision.txt</code></pre>
<p>在web目录下(一般是/var/www/html)为应用创建链接：</p>
<pre><code>cd /var/www/html
ln -sf /var/www/src/myproject/server ./myproject</code></pre>
<p>这样就可以直接访问项目如：<code>http://myserver/myproject/</code>。注意server目录才是线上目录，要用它来创建链接。</p>
<p>在builder主目录下创建链接，便于推送：</p>
<pre><code>ln -sf /var/www/src ./</code></pre>
<p>这样要上线，就只要使用git直接推送到地址: <code>myserver:src/myproject</code></p>
<p><strong>[缓存设置]</strong></p>
<p>即设置apache的.htaccess文件。</p>
<p>使用webcc编译优化时，移动端的缓存策略是：</p>
<ol style="list-style-type: decimal">
<li>m2/.htaccess: m2目录下的html文件不允许浏览器缓存（即要求浏览器每次都获取，apache发现文件未更新，应返回304），其它文件均可缓存；</li>
<li>m2/page/.htaccess: page目录下的逻辑页对html/js/css均不允许缓存。</li>
</ol>
<p>在不使用webcc时，应将m2/.htaccess中设置为对html/js/css均不允许缓存。 否则更新js/css后，前端（尤其是微信）无法得到更新。（如果出现此种情况，只能手工修改html中对css/js的引用链接，比如加参数）。</p>
<p>做法可以直接拷贝web/.htaccess到m2/.htaccess，注意修改后应提交代码库。</p>
<p><strong>[移动端加载优化]</strong></p>
<p>使用webcc时，会对html/js/css/小图标等做压缩优化，以加快移动端加载速度。</p>
<p>使用源码部署后，可酌情做部分优化。</p>
<p>示例：对index.html文件，将不常修改的css/js文件（比如第三方库、jdcloud框架库等）合并压缩。</p>
<p>先在html去掉要优化合并的js/css文件，改为放置：</p>
<pre><code>&lt;!--link rel=&quot;import&quot; href=&quot;lib.html&quot; /--&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;lib.min.css&quot; /&gt;
&lt;script src=&quot;lib.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>将要合并压缩的js/css列举在m2/Makefile中。运行make命令生成上面引用的三个文件（内部使用了tool/mergeJsCss.sh工具），别忘记将它们加到代码库。 其中lib.min.css和lib.min.js即是压缩后的代码。而lib.html用于直接调试合并前的js/css源码，使用时打开该行注释，并注释掉下面两行。</p>
<p>注意当任何被优化的js/css文件修改后，应重新运行make更新相关文件并提交代码库。</p>
<h3 id="客户端自动升级"><span class="header-section-number">7.4</span> 客户端自动升级</h3>
<p>对于Web应用，每次浏览器打开时均已是最新版本；但是如果浏览器一直未关闭，则需要手工刷新页面才能更新。</p>
<p>在手机上，特别是将Web应用打包为手机原生应用后，当服务器升级后，用户必须将应用重新打开才能获得最新版本，这相当于在浏览器中刷新。 如果用户一直不退出应用（这在手机上很常见，应用会在后台一直缓存着），必须有机制能保证版本更新后可自动刷新。</p>
<p>筋斗云框架支持客户端自动升级，原理如下： - 服务端API自动将版本号通过HTTP头<code>X-Daca-Server-Rev</code>发送给客户端。版本号通过全局变量<code>API_VER</code>设定，或从文件<code>revision.txt</code>读取（注意该文件由webcc发布时自动生成），版本号最多为6位。 - 客户端在访问API时，检查版本号是否与本地之前缓存的版本号一致，如果不一致则自动刷新回首页。</p>
<p>通过以上过程，用户不必退出应用再重新打开，就能实现版本自动升级。</p>
<h2 id="工具接口"><span class="header-section-number">8</span> 工具接口</h2>
<p>本节介绍目录 server/tool/ 下的工具。</p>
<p>注意：<code>server/tool/</code>目录下的工具随项目一起发布，一般通过网络访问。而<code>tool/</code>目录下的工具一般是命令行工具，不发布。</p>
<h3 id="toollog.php"><span class="header-section-number">8.1</span> tool/log.php</h3>
<pre><code>log.php(f?=ext, sz?=2500)</code></pre>
<p>查看日志（只显示最新的若干条，倒序排列）。</p>
<p><strong>[参数]</strong></p>
<dl>
<dt>f</dt>
<dd>String. 指定日志类型，缺省查看模拟接口的日志(ext.log), 还可以为&quot;trace&quot;.
</dd>
<dt>sz</dt>
<dd>Integer. 最多读取文件大小。log.php从文件结尾处读缺省3k字节，可以用sz来修改，单位为B.
</dd>
</dl>
<p><strong>[示例]</strong></p>
<pre><code>log.php

log.php?f=trace
(查看trace log)</code></pre>
<h3 id="toolinit.php"><span class="header-section-number">8.2</span> tool/init.php</h3>
<pre><code>init.php(ac?)</code></pre>
<p>数据库初始化或配置文件初始化。可用的ac参数见源文件内部文档。</p>
<p>项目初始化方法参考前面章节&quot;服务端部署与升级&quot;-&gt;&quot;初始化配置&quot;.</p>
<h3 id="tooltool.php"><span class="header-section-number">8.3</span> tool/tool.php</h3>
<pre><code>tool.php(ac?)</code></pre>
<p>具体参数见源程序内部文档。</p>
<p>工具包。目前支持base64编码、解码，md5编码等。</p>
<h3 id="toolupgrade"><span class="header-section-number">8.4</span> tool/upgrade/</h3>
<pre><code>tool/upgrade/index.php(diff?=0)</code></pre>
<p>访问该链接，将根据server/tool/upgrade/META文件自动创建或升级数据库。</p>
<ul>
<li>diff: 如果为1，以SQL语句方式显示数据库表与设计的实际差异。可在SQL工具中运行这些语句修改数据库使其与设计一致。</li>
</ul>
<p>META文件可在tool目录下运行:</p>
<pre><code>make meta</code></pre>
<p>获得更新。其实质是通过upgrade.php工具解析设计文档(DESIGN.md)生成META文件。</p>
<pre><code>php upgrade.php export </code></pre>
<p>该工具已集成到tool/init.php中，用于线上自动升级数据库。</p>
<h2 id="定期任务"><span class="header-section-number">9</span> 定期任务</h2>
<p>例如, 想每天执行一次某任务(假如名为<code>task1</code>), 可以在<code>server/tool/task.php</code>中添加一个名为<code>ac_task1</code>的函数:</p>
<pre><code>function ac_task1()
{
    // 执行任务
}</code></pre>
<p>注意: 与api_functions.php等在Web服务器环境下执行不一样, 它是作为命令行工具执行, 例如手工执行名为<code>db</code>的任务:</p>
<pre><code>php ./task.php task1</code></pre>
<p>由于包含了api.php, 它也可以用queryOne/execOne等函数直接操作数据库, 或用callSvcInt等函数内部调用服务器接口. 注意由于它是未登录的环境, 若是调用有登录权限检查的接口会因未登录而出错, 以确保安全可靠的前提下, 可以通过以下方式调用:</p>
<pre><code>$_SESSION[&quot;uid&quot;] = 1; // 模拟id=1的用户登录.
$rv = callSvcInt(&quot;XX.query&quot;); // 这样就可以调用AC1_XX类的接口.</code></pre>
<p>当然也可以用system函数调用外部命令.</p>
<p><strong>[部署]</strong></p>
<p>通过Linux的crontab机制设置定期执行任务。推荐的部署方法是:</p>
<ul>
<li>在server/tool/task.crontab.php中根据设置任务执行时间. 该文件用于之后在服务器上输出生成crontab安装指令, 并设置日志输出.</li>
<li>代码推送到服务器上, 进入server/tool/目录, 执行<code>php task.crontab.php</code>生成一串文本，复制这些文本.</li>
<li>再运行<code>crontab -e</code>编辑计划任务，将刚刚生成的文本复制过来即安装好。</li>
</ul>
<p>在计划任务执行时, 本来输出到屏幕的内容会输出到日志文件 <code>tool/task.log</code>, 检查日志以查看任务执行情况.</p>
<p>具体设置参照task.crontab.php中的注释说明.</p>
<p><strong>[数据库备份任务:db]</strong></p>
<p>作为示例, task.php中自带一个<code>db</code>任务, 在task.crontab.php中设置每天执行一次, 用于备份数据库。 备份脚本是backup_db.sh, 修改其中的数据库连接设置即可实现数据库日备份.</p>
<h2 id="数据安全"><span class="header-section-number">10</span> 数据安全</h2>
<h3 id="通讯加密"><span class="header-section-number">10.1</span> 通讯加密</h3>
<p>需求：防止通讯中被窃听；为分析通讯数据增加难度</p>
<p>设计原则： 由于前端代码是开放的，只要有人分析前端源码总能破解，所以采用复杂算法意义不大，用简单的非标算法即可。</p>
<p>设计：</p>
<p>原URL参数在urlencoded编码后进行加密，结果放在xp参数中，xp=b64e(原URL参数urlencoded编码)。 调用名须放在URL中，使用ac参数表示，加密后不可见。 b64e是base64编码非标变种。xp表示加密参数 xparam。</p>
<p>对于POST内容，如果URL已加密，则建议加密，结果=b64e(原参数字符串 或 json_encode(原参数对象))，且在contentType中应附加&quot;;xparam=1&quot;字符串。 例外：上传文件场景(contentType是form-data)不加密。</p>
<p>后端处理逻辑：</p>
<ul>
<li>URL中有xp参数则表示是加密传输，使用b64d解码;</li>
<li>此时如果contentType中有&quot;;xparam=1&quot;字样，则对POST内容进行解密。</li>
</ul>
<p>示例：原调用为</p>
<pre><code>POST /api/hello?a=1&amp;b=2

c=3&amp;d=4</code></pre>
<p>先转为</p>
<pre><code>POST /api?ac=hello&amp;a=1&amp;b=2
Content-Type: application/json

{c:3, d:4}</code></pre>
<p>再加密为</p>
<pre><code>POST /api/?xp=xxx1
Content-Type: application/json;xparam=1

xxx2</code></pre>
<h4 id="编码算法"><span class="header-section-number">10.1.1</span> 编码算法</h4>
<p>原base64编码为3字节分组编码算法，使用码表输出文本。</p>
<p>变种算法：码表换位，且增加校验。</p>
<ul>
<li>第1字节：随机数n=是[1-63]范围内随机数，查原码表输出1字节文本。新码表=原码表循环左移n位。</li>
<li>第2字节：校验位n1=（n+原字符串长度）% 64，查新码表输出1字节文本。</li>
<li>之后为使用新码表对原字符串编码的结果。</li>
<li>对编码结果，去除=号，将+号换成-号，得到最终结果。</li>
</ul>
<p>后端在线工具tool/tool.php中，BASE工具下勾上“通讯解码”可以查看解码结果。</p>
<h3 id="数据备份"><span class="header-section-number">10.2</span> 数据备份</h3>
<p><strong>[需求]</strong></p>
<p>考虑以下灾难场景及恢复方式：</p>
<ul>
<li>服务器不正常关机，重启后数据有损失 -- 通过数据库自带的工具修复，不做数据恢复</li>
<li>遭受病毒等破坏，数据无法读取；或服务器硬盘损坏 -- 使用备机(slave)数据进行恢复；或采用每日备份+delta binlog的方式恢复（如果binlog可用）</li>
<li>人为不当操作导致数据损坏 -- 采用每日备份+delta binlog的方式恢复（跳过不当操作部分）</li>
</ul>
<p><strong>[备份建议]</strong></p>
<ul>
<li>每日数据全备份。重要数据应保留7到10天内的每日备份（以备长假等特殊情况导致发现问题较晚）。非重要数据可定期备份（如ApiLog，SmsLog等非业务数据, 但量很大）</li>
<li>异步复制方案(Async Replication)。让从机(slave)与主机基本保持一致。</li>
<li>备份数据至少应放在两个服务器上，以备一台机器数据损坏。可以使用主从机同时备份的方式，也可以主机备份到复制到其它机器。</li>
</ul>
<p><strong>[目前方案]</strong></p>
<ul>
<li>主机myserver.com, 从机server-pc (内网机器), 对数据库carsvc异步全复制(从机数据库名为carsvc_online)。</li>
<li>主机设置每日备份重要数据到 tool/bak/db_{yyyymmdd_hhmmss}.gz (不含ApiLog等非业务数据), 保留7-10天内的每日备份。</li>
</ul>
<p><strong>[注意]</strong></p>
<ul>
<li>目前备份只使用全备份；如果备份文件增长到过大，可增加增量备份(mysqlbinlog --start-position/--start-date --stop-position/--stop-date).</li>
<li>目前将备机置于内网节省成本（机器，网络流量等）。</li>
<li>随着访问量增大，可将备机置于公网，做只读/报表分析等服务器。（仍然用异步复制机制）</li>
<li>如果事务增长至单一主机无法解决，则应组件集群。</li>
</ul>
<h2 id="插件机制"><span class="header-section-number">11</span> 插件机制</h2>
<p>筋斗云框架从v3.0开始支持插件，即plugin下的各目录，因与框架项目在一起，称为内置插件（下一章节介绍）； 到v5.5开始支持外部独立插件，便于独立维护，新的插件都应以这种方式创建和维护，本节只介绍新的插件机制。</p>
<ul>
<li>插件是一块独立的功能，可以被单独安装或删除。</li>
<li>插件有版本管理，可以升级。</li>
<li>插件开发的内容中包括数据模型定义、前端页面及后端接口。</li>
<li>插件间可以有依赖关系。还可能依赖原生cordova插件。</li>
<li>插件可以是通用于所有应用的，也可以是专用于某一应用的。</li>
</ul>
<p>工具tool/jdcloud-plugin.sh用于安装、卸载和创建插件。文件plugin.dat用于记录插件安装信息。</p>
<h3 id="安装与卸载插件"><span class="header-section-number">11.1</span> 安装与卸载插件</h3>
<p>用法：须在项目目录下调用，假设项目目录为myproject, 插件为jdcloud-plugin-notify. 两个目录必须都使用git管理。</p>
<pre><code># 用git下载插件，注意与项目目录平级
git clone server-pc:src/jdcloud-plugin-notify
cd myproject

# 安装
./tool/jdcloud-plugin add ../jdcloud-plugin-notify

# 删除
./tool/jdcloud-plugin del jdcloud-plugin-notify
也可以用
./tool/jdcloud-plugin del ../jdcloud-plugin-notify</code></pre>
<p>插件的目录结构与项目目录一致。</p>
<p>安装时，将插件目录下的文件复制到项目相应目录下，或对于项目中已有的文件，则会将内容合并到相应文件中，然后将安装信息写入plugin.dat文件中，并将相关文件均添加到git。 删除插件时，根据plugin.dat中的相应数据，删除文件或删除共享文件中插件的内容。 目前不支持直接更新插件，可先删除再安装。</p>
<p>特别地，插件下的README.md文件将被复制到项目下的路径<code>server/plugin/{插件名}.README.md</code>。</p>
<p>plugin.dat格式如下：</p>
<pre><code>{pluginName}    #{git版本}
{pluginName}    {newFile}
{pluginName}    +{appendfile}</code></pre>
<p>版本行只用于记录版本，无处理逻辑。标记为+的文件在删除插件时，会自动将追加的内容删除掉，而不是删除整个文件。</p>
<h3 id="创建插件"><span class="header-section-number">11.2</span> 创建插件</h3>
<p>假如要创建名为jdcloud-plugin-url的插件，须先在plugin.dat中注册插件需要的所有文件，如：</p>
<pre><code>jdcloud-plugin-url  #init
jdcloud-plugin-url  server/url.php
jdcloud-plugin-url  +server/plugin/index.php</code></pre>
<p>其中第1行表示插件名；第2行表示将指定文件添加到插件；第3行中，文件名前有加号，表示只需要该文件将特定标识内的内容添加到插件。</p>
<p>特定标识为<code>{插件名} BEGIN</code>和<code>{插件名} END</code>，其中的内容即为插件内容，特定标识一般包在注释内，示例：</p>
<pre><code>/*! jdcloud-plugin-url BEGIN */
function api_getShareUrl()
{
    ...
}
/*! jdcloud-plugin-url END */</code></pre>
<p>创建一个说明文件，路径为<code>server/plugin/{插件名}.README.md</code>。这里创建<code>server/plugin/jdcloud-plugin-url.README.md</code>。 该文件将对应插件目录下的README.md文件。</p>
<p>接下来，创建独立的插件目录和代码库，它与项目平级：</p>
<pre><code>git init jdcloud-plugin-url</code></pre>
<p>然后回到项目目录，调用命令，根据plugin.dat的内容创建插件到指定路径：</p>
<pre><code>./tool/jdcloud-plugin create ../jdcloud-plugin-url</code></pre>
<p>然后进入插件目录，提交文件到git库即可。</p>
<p>若要更新插件，也是相同步骤：更新plugin.dat，调用<code>jdcloud-plugin create</code>命令，提交文件到插件git库。</p>
<h2 id="插件机制旧"><span class="header-section-number">12</span> 插件机制（旧）</h2>
<p>支持版本: v3.0</p>
<h3 id="插件目录结构"><span class="header-section-number">12.1</span> 插件目录结构</h3>
<pre><code>plugin/  - 插件总目录

plugin/index.php - 插件配置文件，指定应用使用哪些插件

plugin/{pluginName}/  某插件的主目录
plugin/{pluginName}/DESIGN.wiki 插件设计文档
plugin/{pluginName}/plugin.php 插件配置及服务端接口
plugin/{pluginName}/m2/page/{page}.[html|js] 插件前端逻辑页面，可直接在应用程序中使用
plugin/{pluginName}/m2/plugin.js 可选，插件前端全局逻辑，文件名字任意，在plugin.php中通过return语句指定使用。
TODO: plugin/{pluginName}/m2/plugin.css 可选，插件前端全局样式，文件名字任意，在plugin.php中通过return语句指定使用。</code></pre>
<p>插件设计文档的结构可参考主设计文档，一般也包括 概要设计（需求），数据库设计，交互接口，前端应用接口这些部分。</p>
<p>插件设计文档中的表应在升级时自动创建，主设计文档中有以下指定用于此目的：</p>
<pre><code>@include server/plugin/*/DESIGN.md</code></pre>
<p>插件中对外部表及字段的依赖，应使用@see指令标注：</p>
<pre><code>依赖数据接口：

@see @User: id, phone
@see @Store: id, name, dscr
@see @Ordr: id, storeId

Ordr.storeId = Store.id</code></pre>
<p>这些被依赖的字段，看似名字固定，其实是可配置的，详参后端接口文档，查询 PluginBase.$colMap 关键字。</p>
<p><strong>[插件配置文件 plugin/index.php]</strong></p>
<p>该文件被后端应用框架自动包含，其内容示例如下：</p>
<pre><code>&lt;?php

Plugins::add([ &quot;plugin1&quot;, &quot;plugin2&quot; ]);</code></pre>
<p>表示当前应用使用两个插件&quot;plugin1&quot;和&quot;plugin2&quot;, 分别对应目录 plugin/plugin1和plugin/plugin2. 如果该文件不存在，则后端应用不加载任何插件。</p>
<p><strong>[插件后端 plugin/{pluginName}/plugin.php]</strong></p>
<p>文件会被自动包含到应用api.php中。在这里实现插件的交互接口，在文件的最后可以返回插件的配置，如</p>
<pre><code>&lt;?php

// 实现交互接口 svcinfo
function api_svrinfo()
{ ... }

// 返回插件配置
return [
    &quot;js&quot; =&gt; &quot;m2/plugin.js&quot; // 前端需要包含的文件
];</code></pre>
<p>详参后端接口文档 模块api_fw -&gt; 插件机制 章节。</p>
<p><strong>[插件移动WEB前端 plugin/{pluginName}/m2/page/]</strong></p>
<p>和应用的 m2/page/ 目录一样，包含插件的每个逻辑页面。</p>
<h3 id="插件安装"><span class="header-section-number">12.2</span> 插件安装</h3>
<p>将插件直接复制到plugin目录下，在plugin/index.php中添加该插件名即可。</p>
<p class="todo">TODO: 安装相关API和交互接口</p>
<p class="todo">TODO: 相关表更新 用upgrade.php</p>
<h3 id="接口"><span class="header-section-number">12.3</span> 接口</h3>
<h4 id="后端php-api"><span class="header-section-number">12.3.1</span> 后端PHP API</h4>
<pre><code>Plugins.add($pluginList);  // 添加插件
Plugins.exists($pluginName); // 判断插件是否存在</code></pre>
<p class="todo">TODO: 服务端安装插件：</p>
<pre><code>Plugins.install(&#39;plugin1@1.1&#39;); -- 注册的插件, 下载到本地，解压到plugin目录下，再自动更新plugin/index.php文件。
Plugins.uninstall(&#39;plugin1&#39;); -- 删除插件目录，再更新plugin/index.php。</code></pre>
<h4 id="前端js-api"><span class="header-section-number">12.3.2</span> 前端JS API</h4>
<pre><code>MUI.initClient(); // 前端初始化，如需调用以下接口，须在muiInit事件中调用。

Plugins.exists(pluginName); // 判断插件是否存在
Plugins.list(); // 返回当前应用的插件列表</code></pre>
<p>示例：</p>
<pre><code>$(document).on(&quot;muiInit&quot;, myInit);
function myInit()
{
    MUI.initClient(); // 初始化客户端环境，包括插件
    ...
}

// 判断和使用插件前端页面
if (Plugins.exists(&#39;plugin1&#39;)) {
    MUI.showPage(&#39;#plugin1-page1&#39;);
}</code></pre>
<h4 id="交互接口"><span class="header-section-number">12.3.3</span> 交互接口</h4>
<p>返回插件列表：</p>
<pre><code>initClient() -&gt; { @plugins? }

plugins:: { name =&gt; {js?} }</code></pre>
<p class="todo">TODO: 安装与卸载</p>
<pre><code>addPlugin(name)
delPlugin(name)</code></pre>
<h3 id="发布与上线"><span class="header-section-number">12.4</span> 发布与上线</h3>
<p>应用专属插件可直接存放在plugin目录下，使用与主应用相同的代码库。</p>
<p>在上线时，不同的项目分别创建一个build_web.sh，根据配置不同选择不同的插件更新到服务器。 文件plugin/index.php不上线，必须手工上传服务器。</p>
<p>build_web.sh</p>
<pre><code>export CFG_PLUGINS=plugin1,plugin2
tool/make_install.sh</code></pre>
<p>通用插件使用专门的代码库维护版本。如果要加到工程中，也可以放到plugin目录下作为子模块加到应用代码库中。</p>
<p>注意：</p>
<ul>
<li>首次上线时，必须配置build_web.sh中的CFG_PLUGINS变量，上线后，在服务器上手工配置 php/index.php 文件。</li>
<li>上线后如果插件有增减，应先修改build_web.sh中的CFG_PLUGINS变量，再手工上传（或删除）相应插件文件夹，再到服务器上手工配置 php/index.php 文件。</li>
</ul>

</body>
</html>

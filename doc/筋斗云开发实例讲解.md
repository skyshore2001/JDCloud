# 筋斗云开发实例讲解

准备好数据模型描述（参考tool\create-wui-page\meta-example.txt）
用在线工具生成对象管理源文件框架： http://localhost/dev/jdcloud/tool/
它可以生成管理端文件、升级数据库、服务端代码、更新菜单项。

也可以直接用命令行工具：server/web/page/create-wui-page.php
先准备好meta.txt文件放在该目录下，然后运行命令：

	create-wui-page.php -

写meta.txt示例：

	@User: id, name(s), storeId, status(4), weixinData(1000), dscr(t), picId, 积分&, adminFlag
	用户: 编号, 昵称, 企业/linkTo:Store/textField:storeName, 状态/enum:UserStatusList, 微信数据, 描述, 头像, 积分, 企业管理员/enum:YesNoMap

- storeId: 链接字段. linkTo/textField.
- status/adminFlag: 枚举字段. enum. 其中常量YesNoMap是框架预定义的，而UserStatusList需要在前端自行定义。
- 积分: 可以直接用中文字段，常用后缀还有：`&` 整数， `@` 货币（高精度小数）

注意：符号最好全用半角英文符号，但也兼容中文逗号和冒号。

## 下拉框：枚举类型字段

如type，status这种字段，由若干固定值构成。展示的需求为：

- 在对话框中，需要以下拉框的方式选择填写(my-combobox)
- 如果要做映射转化，如status的"CR"值需要显示成"未付款"，则在列表显示以及导出文件时，应显示正确文字。

### 使用Map定义枚举

在pageXXX.html中定义:

	<th data-options="field:'status', jdEnumMap: OrderStatusMap, formatter:Formatter.enum(OrderStatusMap), styler:Formatter.enumStyler({PA:'Warning', RE:'Disabled', CR:'#00ff00'}), sortable:true">状态</th>

在全局文件app.js或应用主文件如store.js中定义全局常量：

	var OrderStatusMap = {
		CR: "未付款", 
		PA: "待服务", 
		RE: "已服务", 
		RA: "已评价", 
		CA: "已取消", 
		ST: "正在服务"
	};

formatter用于设置显示文字；jdEnumMap用于在导出excel时也能正确转换。

上面Formatter.enum及Formatter.enumStyler是框架预定义的常用项，也可自定义formatter或styler，一般在pageXXX.js中定义（如果别的地方需要共用，则放到主逻辑文件如store.js中），如：

	var OrderColumns = {
		status: function (value, row) {
			if (! value)
				return;
			return OrderStatusMap[value] || value;
		},
		statusStyler: function (value, row) {
			var colors = {
				CR: "#000",
				RE: "#0f0",
				CA: "#ccc"
			};
			var color = colors[value];
			if (color)
				return "background-color: " + color;
		}
	};

在pageXXX.html引用：

	<th data-options="field:'status', jdEnumMap: OrderStatusMap, formatter:OrderColumns.status, styler:OrderColumns.statusStyler, sortable:true">状态</th>

在dlgXXX.html中为status字段定义下拉列表：

	<select name="status" class="my-combobox" data-options="jdEnumMap:OrderStatusMap"></select>

参考：my-combobox组件。

### 使用List定义枚举

新的设计中，建议直接使用中文来定义枚举，不必做转换，即status的值直接是"待服务", "已服务"这些，不再用"PA", "RE"这些缩写。
这样上面可简化成：

	<th data-options="field:'status', sortable:true, styler:Formatter.enumStyler({'待服务':'Warning'})">状态</th>

在全局文件app.js或应用主文件如store.js中定义全局常量：

	var OrderStatusList = "未付款;待服务;已服务;已评价;已取消;正在服务";

不再需要设置formatter和jdEnumMap，因为显示和导出文件时无须做文字转换。

styler由于比较简单，可使用Formatter.enumStyler直接为各种状态定义颜色，预设的有Warning, Error, Info, Disabled四种，也可以直接指定颜色，注意null也可指定颜色。

	{'待服务':'Warning', '正在服务':'Error', '已服务':'Info', '未付款':'Disabled', '已取消':'#cccccc', null: 'Error'}

在dlgXXX.html中定义：

	<select name="status" class="my-combobox" data-options="jdEnumList:OrderStatusList"></select>

注意：jdEnumList与jdEnumMap选项格式不同。

### flag字段

示例：是否“企业管理员”字段 - adminFlag

列表页：pageUser.html

	<th data-options="field:'adminFlag', sortable:true, jdEnumMap:YesNoMap, formatter: Formatter.enum(YesNoMap)">企业管理员</th>

详情对话框：dlgUser.html

	<select name="adminFlag" class="my-combobox" data-options="jdEnumMap:YesNoMap"></select>

YesNoMap是框架定义的，显示“是”、“否”，也可以自行定义。

示例：disableFlag - 禁用和启动状态

在app.js中定义常量：

	window.DisableMap = {
		0: "启用",
		1: "禁用"
	};

在列表页：pageXXX.html

	<th data-options="field:'disableFlag', sortable:true, formatter: Formatter.enum(DisableMap), styler:Formatter.enumStyler({1:'Disabled'})">启用状态</th>

详情对话框：dlgXXX.html

	<select name="disableFlag" class="my-combobox" data-options="jdEnumMap:DisableMap"></select>

## 下拉框：关联字段（外键）

示例：用户关联所在企业(User.storeId=Store.id)

- 在列表页，需要显示企业名(storeName)，而不是storeId，并且链接到用户（点击可打开用户对话框）：pageUser.html
- 在详情页，可用list中选择，而非填写。

实现：

先在设计文档中，为用户查询接口添加返回关联字段storeName: 文件DESIGN.md

	User.query() -> tbl(..., storeName)

在后端添加关联字段：api_objects.php

	class AC0_User extends AccessControl
	{
		protected $vcolDefs = [
			[
				"res" => ["s.name storeName"],
				"join" => "LEFT JOIN Store s ON s.id=t0.storeId",
				"default" => true
			]
		];
	}
	class AC2_User extends AC0_User { }

注意：

- 习惯上，虚拟字段是公用的，所以放在AC0类（超级管理端），再由AC1（用户端）和AC2（管理端）继承。
- 接口设计中storeName后面未加问号, 表示该字段默认就该返回，所以上次设置了`"default"=>true`。

列表页 pageUser.html

	<th data-options="field:'storeId', sortable:true, sorter:intSort, formatter: Formatter.linkTo('storeId', '#dlgStore', 'storeName')">企业</th>

明细页 dlgUser.html
从企业列表中选择：

		<tr>
			<td>企业</td>
			<td>
				<select name="storeId" class="my-combobox" data-options="ListOptions.Store()"></select>
			</td>
		</tr>

在主文件store.js中添加ListOptions.Store定义：

	var ListOptions = {
	...
		Store: function () {
			var opts = {
				valueField: "id",
				textField: "name",
				url: WUI.makeUrl('Store.query', {
					res: 'id,name',
					pagesz: -1
				}),
				formatter: function (row) { return row.id + "-" + row.name; }
			};
			return opts;
		}
	}

## 图片字段 / 视频字段 / 附件字段

- wui-upload组件

需求：

- 可选择、预览、压缩上传图片。
- 支持缩略图（显示缩略图，点击时查看原图）
- 支持单选、复选
- 支持视频和附件文件。

参考wui-upload组件。

在pageXXX.html中为表格设置列：

	<th data-options="field:'picId', sortable:true, sorter:intSort, formatter: Formatter.pics">主图</th>

在dlgXXX.html中设置字段：

单图：

		<tr>
			<td>主图</td>
			<td class="wui-upload" data-options="multiple:false">
				<input name="picId">
			</td>
		</tr>

多图：

		<tr>
			<td>图片</td>
			<td class="wui-upload">
				<input name="pics">
			</td>
		</tr>

## 复选框字段

- wui-checkList组件

系统用户(Employee)可以赋予一到多个角色。
表设计：

	@Employee: id, name, ..., roles
	- roles: List(role). 角色列表，示例: "mgr"（高级管理员）, "emp"（管理员）, "审核专员", "审核专员,日志分析员"

其中mgr, emp是系统固有角色，其它角色可自定义包含的权限。

	@Role: id, name, perms
	- perms: List(perm). 权限列表。

在系统用户设置对话框中这样展示角色：dlgEmployee.html

			<tr>
				<td>角色</td>
				<td class="wui-checkList" data-options="ListOptions.Role()">
					<input type="hidden" name="roles">
					<div><label><input type="checkbox" value="mgr">最高管理员</label></div>
					<div><label><input type="checkbox" value="emp" checked>管理员</label></div>
				</td>
			</tr>

wui-checkList将自动序列化和反序列化角色列表。固定的选项直接列出，动态的选项根据数据库查询列表，在data-options中指定url相关选项，这与my-combobox组件的使用方式相同。

在全局逻辑中设置ListOptions.Role:  store.js

	var ListOptions = {
		...
		Role: function () {
			var opts = {
				valueField: "name",
				textField: "name",
				url: WUI.makeUrl('Role.query', {
					res: 'name',
					pagesz: -1
				})
			};
			return opts;
		}
	}

## 添加时自动完成某些字段

示例：添加用户时，自动填写:

- 创建时间(User.createTm=当前时间)
- 用户状态(User.status=待审核, 仅当未指定时设置)。
- 所有企业(前端默认取第一个)

在后端完成自动补全：api_objects.php

	class AC2_User extends AccessControl
	{
		protected function onValidate()
		{
			if ($this->ac == "add") {
				$_POST["createTm"] = date(FMT_DT);
				if (!issetval("status"))
					$_POST["status"] = "待审核";
			}
		}
	}
 
明细页中，在添加时，要求“创建时间”字段不可填，而状态字段自动变成“待审核”：在dlgUser.js中动态修改

	function onBeforeShow(ev, formMode, opt) 
	{
		var objParam = opt.objParam;
		var forAdd = formMode == FormMode.forAdd;
		setTimeout(onShow);

		function onShow() {
			// 添加时灰掉createTm字段
			frm.createTm.disabled = forAdd;
			// 添加时自动填写字段
			if (forAdd) {
				$(frm.status).val("待审核");
				$(frm.storeId).val(1);
			}
		}
	}

设置值时，尽量用jQuery操作。虽然一般也可以用

	frm.status.value = "待审核";
	frm.storeId.value = 1;

但是会有bug，比如当第一次打开对话框做添加操作时，企业列表尚未加载成功，设置`frm.storeId.value=1`无效。
而select控件的jQuery.val函数做了扩展，用`$(frm.storeId).val(1)`就可以成功操作。

## 密码字段 / 格式化显示

需求：pwd字段，要求在对话框显示成`****`。

在dlgUser.html中，

	function onBeforeShow(ev, formMode, opt) 
	{
		if (formMode == FormMode.forSet)
			opt.data.pwd = "****";
	}

注意：和前面章节在添加时给初值不同，当时是在onShow中设置UI组件；而这里是在onBeforeShow中修改初始数据opt.data。
因为，如果设置UI组件，则提交时判断UI与初值不同，就会提交修改；而修改了初值，在提交时，如果在UI上未修改，就不会做提交。

## 后端查询时加限制条件

示例：条目Item分为多个类别type. 查询条目接口:

	Item.query(type?)

	- 当type="广告位"时，按cond="广告位优先级>0"查询，默认按此优先级倒序排列；
	- 当type="新鲜事"时，过滤type="活动"/"集市"的条目。
	- 否则按type指定值过滤。

实现：api_objects.php, 在onQuery中用addCond增加条件：

	protected function onQuery()
	{
		$type = param("type");
		if ($type) {
			if ($type == "广告位") {
				$this->addCond("广告位优先级>0");
				// 设置排序条件，可以设置`$this->defaultSort`(可被orderby接口参数覆盖)，也可写死即设置`$this->sqlConf["orderby"]`
				//$this->sqlConf["orderby"] = "广告位优先级 DESC";
				$this->defaultSort = "广告位优先级 DESC";
			}
			else if ($type == "新鲜事") {
				$this->addCond("type IN ('活动', '集市')");
			}
			else {
				$this->addCond("type=" . Q($type));
			}
		}
	}

添加过滤逻辑示例：

	Item.query(q?)

	- AUTH_USER
	- 默认用户只能看已发布的所有条目(即按status='发布中'过滤)
	- 用户可以看到自己的除了“已删除”状态外的所有条目，指定参数为`q=my`

在api_objects.php的AC1_User中实现：

	protected function onQuery()
	{
		...
		$q = param("q");
		if ($q == "my") {
			$uid = $_SESSION["uid"];
			$this->addCond("userId=$uid");

			$this->addCond("status<>'已删除'");
		}
		else {
			$this->addCond("status='发布中'");
		}
	}

特别须注意的是：onQuery函数也会被set/del/setIf/delIf等接口回调，用于限制可修改数据的范围。
所以在onQuery中，如果不是为了限制范围(addCond)的逻辑，比如只是为了query接口的逻辑，可加`$this->ac == "query"`限定，避免影响set/del等接口，如：

	protected function onQuery()
	{
		$q = mparam("q");   // 这个显然是为query接口的强制参数，它会影响get/set/del等接口出错。
		...
	}

应改为：

	protected function onQuery()
	{
		if ($this->ac == "query") {
			$q = mparam("q");
			...
		}
	}

## 更新操作与特定权限

**[需求]**

- 只有“企业管理员”权限的用户才能更新企业信息。且只能更新自己企业的信息。
- 名称、企业积分字段不可更新。

**[数据模型]**

	@User: id, storeId, adminFlag
	- adminFlag: 是否是企业管理员
	@Store: id, name, 积分, 地址, 联系人

**[接口设计]**

	Store.set()(地址, 联系人, ...)

	- (AUTH_USER & PERM_ADMIN_USER) | AUTH_EMP
	- 只可更新自己所在企业，不必传id

**[后端实现]**

先定义一个权限PERM_ADMIN_USER，表示企业管理员. api.php

	// 权限类型
	...
	const PERM_ADMIN_USER = 0x200;

	$PERMS = [
		...
		PERM_ADMIN_USER => "admin-user",
	];

在用户登录时保存adminFlag字段到session：php/class/LoginImp.php
LoginImp.onLogin是login插件的接口实现，参考login插件。(plugin/login)

	class LoginImp extends LoginImpBase
	{
		// 登录成功时回调
		function onLogin($type, $id, &$ret)
		{
			if ($type == "user") {
				$_SESSION["adminFlag"] = $ret["adminFlag"];
			}
		}
	}

在onGetPerms中设置权限：api.php

	function onGetPerms()
	{
		$perms = 0;
		if (isset($_SESSION["uid"])) {
			$perms |= AUTH_USER;
			if ($_SESSION["adminFlag"]) {
				$perms |= PERM_ADMIN_USER;
			}
		}
		...
	}

注意：用户权限一旦被修改，必须重新登录才能生效。

session变量属于重要的后端内部接口，在主设计文档DESIGN.md中添加说明：

	## 后端内部接口

	会话变量：

	- 用户登录
		- uid: 用户编号
		- adminFlag: 管理员标志
	- 员工登录
		- empId: 员工编号

实现Store.set接口: api_objects.php
检查PERM_ADMIN_USER权限，并自动补上id参数，

	class AC1_Store extends AC_Store
	{
		// 默认没有set操作
		protected $allowedAc = ["get", "query"];
		protected $readonlyFields = ["企业积分", "name"];

		protected function onInit() {
			// 当有权限时才加set操作
			if (hasPerm(PERM_ADMIN_USER)) {
				$this->allowedAc[] = "set";
			}
		}
		protected function onValidateId() {
			// set时强制设置成自己企业。
			if (!param("id") || $this->ac == "set") {
				$uid = $_SESSION["uid"];
				$this->id = queryOne("SELECT storeId FROM User WHERE id=" . $uid);
			}
		}
	}

用`$allowedAc`来限制操作；
用`$readonlyFields`来限制更新操作的字段。add/set操作都不可设置这些字段。
如果add接口可以设置该字段，但set操作不可以改，应使用`$readonlyFields2`。假如此例中"name"想要在添加时可指定，但企业积分add/set时都只读：

		protected $readonlyFields = ["企业积分"];
		protected $readonlyFields2 = ["name"];

AC1类保证了用户已登录（可以安全地取session变量uid），
用`hasPerm()`来判断权限，如“企业管理员”时添加"set"接口。也可用`checkAuth`检查权限，不符时将直接报错返回。

**[限制set操作]**

上面为了限制set操作只对本企业，直接在onValidateId中设置id。这意味着即使是给定了错误的id，也不会报错，而是仍修改本企业。
标准的做法是在onQuery中为set操作限定范围，如下：

	class AC1_Store extends AC_Store
	{
		...
		protected function onValidateId() {
			if (! param("id")) { // 不强制设置set操作的id
				$uid = $_SESSION["uid"];
				$this->id = queryOne("SELECT storeId FROM User WHERE id=" . $uid);
			}
		}
		protected function onQuery() {
			// 对set的范围进行限定
			if ($this->ac == "set") {
				$uid = $_SESSION["uid"];
				$storeId = queryOne("SELECT storeId FROM User WHERE id=" . $uid);
				$this->addCond("id=$storeId");
			}
		}
	}

这时，如果给定的id不正确，就会直接报错。

## 查询时的字段隐藏

示例：查询用户时，隐藏微信数据等字段。

	@User: id, name, weixinKey, weixinData(2000)

后端实现：api_objects.php
设置`$hiddenFields`.

	class AC1_User extends AC0_User
	{
		protected $hiddenFields = ["weixinData", "weixinKey"];
	}

## 查询或更改时限制操作内容

在onQuery中限制操作范围。

本节与之前`后端查询时加限制条件`类似。应特别注意onQuery不止用于query接口，还被get/set/del等接口用于限定数据操作范围，即执行其中的addCond操作。
必要时应小心判断`this->ac == 'query'`，避免影响其它接口。

需求：

- 用户只能查看自己所在企业的员工
- 用户只能修改自己；如果是企业管理员(PERM_ADMIN_USER)，可修改本企业的员工

数据模型：

	@Store: id, name
	@User: id, name, storeId

交互接口：

	User.query()
	User.get(id?)
	User.set(id?)

	限定查看自己企业的用户，限定只能操作自己的数据。
	但企业管理员可修改企业中的用户。
	如果未指定id参数，以当前用户id补齐。

后端实现：

	class AC1_User extends AC0_User
	{
		protected $allowedAc = ["get", "set", "query"];

		protected function onValidateId()
		{
			// 自动补上id参数
			if (!param("id")) {
				$uid = $_SESSION["uid"];
				$this->id = $uid;
			}
		}
		protected function onQuery() {
			$uid = $_SESSION["uid"];
			// 读操作(get/query)或是管理员，限制storeId
			if ($this->ac == "get" || $this->ac == "query" || hasPerm(PERM_ADMIN_USER)) {
				$storeId = queryOne("SELECT storeId FROM User WHERE id=" . $uid);
				$this->addCond("storeId=$storeId");
			}
			// 写操作，限制uid
			else {
				$this->addCond("id=$uid");
			}
		}
	}

## 查询时动态添加字段

使用addRes动态添加字段。

需求：预订会议室时，根据日期查看会议室列表。

数据模型：

	@Room: id, name
	@RoomOrder: id, roomId, 时段

接口：

	Room.query(dt?) -> tbl(id, ..., 已用时段?)

	- dt: 如果指定日期dt，则返回每个会议室当天已被占用的时段

后端实现：

	class AC1_Room extends AccessControl
	{
		protected $allowedAc = ["get", "query"];
		protected function onQuery() {
			$dt = param("dt/dt");
			if ($dt) {
				$dtStr = date(FMT_DT, $dt);
				$this->addRes("(SELECT group_concat(时段) FROM RoomOrder WHERE roomId=t0.id AND dt='$dtStr' AND status<>'已取消') 已用时段");
			}
		}
	}

## 内部调用接口

示例：通过手机号发优惠券时，支持批量发量，用逗号分隔的多个手机号。

接口：

	手机号userPhone只有一个时：
	Coupon.add()(userPhone, ...) -> id

	如果userPhone包含多个手机号：（用逗号隔开，支持中文逗号，支持有空格）
	Coupon.add()(userPhone, ...) -> {cnt, idList}

实现：
重载add接口，如果是批量添加则通过callSvc再调用add接口：

	class AC2_Coupon extends AccessControl
	{
		function api_add() {
			if (@$_POST["userPhone"]) {
				$arr = preg_split('/[,，]/u', $_POST["userPhone"]);
				if (count($arr) > 1) {
					$idList = [];
					foreach ($arr as $e) {
						$postParam = array_merge($_POST, ["userPhone"=>trim($e)]);
						$idList[] = $this->callSvc(null, "add", null, $postParam);
					}
					setRet(0, [
						"cnt"=>count($idList),
						"idList"=>$idList
					]);
					throw new DirectReturn();
				}
			}
			return parent::api_add();
		}
	}

## WEB端页面共用

定义了Item表，通过type区分 活动、发包、集市等多种功能。

	@Item: id, type(4), status(4), name, label, content(t), picId, pics, userId, storeId, price, qty, leftQty, startTm, endTm, 时间, 地点, 联系人, 联系方式, 积分&, 广告位优先级&, 公告优先级&

- name: 标题
- type: Enum(活动, 发包, 集市, 公告, 报修, 企业动态, 卡券, 停车券). 条目类别。

首先，在列表页初始化函数initPageXXX中添加参数，如（pageItem.js）：

	// 1. 添加参数objParam，列表页和详情页共用这些参数。
	function initPageItem(objParam)
	{
		...
		var param = {};
		var type;
		if (objParam) {
			jdlg.objParam = objParam; // 2. 传参给对话框

			type = objParam.type;
			param.type = type; // 3. 设置列表查询参数，
			// param.cond = WUI.getQueryCond({type: type}); 
		}
		jtbl.datagrid({
			url: WUI.makeUrl("Item.query", param), // 4. 使用列表查询参数
			toolbar: WUI.dg_toolbar(jtbl, jdlg, "export"),
			onDblClickRow: WUI.dg_dblclick(jtbl, jdlg),
			sortOrder: "desc",
			sortName: "id"
		});
		// 控制列显示, 封装了WUI.toggleFields函数, 列表框和明细框中均可用
		toggleItemFields(jtbl, type);
		// 原理是一列列控制:
		// WUI.toggleCol(jtbl, 'type', !type);
		// WUI.toggleCol(jtbl, 'status', !type || type!="公告");
		...
	}

通过param传参给datagrid查询列表；通过jdlg.objParam传参数给明细对话框。
特别地，objParam.title 参数将修改对话框的标题。参考 showObjDlg 的opt参数。

然后，在store.html中修改主应用的菜单，在菜单中将原先的：

				<a href="#pageItem">活动管理</a>

改成多项，分别指定type参数：

				<a href="javascript:WUI.showPage('pageItem','活动管理',[{type:'活动', title:'活动管理'}])">活动管理</a>
				<a href="javascript:WUI.showPage('pageItem','企业合作',[{type:'发包', title:'企业合作'}])">企业合作</a>
				...

可优化一下，避免标题重复多遍，菜单项改写成这样：

				<a itemType="活动">活动管理</a>
				<a itemType="发包">企业合作</a>
				...

在store.js中处理菜单项的点击事件：

	function main()
	{
		... 
		// 打开item的各个衍生页。title自动从当前a对象内容获取
		$("#menu a[itemType]").click(function () {
			var type = $(this).attr("itemType");
			var title = $(this).text();
			WUI.showPage('pageItem',title,[{type: type, title: title}]);
		});
	}

修改明细对话框dlgItem.js，根据传入的参数opt.objParam, 隐藏type并在添加时自动设置值：

	function initDlgItem()
	{
		...
		function onBeforeShow(ev, formMode, opt) 
		{
			// objParam是外界传入的参数
			var objParam = opt.objParam;
			var forAdd = formMode == FormMode.forAdd;
			setTimeout(onShow);

			function onShow() {
				// 控制字段显示, 与列表上共用toggleItemFields函数
				var type = objParam && objParam.type;
				toggleItemFields(jfrm, type);
				// 原理是控制每个字段显示, 类似于:
				// $(frm.type).closest("tr").toggle(!type);
				// $(frm.status).closest("tr").toggle(!type || type!="公告");
				...

				if (forAdd) {
					// 添加时自动为type设置值
					if (objParam.type) {
						$(frm.type).val(objParam.type);
					}
				}
			}
		}

		function onValidate(ev, mode, oriData, newData) 
		{
		}
	}

建议使用WUI.toggleFields工具函数(v5.4)，它可同时适用于列表页或明细页上的字段显示控制。
在store.js中包装一个对于Item对象的字段控制函数：

	function toggleItemFields(jo, type)
	{
		WUI.toggleFields(jo, {
			type: !type,
			status: !type || type!="公告",
			tm: !type || type=="活动" || type=="卡券" || type=="停车券"
		});
	}

列表中调用，控制列显示：pageItem.js

		var type = objParam && objParam.type;
		toggleItemFields(jtbl, type);

明细页中调用，控制字段显示：dlgItem.js

		var type = objParam && objParam.type;
		toggleItemFields(jfrm, type);

查看上面代码注释中的toggleItemFields，了解这段代码的插入位置。

## 后端表合并/Union

订单日志OrderLog与增项日志表IncrLog，希望查询订单日志时，一并返回关联的增项日志。

	@Order: id, ...
	@OrderLog: id, orderId, action, dscr, empId, createTm, field, fieldName, originValue, newValue

	@IncrementProject: id, orderId, ...
	@IncrLog: id, incrId, action, empId, dscr(l), createTm
	
接口为：

	OrderLog.query(cond="orderId={orderId}")
	IncrLog.query()

现在希望通过OrderLog.query也同时返回该订单对应增项的操作日志。

后端原代码为：api_objects.php

	class AC2_OrderLog extends AccessControl
	{
		protected $allowedAc = ["query"];	
		protected $vcolDefs = [
			[
				"res" => ["emp.name empName"],
				"join" => "LEFT JOIN Employee emp ON emp.id=t0.empId",
				"default" => true
			]
		];
	}

通过AccessControl::$table字段可设定为一个UNION子查询：

	class AC2_OrderLog extends AccessControl
	{
		protected $table = "(SELECT orderId, action, createTm, empId, field, fieldName, originValue, newValue from OrderLog t0
	union
	select i.orderId, '增项操作', t1.createTm, t1.empId, 'incrStatus', '增项状态', null, t1.dscr from IncrLog t1
	inner join IncrementProject i on incrId=i.id)";
		...
	}

- 注意：前后括号不可少。
- 只能查询，不可更新、删除等。

## 字段显示格式调整

在显示时段长度时，数据模型中使用秒来计算：

	@ReviewLog: id, empId, asrReqId, tm, t&
	
	- t: 审核时长(秒)

在前端展示如下：pageReviewLog.html

			<th data-options="field:'t', sortable:true, sorter:intSort">审核时长(秒)</th>

客户希望不要直接展示秒数，而是以“时：分：秒”的习惯方式来显示。

有两种解决方案：一是在后端做格式转换，二是在前端做（但如果考虑到导出操作，后端也需要做转换）。

### 后端调整字段显示格式

一般建议在后端做转换，这样查询和导出文件均可以兼顾：

	// 支持毫秒和秒转成 时:分:秒 格式
	function timeStr($t, $isSec=false)
	{
		$s = $isSec? $t: (int)($t / 1000);
		$h = (int)($s / 3600);
		$s -= $h * 3600;
		$m = (int)($s / 60);
		$s -= $m * 60;
		if ($h == 0)
			return sprintf("%02d:%02d", $m, $s);
		return sprintf("%02d:%02d:%02d", $h, $m, $s);
	}
	class AC2_ReviewLog extends AccessControl
	{
		...
		protected function onQuery() {
			$this->enumFields["t"] = function ($v, $row) {
				if ($v) {
					// 转格式
					return timeStr($v, true);
				}
			};
		}
	}

要注意，由于该列是整型，前端生成列时会以intSort来排序，这时应调整排序：

			<th data-options="field:'t', sortable:true">审核时长</th>

后端修改对排序不影响（当按t排序时在后端仍然是整数排序，不会按"时:分:秒"字符串来排）。
其实jd-web前端，在点击列头排序时，一般都是交给后端来排序，sorter字段不起作用；但对小于5条数据的列表排序有优化，这时不会发送后端（在本例中，将按显示的字符串排序，会有些小问题）。

### 前端调整字段显示格式

在某些情况下（比如，处理过于复杂，想节约后端的处理资源；或是为了兼容以前代码等），由前端为字段添加formatter来设置字段格式:  pageReviewLog.html

			<th data-options="field:'t', sortable:true, sorter:intSort, formatter:Formatter.t">审核时长(秒)</th>

在store.js中定义格式化函数t：

	var Formatter = {
		...
		t: function (val, row) {
			var h = Math.floor(val / 3600);
			val -= h*3600;
			var n = Math.floor(val / 60);
			val -= n*60;
			if (h == 0)
				return pad_2(n)+":"+pad_2(val);
			return h+":"+pad_2(n)+":"+pad_2(val);

			function pad_2(number)
			{
				return number < 10? ("0" + number) : ("" + number);
			}
		}
	}

这时，页面显示好看了，但有个问题：在导出excel文件时仍显示秒数。
这就需要在后端调整，用到enumFields为输出字段设置处理函数：api_objects.php

	class AC2_ReviewLog extends AccessControl
	{
		...
		protected function onQuery() {
			if ($this->isFileExport()) {
				// 这里与上一节的处理一样
				$this->enumFields["t"] = function ($v, $row) {
					if ($v) {
						// 转格式
						return timeStr($v, true);
					}
				};
			}
		}
	}

其中用isFileExport来判断是否是文件导出操作。

## 展示子表

示例图样：![](pic/01_使用子表.png)

- wui-subobj
- objParam传参
- 子表offline模式
- readonly对话框

### 通用子表示例

考虑订单表Ordr与订单明细表Ordr1，v5.4起框架支持添加对象时带子表。表如下：

	@Ordr: id, status, ...
	@Ordr1: id, orderId, itemId, qty, ...

定义添加接口：

	Ordr.add(status, ... @ordr1);

先实现后端支持子表：

	class AC2_Ordr extends AccessControl
	{
		protected $subobj = [
			"ordr1" => ["obj"=>"Ordr1", "cond"=>"orderId=%d", "AC"=>"AC2_Ordr1"]
		];
	}

	// 用于独立的子表查询
	class AC2_Ordr1 extends AccessControl
	{
	}

v5.5支持wui-subobj子表组件，管理端定义主表对话框时，使用wui-subobj组件加上子表表格：
(手册中搜索wui-subobj)

	<form my-obj="Ordr" title="订单" style="width:500px;height:400px;" wui-script="dlgOrdr.js" my-initfn="initDlgOrdr">
		...
		<div class="wui-subobj" data-options="obj:'Ordr1', relatedKey:'orderId', valueField:'orders', dlg:'dlgOrdr1'">
			<p><b>订单明细</b></p>
			<table>
				<thead><tr>
					<th data-options="field:'id', sortable:true, sorter:intSort">编号</th>
					<th data-options="field:'itemId', sortable:true, sorter:intSort">产品</th>
					<th data-options="field:'qty', sortable:true, sorter:numberSort">数量</th>
				</tr></thead>
			</table>
		</div>
	</form>

- obj, relatedKey, res(可选)用于生成子表查询，即调用`Ordr1.query`接口。
- dlg选项用于指定关联的明细对话框，用于添加、更新、查询等，若不指定则相当于只能看表格，即列表只读。
- valueField选项用于随着主表一起添加子表时的子表名字，即调用`Ordr.add()(..., orders)`接口。

若是简单的只读子表（不可添加、更新等），例如用于显示日志，则不必关联对话框：

		<div class="wui-subobj" data-options="obj:'Ordr1', relatedKey:'orderId', res:'id,itemId,qty'">
			<p><b>订单明细</b></p>
			<table>
				...
			</table>
		</div>

这时可以指定res字段，即query接口的res参数，可减少返回字段。

wui-subobj封装了常见操作，v5.5以前的实现见下节，可以了解其原理。
若对子表进行复杂的控制，例如随着主表一起添加，但添加后只读，参考后面例子。

### 通用子表示例(旧版)

（v5.5起可以用wui-subobj组件）

管理端定义主表对话框时，加上子表表格，使用notForFind类让它在查询模式下不显示：dlgOrdr.html

	<form my-obj="Ordr" title="订单" style="width:500px;height:400px;" wui-script="dlgOrdr.js" my-initfn="initDlgOrdr">
		...
		<div class="notForFind">
			<p><b>订单明细</b></p>
			<table id="tblOrdr1">
				<thead><tr>
					<th data-options="field:'id', sortable:true, sorter:intSort">编号</th>
					<th data-options="field:'itemId', sortable:true, sorter:intSort">产品</th>
					<th data-options="field:'qty', sortable:true, sorter:numberSort">数量</th>
				</tr></thead>
			</table>
		</div>
	</form>

管理端实现主表对话框时，在onShow时显示子表，注意添加模式时，应对子表对话框设置offline模式，即缓存子表列表，
在onValidate时设置主表字段newData.ordr1。在设置时，子表的CRUD是立即和独立完成的，不依赖于主表（即直接使用后端的AC2_Ordr1类）。 文件dlgOrdr.js：

	function initDlgOrdr()
	{
		...
		
		// 子表列表与子表对话框
		var jtbl = jdlg.find("#tblOrdr1");
		var jdlg1 = $("#dlgOrdr1");

		jdlg.on("beforeshow", onBeforeShow)
			.on("validate", onValidate);

		function onBeforeShow(ev, formMode, opt) 
		{
			...
			var forAdd = formMode == FormMode.forAdd;
			var forSet = formMode == FormMode.forSet;
			setTimeout(onShow);

			function onShow() {
				if (forAdd || forSet) {
					var orderId = opt.data.id;
					jdlg1.objParam = {
						orderId: orderId,  // 与子表对话框中wui-fix
						offline: forAdd  // 添加时主子表一起提交；更新时子表单独提交
					};
					jtbl.jdata().toolbar = forAdd && "ads"; // add/del/set
					var dgOpt = {
						toolbar: WUI.dg_toolbar(jtbl, jdlg1),
						onDblClickRow: WUI.dg_dblclick(jtbl, jdlg1),
						data: forAdd && [],
						url: forSet && WUI.makeUrl("Ordr1.query", {cond: "orderId=" + orderId})
					};
					jtbl.datagrid(dgOpt);
				}
			}
		}

		function onValidate(ev, mode, oriData, newData) 
		{
			if (mode == FormMode.forAdd) {
				// 添加时设置子表字段
				newData.ordr1 = jtbl.datagrid("getData").rows;
			}
		}
	}

子表对话框须将主表关联字段(此处即orderId字段)设置为wui-fixedField类，它表示在添加时将使用jdlg.objParam中相应字段：dlgOrdr1.html

		<tr>
			<td>编号</td>
			<td>
				<input name="id" disabled>
				<!-- 主表关联字段，设置隐藏，设置wui-fixedField类即可 -->
				<input name="orderId" class="wui-fixedField" style="display:none">
			</td>
		</tr>

### 只读子表示例

（v5.5起可以用wui-subobj组件，指定valueField，指定readonly:true即可实现多数功能。但细节操作比如onCrud不支持）

考虑一个典型的主-子表结构：库存记录表InvRecord保存总金额，及其子表“库存明细”InvRecord1，定义如下：

	库存记录（也可用于销售），记录出入库的时间、总金额等。
	@InvRecord: id, tm, type(s), whId, amount, cusId, discountId, empId, cmt(l), discRate@, tax@
	- type: Enum(出库，入库，报损，赠送，打包，拆包，销售, 调拨入库，调拨出库) 

	库存明细，记录每项物料(Item)的数量、金额等。
	@InvRecord1: id, invId, itemId, qty, curQty, price, itemName, taxRate@, total, noTaxTotal, dir
	- invId: 关联InvRecord.id

添加、编辑、查看库存记录时，使用如下接口：

	InvRecord.add()(type,whId,...,inv1)
	InvRecord.set()(dscr...)
	InvRecord.query/get() -> { ..., empName?, whName?, @inv1={itemId,qty,curQty, itemName, price} }

	- inv1 (add操作参数): List(itemId,qty,price?)。添加时，通过inv1指定子表，示例："101:3:180.00,102:2:200.00"
	- inv1 (query/get返回参数): 一个数组。
	- set接口不可更新子表。即当库存记录添加后，明细表不可编辑（应显示为只读）。

设计WEB管理端时，对主表仍是经典的列表页-详情对话框模式(pageInvRecord.html/js, dlgInvRecord.html/js)。

在详情对话框中展示明细子表：dlgInvRecord.html

	<form my-obj="InvRecord" wui-script="dlgInvRecord.js" my-initfn="initDlgInvRecord" title="出入库">
		<table>
			<tr>
				<td>编号</td>
				<td><input name="id" disabled></td>
			</tr>
			...
		</table>  

		<div id="divInvRecord1" class="notForFind">
			<p><b>商品明细</b></p>
			<table id="tblInvRecord1" style="width:auto;height:auto">
				<thead><tr>
					<th data-options="field:'itemName', formatter:Formatter.itemId">商品</th>
					<th data-options="field:'qty', formatter:WUI.formatter.number,styler: InvRecordColumns.typeStyler">数量</th>
					<th data-options="field:'curQty', formatter:WUI.formatter.number">剩余数量</th>
					<th data-options="field:'price', formatter:WUI.formatter.number">单价(含税)</th>				
					<th data-options="field:'total', formatter:WUI.formatter.number">总价</th>
					<th data-options="field:'noTaxTotal', formatter:WUI.formatter.number">不含税总价</th>
				</tr></thead>
			</table>
		</div>
	</form>

对话框在更新模式(forSet)下，显示子表数据，不可编辑；在查询模式(forFind)下，不显示子表；
在添加模式下(forAdd)，子表为空，可进行CRUD操作，且在操作时，自动重算主表金额： dlgInvRecord.js

	function initDlgInvRecord()
	{
		...
		// 用objParam给子表对话框 dlgInvRecord1 传参。
		var jdlg1 = $("#dlgInvRecord1");
		jdlg1.objParam = {
			offline: true, // 指定该项，则子表操作时将不会立即提交到数据库，可在validate事件中对整个表数据进行处理。
			onCrud:function () { // 在操作子表时回调，可用于在明细项改变时，重新计算主表amount值
				onUpdateAmount();
			}
		};
		var jtbl = jdlg.find("#tblInvRecord1");
		// 显示子表及工具栏（工具栏将在onShow里面再判断是否显示）
		// 注意：要在onShow中loadData，即使是空数据。否则可能表格行对不齐。
		jtbl.jdata().toolbar = "ads"; // add/del/set
		jtbl.datagrid({
			toolbar: WUI.dg_toolbar(jtbl, jdlg1),
			onDblClickRow: WUI.dg_dblclick(jtbl, jdlg1),
			data: []
		});

		// 加载时，根据query/get操作的inv1数组，显示子表数据（当添加时，显示空表，所以用[]）
		function onBeforeShow(ev, mode, opt)
		{
			var forAdd = mode == FormMode.forAdd;

			// 非添加模式下，隐藏子表工具栏，不允许操作（但可以双击一行查看明细，后面将设置这时子对话框只读）
			jtbl.closest(".datagrid").find(".datagrid-toolbar").toggle(forAdd);

			var inv1Arr = opt.data && opt.data.inv1 || [];
			
			setTimeout(onShow);
			function onShow() {
				// 显示子表
				jtbl.datagrid("loadData", inv1Arr);
			}
		}

		// 提交时（添加操作），生成InvRecord.add接口需要的inv1参数
		function onValidate(ev, mode, oriData, newData)
		{
			if (mode == FormMode.forAdd) {
				var inv1Arr = jtbl.datagrid("getData").rows;
				if (inv1Arr.length == 0) {
					WUI.app_alert("请添加商品明细!", "w");
					return false;
				}
				newData.inv1 = WUI.objarr2list(inv1Arr, ["itemId","qty","price"]);
			}
		}

		function onUpdateAmount() {
			// 重新计算主表amount值
			var inv1Arr = jtbl.datagrid("getData").rows,
				discRate = frm.discRate.value || 100,
				amount = 0;
			$.each(inv1Arr,function(k,v) {
				amount += ( v.price * v.qty * discRate / 100 ).toFixed(2) - 0;
			})
			frm.amount.value = amount;
		}
	}

子表对话框，在添加记录时可用，在查看记录时显示为只读： dlgInvRecord1.js (dlgInvRecord1.html没有特殊设置，略)

	function initDlgInvRecord1()
	{
		...
		function onBeforeShow(ev, mode, opt) {
			// 主表在添加时尚没有id，故根据id来判断是否需要只读
			var readonly = opt.data && opt.data.id !=null;
			jdlg.toggleClass("wui-readonly", readonly);
		}
	}

## 关联字段与关联子表

考虑商品（Item）与订单（Order）对象关系，或引申为活动项（Item）与活动报名（Order）对象关系：

	@Item: id, name
	@Ordr: id, name, userId, itemId
	@User: id, name, picId

需求：

- 用户查看商品时(Item.query/get)，显示该商品的总订单数、已下单该商品的用户的头像，并也标识当前用户是否已下过该商品的订单。
- 管理端查看商品列表时，可查看该商品的订单列表（或该活动的报名情况）。
 常用的交互设计是，一种办法是选择一行，点击表格上方工具栏中的“查看明细”按钮；第二种是在列表中显示订单数，订单数可点击，点击后打开该商品对应的订单列表。
 这里两种方式我们均示例实现。

管理端图样：

![](pic/02_关联a.png)
![](pic/03_关联b.png)

获取商品时，设计接口如下：

	Item.query() -> tbl(id, type, status, ..., orderId?, @orders?, orderCnt?)

	- orderId: AUTH_USER权限下可用, 用于标识当前用户是否下过单，如果当前用户参加过该活动（或购买过该商品），则返回最近一次订单的编号，否则返回null.
	- orderCnt: 该商品的总订单数（或引申为该活动的总报名数等）
	- orders: [{id, userId, userPicId}] 该商品的所有订单（或该活动的所有报名）。

为Item增加虚拟字段：api_objects.php

	// AC0常常用于定义通用的逻辑。然后AC1, AC2继承于它。
	class AC0_Item extends AccessControl
	{
		// 定义虚拟字段orderCnt
		protected $vcolDefs = [
			[
				"res" => ["(SELECT COUNT(*) FROM Ordr WHERE itemId=t0.id AND status<>'已取消') orderCnt"]
			]
		];

		// 定义子对象orders，注意userPicId又是Ordr对象的虚拟字段，由AC0_Ordr类负责定义。
		protected $subobj = [
			// use AC0_Ordr, 查询范围不受当前用户限制。
			"orders" => ["obj"=>"Ordr", "cond"=>"itemId=%d AND status<>'已取消'", "AC"=>"AC0_Ordr", "res"=>"id,userId,userPicId"]
		];
	}

	class AC1_Item extends AC_Item
	{
		// 定义虚拟字段orderId。由于与当前用户有关，所以放在onInit中动态添加。
		protected function onInit() {
			parent::onInit();
			$uid = $_SESSION["uid"];
			/* 注意：这样定义orderId比较易理解，但仅适用于一个用户对该商品最多有一个订单的情况。
			$this->vcolDefs[] = [
				"res" => ["o.id orderId"],
				"join" => "LEFT JOIN Ordr o ON o.itemId=t0.id AND o.userId={$uid}"
			];
			*/
			$this->vcolDefs[] = [
				"res" => ["(SELECT id FROM Ordr WHERE itemId=t0.id AND userId={$uid} ORDER BY id DESC LIMIT 1) orderId"]
			];
		}
	}

	class AC0_Ordr extends AccessControl
	{
		// 定义虚拟字段userPicId等。
		protected $vcolDefs = [
			[
				"res" => ["u.name userName", "u.phone userPhone", "u.storeId", "u.picId userPicId"],
				"join" => "INNER JOIN User u ON u.id=t0.userId",
				"default" => true
			]
		]
	]

在管理端展现orderCnt字段，并且可点击，点击后显示订单详情。
在table中添加一列：pageItem.html

			<th data-options="field:'orderCnt', sortable:true, sorter:intSort, formatter:ItemFormatter.orderCnt">订单数/报名数</th>

在pageItem.js中实现链接，点链接显示订单详情，最终调用order列表页的初始化函数 initPageOrder(objParam):

	var ItemFormatter = {
		orderCnt: function (value, row) {
			if (!value)
				return value;
			return WUI.makeLink(value, function () {
				var objParam = {type: row.type, itemId: row.id};
				WUI.showPage("pageOrder", "订单-商品" + objParam.itemId, [ objParam ]);
			});
		},
		/* 上面使用了WUI.makeLink函数生成html源码, 其原理与下面实现等同:
		orderCnt: function (value, row) {
			if (!value)
				return value;
			var p = JSON.stringify({type: row.type, itemId: row.id});
			p = p.replace(/"/g, '&quot;');
			return '<a href="javascript:ItemFormatter.orderCntClick(' + p + ');">' + value + '</a>';
		},
		// objParam: {type, itemId}
		orderCntClick: function (objParam) {
			WUI.showPage("pageOrder", "订单-商品" + objParam.itemId, [ objParam ]);
		}
		*/
	};

对于选择一行，点击查看明细，则更加简单：pageItem.js

	function initPageItem()
	{
		...
		// 自定义按钮
		var btn1 = {text: "查看明细", iconCls:'icon-ok', handler: function () {
			var row = WUI.getRow(jtbl);
			if (row == null)
				return;
			var objParam = {type: row.type, itemId: row.id};
			var name = '订单';
			...
			WUI.showPage("pageOrder", name + "-" + row.id, [ objParam ]);
			// 与点击链接的处理一样
			// ItemFormatter.orderCntClick(objParam);
		}};

		jtbl.datagrid({
			url: WUI.makeUrl("Item.query", param),
			toolbar: WUI.dg_toolbar(jtbl, jdlg, "export", btn1), // 工具栏上添加btn1按钮。
			...
		});
	}

订单页显示时，支持objParam参数用于传递过滤条件：pageOrder.js

	// objParam: {type, itemId?}
	function initPageOrder(objParam) 
	{
		...
		var param = null;
		if (objParam) {
			jdlg.objParam = objParam;
			param = WUI.getQueryParam(objParam);
		}
		jtbl.datagrid({
			url: WUI.makeUrl("Ordr.query", param),
			...
		});
	}

### 最先、最后关联问题

first/last问题。还可扩展到更通用的分组后组内排序问题。

本节较复杂，特别是在数据量大的场景下，各种场景应使用不同的解决方案，学习研究比较费时。

典型问题1：用户表User，订单表Ordr。求用户首次订单的时间、地点。User表是数千级别，Ordr表为数万级别。
典型问题2：列车表Hub, 列表数据HubData。求列车最近一次上传数据的时间和位置。Hub表为数百级别，HubData为数十万级别。

以问题2为例，提供多种方法，且适用场景均不同。
列车查询接口示例如下:

	Hub.query() -> tbl(id, ..., lastDataId?, lastTm?, lastPos?, @hubData?, %lastData?)

- hubData: elem={id,tm,pos}. 关联的列表数据。可用`param_hubData`指定查询条件，如`cond: "tm>='2020-1-1'"`。
 由于关联HubData表很大，只可用于get接口，不可用于query接口（否则有数据丢失风险，必须要用于query时，应加disableSubobjOptimize=1参数，效率较低）。
 hubData默认最多返回1000条。

- lastData: {id,tm,pos} 最近一次接收的数据。可用`param_lastData`指定查询条件。适合get/分页查询场景，不适合全表查询/导出等场景。
- lastData2: {id,tm,pos} 同上，最近一次接收的数据。可用`param_lastData`指定查询条件。适用于大量数据查询（如全表查询不分页时）。

- lastTm, lastPos: 最近一次数据。适用于少量数据查询（如get接口或分页的query接口），对于大量数据查询（如导出全表）性能差。
- lastTm2, lastPos2: 最近一次数据。适用于大量数据查询，实现原理与lastData2相同。

各种实现参考：

	class AC2_Hub extends AccessControl
	{
		protected $vcolDefs = [
			// 使用外部查询，性能不高，适合get接口或带分页的query接口（返回主表项在几十以内数量级的分页查询）。
			[
				"res" => ["(SELECT pos FROM HubData WHERE hubId=t0.id ORDER BY id DESC LIMIT 1) lastPos", "(SELECT tm FROM HubData WHERE hubId=t0.id ORDER BY id DESC LIMIT 1) lastTm"],
			],
			// 与lastData实现相同，适合全表查询或文件导出，用于get或只查几个时性能不同上面的外部查询。
			[
				"res" => ["data.pos lastPos2", "data.tm lastTm2"],
				"join" => "LEFT JOIN (SELECT hubId, MAX(id) hubDataId FROM HubData GROUP BY hubId) t1 ON t1.hubId=t0.id
	LEFT JOIN HubData data ON data.id=t1.hubDataId"
			],
			// 定义lastDataId，下面lastData实现中会引用
			[
				"res" => ["(SELECT MAX(id) FROM HubData WHERE hubId=t0.id) lastDataId"]
			],

			// 奇技淫巧级用法，取决于数据库实现。仅供参考，不建议作为产品实现
			[
				"res" => ["data1.pos lastPos3", "data1.tm lastTm3"],
				"join" => "LEFT JOIN (
	SELECT hubId, pos, tm FROM (SELECT * FROM HubData, (select @n:=0) t_ ORDER BY hubId,id DESC) HubData1 GROUP BY hubId
	) data1 ON data1.hubId=t0.id"
			]
		];
		protected $subobj = [
			// hubData仅用于get接口，本例中1:N关联关系中N过大，不可用于query接口，否则返回子对象可能不全
			"hubData" => ["obj"=>"HubData", "cond"=>"hubId=%d", "AC"=>"AC2_HubData", "res"=>"id,tm,pos", "orderby"=>"t0.id DESC"],

			// 使用了lastDataId虚字段(在vcolDefs中定义)，实现方式同lastPos/lastTm，适合get/分页查询场景，不适合全表查询/导出等场景。
			"lastData" => ["obj"=>"HubData", "%d"=>"lastDataId","cond"=>"id=%d", "AC"=>"AC2_HubData", "res"=>"id,tm,pos", "wantOne"=>true ]

			// 使用了LastHubData虚表，实现方式同lastPos2/lastTm2，但概念更清晰，适合全表查询/导出等场景。
			"lastData2" => ["obj"=>"HubData", "cond"=>"hubId=%d", "AC"=>"AC2_LastHubData", "res"=>"id,tm,pos", "orderby"=>"t0.id DESC", "wantOne"=>true ],

			// 仅供参考，不建议作为产品实现。lastData3只是hubData加上了wantOne属性（也可由前端直接使用hubData并指定wantOne），其限制同hubData
			"lastData3" => ["obj"=>"HubData", "cond"=>"hubId=%d", "AC"=>"AC2_HubData", "res"=>"id,tm,pos", "orderby"=>"t0.id DESC", "wantOne"=>true ]
		];
	}

	// 定义虚表，LastHubData与Hub表形成1:1关联关系。（Hub与HubData是1:N关联，且N很大）
	class AC2_LastHubData extends AccessControl
	{
		protected $table = "HubData";
		protected function onQuery() {
			if ($this->ac == "query") {
				$this->addJoin("JOIN (SELECT hubId, MAX(id) id FROM HubData GROUP BY hubId) t1 ON t1.id=t0.id");
			}
		}
	}
	

测试：

	callSvr("Hub.query", {res:"id,lastTm,lastPos,lastTm2,lastPos2,hubData,lastData"})
	callSvr("Hub.query", {
		res:"id,hubData",
		param_hubData: {cond: "tm>='2020-1-1'"}, // 指定子查询条件
	})
	callSvr("Hub.get", {
		id: 5,
		res:"id,lastTm,lastPos,lastTm2,lastPos2,hubData,lastData",
		res_hubData: "pos",
		param_hubData: {pagesz: 3}, // 取最近3条
		param_lastData: {res: "tm,pos"}
	})
	callSvr("Hub.query", {
		disableSubobjOptimize: 1, // 关联子对象多时，query接口有丢失数据风险，可以设置disableSubobjOptimize。一般不用于生产。
		res:"id,hubData lastData", // 返回时hubData改名lastData
		param_lastData: {wantOne:1}, // 取最新一条，从而与lastData2返回一样。
	})

方式一：
lastTm, lastPos使用外部关联字段，性能不高，适合返回主表项在几十级别（带分页的查询）。
而且，返回多个字段时会重复查询，在这个例子里，同时查lastTm和lastPos，则是两次独立查询。
另外，它只能用于返回最后（或最先）一条的情况，若要最后几条则不可以。

方式二：
hubData是子对象查询的实现，一次可返回多个字段，而且可指定返回的条数（wantOne或pagesz=1返回1条，用pagesz可指定返回多条）。
但这只适合于get接口。**本例中子查询不可用于query接口**。
对于query接口，可用于一般带分页的查询，一次返回主表项几十个的情况。
例如典型的主、子表场景：一次查询不超过100个订单（分页<100），一个订单带有最多几十行明细，或最多几十条订单日志。
不可用于总查询返回（主表项数乘以子表项数）超过千行的场景，因为会丢数据。虽可以通过调节子表的maxPageSz解决，但并不建议这样做。

lastData2的实现与其相同。在本例中，一个Hub对应的子表项HubData很多（数千或万级别），故不可将lastData用于query查询。
即使指定了wantOne，也会将关联子表数据全部查出再取第一行，导致数据易丢失。
这是因为有批量子查询优化机制，例如查询100条订单，每个订单1-10个明细行，默认只查2次，而无优化会查101次。
参考API文档中disableSubobjOptimize参数，可保证在query时也正确，但效率降低。

方式三：（分组后，组内按id排序问题求解）
lastData, lastTm2, lastPos2的实现通过两次关联查询实现。
它适合全表查询（或指定条件下的大量查询），典型场景是导出文件。
它与方式一结果相同，效率不同。100条以内方式一实现很快，数据多时本方式实现很快（如主、子表数据比为2000比20000的规模，方式一可能几十秒，方式三1秒左右）

方式四：（分组后，组内排序问题求解）
lastTm3, lastTm4的实现是方式三的泛化（由唯一索引扩展到非唯一索引），可解决一般的分组后组内查询问题，例如求最大值（非唯一索引列）所在的子表行。
此处的实现取决于数据库的实现，可能并不总是正确，但速度很快。这里用到变量，目的是禁用MySQL对ORDER BY的优化（ORDER BY外面再GROUP BY会导致ORDER BY不执行）。
sqlserver/oracle提供over PARTITION by机制。

### 示例：检测记录报表

车辆出厂检测的结果记录在下表中：

	@PdiRecord: id, tm, carId, result(2), empId

	- result: Enum(Y,N)

当车辆检测不通过时，维修完成后须再次检测。所以一辆车可能存在多个检测记录。
客户要求以下格式报表：

	PDI检测记录报表 2020/5/1 - 2020/6/1
	车型   检测车辆数  检测通过车辆数                      待处理车辆数
                       第一次通过  第二次通过  第三次通过	
	EX5    1000        995         3           1           1

对于车辆，我们关注它的最终检测结果(lastResult)和检测次数(pdiCnt)，所以提供这两个虚拟字段。后端实现(java):

	// class AC2_PdiRecord
		this.vcolDefs = asList( ... ,
			new VcolDef().res("t1.lastPdiId", "t0.result lastResult", "t1.pdiCnt")
				.join(String.join("\n", "JOIN (",
	"SELECT carId, MAX(id) lastPdiId, COUNT(*) pdiCnt",
	"FROM PdiRecord",
	"GROUP BY carId",
	") t1 ON t1.lastPdiId=t0.id"))
			);

通过按carId分组的t1表，再与原PdiRecord表JOIN，就可得到每辆车的最新状态了。
这时可以查询报表：

	callSvr("PdiRecord.query", {
		gres:"modelName, lastResult, pdiCnt", 
		res:"COUNT(*) totalCarCnt",
	});

得到这样的表头：`modelName/车型  lastResult/结果 pdiCnt/检测次数 totalCarCnt/车辆数`
其数据与客户要的表已经一致了，在形式上，只要将“结果”和“检测次数”转置到列上，就与客户要的表完成一致了。

前端实现：在pagePdiRecord列表页上添加报表按钮：

	var btnStat1 = {text: "检测记录报表", "wui-perm": "导出", iconCls:'icon-ok', handler: function () {
		var queryParams = jtbl.datagrid("options").queryParams;
		var url = WUI.makeUrl("PdiRecord.query", {
			gres:"modelName 车型, lastResult 检测结果=Y:通过;N:未通过, pdiCnt 检测次数", 
			res:"COUNT(*) 车辆数",
		});
		WUI.showPage("pageSimple", "检测记录报表!", [url, queryParams]);
	}};

## 树形结构展示 / treegrid

树状结构表设计中, 应有fatherId字段, 示例:
 
	@ItemType: id, name, level&, fatherId, disableFlag, picId

- fatherId: 为null表示顶级，否则指向父结点id.
- level: 层级, 从1开始. 按需定义, 不是必须的字段

在初始化页面时, 与datagrid类似: pageItemType.js

	var dgOpt = {
		// treegrid查询时不分页. 设置pagesz=-1. (注意后端默认返回1000条, 可设置放宽到10000条. 再多应考虑按层级展开)
		url: WUI.makeUrl("ItemType.query", {pagesz: -1}),
		toolbar: WUI.dg_toolbar(jtbl, jdlg),
		onDblClickRow: WUI.dg_dblclick(jtbl, jdlg)
	};
	// 用treegrid替代常规的datagrid
	jtbl.treegrid(dgOpt);

如果数据量非常大, 可以只显示第一层级, 展开时再查询.
仅需增加初始查询条件(只查第一级)以及一个判断是否终端结点的函数(否则都当作终端结点将无法展开):

	var dgOpt = {
		queryParams: {cond: "fatherId is null"},
		isLeaf: function (row) {
			return row.level>1;
		},
		...
	};
	jtbl.treegrid(dgOpt);

## 角色定义

角色包括系统**内置角色**和**自定义角色**. 

默认内置角色有:

- mgr: 最高管理员, 有系统设置权限, 查看无限制
- emp: 管理员, 只能查看自己的内容

如果要添加内置角色, 先在后端定义新角色: api.php

	const PERM_QMGR = 0x200; // 质量管理员
	function onGetPerms()
	{
		...
		if (isset($_SESSION["empId"])) {
			$perms |= AUTH_EMP;

			$p = @$_SESSION["perms"];
			if (is_array($p)) {
				...
				// 设置角色. 注意虽然名称是PERM_XXX像是权限, 实际上这里不区分权限和角色.
				if (array_search("qmgr", $p) !== false)
					$perms |= PERM_QMGR;
			}
		}
	}
	// 后端用hasPerm判断权限
	if (hasPerm(PERM_QMGR)) {
	}

前端一般先设置菜单可见性, 用perm-xxx类或nperm-xxx类为菜单项做设置, perm-xxx表示该角色可看; nperm-xxx表示该角色不可看. store.js:

	<div class="perm-mgr perm-qmgr perm-pdimgr" style="display:none">
		<div class="menu-expand-group">
			<a class="expanded"><span><i class="fa fa-pencil-square-o"></i>运营管理</span></a>
			...
		</div>
	</div>
	<div class="nperm-pdi">
		<a href="javascript:showDlgChpwd()"><span><i class="fa fa-user-times"></i>修改密码</span></a>
	</div>

前端页面中一般用g_data.hasPerm做判断: pageXXX.js / dlgXXX.js

	if (g_data.hasPerm("mgr") || g_data.hasPerm("qmgr")) {
		...
	}


自定义角色一般只做前端菜单限制.
须先将role插件引入(根据其说明文档配置好), 然后直接由最高管理员(mgr权限用户)在角色管理中配置即可.

## 批量导入 / 初始化导入

需求：导入商户及其LOGO图。

要点：

- 用upload接口批量上传文件，以及upload插件下的gen_upload, simiar_join工具将图片id与原表关联起来，形成完整的表供导入。
- 用batchAdd接口批量导入。

表定义如下：

	@Store: id, name, addr, picId

先准备好非图片部分的表，存为store.csv (均使用utf-8编码)

	商户名,商户地址
	丽传文化传媒,三期1101
	发哲文化传播,三期1102
	...

### 批量上传文件

通过upload接口批量上传，得到图片（缩略图）id列表，进而得到`图片文件名,图片id`为标题的对应表。

先创建一个文件列表list.txt：

	find . -name "*.jpg" | tee list.txt

list.txt示例：

	./一二三四期logojpg/一期租户LOGO/上海丽传文化传媒有限公司.jpg
	./一二三四期logojpg/一期租户LOGO/上海发哲文化传播有限公司.jpg

对于图片，为了避免图片尺寸太大导致服务端无法压缩处理（过大图片如6000万像素，处理它需要512M内存，一般php默认只设置128M，可处理6000x4000=2400万像素），可先压缩再上传
(convert/identify为imagemagick软件包中的命令)

	# 查看1M以上的图片
	find . -name '*.jpg' -size +1M -exec identify '{}' \; | tee 1.log
	# 压缩到不超过1280像素
	find . -name '*.jpg' -size +1M -exec convert '{}' -resize 1280 '{}' \; | tee 2.log

以list.txt为基础生成curl命令行，可用工具gen_upload工具，

	php plugin/upload/tool/gen_upload.php list.txt 10 > 1.sh

传入10表示一批传10个文件，避免一次性传太多超过服务器限制，根据文件大小可调整该参数。请检查下服务器上传相关配置，比如查看`tool/init.php`：

	http://localhost/p/jdcloud/tool/init.php

示例：

	上传文件设置	upload_max_filesize=64M, post_max_size=64M, max_execution_time=300

生成命令行大致如下，再修改upload接口参数、验证密码等。

	curl -s \
	-F "file1=@./一二三四期logojpg/一期租户LOGO/上海丽传文化传媒有限公司.jpg" \
	-F "file2=@./一二三四期logojpg/一期租户LOGO/上海发哲文化传播有限公司.jpg" \
	"http://localhost/p/jdcloud/api.php/upload?autoResize=300&genThumb=1" -H "x-daca-simple: 1234" 

执行它，检查结果是否全部成功，并从结果中取出返回的图片thumbId或id:

	./1.sh | tee 1.log

看到结果：1.log

	[0,[{"id":29,"orgName":null,"size":74203,"thumbId":29},{"id":30,"orgName":null,"size":265427,"thumbId":30},...]]
	...

在vim中取出所有thumbId值示例：

	:%s/\v\_.{-}"thumbId":(\d+)/\1\r/gc

它将json等数据转成了：

	29
	30
	...

将结果列并入文件列表list.txt，修改后形成一个新表：table1.txt

	图片名	图片编号
	上海丽传文化传媒有限公司	100
	上海发哲文化传播有限公司	101

再通过similar_join.php工具，将新表table1.txt与原表store.csv做'join'，注意文件均是utf-8编码，格式可以是csv或tsv(逗号或tab分隔的文本):
运行前最好打开similar_join工具里面设置下参数`$RE_DEL`，删除相同的短语以减少错误匹配：

	php plugin/upload/tool/similar_join.php store.csv table1.txt 1 0 | tee result.csv
	(表示store.csv的第1列匹配table1.txt的第0列，输出csv文件)

得到 result.csv

	商户名称,地址,图片名,图片编号
	丽传文化传媒,三期1101,上海丽传文化传媒有限公司,100
	发哲文化传播,三期1102,上海发哲文化传播有限公司,101

### 批量导入 - batchAdd

(v5.4) 超级管理端(web/adm.html)中带有导入工具. 登录后打开"批量导入"对话框:

- 在"导入类型"中选择"自定义"
- 填入对象名, 本例填 "Store"
- 视情况修改或删除参数. 本例填 "title=name,addr,-,picId", 定义与首行标题与数据库字段的对应, "-"表示该列不需要.
- 选择csv文件, 或直接复制文件内容到下方内容框
- 最好打开F12检查网络请求, 点击"确认"执行导入并查看结果.

也可以在浏览器控制台中直接调用导入接口。
打开管理端，登录后打开控制台，调用batchAdd接口导入数据：

	// 用反引号``赋值大量数据，第一行须为标题
	var data = `商户名称,地址,图片名,图片编号
	丽传文化传媒,三期1101,上海丽传文化传媒有限公司,100
	发哲文化传播,三期1102,上海发哲文化传播有限公司,101`;

	// 用title定义列映射，无须导入的列用"-"标识。
	callSvr("Store.batchAdd", {title: "name,addr,-,picId"}, function (ret) {
		app_alert("成功导入" + ret.cnt + "条数据！");
	}, data, {contentType:"text/plain"});

也可以用curl工具导入：

	#/bin/sh
	baseUrl=http://localhost/p/jdcloud/api.php
	curl -v -F "file=@result.csv" "$baseUrl/Store.batchAdd?title=name,addr,-,picId"

### 定制批量导入 - BatchAddLogic

示例，定义任务表，一个订单(Task.orderId是外键)关联多个任务(Task):

	@Task: id, orderId, city, brand, vendorId, storeId

	- vendorId: 供应商编号，映射Vendor.id
	- storeId: 门店编号，映射Store.id

要导入任务，已知orderId字段值，导入表的表头为：`city, brand, vendorName, storeName`

其中vendorName和storeName字段需要通过查阅相关表修正为vendorId和storeId字段。
如果供应商不存在（找不到vendorId），应报错；如果门店不存在（找不到storeId），则自动以storeName添加门店。

以上逻辑一般可以用add接口的onValidate回调来处理，做name到id的转换：

	Task.add(orderId)(city, brand, vendorName, storeName)

调用通用的batchAdd接口，它会自动对每行内部调用add接口。

这里介绍另一种方法，即定制batchAdd接口，在导入性能需要调优等场景下可以考虑它:

	Task.batchAdd(orderId)(city, brand, vendorName, storeName)

实现示例：在api_objects.php添加导入处理逻辑 TaskBatchAddLogic

	class TaskBatchAddLogic extends BatchAddLogic
	{
		function __construct () {
			// 每个对象添加时都会用的字段，加在$this->params数组中
			$this->params["orderId"] = mparam("orderId", "G"); // mparam要求必须指定该字段, "G"表示通过GET传参
		}

		// $params为待添加数据，可在此修改，如用`$params["k1"]=val1`添加或更新字段，用unset($params["k1"])删除字段。
		// $row为原始行数据数组。
		function beforeAdd(&$params, $row) {
			// 检查必填字段vendorName, storeName
			checkParams($params, [
				"vendorName" => "供应商",
				"storeName" => "商户"
			]);

			$vendorId = queryOne("SELECT id FROM Vendor", false, ["name" => $params["vendorName"]] );
			if (!$vendorId) {
				throw new MyException(E_PARAM, "请添加供应商", "供应商未注册: " . $params["vendorName"]);
			}
			// 将vendorName换成vendorId字段：
			$params["vendorId"] = $vendorId;
			unset($params["vendorName"]);
		
			// storeName -> storeId
			$storeId = queryOne("SELECT id FROM Store", false, ["name" => $params["storeName"]] );
			if (!$storeId) {
				$storeId = callSvcInt("Store.add", null, [
					"name" => $params["storeName"]
				]);
			}
			$params["storeId"] = $storeId;
			unset($params["storeName"]);
		}

		// 可选回调函数：处理原始标题行数据, $row1是通过title参数传入的标题数组，可能为空. 一般用的比较少
		function onGetTitleRow($row, $row1) {
		}
	}

	// 在Task类中应用导入逻辑
	class AC2_Task extends AC0_Task
	{
		function api_batchAdd() {
			$this->batchAddLogic = new TaskBatchAddLogic();
			return parent::api_batchAdd();
		}
	}

如果导入表很大，导入较慢，且供应商重复很多，可以通过SimpleCache类来缓存结果优化性能，示例如下：

	class TaskBatchAddLogic extends BatchAddLogic
	{
		protected $vendorCache = [];

		function beforeAdd(&$params, $row) {
			...
			if (! $this->vendorCache)
				$this->vendorCache = new SimpleCache(); // tel=>vendorId
			// 通过缓存优化：如果缓存中存在，则不再查询，直接使用；否则查询数据库并插入缓存中：
			$vendorId = $this->vendorCache->get($params["vendorName"], function () use ($params) {
				$id = queryOne("SELECT id FROM Vendor", false, ["name" => $params["vendorName"]] );
				if (!$id) {
					throw new MyException(E_PARAM, "请添加供应商", "供应商未注册: " . $params["vendorName"]);
				}
				return $id;
			});
			...
		}
	}

## 批量导入 - 管理端设计

需求：在管理端中开放批量导入员工。

在超级管理员中内置了导入对话框的例子：server/web/adm/dlgImport.html(.js)
可将对话框的html/js复制到管理端：server/web/page/下面。

在菜单中添加导入对话框：

				<a href="javascript:WUI.showDlg('#dlgImport',{modal:false})">批量导入</a>

dlgImport可以支持多类对象的导入。例如：要定制Employee的导入，只须在dlgImport.html中定义导入模板：

	<script type="text/template" class="tplEmployee">
	!title=uname,phone,name,perms
	登录名	手机号	姓名	权限
	admin	12345678901	管理员	mgr
	test1	12345678902	运营人员1	
	</script>

一般习惯在相应对象的列表页中添加导入按钮，只需要添加"import"指令：pageEmployee.js，函数 initPageEmployee中

	jtbl.datagrid({
		toolbar: WUI.dg_toolbar(jtbl, jdlg, ..., "import"),
	});

可以直接用"import"是因为框架定义了dg_toolbar.import函数。
其原理如下，若要定制导入操作可以效仿这里代码：pageEmployee.js

	var jtbl = jpage.find("#tblEmployee");
	var btnImport = {text: "导入", "wui-perm": "新增", iconCls:'icon-ok', handler: function () {
		DlgImport.show({obj: "Employee"}, function () {
			// 导入后刷新列表
			WUI.reload(jtbl);
		});
	}};

	jtbl.datagrid({
		toolbar: WUI.dg_toolbar(jtbl, jdlg, ..., btnImport),
	});

## 定时任务开发与设置

需求：已发布的活动如果过期，应自动关闭。

解决方案：

每天定时扫描过期活动，将其状态设置为“已完成”。
在tool/task.php中添加一个任务，名为`ac_dailyWork`:

	function ac_dailyWork()
	{
		// 定时关闭过期活动
		$cnt = dbUpdate("Item", [
			"status" => "已完成"
		], [
			"type" => "活动",
			"status" => "发布中",
			"tm2<=" . Q(date(FMT_DT))
		]);
		echo("=== Auto close $cnt Items\n");
	}

测试执行可以用：

	php task.php dailyWork

在tool/task.cron.php中配置定时器，本例可添加如下一行：

	10 1 * * * $TASK dailyWork >> $LOG 2>&1

上面表示每天凌晨1:10执行dailyWork任务。日志记录到$LOG（一般是tool/task.log)

定时任务使用的是Linux的crontab机制，时间配置格式为：

	分钟(0-59) 小时(0-23) 日(1-31) 月(1-12) 星期几(0-7,0或7是周日)

示例：

	10 2 * * *	 每天2:10

其它格式："2,4,6"表示2时，4时和6时，"2-10/2"表示2:00-10:00每两小时。

上线后需要在服务器上安装定时任务：进入tool目录执行`php task.crontab.php`生成一串文本，再运行crontab -e编辑计划任务，将刚刚生成的文本复制过来即安装好。

详细设置可参考tool/task.crontab.php中的注释说明。
原理请查阅Linux crontab机制。

此机制不支持执行秒级轮询任务（也不建议用于过于频繁的轮询类任务如每分钟检测），这类需求一般还是自行开个进程（可设置做为daemon进程）轮询解决。

## 与外部页面通信

需求: 在管理端列表上选择一行点击"审核", 打开一个新的审核页面, 点击"审核完成"按钮, 会设置状态值. 
要求在回到管理端WEB应用时, 能自动刷新列表, 以便显示正确的状态.

解决方案: 通过storage变量做为"信号量"来通信. 在新打开的外部页面中, 当点击审核完成后, 设置一个storage变量. 
在回到管理端中, 监控focus事件并刷新列表.

示例: 审核完成后, 设置信号量. m2/emp/videoDetail.js

		onReviewComplete: function (ev) {
			callSvr("AsrReq.set", {id: this.obj.id}, function () {
				MUI.setStorage("AsrReqReload", that.obj.id);
				...
			}, {doneFlag: 1});
		}

在管理端列表中: web/page/pageAsrReq.js

	function initPageAsrReq() 
	{
		var jpage = $(this);
		var jtbl = jpage.find("#tblAsrReq");
		...
		jpage.on("checkSignal", function () {
			var val = WUI.getStorage("AsrReqRefresh");
			if (val) {
				WUI.delStorage("AsrReqRefresh");
				WUI.reload(jtbl);
			}
		});
		...
	}

	$(window).off("focus.pageOrder").on("focus.pageOrder", function () {
		$(".wui-page.pageAsrReq").trigger("checkSignal");
	});

注意: 监听window的focus事件, 没有放在pageinit函数中去做, 而且绑定前先做off, 可确保只绑定一次. (而pageinit函数每次都打开都会执行)
下面这样写法是有问题的:

	function initPageAsrReq() 
	{
		var jpage = $(this);
		var jtbl = jpage.find("#tblAsrReq");
		...
		// 错误! 如果页面被remove掉, 其内部的变量或DOM元素访问很可能出问题. 可以用`jtbl.prop("isConnected")`来判断DOM是否被删除, 但该属性较新, 存在兼容性问题.
		// 更好的做法是由jpage来绑定自定义事件, 当jpage被remove时, jQuery会自动删除其所有事件, 不会造成问题
		$(window).on("focus.pageOrder", function () {
			...
			WUI.reload(jtbl);
		});
		...
	}

### 绑定事件后可能删除问题

初始化echart组件显示统计报表时, 当窗口大小变化时, 希望重绘echart组件, 常常代码像这样:

	function initChart(chartTable, statData, seriesOpt, chartOpt)
	{
		...
		// TODO: 何时删除事件？
		$(window).on('resize', function () {
			myChart.resize();
		});
	}

上面代码会一直添加事件绑定. 当echart所有DOM被删除或重新初始化时, 都有潜在问题.
下面是解决方案: echart所在DOM自身来监听事件(而不是直接用window来监听事件), 且先调用off保证只监听一次, 这样保存它在删除或多次初始化后也没有问题.

	function initChart(chartTable, statData, seriesOpt, chartOpt)
	{
		...
		$(chartTable).addClass("jd-echart").off("doResize").on("doResize", function () {
			myChart.resize();
		});
	}
	$(window).on('resize.echart', function () {
		$(".jd-echart").trigger("doResize");
	});

## 管理端对话框多列布局

默认管理端对话框是2列布局, 即"字段名 字段值". 
在字段很多时, 也可以在一行中定义4列, 并把字段分组显示.

示例：物流订单对话框中分组显示字段, 按4列布局, 以及显示子表.

	<form my-obj="Ordr" wui-script="dlgOrder.js" my-initfn="initDlgOrder" title="物流订单" style="width:750px;height:750px;">  
		<table>
			<!-- 一个分组 -->
			<tr>
				<td colspan=4>
					<div class="form-caption"><hr>订单基本信息</div>
				</td>
			</tr>
			<tr>
				<td>订单编号</td>
				<td><input name="id" disabled></td>
				<td>订单类型</td>
				<td><input name="type" class="my-combobox" data-options="jdEnumList:'包车发运;散货发运;其他'"></td>
			</tr>
			<tr>
				<td>客户</td>
				<td colspan=3>
					<select name="customerId" class="my-combobox" data-options="ListOptions.Customer()"></select>
				</td>
			</tr>
			<!-- 另一个分组 -->
			<tr>
				<td colspan=4>
					<div class="form-caption"><hr>客户结算信息</div>
				</td>
			</tr>
			...
			<!-- 无名分组 -->
			<tr>
				<td colspan=4>
					<div class="form-caption"><hr></div>
				</td>
			</tr>
		</table>

		<div class="form-caption"><hr>订单明细信息</div>

		<table id="tblOrder1" width="100%">
			<thead><tr>
				<th data-options="field:'dispatchId', formatter:Formatter.dispatchId">调度单</th>
				<th data-options="field:'brand'">商品车品牌</th>
				...
			</tr></thead>
		</table>
	</form>

## 对话框示例 / WUI.showDlg

需求：财务每月均会录入每个员工基本工资、天数（即出勤天数）、备注等信息。
为了方便录入，希望系统可自动根据上月数据给出所有人员工资表，财务只需要调整每人的出勤天数等字段后，即可批量录入。


设计：工资列表为pageSalary，在表头上添加一个“复制最近”按钮，点击则打开一个对话框dlgCopy，可查询和展示上月工资列表，
且表格每行可进行编辑（可复用工资列表的对话框dlgSalary，但要注意在点确定后不要立即操作数据库，即需要设置对话框的offline模式），全部编辑完成后，点击确定，调用批量添加接口Salary.batchAdd()({list})，然后刷新主表pageSalary。

（还有另一种复制行/粘贴行的设计操作和开发更方便，但须添加数据后再调用，下节介绍）

实现：

在工资表中添加操作按钮，可打开对话框dlgCopy，且在批量添加后刷新列表数据：pageSalary.html

	function initPageSalary() 
	{
		...
		var btn3 = {text: "复制最近", iconCls:'icon-ok', handler: function () {
			WUI.showDlg("#dlgCopy", {
				onOk: function () {
					WUI.reload(jtbl);
				}
			});
		}};
		...
		jtbl.datagrid({
			toolbar: WUI.dg_toolbar(jtbl, jdlg, ..., btn3),
			...
		});
	}

注意：按钮的权限取决于名字，也可以特别设置**wui-perm**属性，往往直接使用内置权限如“新增”，“删除”，“设置”，“导出”等：

		var btn3 = {text: "复制最近", "wui-perm": "新增", iconCls:'icon-ok', handler: function () {...} }

系统弹出带可编辑列表的对话框：dlgCopy.html:

	<form title="复制工资" wui-script="dlgCopy.js" my-initfn="initDlgCopy" style="width:800px; height:500px">
		<table id="tblSalary">
			<thead><tr>
				<th data-options="field:'empName', sortable:true">员工</th>
				<th data-options="field:'年月', sortable:true">年月</th>
				<th data-options="field:'基本工资', sortable:true, sorter:numberSort">基本工资</th>
				<th data-options="field:'天数', sortable:true, sorter:numberSort">天数</th>
				<th data-options="field:'备注', sortable:true, sorter:numberSort">备注</th>
			</tr></thead>
		</table>
	</form>


dlgCopy.js:

	function initDlgCopy()
	{
		var jdlg = $(this);
		var jtbl = jdlg.find("#tblSalary");

		jdlg.on("show", onShow)
			.on("validate", onValidate);

		function onShow(ev, formMode, opt) 
		{
			var jdlg = $("#dlgSalary");
			jdlg.objParam = {
				offline: true
			};
			// 只能修改或删除
			jtbl.jdata().toolbar = "ds";
			jtbl.datagrid({
				url: WUI.makeUrl("Salary.query", {q: "last"}), // 取上月数据
				toolbar: WUI.dg_toolbar(jtbl, jdlg),
				onDblClickRow: WUI.dg_dblclick(jtbl, jdlg),
	// 			pagination: false,
	// 			fitColumns: true
				loadFilter: function (data) {
					// 处理数据并展示
					var data1 = $.fn.datagrid.defaults.loadFilter.call(this, data); // 已由框架将table格式处理成datagrid的格式: {total, rows}
					data1.rows.forEach(function (row) {
						// 清空部分数据，比如清除原始的id，避免重复添加出错; 清除创建日期dt，在添加时设置成当前日期。
						var cols = ["id", "备注", "dt"];
						cols.forEach(function (k) {
							delete row[k];
						});
						// 修改部分数据：如年月从 201910 变成 201911
						row.年月 = (row.年月 % 100 == 12? row.年月+89: row.年月+1);
					});
					return data1;
				},
			});
		}

		// 点击确定时，做批量添加
		function onValidate() {
			var data = $.extend(true, {}, jtbl.datagrid("getData"));
			data.rows.forEach(function (row) {
				// 删除添加接口中不需要的数据
				delete row.empName;
			});
			return callSvr("Salary.batchAdd", function (data) {
				app_alert("添加" + data.cnt + "条数据!");
				WUI.closeDlg(jdlg);
			}, {list: data.rows} );
		}
	}

### 复制行/粘贴行

仍然是上面的例子，设计成在工资表上添加两个按钮：“复制行”和“粘贴行”，实现上述类似功能：

- 可单选或多选行，点“复制行”，右下角弹出提示已复制几行。
- 再点粘贴行，则批量添加这些行，添加前须用户确认，添加后需提示添加了几条。添加时可加些自定义的逻辑，比如清空或设置数据。

	var btn4 = {text: "复制行", iconCls:'icon-ok', handler: function () {
		var rows = jtbl.datagrid("getSelections");
		// 把数据暂存于此：
		jpage.jdata().copy = rows;
		WUI.app_show("复制" + rows.length + "行");
	}};
	var btn5 = {text: "粘贴行", iconCls:'icon-ok', handler: function () {
		var rows = $.extend(true, [], jpage.jdata().copy);
		if (rows.length == 0)
			return;
		app_alert("粘贴添加" + rows.length + "行数据?", "q", function () {
			rows.forEach(function (row) {
				// 删除不适合add接口的参数：
				var cols = ["id", "备注", "empName", "disableFlag"];
				cols.forEach(function (k) {
					delete row[k];
				});
				row.年月 = (row.年月 % 100 == 12? row.年月+89: row.年月+1);
			});
			callSvr("Salary.batchAdd", function (data) {
				WUI.app_show("添加" + data.cnt + "条数据!");
				WUI.reload(jtbl);
			}, {list: rows} );
		});
	}};

	jtbl.datagrid({
		url: WUI.makeUrl("Salary.query"),
		toolbar: WUI.dg_toolbar(jtbl, jdlg, "export", ..., btn4, btn5),
		...
	});

## 管理端下拉列表组件 wui-combogrid

示例：在dialog上，填写门店字段（填写Id，显示名字），从门店列表中选择一个门店。

由于门店非常多，如果用my-combobox组件，操作很不方便，且最大一般只显示1000条，查询也不友好。
使用wui-combogrid(基于easyui-combogrid组件封装)，录入时将匹配结果在表格中展现，由于是实时查询且支持分页，不受数据量大小的限制。

在逻辑页上添加wui-combogrid: dlgTask.html

	<form my-obj="Task" title="安装任务" wui-script="dlgTask.js" my-initfn="initDlgTask">
		<tr>
			<td>门店</td>
			<td>
				<input class="wui-combogrid" name="storeId" data-options="ListOptions.StoreGrid">
			</td>
		</tr>
	</form>

选项定义如下：全局store.js

	ListOptions.StoreGrid = {
		jd_vField: "storeName",
		panelWidth: 450,
		width: '95%',
		textField: "name",
		columns: [[
			{field:'id',title:'编号',width:80},
			{field:'name',title:'名称',width:120}
		]],
		url: WUI.makeUrl('Store.query', {
			res: 'id,name',
		})
	};

属性请参考easyui-combogrid相关属性。wui-combogrid扩展属性如下:

- jd_vField: 显示文本对应的虚拟字段, 用于初始显示和查询。
- jd_showId: 默认为true. 显示"idField - textField"格式. 设置为false时只显示textField.

在输入时，它会自动以url及参数q向后端发起查询，如`callSvr("Store.query", {res:'id,name', q='1'})`.

在筋斗云后端须支持相应对象的模糊查询(请查阅文档qsearch)。api_objects.php

	class AC2_Store extends AccessControl
	{
		protected function onQuery()
		{
			// 指定要搜索的字段数组
			$this->qsearch(["id","name"], param("q"));
		}
	}

如果要处理从表格选择后的结果，可以用choose事件：

	var jo = jdlg.find("[comboname=storeId]"); // 注意不是 "[name=storeId]"（原始的input已经变成一个hidden组件，只存储值）
	jo.on("choose", function (ev, row) {
		console.log('choose row: ', row);
		...
	});

或是直接取数据：

	var row = jo.combogrid("grid").datagrid("getSelected");

获得选择的行。注意：在未选择时它可能为null.

## 统计表显示与导出

- 后端q=stat生成统计表
- 前端pageSimple，通用报表显示与导出。

在生产过程列表中，提供按钮，点击显示“工作量日统计表”，并可以导出。

设计：可以由后端生成统计表(中文字段)，前端只须直接显示；也可以由前端直接拼出字段。
对象设计如下，SnLog表示工件日志（即生成过程）：

	@SnLog: id, mh, ...
	虚拟字段vcol: totalOrderCnt/总工单数, totalSnCnt/总工件数, totalMh/总理论工时

接口如下：

	前端自行调用：
	SnLog.query(gres:"y 年,m 月,d 日", res:"totalOrderCnt 工单数, totalSnCnt 工件数, totalMh 理论工时") -> tbl(年,月,日,工单数,工件数,理论工时,...)

	后端直接拼好：
	SnLog.query(q=stat, t=ymd, cond?) -> tbl(年,月,日,工单数,工件数,理论工时,...)

后端会直接设置好分组字段、输出字段(res/gres等)，允许前端传入cond过滤条件。

后端实现totalOrderCnt等虚拟字段：

	class AC2_SnLog extends AccessControl
	{
		protected $requiredFields = ["procId", "stationId"];
		protected $vcolDefs = [
			[
				"res" => ["proc.name procName", "proc.mh"],
				"join" => "LEFT JOIN WorkProc proc ON proc.id=t0.procId",
				"default" => true
			],
			[
				"res" => ["SUM(proc.mh * t0.snCnt) totalMh"],
				"require" => "mh"
			],
			[
				"res" => ["COUNT(DISTINCT sn.orderId) totalOrderCnt", "SUM(t0.snCnt) totalSnCnt"],
				"require" => "orderId"
			],
			...
		]
	}

后端实现统计表：

		protected function onInit()
		{
			if (param("q") == "stat") {
				$tmUnit = param("t");
				if ($tmUnit == "ymd")
					setParam("gres", "y 年,m 月,d 日");
				else if ($tmUnit == "ym")
					setParam("gres", "y 年,m 月");
				setParam("res", "totalOrderCnt 工单数, totalSnCnt 工件数, totalMh 理论工时, totalMh1 实际工时, totalMh2 出勤工时");
			}
		}

前端利用pageSimple通用列表页，可无须为每个统计表添加新的页面，它将根据统计表的字段自动显示。
前端在SnLog列表中添加操作按钮：

	// function initPageSnLog() 
	// 示例1：由后端生成完整报表
	var btnStat1 = {text: "日统计", iconCls:'icon-ok', handler: function () {
		var queryParams = jtbl.datagrid("options").queryParams;
		var url = WUI.makeUrl("SnLog.query", { q: 'stat', t: 'ymd' });
		WUI.showPage("pageSimple", "工作量日统计!", [url, queryParams]);
	}};
	// 示例2：由前端指定字段生成报表
	var btnStat2 = {text: "月统计", iconCls:'icon-ok', handler: function () {
		var queryParams = jtbl.datagrid("options").queryParams;
		var url = WUI.makeUrl("SnLog.query", { gres: "y 年, m 月", res: "totalOrderCnt 工单数, totalSnCnt 工件数, totalMh 理论工时, totalMh1 实际工时, totalMh2 出勤工时" });
		WUI.showPage("pageSimple", "工作量月统计!", [url, queryParams]);
	}};

	jtbl.datagrid({
		...
		toolbar: WUI.dg_toolbar(jtbl, jdlg, ..., btnStat1, btnStat2),
	})

注意：调用WUI.showPage时，若标题以"!"结尾，则每次都重新打开页面。pageSimple.js中也有参考例子。

## 移动端部署与应用优化

在过去，为了优化移动端应用的加载体验，框架提供webcc工具，用于“缓存优化”和“JS/CSS优化”（即合并压缩）等。详细可参考文档：
http://oliveche.com/jdcloud-site/jdcloud-tool.html

webcc是需要将源码编译生成发布目录的，为了更方便的直接以源码部署，已经不太使用了。

使用源码部署，只能放弃了“缓存优化”。
在server/m2/.htaccess中包含有apache缓存配置，过去是只有html不缓存，现在是html/js/css都不缓存，以避免修改源码后客户得不到及时更新。

对于“JS/CSS优化”目前建议是这样来做：

在server/m2/Makefile中定义了需要优化合并的js/css文件。
应用中引用的大量库，都应添加到这里来。而原先引入这些js/css的地方，应改为：

	<!--link rel="import" href="lib.html" /-->
	<link rel="stylesheet" href="lib.min.css" />
	<script src="lib.min.js"></script>

如果库文件有改动，应运行`make`命令重新生成`lib.min.js`, `lib.min.css`文件。工具同时还会生成lib.html文件，包含所有的原始js/css文件，便于调试时使用。

类似的，对于cordova插件，也做了合并优化。
这带来一个问题，框架原先是自动加载`cordova/cordova.js`文件的，怎样让它自动加载新的`lib-cordova.min.js`文件呢？
为了解决这个问题，在生成lib.min.js时，自动加了g_args.mergeJs变量，让框架根据它来识别是是否做了优化，以加载正确的文件。

	@echo "g_args.mergeJs=1;" >> lib.min.js

注意以后对库的任何改动，是要用make编译后才能生效了。

这在调试内部库时是比较麻烦的，解决方法是在调试时，用自动生成的lib.html文件的内容替换掉lib.min.js, lib.min.css那两行引用。
（旧版本chrome支持用link标签包含html片段的功能，可惜在chrome 80版本后删除了这一功能）

## 消息通知的实现

管理端登录后，显示通知数，点击通知数显示通知详情。点击详情可跳转相关页面。

示例：在车辆出厂检测时，若发现缺陷问题，则质量人员登录系统时应得到消息通知，来分析处理缺陷问题。这就相当于用户的待办事项列表。

后端接口设计：

	Notify.queryCnt() -> {cnt}
	Notify.query() -> [{type, tm, name, relId}]

- type: 一般就用表的名字。比如`Issue`表示缺陷。
- name: 通知的标题。
- relId: 关联的对象编号。与type合在一起就能定位到一个具体的对象了。

前端在登录后，调用queryCnt接口显示通知数。用户查看详情时，调用Notify.query接口获取待办项列表。点一项可跳转相关对象。

安装插件jdcloud-plugin-notify，后端去修改AC2_Notify类的两个接口实现。

前端在handleLogin方法中添加调用(store.js)

	function handleLogin(data)
	{
		WUI.handleLogin(data);
		...
		Notify.init();
	}

前端修改 web/page/dlgNotify.js 中的显示和跳转逻辑。

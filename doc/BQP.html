<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>BQP - 业务查询协议</title>
  <style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="doc.css" />
<script src="doc.js"></script>

</head>
<body>
<h1 id="bqp---业务查询协议">BQP - 业务查询协议</h1>
<p>业务查询协议，简称BQP(Business Query Protocol)，它是一种远程过程调用(RPC)协议。 本文档定义业务接口如何调用及返回，如何规范描述接口，以及定义通用对象操作接口。</p>
<p>请求由接口名（action），参数（param），数据（data）三部分构成，表示为<code>action(param)(data)</code>，其中参数或数据可以缺省，如<code>action(param)</code>或<code>action()(data)</code>。 参数一般是键值对，而数据的内容和形式则由具体接口定义。</p>
<p>接口返回形式为<code>[code, retData, ...]</code>的JSON数组，至少为两个元素。当调用成功时，code为0，返回数据retData由接口原型定义。 调用失败时（也称为异常），code为非0错误码，retData为错误信息。 返回数组中其它内容一般为调试信息。</p>
<p>假如接口原型如下：</p>
<pre><code>fn(p1, p2?)(data) -&gt; {field1, field2}</code></pre>
<p>其中<code>fn</code>为接口名，<code>p1</code>, <code>p2</code>是两个参数，且<code>p2</code>可以缺省。第二个括号表示需要传输数据（数据格式会特别说明）。 箭头后面部分是调用成功时的返回值，如果没有箭头后面部分，则表示不关心返回值，默认返回字符串&quot;OK&quot;。 调用成功后返回JSON数组示例: <code>[0, {&quot;field1&quot;: &quot;value1&quot;, &quot;field2&quot;: &quot;value2&quot;}]</code>。</p>
<p>本文档调用示例使用JS函数<code>callSvr</code>表示：</p>
<pre><code>callSvr(调用名, URL参数/可选, $.noop(表示空的回调函数，用来分隔URL和POST参数), POST参数/可选, 其它选项/可选)</code></pre>
<p>比如，下面表示同时传了URL参数id和POST参数amount：</p>
<pre><code>callSvr(&quot;Ordr.set&quot;, {id: 100}, $.noop, {amount: 99.9});</code></pre>

<div id="TOC" class="toc">
<ul>
<li><a href="#bqp---业务查询协议">BQP - 业务查询协议</a><ul>
<li><a href="#接口通讯协议"><span class="toc-section-number">1</span> 接口通讯协议</a><ul>
<li><a href="#关于空值"><span class="toc-section-number">1.1</span> 关于空值</a></li>
<li><a href="#多应用支持与应用标识"><span class="toc-section-number">1.2</span> 多应用支持与应用标识</a></li>
<li><a href="#测试模式及调试等级"><span class="toc-section-number">1.3</span> 测试模式及调试等级</a></li>
<li><a href="#通用接口格式参数"><span class="toc-section-number">1.4</span> 通用接口格式参数</a></li>
</ul></li>
<li><a href="#接口描述"><span class="toc-section-number">2</span> 接口描述</a><ul>
<li><a href="#接口原型描述"><span class="toc-section-number">2.1</span> 接口原型描述</a></li>
<li><a href="#应用逻辑描述"><span class="toc-section-number">2.2</span> 应用逻辑描述</a></li>
</ul></li>
<li><a href="#通用对象操作接口"><span class="toc-section-number">3</span> 通用对象操作接口</a><ul>
<li><a href="#基本增删改查操作"><span class="toc-section-number">3.1</span> 基本增删改查操作</a></li>
<li><a href="#查询操作"><span class="toc-section-number">3.2</span> 查询操作</a><ul>
<li><a href="#查询条件cond"><span class="toc-section-number">3.2.1</span> 查询条件(cond)</a></li>
<li><a href="#查询结果格式fmt"><span class="toc-section-number">3.2.2</span> 查询结果格式(fmt)</a></li>
<li><a href="#查询结果支持分页"><span class="toc-section-number">3.2.3</span> 查询结果支持分页</a></li>
<li><a href="#导出文件"><span class="toc-section-number">3.2.4</span> 导出文件</a></li>
<li><a href="#枚举名字映射"><span class="toc-section-number">3.2.5</span> 枚举名字映射</a></li>
<li><a href="#汇总统计"><span class="toc-section-number">3.2.6</span> 汇总统计</a></li>
<li><a href="#分组统计"><span class="toc-section-number">3.2.7</span> 分组统计</a></li>
<li><a href="#模糊查询"><span class="toc-section-number">3.2.8</span> 模糊查询</a></li>
</ul></li>
<li><a href="#查询分页机制"><span class="toc-section-number">3.3</span> 查询分页机制</a></li>
<li><a href="#批量导入数据"><span class="toc-section-number">3.4</span> 批量导入数据</a><ul>
<li><a href="#批量导入支持三种方式"><span class="toc-section-number">3.4.1</span> 批量导入支持三种方式</a></li>
<li><a href="#通过导入实现批量更新"><span class="toc-section-number">3.4.2</span> 通过导入实现批量更新</a></li>
<li><a href="#支持带子表导入"><span class="toc-section-number">3.4.3</span> 支持带子表导入</a></li>
<li><a href="#支持列名映射"><span class="toc-section-number">3.4.4</span> 支持列名映射</a></li>
</ul></li>
<li><a href="#子表的增删改查操作"><span class="toc-section-number">3.5</span> 子表的增删改查操作</a><ul>
<li><a href="#子表添加"><span class="toc-section-number">3.5.1</span> 子表添加</a></li>
<li><a href="#子表查询"><span class="toc-section-number">3.5.2</span> 子表查询</a></li>
<li><a href="#子表更新与删除"><span class="toc-section-number">3.5.3</span> 子表更新与删除</a></li>
</ul></li>
</ul></li>
<li><a href="#批请求"><span class="toc-section-number">4</span> 批请求</a></li>
<li><a href="#服务端信息反馈x-daca头"><span class="toc-section-number">5</span> 服务端信息反馈/X-Daca头</a></li>
</ul></li>
</ul></div>

<h2 id="接口通讯协议"><span class="header-section-number">1</span> 接口通讯协议</h2>
<p>本章定义业务查询协议的实现方式，如何表示请求（调用名、参数、数据）和返回。</p>
<p>业务查询协议基于HTTP协议实现，以下列接口为例：</p>
<pre><code>fn(p1, p2) -&gt; {field1, field2}</code></pre>
<p>以下假定接口服务的URL基地址(BASE_URL)为<code>/api</code>。 该接口可以使用HTTP GET请求实现：</p>
<pre><code>GET /api/fn?p1=value1&amp;p2=value2</code></pre>
<p>或表示为</p>
<pre><code>callSvr(&quot;fn&quot;, {p1: &quot;value1&quot;, p2: &quot;value2&quot;})</code></pre>
<p>也可以使用HTTP POST请求实现：</p>
<pre><code>POST /api/fn
Content-Type: application/x-www-form-urlencoded;charset=utf-8

p1=value1&amp;p2=value2</code></pre>
<p>或表示为</p>
<pre><code>callSvr(&quot;fn&quot;, $.noop, {p1: &quot;value1&quot;, p2: &quot;value2&quot;})</code></pre>
<p>POST内容也可以使用json格式，如：</p>
<pre><code>POST /api/fn
Content-Type: application/json;charset=utf-8

{&quot;p1&quot;:&quot;value1&quot;,&quot;p2&quot;:&quot;value2&quot;}</code></pre>
<p>参数允许部分出现在URL中，部分出现在POST内容中，如</p>
<pre><code>POST /api/fn?p1=value1
Content-Type: application/x-www-form-urlencoded;charset=utf-8

p2=value2</code></pre>
<p>或表示为</p>
<pre><code>callSvr(&quot;fn&quot;, {p1: &quot;value1&quot;}, $.noop, {p2: &quot;value2&quot;})</code></pre>
<p>如果URL与POST内容中出现同名参数，最终以URL参数为准。</p>
<p>接口名为URL基地址后一个词（常称为PATH_INFO），如URL<code>/api/fn</code>中接口名为&quot;fn&quot;。 如果难以实现，也可以使用URL参数ac表示接口名，即URL中<code>/api?ac=fn&amp;p1=value1&amp;p2=value2</code>中接口名也是&quot;fn&quot;。</p>
<p><strong>[必须使用HTTP POST的情形]</strong></p>
<p>如果接口定义中有请求数据（即在接口原型中用两个括号），如：</p>
<pre><code>fn(p1,p2)(p3,p4) -&gt; {field1, field2}</code></pre>
<p>这时必须使用HTTP POST请求，参数只能通过URL传递，数据通过POST内容传递：</p>
<pre><code>POST /api/fn?p1=value1&amp;p2=value2
Content-Type: application/x-www-form-urlencoded;charset=utf-8

p3=value3&amp;p4=value4</code></pre>
<p>注意数据的格式应通过HTTP头Content-Type正确设置，一般应支持&quot;application/x-www-form-urlencoded&quot;或&quot;application/json&quot;格式。 少数例外情况应特别指出，比如上传文件接口upload一般设计为使用HTTP头&quot;Content-type: multipart/form-data&quot;，应在接口文档中明确说明。</p>
<p>协议规定：</p>
<ul>
<li>只要服务端正确收到请求并处理，均返回HTTP Code 200，返回内容使用JSON格式，为一个至少含有2元素的数组。</li>
<li>在请求成功时返回内容格式为 <code>[0, retData]</code>，其中<code>retData</code>的类型由接口描述定义。</li>
<li>在请求失败时返回内容格式为 <code>[非0错误码, 错误信息]</code>.</li>
<li>从返回数组的第3个元素起, 为调试信息, 仅用于问题诊断, 一般不应显示出来给最终用户。</li>
<li>所有交互内容采用UTF-8编码。</li>
</ul>
<p>服务端在返回JSON格式数据时应如下设置HTTP头属性：</p>
<pre><code>Content-Type: text/plain; charset=UTF-8</code></pre>
<p>注意：不采用&quot;application/json&quot;类型是考虑客户端可以更自由的处理返回结果。</p>
<p>服务端应避免客户端对返回结果缓冲，一般应在HTTP响应中加上</p>
<pre><code>Cache-Control: no-cache</code></pre>
<p>以下面的接口描述为例：</p>
<pre><code>获取订单：
getOrder(id) -&gt; {id, dscr, total}</code></pre>
<p>一次成功调用可描述为：</p>
<pre><code>getOrder(id=101) -&gt; {id: 101, dscr: &quot;套餐1&quot;, total: 38.0}</code></pre>
<p>它表示：发起HTTP请求为 <code>GET /api/getOrder?id=101</code>（当然也可以用POST请求），服务端处理成功时返回类型为<code>{id, dscr, total}</code>：</p>
<pre><code>HTTP/1.1 200 OK

[0, {&quot;id&quot;: 101, &quot;dscr&quot;: &quot;套餐1&quot;, &quot;total&quot;: 38.0}]</code></pre>
<p>关于返回类型表述方式详见后面章节描述。</p>
<p>服务端处理失败时返回示例：</p>
<pre><code>HTTP/1.1 200 OK

[1, &quot;未认证&quot;]</code></pre>
<p>错误码及错误信息在应用中应明确定义，协议规定以下错误码：</p>
<pre><code>enum {
    E_ABORT=-100; // &quot;取消操作&quot;。要求客户端不报错，不处理。
    E_AUTHFAIL=-1; // &quot;认证失败&quot;
    E_OK=0;
    E_PARAM=1; // &quot;参数不正确&quot;
    E_NOAUTH=2; // &quot;未认证&quot;, 一般要求客户端引导用户到登录页，或尝试自动登录
    E_DB=3;　// &quot;数据库错误&quot;
    E_SERVER=4; // &quot;服务器错误&quot;
    E_FORBIDDEN=5; // &quot;禁止操作&quot;，用户没有权限调用接口或操作数据
}</code></pre>
<h3 id="关于空值"><span class="header-section-number">1.1</span> 关于空值</h3>
<p>假如传递参数<code>a=1&amp;b=&amp;c=hello</code>，或JSON格式的<code>{a:1, b:null, c:&quot;hello&quot;}</code>，其中参数&quot;b&quot;值为空串。 一般情况下，参数&quot;b&quot;没有意义，即与<code>a=1&amp;c=hello</code>意义相同。</p>
<p>在某些场合，如通用对象保存接口<code>{Obj}.set</code>，在POST内容中如果出现&quot;b=&quot;, 则表示将该字段置null。在这些场合下将单独说明。</p>
<h3 id="多应用支持与应用标识"><span class="header-section-number">1.2</span> 多应用支持与应用标识</h3>
<p>接口应支持多个应用同时访问，例如按登录角色划分，常见有用户端应用、员工端应用等。</p>
<p>每个客户端应用要求有唯一应用标识（如果没有，缺省为&quot;user&quot;，表示用户端应用），以URL参数&quot;_app&quot;指定。 在每次接口请求时，客户端框架应自动添加该参数。</p>
<p>应用标识（称为app或appName）对应一个应用类型（称为appType），如应用标识&quot;user&quot;, &quot;user2&quot;, &quot;user-keyacct&quot;对应同一应用类型&quot;user&quot;，即应用标识的第一个词（不含结尾数字）作为应用类型。</p>
<p>使用同一接口服务的不同应用类型的应用，如果在浏览器的两个Tab页中分别打开，两者不应相互影响，如用户端的退出登录不会导致员工端的应用也退出登录。 而同一应用类型和不同应用如果在浏览器中同时打开，其会话状态可以共享，比如当一个应用登录后，另一个应用也处于登录状态。</p>
<p>习惯上常用以下应用类型：</p>
<ul>
<li>user: 用户端应用</li>
<li>emp: 员工端应用，如平台员工使用手机应用程序处理客户订单等。而应用标识&quot;emp-admin&quot;常用于表示运营管理端应用。</li>
<li>admin: 超级管理端应用，一般由IT人员做初始化配置。</li>
</ul>
<p>一般建议使用标准的HTTP Cookie来实现会话，且以应用类型决定HTTP会话中的Cookie项的名字：</p>
<pre><code>用于HTTP会话的Cookie名={应用类型}id</code></pre>
<p>例如，应用标识为&quot;emp&quot;(表示员工端), 当第一次接口请求时：</p>
<pre><code>GET /api/fn?_app=emp</code></pre>
<p>服务端应通过HTTP头指定会话标识，如：</p>
<pre><code>SetCookie: empid=xxxxxx</code></pre>
<h3 id="测试模式及调试等级"><span class="header-section-number">1.3</span> 测试模式及调试等级</h3>
<p>接口服务可配置为“测试模式”（TEST_MODE），这种模式用于开发和自动化测试，建议的功能有：</p>
<ul>
<li>输出美化的JSON数据</li>
<li>允许输出额外调试信息</li>
<li>允许跨域调用</li>
<li>允许一些测试接口（比如执行SQL语句，常用于自动化测试）。</li>
<li>允许一些第三方服务以模拟方式执行（模拟模式 - MOCK_MODE）</li>
</ul>
<p>接口服务可配置调试等级为0到9，向前端输出不同级别的调试信息。一般设置为9（最高）时，可以查看SQL调用日志，便于调试SQL语句。 调试信息仅在测试模式下生效。</p>
<p><strong>线上生产环境不可设置为测试模式。</strong> 当前端发现服务处于测试模式，应给予明确提示。</p>
<h3 id="通用接口格式参数"><span class="header-section-number">1.4</span> 通用接口格式参数</h3>
<p>接口默认返回格式为<code>[0, 数据, ...]</code>，支持以下通用URL参数：</p>
<ul>
<li>_raw: 只返回数据部分（第2元素）；</li>
<li>_jsonp: 返回函数调用或变量赋值形式，是合法的javascript语句。</li>
</ul>
<p>示例：<code>callSvr(&quot;Ordr.get&quot;, {res: &quot;id, tm, amount&quot;})</code>假设返回<code>[0, {id: 100, tm: '2020-10-10', amount: 380.5}]</code>，那么：</p>
<ul>
<li><p><code>callSvr(&quot;Ordr.get&quot;, {res: &quot;id, tm, amount&quot;, _raw:1})</code>返回<code>{id: 100, tm: '2020-10-10', amount: 380.5}</code></p></li>
<li><p><code>callSvr(&quot;Ordr.get&quot;, {res: &quot;id, tm, amount&quot;, _raw:2})</code>返回<code>100  2020-10-10  380.5</code> 字段间以TAB分隔的表；如果有多条记录则可以有多行。可用于与shell script集成。</p></li>
<li><p><code>callSvr(&quot;Ordr.get&quot;, {res: &quot;id, tm, amount&quot;, _jsonp:'handleOrder'})</code>返回<code>handleOrder([0, {id: 100, tm: '2020-10-10', amount: 380.5}])</code> 即JS函数调用形式，可用于跨域调用。</p></li>
<li><p><code>callSvr(&quot;Ordr.get&quot;, {res: &quot;id, tm, amount&quot;, _jsonp:'api_order='})</code>返回<code>api_order=[0, {id: 100, tm: '2020-10-10', amount: 380.5}]</code> 即JS变量赋值形式，可用于跨域调用。</p></li>
<li><p><code>callSvr(&quot;Ordr.get&quot;, {res: &quot;id, tm, amount&quot;, _raw:1, _jsonp:'api_order='})</code>返回<code>api_order={id: 100, tm: '2020-10-10', amount: 380.5}</code> 两个参数可以组合使用。</p></li>
</ul>
<h2 id="接口描述"><span class="header-section-number">2</span> 接口描述</h2>
<p>接口描述应包括接口原型和应用逻辑的说明。</p>
<p>接口原型包括接口名、参数、请求数据、返回值的声明。应用逻辑常包括接口权限、字段自动完成逻辑、字段检查逻辑、关联数据添加或更新逻辑等。</p>
<p>示例：</p>
<pre><code>获取订单
Ordr.get(id) -&gt; {id, status, storePos, @orderLog}

参数：

- id: Integer.

返回：

- id: Integer.
- status: enum(CR-创建,PA-已付款,CA-已取消,RE-已完成)。订单状态。
- storePos: Coord=&quot;经度, 纬度&quot;. 商户坐标.
- orderLog: [{id, tm, ac, dscr}]. 订单日志。

- ac: enum(CR-创建,PA-已付款,CA-已取消,RE-已完成). 操作类型.

应用逻辑：

- 权限：AUTH_USER</code></pre>
<p>上例参数或返回中的<code>id</code>, <code>status</code>等字段如果含义及类型明确，或是在对象对应的数据模型设计文档中已提及，这里也可省略不做介绍。 <code>storePos</code>是一个序列化类型（以字符串表示的复杂类型），称为<code>Coord</code>类型，特别标明。 而<code>orderLog</code>是一个复杂结构，应分解介绍其内部属性，其中<code>id</code>, <code>tm</code>等属性因含义明确省略了介绍。</p>
<h3 id="接口原型描述"><span class="header-section-number">2.1</span> 接口原型描述</h3>
<p>接口名使用驼峰式命名规则，一般有两种形式，1）函数调用型，以小写字母开头，如<code>getOrder</code>；2）对象调用型，对象名首字母为大写，后跟调用名，中间以&quot;.&quot;分隔，如<code>Order.get</code>。</p>
<p>在接口原型中，以&quot;?&quot;结尾的参数字段、数据字段或返回字段表示该字段可能缺省，如</p>
<pre><code>fn(p1, p2?, p3?=1) -&gt; {attr1, attr2?}</code></pre>
<p>其中，参数p3的缺省值是1，p2缺省值是0或空串&quot;&quot;或null(取决于基本类型是数值型，字符串还是对象等)。 返回对象中，attr1是必出现的属性，而attr2可能没有（接口说明中应描述何时没有）。</p>
<p>接口原型中应描述参数或返回的类型。类型可能是数值、字符串这些基本类型，也可能是对象、数组、字典及其相互组合而成的复杂类型，或虽然是一个字符串但表示某个复杂类型的序列化。</p>
<p>基本类型不可再细分，其类型一般通过名称暗示，如：</p>
<ul>
<li>Integer: 后缀标识符为&quot;&amp;&quot;, 或以&quot;Id&quot;, &quot;Cnt&quot;等结尾, 如 customerId, age&amp;</li>
<li>Number: 后缀标识符为&quot;#&quot;, 如 avgValue#</li>
<li>Currency: 后缀标识符为&quot;@&quot;, 或以&quot;Price&quot;, &quot;Total&quot;, &quot;Qty&quot;, &quot;Amount&quot;结尾, 如 unitPrice, price2@。</li>
<li>Datetime/Date/Time: 分别以&quot;Tm&quot;/&quot;Dt&quot;/&quot;Time&quot;结尾，如 tm 可表示日期时间如&quot;2010-1-1 9:00&quot;，comeDt 只表示日期如&quot;2010-1-1&quot;，而 comeTime只表示时间如&quot;9:00&quot;</li>
<li>Boolean/TinyInt(1-byte): 以Flag结尾, 或以is开头.</li>
<li>String: 未显示指明的一般都作为字符串类型。</li>
</ul>
<p>对于复杂类型，其描述方法用类似JSON格式来解析其中对象、数组、字典这些结构的组合，举例列举如下：</p>
<p><strong>{id, name}</strong></p>
<p>一个简单对象，有两个字段id和name。例：<code>{id: 100, name: &quot;name1&quot;}</code></p>
<p><strong>[id...]</strong> 或 <strong>[id]</strong></p>
<p>一个简单数组，每个元素表示id。例：<code>[100, 200, 400]</code>, 每项为一个id</p>
<p><strong>[id, name]</strong></p>
<p>一个简单数组，例：<code>[100, &quot;liang&quot;]</code>，第一项为id, 第二项为name</p>
<p><strong>[ [id, name] ]</strong> 或 <strong>varr(id, name)</strong></p>
<p>简单二维数组，又称varr(value array), 如 <code>[ [100, &quot;liang&quot;], [101, &quot;wang&quot;] ]</code>.</p>
<p><strong>[{id, name}]</strong> 或 <strong>objarr(id, name)</strong></p>
<p>一个数组，每项为一个对象，又称objarr。例：<code>[{id: 100, name: &quot;name1&quot;}, {id: 101, name: &quot;name2&quot;}]</code></p>
<p><strong>tbl(id, name)</strong></p>
<p>压缩表对象，常用于返回分页列表。其详细格式为 <code>{h: [header1, header2, ...], d:[row1, row2, ...], nextkey?, total?}</code>，例如</p>
<pre><code>{
  h: [&quot;id&quot;, &quot;name&quot;],
  d: [[100, &quot;myname1&quot;], [200, &quot;myname2&quot;]]
}</code></pre>
<p>压缩对象支持分页机制(paging)，返回字段中可能包含&quot;nextkey&quot;，&quot;total&quot;等字段。 详情请参考后面章节&quot;分页机制&quot;.</p>
<p>在类型描述时，可以用&quot;@&quot;符号表示一个数组属性，而对象或字典一般用&quot;%&quot;表示，如：</p>
<pre><code>获取订单接口：
Ordr.get(id) -&gt; { id, dscr, %addr, @items }

返回

- addr: {country, city}. 收货地址
- items: [{id, name, qty}]. 订单中的物品。</code></pre>
<p>注意：</p>
<ul>
<li>在使用JSON传输数据时，字段可以不区分类型，即使是整形也<strong>可能</strong>用引号括起来当作字符串传输，客户端在对JSON数据反序列化时应自行考虑类型转换。</li>
<li>不论哪种类型，都可能返回null。客户端必须能够处理null，将其转为相应类型正确的值。</li>
</ul>
<p>以上对类型的描述，使用的是一种层层剖析的形式化表达方法，请参考<a href="https://github.com/skyshore2001/cocoon-notation">蚕茧表示法</a>。</p>
<p>除了基本类型和复杂类型，有时传递参数还会使用一个字符串来代表复杂结构，称为序列化类型。 常用的有：</p>
<ul>
<li><p>逗号分隔的简单字符串序列(数组序列化)，如</p>
<pre><code>&quot;经度,纬度&quot;</code></pre>
<p>或带上类型描述：</p>
<pre><code>&quot;经度/Double,纬度/Double&quot;</code></pre>
<p>它可表示 <code>121.233543,31.345457</code>。</p></li>
<li><p>List表，以逗号分隔行，以冒号分隔列的表，如定义：</p>
<pre><code>List(id, name?)</code></pre>
<p>或指定每列的类型，如</p>
<pre><code>List(id/Integer, name?/String)</code></pre>
<p>参数后加&quot;?&quot;表示是可选参数, 该项可以为空。 它可以表示这样的数据：</p>
<pre><code>10:liang,11:wang</code></pre>
<p>因为name字段可省略，它也可以表示：</p>
<pre><code>10,11</code></pre>
<p>这种格式一般用于前后端间传递简单的表，尤其是一组数字如<code>10,11</code>常定义类型为<code>List(id)</code>。</p>
<p>注意：由于使用分隔符&quot;,&quot;和&quot;:&quot;，每个字段内不能有这两个特殊符号(例如假如有日期字段，中间不可以有&quot;:&quot;, 如&quot;2015/11/20 1030&quot;或&quot;20151120 1030&quot;)。</p>
<p>在传输数据时，也允许带表头信息，这时用首字符&quot;@&quot;标明表头行，如</p>
<pre><code>@id:name,10:liang,11:wang</code></pre></li>
<li><p>JSON序列化。将一个复杂结构以JSON格式序列化后的字符串，如定义：</p>
<pre><code>Json({id, name})</code></pre>
<p>括号内描述实际数据结构。它可以表示这样格式的字符串：</p>
<pre><code>&quot;{\&quot;id\&quot;: 100, \&quot;name\&quot;: \&quot;liang\&quot;}&quot;</code></pre>
<p>又比如，要将一个普通的表用一个字段传递，可以描述为：</p>
<pre><code>Json(tbl(id, name))</code></pre></li>
</ul>
<h3 id="应用逻辑描述"><span class="header-section-number">2.2</span> 应用逻辑描述</h3>
<p>在接口描述的应用逻辑说明中应包括接口权限说明。</p>
<p>权限在设计接口时定义，常用的定义示例如下：</p>
<ul>
<li>AUTH_GUEST: 任何人可用, 无权限限制。如不用登录即可查看商户, 天气等.</li>
<li>AUTH_USER: 用户登录后可用. 可做下单, 查看订单等操作.</li>
<li>AUTH_EMP: 员工操作，如查看和操作订单等。</li>
<li>PERM_TEST_MODE: 测试模式下可用。</li>
</ul>
<p>权限一般名为<code>PERM_XXX</code>，特别地，登录类型是一种特殊的权限，一般定义名称为<code>AUTH_XXX</code>。</p>
<p>如果接口未明确指定权限，则认为是AUTH_GUEST.</p>
<h2 id="通用对象操作接口"><span class="header-section-number">3</span> 通用对象操作接口</h2>
<p>业务接口包括函数调用型接口和对象调用型接口。</p>
<p>函数型接口名称一般为动词或动词开头，如queryOrder, getOrder等。对象型接口的格式为<code>{对象名}.{动作}</code>, 如 &quot;Order.get&quot;, &quot;Order.query&quot;等。</p>
<p>接口服务框架应支持对象型接口的以下标准操作：add, set, query, get, del。 这些操作提供对象的基本增删改查(CRUD)以及列表查询、统计分析、导出等服务，称为通用对象接口。</p>
<p>在做接口设计时，应以通用对象接口为基础，按业务逻辑需要进行定制形成专用接口，如进行权限限制、指定允许的操作类型(如只能get/set,不能add/del)、只读字段、隐藏字段等。</p>
<p>下面将分别定义这些操作，其中用Obj代指对象实际名称。</p>
<h3 id="基本增删改查操作"><span class="header-section-number">3.1</span> 基本增删改查操作</h3>
<p><strong>[添加操作]</strong></p>
<p>接口原型：</p>
<pre><code>Obj.add(uniKey?, uniKeyMode?=set)(POST fields...) -&gt; id
Obj.add(res)(POST fields...) -&gt; {fields...} (返回的字段由res参数指定)</code></pre>
<p>对象的属性通过POST请求内容给出，为一个个键值对。 添加完成后，默认返回新对象的id, 如果想多返回其它字段，可设置res参数，如</p>
<pre><code>callSvr(&quot;Ordr.add&quot;, $.noop, {status:&quot;CR&quot;, total:100})
返回
809

callSvr(&quot;Ordr.add&quot;, {res:&quot;id,status,total&quot;}, $.noop, {status:&quot;CR&quot;, total:100})
返回
{id: 810, status:&quot;CR&quot;, total: 100}</code></pre>
<p>对象id支持自动生成。</p>
<ul>
<li><p>uniKey: 唯一索引字段. 如果指定, 则以该字段查询记录是否存在(调用query接口）, 存在则更新（调用set接口）。例如&quot;code&quot;, 也支持多个字段（用于关联表），如&quot;bpId,itemId&quot;。 uniKey支持使用虚拟字段（如关联字段）。 该字段常用于检查记录不存在则添加记录，存在则更新记录；也用于避免记录重复添加。 特别地，如果uniKey以&quot;!&quot;结尾（如&quot;code!&quot;），则变成<strong>更新模式</strong>，表示必须匹配到记录，不匹配则报错而不做添加，常用于通过导入批量更新数据。 不加!后缀时虽然也可更新记录，但若不匹配时会误添加记录。</p></li>
<li>uniKeyMode: 在uniKey匹配时，默认处理是更新操作，可以通过本参数来定制匹配后的操作，其值定义为：
<ul>
<li>set: （默认）转为更新操作（如果要更新的字段刚好就是uniKey字段，则忽略更新），接口最终返回已存在记录的id。</li>
<li>error: 如果已存在记录，则报错。在更新模式下等同于set，即记录不存在时报错。</li>
<li>ignore: 忽略添加操作，接口直接返回已存在记录的id。在更新模式下，不添加，也不报错，以-1值返回记录id。</li>
</ul></li>
</ul>
<p><strong>[更新操作]</strong></p>
<p>接口原型：</p>
<pre><code>Obj.set(id)(POST fields...)</code></pre>
<p>与add操作类似，对象属性的修改通过POST请求传递，而在URL参数中需要有id标识哪个对象。</p>
<p>示例：</p>
<pre><code>callSvr(&quot;Obj.set&quot;, {id: 809}, $.noop, {status:&quot;PA&quot;, empId:10})
返回
&quot;OK&quot;</code></pre>
<p>如果未指定返回值，一般默认返回&quot;OK&quot;。下面示例也将省略返回值。</p>
<p>如果要将某字段置空, 可以用空串或&quot;null&quot; (小写)。例如：</p>
<pre><code>callSvr(&quot;Obj.set&quot;, {id: 809}, $.noop, {picId:&quot;&quot;, empId:&quot;null&quot;})
（实际传递参数的形式为 &quot;picId=&amp;empId=null&quot;，注意是字符串&quot;null&quot;，不是直接的null）</code></pre>
<p>这两种方式都是将字段置空。 注意：一般情况下，接口传参数&quot;picId=&quot;这样的，参数会被忽略，相当于没有设置该字段。</p>
<p>另外注意，上例是设置字段为null，而不是设置成空串&quot;&quot;。 如果要将字符串置空串(一般不建议使用)，可以用&quot;empty&quot;, 例如：</p>
<pre><code>callSvr(&quot;Obj.set&quot;, {id: 809}, $.noop, {sn: &quot;empty&quot;})</code></pre>
<p>假如sn是数值类型，会导致其值为0或0.0。</p>
<p>支持根据条件批量更新，使用setIf或batchSet接口：</p>
<pre><code>Obj.setIf(cond)(POST fields...)
Obj.batchSet(cond)(POST fields...)</code></pre>
<p>注意：setIf接口相当于执行1条数据库SQL UPDATE语句，不执行业务逻辑，速度快； 而batchSet接口先根据条件查出所有记录，然后对每个记录逐一调用set接口进行更新，会执行每条记录更新时的业务逻辑。</p>
<p>示例：</p>
<pre><code>callSvr(&quot;Obj.setIf&quot;, {cond: &quot;tm&gt;=&#39;2010-1-1&#39; and tm&lt;&#39;2011-1-1&#39;&quot;}, $.noop, {dscr: &quot;已处理&quot;});</code></pre>
<p><strong>[获取对象操作]</strong></p>
<p>接口原型：</p>
<pre><code>Obj.get(id, res?) -&gt; {fields...}</code></pre>
<p>默认返回所有暴露的属性，通过res参数可以指定需要返回的字段。</p>
<p><strong>[删除操作]</strong></p>
<p>接口原型：</p>
<pre><code>Obj.del(id)</code></pre>
<p>根据id删除一个对象，例如：</p>
<pre><code>callSvr(&quot;Obj.del&quot;, {id: 809})</code></pre>
<p>支持根据条件进行批量删除，使用delIf接口：</p>
<pre><code>Obj.delIf(cond)
Obj.batchDel(cond)</code></pre>
<p>delIf与batchDel的区别，类似于setIf与batchSet的区别。前者只根据条件执行一条SQL DELETE语句，速度快；后者是先查出符合条件的所有记录，再逐一记录删除（走del接口）。</p>
<p>示例：</p>
<pre><code>callSvr(&quot;Obj.delIf&quot;, {cond: &quot;tm&gt;=&#39;2010-1-1&#39; and tm&lt;&#39;2011-1-1&#39;&quot;});</code></pre>
<h3 id="查询操作"><span class="header-section-number">3.2</span> 查询操作</h3>
<p>接口原型：</p>
<pre><code>查询列表(默认压缩表格式)：
Obj.query(res?, cond?, distinct?=0, pagesz?=20, pagekey/page?) -&gt; tbl(fields...) = {nextkey?, total?, @h, @d}

查询列表 - 对象列表格式：
Obj.query(fmt=list/one/one?/array/hash/multihash, ...) -&gt; {nextkey?, total?, @list=[obj1, obj2...]}

分组统计：
Obj.query(gres, ...) -&gt; tbl(fields...)

导出查询列表到文件：
Obj.query(fmt=csv/txt/excel, ...) -&gt; 文件内容</code></pre>
<p>查询接口非常灵活，不仅支持条件组合查询、排序、指定输出字段等，还支持分页列表、分组统计、导出文件等。</p>
<p>查询操作的参数可参照SQL语句来理解：</p>
<dl>
<dt>res</dt>
<dd>String. 指定返回字段, 多个字段以逗号分隔，例如, res=&quot;field1,field2&quot;。字段前不可加表名或别名(alias)，如&quot;t0.id&quot;或&quot;id as userId&quot;不合法。 在res中允许使用部分统计函数如<code>sum</code>与<code>count</code>, 这时必须指定字段别名, 如<code>count(id) cnt</code>, <code>sum(qty*price) total</code>, <code>count(distinct addr) addrCnt</code>.
</dd>
<dt>cond</dt>
<dd>String. 指定查询条件，语法可参照SQL语句的&quot;WHERE&quot;子句。例如：<code>cond=&quot;field1&gt;100 AND field2='hello'&quot;</code>, 注意使用UTF8+URL编码, 字符串值应加上单引号.
</dd>
<dt>orderby</dt>
<dd>String. 指定排序条件，语法可参照SQL语句的&quot;ORDER BY&quot;子句，例如：<code>id desc</code>，也可以多个排序如：<code>tm desc,status</code> (按时间倒排，再按状态正排)
</dd>
<dt>distinct</dt>
<dd>Boolean. 如果为1, 生成<code>SELECT DISTINCT ...</code>查询.
</dd>
</dl>
<p>尽管类似SQL语句，但对参数值有一些安全限制：</p>
<ul>
<li>res, orderby只能是字段（或虚拟字段）列表，不能出现表达式、函数、子查询等。特别地，res参数允许部分统计函数，见上面示例。</li>
<li>cond可以由多个条件通过and或or组合而成，而每个条件的左边是字段名，右边是常量。不允许对字段运算，不允许子查询（不可以有select等关键字）。</li>
</ul>
<h4 id="查询条件cond"><span class="header-section-number">3.2.1</span> 查询条件(cond)</h4>
<p>用参数<code>cond</code>指定查询条件, 如：</p>
<pre><code>{cond: &quot;type=&#39;A&#39; and name like &#39;%hello%&#39;&quot;}</code></pre>
<p>也可以使用键值对方式：</p>
<pre><code>{cond: {type: &quot;A&quot;, name: &quot;~hello&quot;} }</code></pre>
<p>以下情况都不允许：</p>
<pre><code>left(type, 1)=&#39;A&#39;  -- 条件左边只能是字段，不允许计算或函数
type=type2  -- 字段与字段比较不允许
type in (select type from table2) -- 子查询不允许</code></pre>
<p>cond参数可以同时在URL参数和POST参数中指定，支持字符串、数组、键值对方式指定查询条件。</p>
<ul>
<li><p>条件字符串，参考SQL语句WHERE条件语法（不支持函数、子查询等），示例：</p>
<pre><code>&quot;100&quot;或100 生成 &quot;id=100&quot;
&quot;id=1&quot;
&quot;id&gt;=1 and id&lt;100&quot;
&quot;status=&#39;CR&#39;&quot;  注意字符串要加引号
&quot;status IN (&#39;CR&#39;,&#39;PA&#39;)&quot;
&quot;tm&gt;=&#39;2020-1-1&#39; AND tm&lt;&#39;2020-2-1&#39;&quot;
&quot;name like &#39;wang%&#39; OR dscr like &#39;want%&#39;&quot;
&quot;name IS NULL OR dscr IS NOT NULL&quot;</code></pre></li>
<li><p>键值对，键为字段名，值为查询条件，使用更加直观（如字符串不用加引号），如：</p>
<pre><code>{id:1, status:&quot;CR&quot;, name:&quot;null&quot;, dscr:null, f1:&quot;&quot;, f2:&quot;empty&quot;}
生成 &quot;id=1 AND status=&#39;CR&#39;&quot; AND name IS NULL AND f2=&#39;&#39;
注意：null和空串匹配是特殊处理的，要用字符串&quot;null&quot;表示null, 用&quot;empty&quot;表示空串：

可以使用符号： &gt; &lt; &gt;= &lt;= !(not) ~(like匹配)
{id:&quot;&lt;100&quot;, tm:&quot;&gt;2020-1-1&quot;, status:&quot;!CR&quot;, name:&quot;~wang%&quot;, dscr:&quot;~aaa&quot;, dscr2:&quot;!~aaa&quot;}
生成 &quot;id&lt;100 AND tm&gt;&#39;2020-1-1&quot; AND status&lt;&gt;&#39;CR&#39; AND name LIKE &#39;wang%&#39; AND dscr LIKE &#39;%aaa%&#39; AND dscr2 NOT LIKE &#39;%aaa%&#39;&quot;
like用于字符串匹配，字符串中用&quot;%&quot;或&quot;*&quot;表示通配符，如果不存在通配符，则表示包含该串(即生成&#39;%xxx%&#39;)

{b:&quot;!null&quot;, d:&quot;!empty&quot;]
生成 &quot;b IS NOT NULL&quot; AND d&lt;&gt;&#39;&#39;&quot;

支持IN和NOT IN:
{id: &quot;IN 100,101&quot;, status: &quot;NOT IN CA,XX&quot;}
生成&quot;id IN (1,2,3) AND status NOT IN (&#39;CR&#39;,&#39;XX&#39;)&quot;。注意：如果是id字段（如id, empId, empId2都是id字段），且值都是数值则不对值加引号。</code></pre>
<p>可用AND或OR连接多个条件，但不可加括号嵌套：</p>
<pre><code>{tm: &quot;&gt;=2020-1-1 AND &lt;2020-2-1&quot;, tm2: &quot;&lt;2020-1-1 OR &gt;=2020-2-1&quot;}
生成 &quot;(tm&gt;=&#39;2020-1-1&#39; AND tm&lt;&#39;2020-2-1&#39;) AND (tm2&lt;&#39;2020-1-1&#39; OR tm2&gt;=&#39;2020-2-1&#39;&quot;

{id:&quot;&gt;=1 AND &lt;100&quot;, status:&quot;CR OR PA&quot;, status2:&quot;!CR AND !PA OR null&quot;}
生成 &quot;(id&gt;=1 AND id&lt;100) AND (status=&#39;CR&#39; OR status=&#39;PA&#39;) AND (status2&lt;&gt;&#39;CR&quot; AND status2&lt;&gt;&#39;PA&#39; OR status2 IS NULL)&quot;

{a:&quot;null OR empty&quot;, b:&quot;!null AND !empty&quot;, _or: 1}
生成 &quot;(a IS NULL OR a=&#39;&#39;) OR (b IS NOT NULL AND b&lt;&gt;&#39;&#39;)&quot;, 默认为AND条件, `_or`选项用于指定OR条件</code></pre></li>
<li><p>数组，每个元素是上述条件字符串或键值对，如：</p>
<pre><code>[&quot;id&gt;=1&quot;, &quot;id&lt;100&quot;, &quot;name LIKE &#39;wang%&#39;&quot;] // &quot;id&gt;=1 AND id&lt;100&quot; AND name LIKE &#39;wang%&#39;&quot;
[ {id: &quot;&gt;=1&quot;}, {id:&quot;&lt;100&quot;}, {name: &quot;~want*} ] // 同上</code></pre></li>
</ul>
<h4 id="查询结果格式fmt"><span class="header-section-number">3.2.2</span> 查询结果格式(fmt)</h4>
<p>查询结果可以以指定形式返回, 缺省返回压缩表类型即&quot;h/d&quot;格式，例如：</p>
<pre><code>{
    h: [&quot;id&quot;, &quot;name&quot;],
    d: [[1, &quot;jerry&quot;], [2, &quot;tom&quot;]]
    nextkey: ... (用于分页，注意默认分页20条)
}</code></pre>
<p>由于不会每行重复传输字段名，压缩表类型一般传输效率更高。</p>
<p><strong>[list与array格式]</strong></p>
<p>如果指定<code>{fmt: &quot;list&quot;}</code>，则返回对象列表格式:</p>
<pre><code>{
    &quot;list&quot;: [
        {&quot;id&quot;: 1, &quot;name&quot;: &quot;jerry&quot;},
        {&quot;id&quot;: 2, &quot;name&quot;: &quot;tom&quot;}
    ],
    nextkey: ... (用于分页，注意默认分页20条)
}</code></pre>
<p>如果指定<code>{fmt: &quot;array&quot;}</code>，则返回数组对象列表格式（相当于list格式的list内容部分），注意此时不支持分页，返回后端限制的最大行数的数据（默认1000，最大可调到10000），常用于已知行数有限的查询：</p>
<pre><code>[
    {&quot;id&quot;: 1, &quot;name&quot;: &quot;jerry&quot;},
    {&quot;id&quot;: 2, &quot;name&quot;: &quot;tom&quot;}
]</code></pre>
<p><strong>[one与one?格式]</strong></p>
<p>如果指定<code>{fmt: &quot;one&quot;}</code>，则只以对象格式返回一行，类似get接口：</p>
<pre><code>{&quot;id&quot;: 1, &quot;name&quot;: &quot;jerry&quot;}</code></pre>
<p>且如果查询不到数据，会抛出错误（也是与get接口类似）。</p>
<p>如果查询不到数据时不想抛出错误，而是返回null，可以用<code>{fmt: &quot;one?&quot;}</code>参数。</p>
<p>特别地，如果返回数据只有一列，<code>one?</code>格式则直接返回该列值。 示例：查询订单数，返回只有一列cnt。</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {res: &quot;COUNT(*) cnt&quot;, fmt: &quot;one?&quot;})</code></pre>
<p>假如有99个订单，使用<code>fmt:&quot;one?&quot;</code>直接返回<code>99</code>，如果使用<code>fmt:&quot;one&quot;</code>则返回<code>{cnt: 99}</code>。</p>
<p><strong>[hash与multihash格式]</strong></p>
<p>如果指定<code>{fmt: &quot;hash&quot;}</code>，则以映射表格式返回：</p>
<pre><code>{
    1: {&quot;id&quot;: 1, &quot;name&quot;: &quot;jerry&quot;},
    2: {&quot;id&quot;: 2, &quot;name&quot;: &quot;tom&quot;}
}</code></pre>
<p>它等价于<code>{fmt: &quot;hash:id&quot;}</code>，即hash后未指定字段时，默认取第一个字段做为hash key。</p>
<p>如果指定<code>{fmt: &quot;hash:name&quot;}</code>:</p>
<pre><code>{
    &quot;jerry&quot;: {&quot;id&quot;: 1, &quot;name&quot;: &quot;jerry&quot;},
    &quot;tom&quot;: {&quot;id&quot;: 2, &quot;name&quot;: &quot;tom&quot;}
}</code></pre>
<p>如果指定<code>{fmt: &quot;hash:id,name&quot;}</code>:</p>
<pre><code>{1: &quot;jerry&quot;, 2: &quot;tom&quot;}</code></pre>
<p>如果指定<code>{fmt: &quot;hash:name,id&quot;}</code>:</p>
<pre><code>{&quot;jerry&quot;: 1, &quot;tom&quot;: 2}</code></pre>
<p>multihash与hash类似，只是用数组表示结果，所以就算出现key重名时也不会覆盖，示例：指定<code>{fmt: &quot;multihash&quot;}</code>：</p>
<pre><code>{
    1: [ {&quot;id&quot;: 1, &quot;name&quot;: &quot;jerry&quot;} ],
    2: [ {&quot;id&quot;: 2, &quot;name&quot;: &quot;tom&quot;} ]
}</code></pre>
<p>如果指定<code>{fmt: &quot;multihash:name,id&quot;}</code>:</p>
<pre><code>{&quot;jerry&quot;: [ 1 ], &quot;tom&quot;: [ 2 ]}</code></pre>
<p><strong>[tree树型结构]</strong></p>
<p>例如如下<code>{id,fatherId}</code>线性结构数组中，数组的每个元素中有个fatherId字段指向父结点的id属性：</p>
<pre><code>[
    {&quot;id&quot;:1},
    {&quot;id&quot;:2, &quot;fatherId&quot;:1},
    {&quot;id&quot;:3, &quot;fatherId&quot;:2},
    {&quot;id&quot;:4, &quot;fatherId&quot;:1}
]</code></pre>
<p>如果指定<code>{fmt: &quot;tree&quot;}</code>,返回转为树型结构<code>{id,children}</code>:</p>
<pre><code>[
    {&quot;id&quot;:1, &quot;children&quot;: [
        {&quot;id&quot;:2, &quot;fatherId&quot;:1, &quot;children&quot;: [
            {&quot;id&quot;:3, &quot;fatherId&quot;:2},
        ]},
        {&quot;id&quot;:4, &quot;fatherId&quot;:1}
    ]},
]</code></pre>
<p>可以通过URL参数treeFields重定义各字段名，默认值为<code>id,fatherId,children</code>，设置示例：<code>{treeFields:'code,fatherCode'}</code>，<code>{treeFields:'code,fatherCode,subtree'}</code></p>
<h4 id="查询结果支持分页"><span class="header-section-number">3.2.3</span> 查询结果支持分页</h4>
<p>参数pagesz/pagekey等与返回分页列表有关，详细介绍请参考“<a href="#查询分页机制">查询分页机制</a>”章节。</p>
<h4 id="导出文件"><span class="header-section-number">3.2.4</span> 导出文件</h4>
<p><strong>查询结果支持导出到文件</strong></p>
<p>在对象查询接口中添加参数&quot;fmt&quot;，可以输出指定格式，一般用于列表导出。参数：</p>
<dl>
<dt>fmt</dt>
<dd>Enum(csv,txt,excel,excelcsv,html). 导出Query的内容为指定格式。格式说明如下：
</dd>
</dl>
<ul>
<li>csv为逗号分隔UTF8编码文本；</li>
<li>txt为制表分隔的UTF8文本；</li>
<li>excel为microsoft excel格式(xlsx)。</li>
<li>excelcsv为逗号分隔的使用本地编码如gb2312编码文本（因为默认excel打开Csv文件时不支持utf8编码）。</li>
<li>html为网页格式。</li>
</ul>
<p>在实现时，注意设置正确的HTTP头，如csv文件：</p>
<pre><code>Content-Type: application/csv; charset=UTF-8
Content-Disposition: attachment;filename=1.csv</code></pre>
<p>导出txt文件设置HTTP头的例子：</p>
<pre><code>Content-Type: text/plain; charset=UTF-8
Content-Disposition: attachment;filename=1.txt</code></pre>
<p>示例：导出以逗号分隔的表格文本</p>
<pre><code>var url = makeUrl(&quot;Store.query&quot;, {
    res: &quot;id,name,addr&quot;,
    fmt: &quot;csv&quot;,
    pagesz: -1
})
window.open(url); // 下载文件</code></pre>
<p>注意，由于默认会有分页，要想导出所有数据，一般可指定分页大小为-1（后端最大限制一般为10000条，可在后端调整）</p>
<h4 id="枚举名字映射"><span class="header-section-number">3.2.5</span> 枚举名字映射</h4>
<p>例如有状态字段，定义为：</p>
<ul>
<li>status: Enum(CR:新创建;CA:已取消)。我们称之为枚举字段。</li>
</ul>
<p>在query接口中，可以通过res指定映射关系，示例：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {res: &quot;id, status =CR:新创建;CA:已取消&quot;})</code></pre>
<p>如果该字段值为CR，应返回&quot;新创建&quot;，返回示例：</p>
<pre><code>[ {id: 1, status: &quot;新创建&quot;} , {id: 2, status: &quot;已取消&quot;} ]</code></pre>
<p>也可定义空值(null)或空串(&quot;&quot;)的显示，如: <code>status =CR:新创建;CA:已取消;:(null)</code>，表示将空值显示为<code>(null)</code>。</p>
<p>如果字段值是多个逗号分隔的值列表，如&quot;CR,CA&quot;，则应返回&quot;新创建,已取消&quot;。</p>
<p>可以与别名一起使用，示例：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {res: &quot;id 编号, status 状态=CR:新创建;CA:已取消&quot;})</code></pre>
<p>返回示例：</p>
<pre><code>[ {编号: 1, 状态: &quot;新创建&quot;} , {编号: 2, 状态: &quot;已取消&quot;} ]</code></pre>
<p>该特性在使用query接口导出文件时特别有用。</p>
<h4 id="汇总统计"><span class="header-section-number">3.2.6</span> 汇总统计</h4>
<p>通过在res中指定SUM等字段，可以返回汇总信息，如：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    res: &quot;COUNT(id) cnt, SUM(amount) amount&quot;,
    fmt: &quot;one&quot; // 由于结果必然只有一行，指定one格式更方便
})</code></pre>
<p>返回示例：</p>
<pre><code>{cnt: 82, amount: 35340}</code></pre>
<p>考虑安全性与便利性，res中只能使用白名单中的安全统计函数，包括：MAX, MIN, AVG, SUM, COUNT, SUMIF, COUNTIF. 函数名不区分大小写。</p>
<p>其中SUMIF和COUNTIF是扩展函数，便于进行带条件的统计，如统计今日(假设日期为2020-10-10)、本月、今年的累计订单数和订单金额：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    res: &quot;COUNTIF(createTm&gt;=&#39;2020-10-10&#39;) 今日订单数, COUNTIF(createTm&gt;=&#39;2020-10-1&#39;) 本月订单数, COUNTIF(createTm&gt;=&#39;2020-1-1&#39;) 今年订单数, &quot; +
        &quot;SUMIF(createTm&gt;=&#39;2020-10-10&#39;, amount) 今日订单额, SUMIF(createTm&gt;=&#39;2020-10-1&#39;, amount) 本月订单额, SUMIF(createTm&gt;=&#39;2020-1-1&#39;, amount) 今年订单额&quot;,
    fmt: &quot;one&quot; 
})</code></pre>
<p>它等价于多次下面带cond参数的调用：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    res: &quot;COUNT(1) 今日订单数, SUM(amount) 今日订单额&quot;,
    cond: &quot;createTm&gt;&#39;2020-10-10&#39;&quot;,
    fmt: &quot;one&quot; 
})</code></pre>
<p>也可以在普通查询的同时指定要统计哪些列，使用statRes字段。</p>
<dl>
<dt>statRes</dt>
<dd>指定统计字段，会在分页返回结果中添加stat对象。注意fmt参数不能是one, array, hash等，只允许是list或默认（即hd格式）。 statRes的写法与res相同，支持COUNT/COUNTIF等白名单内的统计函数。
</dd>
</dl>
<p>请求示例：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    res: &quot;id, createTm, amount&quot;,
    statRes: &quot;COUNT(id) cnt, SUM(amount) amount&quot;,
})</code></pre>
<p>返回示例：</p>
<pre><code>{
    h: [&quot;id&quot;, &quot;createTm&quot;, &quot;amount&quot;],
    d: [
        [ 100, &quot;2015-1-1 10:10:10&quot;, 1000],
        [ 101, &quot;2015-1-2 10:11:10&quot;, 1200],
        ...
    ],
    stat: {cnt: 82, amount: 35340},
    nextkey: 9
}</code></pre>
<p>如果上面指定<code>fmt: &quot;list&quot;</code>则返回示例：</p>
<pre><code>{
    list: [
        { id: 100, createTm: &quot;2015-1-1 10:10:10&quot;, amount: 1000 },
        { id: 101, createTm: &quot;2015-1-2 10:11:10&quot;, amount: 1200 },
        ...
    ],
    stat: {cnt: 82, amount: 35340},
    nextkey: 9
}</code></pre>
<h4 id="分组统计"><span class="header-section-number">3.2.7</span> 分组统计</h4>
<p>主要通过gres参数实现查询结果分组：</p>
<dl>
<dt>gres</dt>
<dd>String. 分组字段。如果设置了gres字段，则res参数中每项应该带统计函数，如&quot;sum(cnt) sum, count(id) userCnt&quot;. 最终返回列为gres参数指定的列加上res参数指定的列; 如果res参数未指定，则只返回gres参数列。
</dd>
</dl>
<p>例：统计2015-2016两年间，按年份、状态分类（如已付款、已评价、已取消等）的各类订单的总数和总金额。</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    gres: &quot;y,status&quot;, res: &quot;count(&#39;A&#39;) totalCnt, sum(amount) totalAmount&quot;,
    cond: &quot;tm&gt;=&#39;2015-1-1&#39; and tm&lt;&#39;2017-1-1&#39;&quot;
})</code></pre>
<p>返回内容示例：</p>
<pre><code>{
    h: [&quot;y&quot;, &quot;status&quot;, &quot;totalCnt&quot;, &quot;totalAmount&quot;],
    d: [
        [ 2015, &quot;PA&quot;, 1130, 14420 ],  // 已付款，共1130单，14420元
        [ 2015, &quot;CA&quot;, 2, 38 ], // 取消的订单
        [ 2016, &quot;PA&quot;, 170, 3390 ],
        [ 2016, &quot;CA&quot;, 9, 220 ],
        [ 2016, &quot;RA&quot;, 1530, 15580 ], // 已评价的订单
    ]
}</code></pre>
<p>以下为约定时间统计字段：</p>
<ul>
<li>y: 年</li>
<li>m: 月, 1-12</li>
<li>d: 日, 1-31</li>
<li>h: 时, 0-23</li>
<li>q: 季度</li>
<li>w: 周。计算模式为：一年中第一周，从该年第一个周一开始(mysql week函数模式7).</li>
<li>wd: 周几, 1-7, 表示周一到周日</li>
</ul>
<p>后端可以默认提供这些时间统计字段，也可以由前端指定一个时间字段，生成这些统计字段：</p>
<dl>
<dt>tmField</dt>
<dd>String. 指定时间字段，基于该字段生成时间统计字段（y,m,d等虚拟字段）。
</dd>
</dl>
<p>示例：按付款时间payTm来统计每年订单数：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    res: &quot;count(*) cnt&quot;,
    gres: &quot;y&quot;,
    tmField: &quot;payTm&quot;
});</code></pre>
<p><strong>[行列转置]</strong></p>
<p>在做数据透视表展示统计结果时，常常用到行列转置，可用以下参数：</p>
<dl>
<dt>pivot</dt>
<dd>String. 设置行列转置。
</dd>
<dt>pivotCnt</dt>
<dd>Integer. 可选，默认统计列为最后1列，若最后两列都是是统计列，可以设置为2.
</dd>
</dl>
<p>例：上面示例中，将状态status列转置到行上：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    gres: &quot;y,status&quot;, res: &quot;count(&#39;A&#39;) totalCnt, sum(amount) totalAmount&quot;,
    cond: &quot;tm&gt;=&#39;2015-1-1&#39; and tm&lt;&#39;2017-1-1&#39;&quot;,
    pivot: &quot;status&quot;,
    pivotCnt: 2
})</code></pre>
<p>返回内容示例：</p>
<pre><code>{
    h: [&quot;y&quot;, &quot;PA&quot;,&quot;CA&quot;,&quot;RA&quot;],
    d: [
        [ 2015, [1130, 14420], [2, 38], [0, 0] ],
        [ 2016, [170, 3390], [9, 220], [1530, 15580] ]
    ]
}</code></pre>
<p>转置到列上的数据如果为null，则以&quot;(null)&quot;来显示；如果是空串，不做特殊处理。</p>
<p>pivot参数可以设置多列，以逗号分隔，如将年、月显示到列上：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    gres: &quot;y,m,status&quot;, res: &quot;count(&#39;A&#39;) totalCnt&quot;,
    cond: &quot;tm&gt;=&#39;2015-1-1&#39; and tm&lt;&#39;2017-1-1&#39;&quot;,
    pivot: &quot;y,m&quot;
})</code></pre>
<p>转置到列后的字段以&quot;-&quot;拼接，如果有值为null的，以&quot;(null)&quot;显示。 返回内容示例：</p>
<pre><code>{
    h: [&quot;status&quot;, &quot;2020-1&quot;, &quot;2020-2&quot;, &quot;2020-(null)&quot;, &quot;(null)-(null)&quot;],
    d: [
        [ &quot;PA&quot;, 120, 230, 1, 0],
        [ &quot;CA&quot;, 300, 310, 0, 2]
    ]
}</code></pre>
<p><strong>[行列汇总]</strong></p>
<p>没有pivot时，用sumFields参数指定要统计的列，支持多列；有pivot时，用pivotSumField参数指定新添加的统计列的名字，只有一列，不存在多列。</p>
<dl>
<dt>sumFields</dt>
<dd>String. 在数据最后添加汇总行，对一个或多个字段进行汇总。当有pivot参数时，该选项无效，应使用pivotSumField参数（下面有介绍）。 注意如果数据仅有一行，不添加汇总行。注意如果有分页，即数据在一页内显示不完，只会累加当前页的数据。
</dd>
</dl>
<p>示例：简单查询，汇总其中一列</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    res: &quot;id, createTm, amount&quot;,
    sumFields: &quot;amount&quot;
})</code></pre>
<p>返回内容示例：</p>
<pre><code>{
    h: [&quot;id&quot;, &quot;createTm&quot;, &quot;amount&quot;],
    d: [
        [ 100, &quot;2015-1-1 10:10:10&quot;, 1000],
        [ 101, &quot;2015-1-2 10:11:10&quot;, 1200],
        [ &quot;合计&quot;, null, 2200 ], // 自动添加的汇总行，对指定列进行汇总
    ]
}</code></pre>
<p>如果一页无法返回所有数据，又想在汇总中累计所有数据，要么调整pagesz参数让数据尽可能在一页内返回，要么额外使用statRes参数（前面有介绍）得到统计字段，如：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    res: &quot;id, createTm, amount&quot;,
    statRes: &quot;SUM(amount) amount&quot;,
    sumFields: &quot;amount&quot;
})</code></pre>
<p>返回内容示例：</p>
<pre><code>{
    h: [&quot;id&quot;, &quot;createTm&quot;, &quot;amount&quot;],
    d: [
        [ 100, &quot;2015-1-1 10:10:10&quot;, 1000],
        [ 101, &quot;2015-1-2 10:11:10&quot;, 1200],
        ...
        [ &quot;合计&quot;, null, 50200 ], // 自动添加的汇总行，对指定列进行汇总
    ],
    // statRes参数将会自动添加stat对象，表示各统计列
    stat: { amount: 50200 },
    nextkey: 9
}</code></pre>
<p>注意：sumFields中的字段，是优先从stat对象中获取的，如果在stat中不存在，才做页内累加。</p>
<p>示例：分组统计查询，汇总两列</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    gres: &quot;y,status&quot;, res: &quot;count(&#39;A&#39;) totalCnt, sum(amount) totalAmount&quot;,
    sumFields: &quot;totalCnt, totalAmount&quot;
})</code></pre>
<p>返回内容示例：</p>
<pre><code>{
    h: [&quot;y&quot;, &quot;status&quot;, &quot;totalCnt&quot;, &quot;totalAmount&quot;],
    d: [
        [ 2015, &quot;PA&quot;, 1130, 14420 ],  // 已付款，共1130单，14420元
        [ 2015, &quot;CA&quot;, 2, 38 ], // 取消的订单
        [ 2016, &quot;PA&quot;, 170, 3390 ],
        [ 2016, &quot;CA&quot;, 9, 220 ],
        [ 2016, &quot;RA&quot;, 1530, 15580 ], // 已评价的订单
        [ &quot;合计&quot;, null, 2841, 33648 ], // 自动添加的汇总行，对指定的两列进行汇总
    ]
}</code></pre>
<dl>
<dt>pivotSumField</dt>
<dd>String. 例如设置值为&quot;合计&quot;，则会在每行添加一个名为&quot;合计&quot;的汇总列，且在数据最后添加一个汇总行。 注意：如果行转置后只有一行，则不显示统计列；如果总共只有一行，则不显示统计行。
</dd>
</dl>
<p>示例：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {
    gres: &quot;y,status&quot;, res: &quot;count(&#39;A&#39;) totalCnt, sum(amount) totalAmount&quot;,
    pivot: &quot;status&quot;,
    pivotSumField: &quot;合计&quot;
})</code></pre>
<p>返回内容示例：</p>
<pre><code>{
    h: [&quot;y&quot;, &quot;PA&quot;,&quot;CA&quot;,&quot;RA&quot;, &quot;合计&quot;], // 自动添加汇总列&quot;合计&quot;
    d: [
        [ 2015, [1130, 14420], [2, 38], [0, 0], [1132, 14458] ],
        [ 2016, [170, 3390], [9, 220], [1530, 15580], [1709, 19190] ],
        [ &quot;合计&quot;, [1300, 17810], [11, 258], [1530, 15580], [2841, 33648] ] // 自动添加汇总行
    ]
}</code></pre>
<h4 id="模糊查询"><span class="header-section-number">3.2.8</span> 模糊查询</h4>
<dl>
<dt>qsearch</dt>
<dd>格式是<code>字段1,字符2,...:查询内容</code>(使用英文逗号及冒号分隔), 表示在指定的若干字段中模糊查询。
</dd>
</dl>
<p>示例：在dscr或cmt字段中，查找以&quot;张&quot;开头，并且包含&quot;退款&quot;的订单记录</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {qsearch: &quot;dscr,cmt:张* 退款&quot;})</code></pre>
<p>字段可以使用虚拟字段。</p>
<p>查询内容是一个字符串，或多个以空格分隔的字符串。例如&quot;aa bb&quot;表示字段包含&quot;aa&quot;且包含&quot;bb&quot;。 每个字符串中可以用通配符<code>*</code>，如<code>a*</code>表示以a开头，<code>*a</code>表示以a结尾，而<code>*a*</code>和<code>a</code>是效果相同的。</p>
<h3 id="查询分页机制"><span class="header-section-number">3.3</span> 查询分页机制</h3>
<p>如果一个查询支持分页(paging), 则一般调用形式为</p>
<pre><code>Ordr.query(page/pagekey?, pagesz/rows?=20) -&gt; {nextkey, total?, @h, @d}</code></pre>
<p><strong>[参数]</strong></p>
<dl>
<dt>pagesz或rows</dt>
<dd>Integer. 这两个参数含义相同，均表示页大小，默认为20条数据。
</dd>
<dt>page</dt>
<dd>Integer. 可选，指定分页页码，默认为1（第1页）。
</dd>
<dt>pagekey</dt>
<dd>Integer. 与page参数指定页码不同，pagekey是另一种基于主键的分页。一般首次查询时不填写（或填写0，表示需要返回总记录数即total字段），而下次查询时应根据上次调用时返回数据的&quot;nextkey&quot;字段来填写。
</dd>
</dl>
<p><strong>[查询返回字段]</strong></p>
<dl>
<dt>nextkey</dt>
<dd>Integer. 一个字符串, 供取下一页时填写参数&quot;pagekey&quot;或&quot;page&quot;。如果不存在该字段，则说明已经是最后一批数据。
</dd>
<dt>total</dt>
<dd>Integer. 返回总记录数，仅当&quot;pagekey&quot;指定为0时返回，或是指定&quot;page&quot;参数时也会返回。）
</dd>
<dt>h/d</dt>
<dd>两个数组。实际数据表的头信息(header)和数据行(data)，符合压缩表对象的格式。
</dd>
</dl>
<p><strong>[示例]</strong></p>
<p>基于page页码的查询较容易理解，常用于管理端分页列表。而pagekey是基于主键的查询，常用于移动端上拉自动加载下一页的列表，示例如下。</p>
<p>第一次查询</p>
<pre><code>callSvr(&quot;Ordr.query&quot;)</code></pre>
<p>返回</p>
<pre><code>{nextkey: 10800910, h: [&quot;id&quot;, &quot;desc&quot;, ...], d: [...]}</code></pre>
<p>其中的nextkey将供下次查询时填写pagekey字段；</p>
<p>要在首次查询时返回总记录数，可以设置用pagekey=0：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {pagekey:0})</code></pre>
<p>这时返回</p>
<pre><code>{nextkey: 10800910, total: 51, h: [&quot;id&quot;, ...], d: [...]}</code></pre>
<p>total字段表示总记录数。由于缺省页大小为20，所以可估计总共有51/20=3页。</p>
<p>第二次查询(下一页)</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {pagekey:&quot;10800910&quot;});</code></pre>
<p>返回</p>
<pre><code>{nextkey: 10800931, h: [...], d: [...]}</code></pre>
<p>仍返回nextkey字段说明还可以继续查询，</p>
<p>再查询下一页</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {pagekey: &quot;10800931&quot;})</code></pre>
<p>返回</p>
<pre><code>{h: [...], d: [...]}</code></pre>
<p>返回数据中不带&quot;nextkey&quot;属性，表示所有数据获取完毕。</p>
<p><strong>[分页实现]</strong></p>
<p>分页有两种实现方式：按主键字段的分段查询式分页，以及使用LIMIT操作为核心的传统分页。</p>
<p>分段查询的原理是利用主键id进行查询条件控制（自动修改WHERE语句），每次返回的pagekey字段实际是上次数据的最后一个id.</p>
<p>首次查询：</p>
<pre><code>callSvr(&quot;Ordr.query&quot;)</code></pre>
<p>SQL样例如下：</p>
<pre><code>SELECT * FROM Ordr t0
...
ORDER BY t0.id
LIMIT {pagesz}</code></pre>
<p>再次查询</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {pagekey: &quot;10800910&quot;})</code></pre>
<p>SQL样例如下：</p>
<pre><code>SELECT * FROM Ordr t0
...
WHERE t0.id&gt;10800910
ORDER BY t0.id
LIMIT {pagesz}</code></pre>
<p>分段查询性能高，更精确，不会丢失数据。但它仅适用于未指定排序字段（无orderby参数）或排序字段是id的情况（例如：orderby=&quot;id DESC&quot;）。 查询引擎应根据orderby参数自动选择分段查询或传统分页。</p>
<p>传统分页常通过SQL语句的LIMIT关键字来实现。pagekey字段实际是页码。其原理是：</p>
<p>首次查询</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {orderby:&quot;comeTm DESC&quot;})</code></pre>
<p>（以comeTm作为排序字段，无法应用分段查询机制，只能使用传统分页。）</p>
<p>SQL样例如下：</p>
<pre><code>SELECT * FROM Ordr t0
...
ORDER BY comeTm DESC, t0.id
LIMIT 0,{pagesz}</code></pre>
<p>再次查询</p>
<pre><code>callSvr(&quot;Ordr.query&quot;, {pagekey:2})</code></pre>
<p>SQL样例如下：</p>
<pre><code>SELECT * FROM Ordr t0
...
ORDER BY comeTm DESC, t0.id
LIMIT ({pagekey}-1)*{pagesz}, {pagesz}</code></pre>
<h3 id="批量导入数据"><span class="header-section-number">3.4</span> 批量导入数据</h3>
<p>标准接口<code>Obj.batchAdd</code>用于批量导入数据（支持不存在则添加，存在则更新）。返回导入记录数cnt及编号列表idList：</p>
<pre><code>Obj.batchAdd(title?, uniKey?, useColMap?)(...) -&gt; {cnt, @idList}</code></pre>
<p>它在一个事务中执行，一行出错后立即失败返回，该行前面已导入的内容也会被取消（回滚）。</p>
<ul>
<li><p>title: List(fieldName). 指定标题行(即字段列表). 如果有该参数, 则忽略POST内容或文件中的标题行. 如&quot;title=name,-,addr&quot;表示导入第一列name和第三列addr, 其中&quot;-&quot;表示忽略该列，不导入。 字段列表以逗号或空白分隔, 如&quot;title=name - addr&quot;与&quot;title=name, -, addr&quot;都可以.</p></li>
<li><p>uniKey: 唯一索引字段. 如果指定, 则以该字段查询记录是否存在, 存在则更新。例如&quot;code&quot;, 也支持多个字段（用于关联表），如&quot;bpId,itemId&quot;。 还可以加&quot;!&quot;后缀表示只更新不添加；支持通过参数uniKeyMode定制行为。详见add接口参数介绍。</p></li>
<li><p>useColMap: 设置为1时，使用列名映射。</p></li>
</ul>
<h4 id="批量导入支持三种方式"><span class="header-section-number">3.4.1</span> 批量导入支持三种方式</h4>
<ol style="list-style-type: decimal">
<li><p>直接在HTTP POST中传输内容，数据格式为：首行为标题行(即字段名列表)，之后为实际数据行。 行使用&quot;&quot;分隔, 列使用&quot;&quot;或逗号分隔（后端自动判断），方便直接从Excel中拷贝数据出来，或导出csv格式文件。 接口为：</p>
<p>{Obj}.batchAdd(title?)(标题行，数据行) (Content-Type=text/plain)</p></li>
</ol>
<p>前端JS调用示例：</p>
<pre><code>var data = &quot;name\taddr\n&quot; + &quot;门店1\t地址1\n门店2\t地址2\n&quot;;
callSvr(&quot;Store.batchAdd&quot;, function (ret) {
    app_alert(&quot;成功导入&quot; + ret.cnt + &quot;条数据！&quot;);
}, data, {contentType:&quot;text/plain&quot;});</code></pre>
<p>或指定title参数:</p>
<pre><code>var data = &quot;门店名\t地址\n&quot; + &quot;门店1\t地址1\n门店2\t地址2\n&quot;;
callSvr(&quot;Store.batchAdd&quot;, {title: &quot;name,addr&quot;}, function (ret) {
    app_alert(&quot;成功导入&quot; + ret.cnt + &quot;条数据！&quot;);
}, data, {contentType:&quot;text/plain&quot;});</code></pre>
<p>示例: 在chrome console中导入数据</p>
<pre><code>callSvr(&quot;Vendor.batchAdd&quot;, {title: &quot;-,name, tel, idCard, addr, picId&quot;}, $.noop, `编号 姓名  手机号码    身份证号    通讯地址    身份证图
112 郭志强 15384811000 150221199211215XXX  地址1 532
111 高长平 18375991001 500226198312065XXX  地址2 534
`, {contentType:&quot;text/plain&quot;});
    </code></pre>
<ol start="2" style="list-style-type: decimal">
<li>标准csv/txt文件上传：</li>
</ol>
<p>上传的文件首行当作标题列，如果这一行不是后台要求的标题名称，可通过URL参数title重新定义。 一般使用excel csv文件（编码一般为gbk），或txt文件（以&quot;&quot;分隔列）。 接口为：</p>
<pre><code>{Obj}.batchAdd(title?)(csv/txt文件)
(Content-Type=multipart/form-data, 即html form默认传文件的格式)</code></pre>
<p>后端处理时, 将自动判断文本编码(utf-8或gbk).</p>
<p>前端HTML:</p>
<pre><code>&lt;input type=&quot;file&quot; name=&quot;f&quot; accept=&quot;.csv,.txt&quot;&gt;</code></pre>
<p>前端JS示例：</p>
<pre><code>var fd = new FormData();
fd.append(&quot;file&quot;, frm.f.files[0]);
callSvr(&quot;Store.batchAdd&quot;, {title: &quot;name,addr&quot;}, function (ret) {
    app_alert(&quot;成功导入&quot; + ret.cnt + &quot;条数据！&quot;);
}, fd);</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>传入对象数组</li>
</ol>
<p>格式为 {list: [...]}，示例：</p>
<pre><code>var data = {
    list: [
        {name: &quot;郭志强&quot;, tel: &quot;15384811000&quot;},
        {name: &quot;高长平&quot;, tel: &quot;18375991001&quot;}
    ]
};
callSvr(&quot;Store.batchAdd&quot;, function (ret) {
    app_alert(&quot;成功导入&quot; + ret.cnt + &quot;条数据！&quot;);
}, data);</code></pre>
<h4 id="通过导入实现批量更新"><span class="header-section-number">3.4.2</span> 通过导入实现批量更新</h4>
<p>batchAdd接口配合标准add接口支持的uniKey参数，可实现存在则更新，不存在则添加的逻辑。</p>
<p>示例：接上节示例，在导入时希望实现根据名称与电话(name和tel字段)匹配，则记录存在则做更新，不存在则添加，只须增加uniKey参数：</p>
<pre><code>callSvr(&quot;Store.batchAdd&quot;, {uniKey: &quot;name,tel&quot;}, function (ret) {
    app_alert(&quot;成功导入&quot; + ret.cnt + &quot;条数据！&quot;);
}, data);</code></pre>
<h4 id="支持带子表导入"><span class="header-section-number">3.4.3</span> 支持带子表导入</h4>
<p>示例：有以下主-子表对象：</p>
<pre><code>工单：@Ordr: id, code, itemId, qty
工单配料单 @BOM: id, orderId, code, name</code></pre>
<p>注意：拷贝到Excel中看的比较清楚；为避免Excel将长数字显示为科学计数法，在复制前先设置单元格格式为文本。</p>
<pre><code>生产订单号   物料编码    物料规格    开工日期    完工日期    生产数量    子件编码    子件规格    基本用量
SCDD210202302   30101001010484  热像仪#Fotric 615C-L47 2021-02-04  2021-02-04  1.00    20901001000052  标品#Lantern_B31-L47  1
SCDD210202302   30101001010484  热像仪#Fotric 615C-L47 2021-02-04  2021-02-04  1.00    10205001000017  标签#Lantern_40*30mm铜版纸空白标签#中性#通用 1</code></pre>
<p>调用示例：</p>
<pre><code>callSvr(&quot;Ordr.batchAdd&quot;, {title: &quot;code,itemCode,itemName,planTm,planTm1,qty,@bom.code,@bom.name,@bom.qty&quot;, uniKey: &quot;code&quot;}, $.noop, data);</code></pre>
<p>注意：由于子表分布在多行，必须以uniKey参数指定主表唯一字段（支持多个字段联合，以逗号分隔），将根据此字段将多行数组组合成对象后一次导入。 为了正确将主-子表结构的数据行组合成对象，必须保证：组成一个对象的所有行必须在一起，具有相同的uniKey字段，或是对象的第二行起，不指定uniKey字段。</p>
<p>上例也可以简化定义成：(第二行起，无须主表字段，只需要最后三个子表字段) (拷贝到Excel中看)</p>
<pre><code>生产订单号   物料编码    物料规格    开工日期    完工日期    生产数量    子件编码    子件规格    基本用量
SCDD210202302   30101001010484  热像仪#Fotric 615C-L47 2021-02-04  2021-02-04  1.00    20901001000052  标品#Lantern_B31-L47  1
                        10205001000017  标签#Lantern_40*30mm铜版纸空白标签#中性#通用 1</code></pre>
<h4 id="支持列名映射"><span class="header-section-number">3.4.4</span> 支持列名映射</h4>
<p>数据表导入时，默认是按固定列顺序来确定字段的，比如第1列必须是code，第2列必须是itemCode，如果要跳过一列，须通过&quot;-&quot;来指定； 使用列名映射是另一种方式（通过指定参数useColMap=1激活），示例：</p>
<pre><code>id  name    code    itemId  itemCode
1   name1   code1   101 item-101
2   name2   code2   102 item-102</code></pre>
<p>batchAdd调用参数为: <code>{title: &quot;code,itemCode&quot;, useColMap:1}</code>。</p>
<p>这时只通过列名来匹配（若找不到匹配列则报错！），列的顺序对导入就没有影响。可以通过<code>-&gt;</code>来指定列的别名，示例：</p>
<pre><code>编号  物料名 编码  物料名 物料编码
1   name1   code1   101 item-101
2   name2   code2   102 item-102</code></pre>
<p>batchAdd调用参数为: <code>{title: &quot;编码-&gt;code,物料编码-&gt;itemCode&quot;, useColMap:1}</code>。支持子对象列名映射，如<code>子件编码-&gt;@bom.code</code>。</p>
<h3 id="子表的增删改查操作"><span class="header-section-number">3.5</span> 子表的增删改查操作</h3>
<p>假设主对象为Obj，子对象为Obj1，设计如下：</p>
<pre><code>@Obj: id, name
vcol: @obj1 (说明：vcol表示虚拟字段，@obj1表示字段obj1是个数组，一般就是子对象)

@Obj1: id, objId, name （通过objId关联主对象)</code></pre>
<h4 id="子表添加"><span class="header-section-number">3.5.1</span> 子表添加</h4>
<p>在添加主对象时，同时添加子对象:</p>
<pre><code>Obj.add()(name, @obj1...) -&gt; id</code></pre>
<p>示例：</p>
<pre><code>callSvr(&quot;Obj.add&quot;, $.noop, {
    name: &quot;name1&quot;,
    obj1: [
        { name: &quot;obj1-name1&quot; },
        { name: &quot;obj1-name2&quot; }
    ]
});</code></pre>
<h4 id="子表查询"><span class="header-section-number">3.5.2</span> 子表查询</h4>
<p>主对象添加后，可以通过get接口获取主对象及子对象：</p>
<pre><code>callSvr(&quot;Obj.get&quot;, {id: 1001, res:&quot;id,name,obj1&quot;})
返回
{
    id: 1001,
    name: &quot;name1&quot;,
    obj1: [
        { id: 10001, name: &quot;obj1-name1&quot; },
        { id: 10002, name: &quot;obj1-name2&quot; }
    ]
}</code></pre>
<p>要控制子对象的查询结果字段，可以加<code>res_{子对象名}</code>参数；要控制子对象的查询参数，可以加<code>param_{子对象名}</code>参数，示例：</p>
<pre><code>callSvr(&quot;Obj.get&quot;, {id: 1001, res:&quot;id,name,obj1&quot;, res_obj1:&quot;id,name&quot;})
或
callSvr(&quot;Obj.get&quot;, {id: 1001, res:&quot;id,name,obj1&quot;, param_obj1: { res: &quot;id,name&quot;} })
callSvr(&quot;Obj.get&quot;, {id: 1001, res:&quot;id,name,obj1&quot;, param_obj1: { res: &quot;id,name&quot;, cond: &quot;id&gt;=10002&quot;} })</code></pre>
<p>注意：如果使用了别名，则指定res,param时也要用别名：</p>
<pre><code>callSvr(&quot;Obj.get&quot;, {id: 1001, res:&quot;id,name,obj1 objList&quot;, res_objList:&quot;id,name&quot;})
// 甚至可以多别名分别指定:
callSvr(&quot;Obj.get&quot;, {id: 1001, res:&quot;id,name,obj1 objList,obj1 objList2&quot;, res_objList:&quot;id,name&quot;, res_objList2:&quot;id,code&quot;})</code></pre>
<p>当然，也可以直接查询子对象，如：</p>
<pre><code>callSvr(&quot;Obj1.query&quot;, {cond: &quot;objId=1001&quot;, res:&quot;id,name,obj1&quot;, fmt:&quot;array&quot;})
返回
[
    { id: 10001, name: &quot;obj1-name1&quot; },
    { id: 10002, name: &quot;obj1-name2&quot; }
]</code></pre>
<p>这里用fmt参数指定返回array格式，因为默认返回的是<code>h/d</code>格式.</p>
<h4 id="子表更新与删除"><span class="header-section-number">3.5.3</span> 子表更新与删除</h4>
<p>主对象添加后，可以通过set接口添加/更新/删除子对象。假定后端提供如下更新接口（可更新主表字段name等，子表名为obj1）：</p>
<pre><code>Obj.set(id)(name?, @obj1...)</code></pre>
<p>示例：</p>
<pre><code>callSvr(&quot;Obj.set&quot;, {id: 1001}, $.noop, {
    name: &quot;name1&quot;,
    obj1: [
        { id: 10001, name: &quot;obj1-name1-changed&quot; }, // set接口中指定子表id的，表示更新该子表行
        { name: &quot;obj1-name3&quot; },  // set接口中未指定子表id的，表示新增子表行
        { id: 10002, _delete: 1}  // set接口中指定子表id且设置了`_delete: 1`，表示删除该子表行
    ]
});</code></pre>
<p>注意：主对象删除时（del/delIf接口），子对象不会自动删除。后端应根据情况自行处理。</p>
<p>对子表的更新有patch/put两种模式，通过submode参数指定，该参数只对主表set接口有效：</p>
<ul>
<li>patch: 默认模式，见上面示例。须用<code>_delete</code>指定要删除的原来子表项。</li>
<li>put: 覆盖更新模式。与patch的区别是无须指定<code>_delete</code>来删除原来子表项，新子表直接覆盖原子表。</li>
</ul>
<p>与上述示例中效果相同的操作示例：</p>
<pre><code>// submode=put模式
callSvr(&quot;Obj.set&quot;, {id: 1001, submode: &quot;put&quot;}, $.noop, {
    name: &quot;name1&quot;,
    obj1: [
        { id: 10001, name: &quot;obj1-name1-changed&quot; }, // set接口中指定子表id的，表示更新该子表行; 也可以不指定id，则原来记录被删除，这条会被重新添加。
        { name: &quot;obj1-name3&quot; },  // set接口中未指定子表id的，表示新增子表行
        // 原表中的10002项未指定，则自动被删除。
    ]
});</code></pre>
<p>注意：add接口在指定uniKey参数时，可检查数据存在则更新(即调用set接口)。因此add/batchAdd接口也可以指定submode参数。 在批量导入(batchAdd接口+uniKey参数)时，默认使用put模式做子表更新。</p>
<h2 id="批请求"><span class="header-section-number">4</span> 批请求</h2>
<p>BQP协议支持批请求，即在一次请求中，包含多条接口调用。 而且支持向前引用，即后面的调用可以引用前面调用的返回值。 而且在创建批请求时，可以指定这些调用是否在一个事务(transaction)中，一起成功提交或失败回滚。</p>
<p>假如某场景需要两个请求，先获取用户信息(User.get接口)，然后上传页面名、用户编号等信息到服务器(ActionLog.add接口)供统计分析，调用示意如下：</p>
<pre><code>User.get(res=&quot;id,name,phone&quot;) -&gt; {id, name, phone}
ActionLog.add()(page=home, ver=android, userId={上一调用User.get返回的id}) -&gt; logId</code></pre>
<p>其中，调用二中参数userId需要引用调用一的返回结果。 如果想通过减少调用次数优化性能，可通过批请求，一次性提交两个调用，以及获得每个调用的返回值。</p>
<p>批请求使用接口名&quot;batch&quot;，通过JSON格式传递数据，请求示例如下：</p>
<pre><code>POST /api/batch
Content-Type: application/json;charset=utf-8

[
    {
        &quot;ac&quot;: &quot;User.get&quot;,
        &quot;get&quot;: {&quot;res&quot;: &quot;id,name,phone&quot;}
    },
    {
        &quot;ac&quot;: &quot;ActionLog.add&quot;,
        &quot;post&quot;: {&quot;page&quot;: &quot;home&quot;, &quot;ver&quot;: &quot;android&quot;, &quot;userId&quot;: &quot;{$-1.id}&quot;},
        &quot;ref&quot;: [&quot;userId&quot;]
    }
]</code></pre>
<p>请求数据是一个数组，数组中每一项为一个调用，其格式为: {ac, %get?, %post?, <span class="citation">@ref</span>?}, 只有ac参数必须，其它均可省略。</p>
<ul>
<li>get: URL请求参数。</li>
<li>post: POST请求参数。</li>
<li>ref: 使用了batch引用的参数列表。</li>
</ul>
<p>POST参数userId的值&quot;{$-1.id}&quot;表示取上一次调用值的id属性。使用向前引用的参数，必须在&quot;ref&quot;参数中指定。</p>
<p>注意：引用表达式应以&quot;{}&quot;包起来，&quot;$n&quot;中n可以为正数或负数（但不能为0），表示对第n次或前n次调用结果的引用，以下为允许的格式：</p>
<pre><code>&quot;{$1}&quot;  -- 第一个调用的返回值
&quot;{$-1}&quot;  -- 前一个调用的返回值
&quot;id={$1.id}&quot;
&quot;{$-1.d[0][0]}&quot;
&quot;id in ({$1}, {$2})&quot;
&quot;diff={$-2 - $-1}&quot;</code></pre>
<p>花括号中的内容将用计算后的结果替换。如果表达式非法，将使用&quot;null&quot;值替代。</p>
<p>batch的返回内容是多条调用返回内容组成的数组，样例如下：</p>
<pre><code>[0, [
    [ 0, {&quot;id&quot;: 1, &quot;name&quot;: &quot;用户1&quot;, &quot;phone&quot;: &quot;13712345678&quot;} ],  // 调用User.get的返回结果
    [ 0, 99 ]  // 调用ActionLog.add的返回结果logId
]]</code></pre>
<p><strong>批量请求支持事务(transaction)。</strong></p>
<p>如果批量请求在一个事务中，则最终所有调用会一起成功提交或失败回滚。 要使用事务，只需要请求加个URL参数<code>useTrans=1</code>：</p>
<pre><code>POST /api/batch?useTrans=1</code></pre>
<h2 id="服务端信息反馈x-daca头"><span class="header-section-number">5</span> 服务端信息反馈/X-Daca头</h2>
<p>BQP协议规定，以下服务端信息应通过HTTP头反馈给客户端。</p>
<p><strong>[接口服务版本号与前端应用热更新]</strong></p>
<p>服务端接口的版本号如果可以获取，应发送给客户端:</p>
<pre><code>X-Daca-Server-Rev: {value}</code></pre>
<p>其中value为最多6位的字符串。</p>
<p>前端应用程序可依据此信息实现热更新： 假如某前端H5应用（或以H5应用为内核的手机原生应用）操作期间，后端接口服务刚好升级过，应用程序再请求时，可以依据版本号变更发现升级行为，从而自动刷新到新版本。</p>
<p><strong>[测试模式和模拟模式]</strong></p>
<p>如果服务运行于测试模式或模拟模式，应设置：</p>
<pre><code>X-Daca-Test-Mode: {value}
X-Daca-Mock-Mode: {value}</code></pre>
<p>其中value为非0值，一般设置为1.</p>
<p>前端应用程序在发现接口服务运行在测试模式时，应予以提示。</p>

</body>
</html>

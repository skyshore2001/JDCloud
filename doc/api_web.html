<html>
<head>
<meta charset="utf-8">
<title>API参考 - 筋斗云前端（桌面Web版）</title>
<style>
h3,h4,h5,h6 {
	font-size: 1em;
}

pre {
	border-left: 1px solid #ccc;
	margin: 0 1em;
	padding: 0 0.5em;
	tab-size:4;
}

code {
	font-family: "Courier New";
    padding: 0px 3px;
    display: inline-block;
}

.toc {
	margin: 2em;
}

.toc p {
	margin: 0.3em 0;
}

.block {
	border-bottom: 1px solid #ccc;
}

</style>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="doc.css" />
<script src="refdoc.js"></script>
</head>

<body>
<h1>API参考 - 筋斗云前端（桌面Web版）</h1>
<div>最后更新：2017-08-17</div>
<div id="menu">
<h2>Modules</h2>
<div class="toc">
<p><a href="#WUI">WUI (module)</a></p>
</div><hr>
<h2>Keywords</h2>
<div class="toc">
<p><a href="##my-pages">#my-pages (key)</a></p>
<p><a href="#.easyui-validatebox">.easyui-validatebox (key)</a></p>
<p><a href="#.my-combobox">.my-combobox (key)</a></p>
<p><a href="#.wui-dialog">.wui-dialog (key)</a></p>
<p><a href="#.wui-page">.wui-page (key)</a></p>
<p><a href="#BASE_URL">BASE_URL (var)</a></p>
<p><a href="#Date.add">Date.add (fn)</a></p>
<p><a href="#Date.addDay">Date.addDay (fn)</a></p>
<p><a href="#Date.addHours">Date.addHours (fn)</a></p>
<p><a href="#Date.addMin">Date.addMin (fn)</a></p>
<p><a href="#Date.addMonth">Date.addMonth (fn)</a></p>
<p><a href="#Date.diff">Date.diff (fn)</a></p>
<p><a href="#Date.format">Date.format (fn)</a></p>
<p><a href="#DirectReturn">DirectReturn (class)</a></p>
<p><a href="#ListOptions">ListOptions (var)</a></p>
<p><a href="#MUI.batchCall">MUI.batchCall (class)</a></p>
<p><a href="#MUI.callSvr">MUI.callSvr (fn)</a></p>
<p><a href="#MUI.callSvrExt">MUI.callSvrExt (key)</a></p>
<p><a href="#MUI.callSvrExt['default']">MUI.callSvrExt['default'] (key)</a></p>
<p><a href="#MUI.callSvrExt[].beforeSend">MUI.callSvrExt[].beforeSend (key)</a></p>
<p><a href="#MUI.callSvrExt[].dataFilter">MUI.callSvrExt[].dataFilter (key)</a></p>
<p><a href="#MUI.callSvrExt[].makeUrl">MUI.callSvrExt[].makeUrl (key)</a></p>
<p><a href="#MUI.callSvrSync">MUI.callSvrSync (fn)</a></p>
<p><a href="#MUI.defDataProc">MUI.defDataProc (fn)</a></p>
<p><a href="#MUI.disableBatch">MUI.disableBatch (var)</a></p>
<p><a href="#MUI.enhanceWithin">MUI.enhanceWithin (fn)</a></p>
<p><a href="#MUI.enterWaiting">MUI.enterWaiting (fn)</a></p>
<p><a href="#MUI.getBaseUrl">MUI.getBaseUrl (fn)</a></p>
<p><a href="#MUI.getOptions">MUI.getOptions (fn)</a></p>
<p><a href="#MUI.hideLoading">MUI.hideLoading (fn)</a></p>
<p><a href="#MUI.lastError">MUI.lastError (var)</a></p>
<p><a href="#MUI.leaveWaiting">MUI.leaveWaiting (fn)</a></p>
<p><a href="#MUI.m_curBatch">MUI.m_curBatch (var)</a></p>
<p><a href="#MUI.m_enhanceFn">MUI.m_enhanceFn (var)</a></p>
<p><a href="#MUI.makeUrl">MUI.makeUrl (fn)</a></p>
<p><a href="#MUI.mockData">MUI.mockData (var)</a></p>
<p><a href="#MUI.setOnError">MUI.setOnError (fn)</a></p>
<p><a href="#MUI.setupCallSvrViaForm">MUI.setupCallSvrViaForm (fn)</a></p>
<p><a href="#MUI.showLoading">MUI.showLoading (fn)</a></p>
<p><a href="#MUI.useBatchCall">MUI.useBatchCall (fn)</a></p>
<p><a href="#Plugins">Plugins (class)</a></p>
<p><a href="#Plugins.exists">Plugins.exists (fn)</a></p>
<p><a href="#Plugins.list">Plugins.list (fn)</a></p>
<p><a href="#WUI">WUI (module)</a></p>
<p><a href="#WUI.app_alert">WUI.app_alert (fn)</a></p>
<p><a href="#WUI.closeDlg">WUI.closeDlg (fn)</a></p>
<p><a href="#WUI.dg_dblclick">WUI.dg_dblclick (fn)</a></p>
<p><a href="#WUI.dg_toolbar">WUI.dg_toolbar (fn)</a></p>
<p><a href="#WUI.getActivePage">WUI.getActivePage (fn)</a></p>
<p><a href="#WUI.getExportHandler">WUI.getExportHandler (fn)</a></p>
<p><a href="#WUI.getParamFromTable">WUI.getParamFromTable (fn)</a></p>
<p><a href="#WUI.getQueryCond">WUI.getQueryCond (fn)</a></p>
<p><a href="#WUI.getQueryParam">WUI.getQueryParam (fn)</a></p>
<p><a href="#WUI.getTopDialog">WUI.getTopDialog (fn)</a></p>
<p><a href="#WUI.handleLogin">WUI.handleLogin (fn)</a></p>
<p><a href="#WUI.initClient">WUI.initClient (fn)</a></p>
<p><a href="#WUI.logout">WUI.logout (fn)</a></p>
<p><a href="#WUI.options">WUI.options (var)</a></p>
<p><a href="#WUI.options.pageFolder">WUI.options.pageFolder (key)</a></p>
<p><a href="#WUI.reload">WUI.reload (fn)</a></p>
<p><a href="#WUI.reloadDialog">WUI.reloadDialog (alias)</a></p>
<p><a href="#WUI.reloadPage">WUI.reloadPage (fn)</a></p>
<p><a href="#WUI.reloadRow">WUI.reloadRow (fn)</a></p>
<p><a href="#WUI.reloadTmp">WUI.reloadTmp (fn)</a></p>
<p><a href="#WUI.setApp">WUI.setApp (fn)</a></p>
<p><a href="#WUI.showDlg">WUI.showDlg (fn)</a></p>
<p><a href="#WUI.showObjDlg">WUI.showObjDlg (fn)</a></p>
<p><a href="#WUI.showPage">WUI.showPage (fn)</a></p>
<p><a href="#WUI.tabClose">WUI.tabClose (fn)</a></p>
<p><a href="#WUI.tabMain">WUI.tabMain (var)</a></p>
<p><a href="#WUI.tryAutoLogin">WUI.tryAutoLogin (fn)</a></p>
<p><a href="#WUI.unloadDialog">WUI.unloadDialog (fn)</a></p>
<p><a href="#WUI.unloadPage">WUI.unloadPage (fn)</a></p>
<p><a href="#a[href=">a[href= (key)</a></p>
<p><a href="#a[href=#page]">a[href=#page] (key)</a></p>
<p><a href="#app_abort">app_abort (fn)</a></p>
<p><a href="#app_confirm">app_confirm (fn)</a></p>
<p><a href="#app_show">app_show (fn)</a></p>
<p><a href="#appendParam">appendParam (fn)</a></p>
<p><a href="#applyTpl">applyTpl (fn)</a></p>
<p><a href="#assert">assert (fn)</a></p>
<p><a href="#beforeshow">beforeshow (key)</a></p>
<p><a href="#callSvr">callSvr (alias)</a></p>
<p><a href="#callSvr.noex">callSvr.noex (key)</a></p>
<p><a href="#callSvrSync">callSvrSync (alias)</a></p>
<p><a href="#datagrid.formatter">datagrid.formatter (key)</a></p>
<p><a href="#datagrid.sortable">datagrid.sortable (key)</a></p>
<p><a href="#datagrid.sorter">datagrid.sorter (key)</a></p>
<p><a href="#datagrid.styler">datagrid.styler (key)</a></p>
<p><a href="#delCookie">delCookie (fn)</a></p>
<p><a href="#delStorage">delStorage (fn)</a></p>
<p><a href="#delayDo">delayDo (fn)</a></p>
<p><a href="#deleteParam">deleteParam (fn)</a></p>
<p><a href="#enterWaiting">enterWaiting (alias)</a></p>
<p><a href="#evalAttr">evalAttr (fn)</a></p>
<p><a href="#example-dialog">example-dialog (key)</a></p>
<p><a href="#example-upload">example-upload (key)</a></p>
<p><a href="#formItems">formItems (fn)</a></p>
<p><a href="#g_args">g_args (var)</a></p>
<p><a href="#g_args._app">g_args._app (var)</a></p>
<p><a href="#g_data">g_data (var)</a></p>
<p><a href="#g_data.userInfo">g_data.userInfo (key)</a></p>
<p><a href="#getAncestor">getAncestor (fn)</a></p>
<p><a href="#getCookie">getCookie (fn)</a></p>
<p><a href="#getFormData">getFormData (fn)</a></p>
<p><a href="#getStorage">getStorage (fn)</a></p>
<p><a href="#getTimeDiffDscr">getTimeDiffDscr (fn)</a></p>
<p><a href="#initdata">initdata (key)</a></p>
<p><a href="#intSort">intSort (fn)</a></p>
<p><a href="#isAndroid">isAndroid (fn)</a></p>
<p><a href="#isBusy">isBusy (var)</a></p>
<p><a href="#isIOS">isIOS (fn)</a></p>
<p><a href="#isWeixin">isWeixin (fn)</a></p>
<p><a href="#jQuery.fn.jdata">jQuery.fn.jdata (fn)</a></p>
<p><a href="#jQuery.fn.mycombobox">jQuery.fn.mycombobox (fn)</a></p>
<p><a href="#jdModule">jdModule (fn)</a></p>
<p><a href="#jdModule">jdModule (fn)</a></p>
<p><a href="#jdModule">jdModule (fn)</a></p>
<p><a href="#leaveWaiting">leaveWaiting (alias)</a></p>
<p><a href="#loadScript">loadScript (fn)</a></p>
<p><a href="#loaddata">loaddata (key)</a></p>
<p><a href="#makeLinkTo">makeLinkTo (fn)</a></p>
<p><a href="#my-initfn">my-initfn (key)</a></p>
<p><a href="#my-obj">my-obj (key)</a></p>
<p><a href="#numberSort">numberSort (fn)</a></p>
<p><a href="#pagecreate,pageshow,pagedestroy">pagecreate,pageshow,pagedestroy (key)</a></p>
<p><a href="#parseDate">parseDate (fn)</a></p>
<p><a href="#parseQuery">parseQuery (fn)</a></p>
<p><a href="#parseTime">parseTime (fn)</a></p>
<p><a href="#parseValue">parseValue (fn)</a></p>
<p><a href="#reloadSite">reloadSite (fn)</a></p>
<p><a href="#retdata">retdata (key)</a></p>
<p><a href="#rs2Array">rs2Array (fn)</a></p>
<p><a href="#rs2Hash">rs2Hash (fn)</a></p>
<p><a href="#rs2MultiHash">rs2MultiHash (fn)</a></p>
<p><a href="#savedata">savedata (key)</a></p>
<p><a href="#setCookie">setCookie (fn)</a></p>
<p><a href="#setDateBox">setDateBox (fn)</a></p>
<p><a href="#setFormData">setFormData (fn)</a></p>
<p><a href="#setStorage">setStorage (fn)</a></p>
<p><a href="#setTimeBox">setTimeBox (fn)</a></p>
<p><a href="#show">show (key)</a></p>
<p><a href="#tobool">tobool (fn)</a></p>
<p><a href="#waitFor">waitFor (fn)</a></p>
<p><a href="#wui-pageFile">wui-pageFile (key)</a></p>
<p><a href="#wui-pageName">wui-pageName (key)</a></p>
<p><a href="#wui-script">wui-script (key)</a></p>
</div><hr>
</div>
<div class="block">
<h2 id="WUI">@module WUI</h2><div class="toc"><p style="margin-left:0em"><a href="#WUI-1 对象管理功能">1 对象管理功能</a></p>
<p style="margin-left:2em"><a href="#WUI-1.1 定义列表页和详情页">1.1 定义列表页和详情页</a></p>
<p style="margin-left:2em"><a href="#WUI-1.2 添加入口按钮">1.2 添加入口按钮</a></p>
<p style="margin-left:2em"><a href="#WUI-1.3 定义页面初始化函数">1.3 定义页面初始化函数</a></p>
<p style="margin-left:2em"><a href="#WUI-1.4 定义对话框的初始化函数">1.4 定义对话框的初始化函数</a></p>
<p style="margin-left:2em"><a href="#WUI-1.5 列表页中的常见需求">1.5 列表页中的常见需求</a></p>
<p style="margin-left:4em"><a href="#WUI-1.5.1 列表页中的列，以特定格式展现">1.5.1 列表页中的列，以特定格式展现</a></p>
<p style="margin-left:4em"><a href="#WUI-1.5.2 排序与分页">1.5.2 排序与分页</a></p>
<p style="margin-left:2em"><a href="#WUI-1.6 详情页对话框的常见需求">1.6 详情页对话框的常见需求</a></p>
<p style="margin-left:4em"><a href="#WUI-1.6.1 设计模式：关联选择框">1.6.1 设计模式：关联选择框</a></p>
<p style="margin-left:4em"><a href="#WUI-1.6.2 picId字段显示图片">1.6.2 picId字段显示图片</a></p>
<p style="margin-left:4em"><a href="#WUI-1.6.3 List字段显示为多个选项框">1.6.3 List字段显示为多个选项框</a></p>
<p style="margin-left:2em"><a href="#WUI-1.7 设计模式：展示层次对象">1.7 设计模式：展示层次对象</a></p>
<p style="margin-left:0em"><a href="#WUI-2 对话框功能">2 对话框功能</a></p>
<p style="margin-left:2em"><a href="#WUI-2.1 定义对话框">2.1 定义对话框</a></p>
<p style="margin-left:2em"><a href="#WUI-2.2 显示对话框">2.2 显示对话框</a></p>
<p style="margin-left:0em"><a href="#WUI-3 模块化开发">3 模块化开发</a></p>
</div>
<p>筋斗云前端框架-Web应用桌面版</p>
<p>此框架实现与筋斗云服务端接口的无缝整合。在界面上以jquery-easyui库为基础展示列表、Tab页等。<br />
参考应用 web/store.html - 商户管理端应用。</p>
<h4 id="WUI-1 对象管理功能">1 对象管理功能</h4>
<p>设计模式：列表页与详情页。</p>
<p>以订单对象Order为例：为订单对象增加“列表页”和“详情页”。</p>
<p>列表页应包含分页功能，默认只显示“未完成”订单。<br />
点击列表中一项（一个订单），可显示详情页，即订单详情，并可进行查找、更新等功能。</p>
<h5 id="WUI-1.1 定义列表页和详情页">1.1 定义列表页和详情页</h5>
<p class="key"><strong>@key <a id="#my-pages">#my-pages</a></strong>   包含所有页面、对话框定义的容器。</p>
<p class="key"><strong>@key <a id="my-obj">my-obj</a></strong>  DOM属性，标识服务端对象</p>
<p class="key"><strong>@key <a id="my-initfn">my-initfn</a></strong>  DOM属性，标识页面或对话框的初始化函数，首次显示页面/对话框时调用。</p>
<p>列表页使用逻辑页面定义如下（放在div#my-pages之下），它最终展示为一个tab页：</p>
<pre><code>&lt;div id="my-pages" style="display:none"&gt;
    ...
    &lt;div class="pageOrder" title="订单管理" my-initfn="initPageOrder"&gt;
        &lt;table id="tblOrder" style="width:auto;height:auto"&gt;
            &lt;thead&gt;&lt;tr&gt;
                &lt;th data-options="field:'id', sortable:true, sorter:intSort"&gt;订单号&lt;/th&gt;
                &lt;th data-options="field:'userPhone', sortable:true"&gt;用户联系方式&lt;/th&gt;
                &lt;th data-options="field:'createTm', sortable:true"&gt;创建时间&lt;/th&gt;
                &lt;th data-options="field:'status', formatter:OrderColumns.statusStr, styler:OrderColumns.statusStyler, sortable:true"&gt;状态&lt;/th&gt;
                &lt;th data-options="field:'dscr', sortable:true"&gt;描述&lt;/th&gt;
                &lt;th data-options="field:'cmt'"&gt;用户备注&lt;/th&gt;
            &lt;/tr&gt;&lt;/thead&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>注意：</p>
<ul>
<li>逻辑页面div.pageOrder，属性class=&quot;pageOrder&quot;定义了该逻辑页面的名字。它将作为页面模板，在WUI.showPage(&quot;pageOrder&quot;)时复制一份显示出来。</li>
<li>属性my-initfn定义了该页面的初始化函数. 在初次调用WUI.showPage时，会执行该初始化函数，用于初始化列表，设定事件处理等。</li>
<li>逻辑页面下包含了一个table，用于显示订单列表。里面每列对应订单的相关属性。</li>
</ul>
<p>详情页展示为一个对话框，也将它也放在 div#my-pages 下。定义如下（此处为展示原理已简化）：</p>
<pre><code>&lt;div id="dlgOrder" my-obj="Ordr" my-initfn="initDlgOrder" title="用户订单" style="width:520px;height:500px;"&gt;  
    &lt;form method="POST"&gt;
        订单号：&lt;input name="id" disabled&gt;&lt;/td&gt;
        订单状态：
                    &lt;select name="status" style="width:150px"&gt;
                        &lt;option value=""&gt;&amp;nbsp;&lt;/option&gt;
                        &lt;option value="CR"&gt;未付款&lt;/option&gt;
                        &lt;option value="PA"&gt;待服务(已付款)&lt;/option&gt;
                        &lt;option value="ST"&gt;正在服务&lt;/option&gt;
                        &lt;option value="RE"&gt;已服务(待评价)&lt;/option&gt;
                        &lt;option value="RA"&gt;已评价&lt;/option&gt;
                        &lt;option value="CA"&gt;已取消&lt;/option&gt;
                    &lt;/select&gt;
        用户备注：&lt;textarea name="cmt" rows=3 cols=30&gt;&lt;/textarea&gt;
    &lt;/form&gt;
&lt;div&gt;</code></pre>
<p>注意：</p>
<ul>
<li>对话框div#dlgOrder. 与列表页使用class标识名称不同，详情页对话框以id标识（因为全局共用一个对话框，而列表页可以复制为多个同时显示）。</li>
<li>对话框上定义了 &quot;my-obj&quot;属性，用于标识它对应的服务端对象名。对象增删改查操作都会用到它。</li>
<li>对话框的属性 my-initfn 定义了初始化函数，在首次显示时调用。</li>
<li>调用 WUI.showObjDlg($(&quot;#dlgOrder&quot;), formMode) 可显示该对话框，一般由列表页自动调用。</li>
<li>对话框中包含一个form用于向服务端发起请求。form中每个带name属性的对象，都对应订单对象的一个属性，在添加、查找、显示或更新时都将用到，除非它上面加了disabled属性（这样就不会提交该字段）</li>
<li>对话框一般不用加“提交”按钮，框架会自动为它添加“确定”、“取消”按钮。</li>
</ul>
<p class="see"><strong>@see <a href="#WUI.showObjDlg">WUI.showObjDlg</a></strong> </p>
<p class="see"><strong>@see <a href="#WUI.showDlg">WUI.showDlg</a></strong> </p>
<p>以上定义了订单对象的列表页和详情页，围绕对象&quot;Order&quot;, 按规范，我们定义了以下名字：</p>
<ul>
<li>列表页面（Tab页） div.pageOrder，列表 table#tblOrder，页面初始化函数 initPageOrder</li>
<li>详情页（对话框）div#dlgOrder，其中包含一个form。对话框初始化函数</li>
</ul>
<h5 id="WUI-1.2 添加入口按钮">1.2 添加入口按钮</h5>
<pre><code>&lt;a href="#pageOrder" class="easyui-linkbutton" icon="icon-ok"&gt;订单管理&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;</code></pre>
<h5 id="WUI-1.3 定义页面初始化函数">1.3 定义页面初始化函数</h5>
<p>打开页面后，页面的生存周期如下：</p>
<p class="key"><strong>@key <a id="pagecreate,pageshow,pagedestroy">pagecreate,pageshow,pagedestroy</a></strong>  页面事件</p>
<p class="key"><strong>@key <a id="wui-pageName">wui-pageName</a></strong>  属性：页面名</p>
<p class="key"><strong>@key <a id=".wui-page">.wui-page</a></strong>  页面类</p>
<ul>
<li>页面加载成功后，会为页面添加类&quot;wui-page&quot;, 并将属性wui-pageName设置为页面名，然后调用 my-initfn指定的初始化函数，如initPageOrder</li>
<li>触发pagecreate事件</li>
<li>触发pageshow事件, 以后每次页面切换到当前页面，也会触发pageshow事件。</li>
<li>在关闭页面时，触发pagedestroy事件</li>
<li>注意：没有pagebeforeshow, pagehide事件</li>
</ul>
<p>订单列表页的初始化，需要将列表页(代码中jpage)、列表(代码中jtbl)与详情页(代码中jdlg)关联起来，实现对话增删改查各项功能。</p>
<pre><code>function initPageOrder() 
{
    var jpage = $(this);
    var jtbl = jpage.find("#tblOrder");
    var jdlg = $("#dlgOrder");

    // 注意：此处定义显示哪些缺省操作按钮：
    // r-refresh/刷新, f-find/查找, s-set/更新。参考 WUI.dg_toolbar.
    // 如果不定义则所有操作按钮都展示。
    jtbl.jdata().toolbar = "rfs";

    // 当天订单
    var query1 = {cond: "createTm between '" + new Date().format("D") + "' and '" + new Date().addDay(1).format("D") + "'"};
    // 显示待服务/正在服务订单
    var query2 = {cond: "status='CR' OR status='PA' OR status='ST'"};

    function getTodoOrders()
    {
        WUI.reload(jtbl, null, query2);
    }
    function getTodayOrders()
    {
        WUI.reload(jtbl, null, query1);
    }
    var btn1 = {text: "今天订单", iconCls:'icon-search', handler: getTodayOrders};
    var btn2 = {text: "所有未完成", iconCls:'icon-search', handler: getTodoOrders};

    var dgOpt = {
        // 设置查询接口
        url: WUI.makeUrl(["Ordr", "query"], {res:"*,createTm,userPhone"}),
        // 设置缺省查询条件
        queryParams: query1,
        // 设置工具栏上的按钮，并与对话框jdlg关联。
        toolbar: WUI.dg_toolbar(jtbl, jdlg, "-", btn1, btn2),
        // 双击一行，应展示详情页对话框
        onDblClickRow: WUI.dg_dblclick(jtbl, jdlg)
    };
    jtbl.datagrid(dgOpt);
}</code></pre>
<p class="see"><strong>@see <a href="#WUI.showPage">WUI.showPage</a></strong> </p>
<p class="see"><strong>@see <a href="#WUI.dg_toolbar">WUI.dg_toolbar</a></strong> </p>
<p class="see"><strong>@see <a href="#WUI.dg_dblclick">WUI.dg_dblclick</a></strong> </p>
<p class="see"><strong>@see <a href="#WUI.makeUrl">WUI.makeUrl</a></strong> </p>
<h5 id="WUI-1.4 定义对话框的初始化函数">1.4 定义对话框的初始化函数</h5>
<p class="key"><strong>@key <a id="example-dialog">example-dialog</a></strong> </p>
<p>默认对话框中由于设定了底层对象(my-obj)及属性关联（form中带name属性的组件，已关联对象属性），因而可自动显示和提交数据。</p>
<p>特别地，某些属性不宜直接展示，例如属性“人物头像”，服务器存储的是图片id(picId)，而展示时应显示为图片而不是一个数字；<br />
或者如“权限列表”属性，服务器存储的是逗号分隔的一组权限比如&quot;emp,mgr&quot;，而展示时需要为每项显示一个勾选框。<br />
这类需求就需要编码控制。</p>
<p>相关事件：</p>
<p class="see"><strong>@see <a href="#beforeshow">beforeshow</a> <a href="#show">show</a></strong>  对话框中form显示前后</p>
<p class="see"><strong>@see <a href="#initdata">initdata</a> <a href="#loaddata">loaddata</a></strong>  对话框中form加载数据前后</p>
<p class="see"><strong>@see <a href="#savedata">savedata</a> <a href="#retdata">retdata</a></strong>  对话框中form保存数据前后</p>
<p>对话框类名：</p>
<p class="see"><strong>@see <a href="#.wui-dialog">.wui-dialog</a></strong> </p>
<pre><code>function initDlgOrder()
{
    var jdlg = $(this);
    var jfrm = jdlg.find("form");
    jfrm.on("beforeshow", function(ev, formMode) {
        jdlg.find(".forFind").toggle(formMode == FormMode.forFind);
        jdlg.find(".notForFind").toggle(formMode != FormMode.forFind);
    })
    .on("loaddata", function (ev, data, formMode) {
        // data是列表页中一行对应的数据，框架自动根据此数据将对应属性填上值。
        // 如果界面上展示的字段无法与属性直接对应，可以在该事件回调中设置。
        // hiddenToCheckbox(jfrm.find("#divPerms"));
    })
    .on("savedata", function (ev, formMode, initData) {
        // 在form提交时，所有带name属性且不带disabled属性的对象值会被发往服务端。
        // 此事件回调可以设置一些界面上无法与属性直接对应的内容。
        // checkboxToHidden(jfrm.find("#divPerms"));
    })
    .on("retdata", function (ev, data, formMode) {
        var formMode = jdlg.jdata().mode;
        if (formMode == FormMode.forAdd) {
            alert('返回ID: ' + data);
        }
    };
}</code></pre>
<p class="see"><strong>@see <a href="#checkboxToHidden">checkboxToHidden</a></strong>  (有示例)</p>
<p class="see"><strong>@see <a href="#hiddenToCheckbox">hiddenToCheckbox</a></strong>  </p>
<p class="see"><strong>@see <a href="#imgToHidden">imgToHidden</a></strong> </p>
<p class="see"><strong>@see <a href="#hiddenToImg">hiddenToImg</a></strong>  (有示例)</p>
<h5 id="WUI-1.5 列表页中的常见需求">1.5 列表页中的常见需求</h5>
<p>框架中，对象列表通过easyui-datagrid来展现。<br />
注意：由于历史原因，我们没有使用datagrid中的编辑功能。</p>
<p>参考：<a href="http://www.jeasyui.net/plugins/183.html">http://www.jeasyui.net/plugins/183.html</a><br />
教程：<a href="http://www.jeasyui.net/tutorial/148.html">http://www.jeasyui.net/tutorial/148.html</a></p>
<h6 id="WUI-1.5.1 列表页中的列，以特定格式展现">1.5.1 列表页中的列，以特定格式展现</h6>
<p class="key"><strong>@key <a id="datagrid.formatter">datagrid.formatter</a></strong> </p>
<p class="key"><strong>@key <a id="datagrid.styler">datagrid.styler</a></strong> </p>
<p>示例一：显示名称及颜色</p>
<p>订单状态字段定义为：</p>
<pre><code>status:: Enum. 订单状态。CR-新创建,RE-已服务,CA-已取消. </code></pre>
<p>在显示时，要求显示其中文名称，且根据状态不同，显示不同的背景颜色。</p>
<p>在table中设置formatter与styler选项：</p>
<pre><code>&lt;div class="pageOrder" title="订单管理" my-initfn="initPageOrder"&gt;
    &lt;table id="tblOrder" style="width:auto;height:auto"&gt;
        &lt;thead&gt;&lt;tr&gt;
            &lt;th data-options="field:'id', sortable:true, sorter:intSort"&gt;订单号&lt;/th&gt;
            ...
            &lt;th data-options="field:'status', formatter:OrderColumns.statusStr, styler:OrderColumns.statusStyler, sortable:true"&gt;状态&lt;/th&gt;
        &lt;/tr&gt;&lt;/thead&gt;
    &lt;/table&gt;
&lt;/div&gt;</code></pre>
<p>formatter用于控制Cell中的HTML标签，styler用于控制Cell自己的CSS style.<br />
在JS中定义函数：</p>
<pre><code>var OrderColumns = {
    statusStr: function (value, row) {
        var OrderStatusStr = {
            CR: "未付款", 
            RE: "已服务", 
            CA: "已取消"
        };
        return OrderStatusStr[value] || value;
    },
    statusStyler: function (value, row) {
        var colors = {
            CR: "#000",
            RE: "#0f0",
            CA: "#ccc"
        };
        var color = colors[value];
        if (color)
            return "background-color: " + color;
    },
    ...
}</code></pre>
<p>注意：</p>
<ul>
<li>习惯上，对同一个对象的字段的设定，都放到一个名为　{Obj}Columns 的变量中一起定义。</li>
<li>对于通用的或多处共享的字段设定，放到变量 Formatter 中.</li>
</ul>
<p>示例二：下面是一些通用的例子，特别是生成对象链接经常会用到。</p>
<pre><code>var Formatter = {
    // 显示数值
    number: function (value)
    {
        return parseFloat(value);
    },
    // 显示一张或一组图片链接，点一个链接可以在新页面上显示原图片
    pics: function (value) {
        if (value == null)
            return "(无图)";
        return value.replace(/(\d+),?/g, function (ms, picId) {
            var url = WUI.makeUrl("att", {thumbId: picId});
            return "&lt;a target='_black' href='" + url + "'&gt;" + picId + "&lt;/a&gt;&amp;nbsp;";
        });
    },
    // 订单编号，显示为一个链接，点击就打开订单对话框该订单。
    orderId: function (value) {
        if (value != null)
        {
            return makeLinkTo("#dlgOrder", value, value);
        }
    }
};</code></pre>
<p class="see"><strong>@see <a href="#makeLinkTo">makeLinkTo</a></strong>  生成对象链接，以便点击时打开该对象的详情对话框。</p>
<h6 id="WUI-1.5.2 排序与分页">1.5.2 排序与分页</h6>
<p class="key"><strong>@key <a id="datagrid.sortable">datagrid.sortable</a></strong> </p>
<p class="key"><strong>@key <a id="datagrid.sorter">datagrid.sorter</a></strong> </p>
<p>使用sortable:true指定该列可排序（可点击列头排序），用sorter指定排序算法（缺省是字符串排序），例如：</p>
<pre><code>&lt;th data-options="field:'name', sortable:true"&gt;姓名&lt;/th&gt;
&lt;th data-options="field:'id', sortable:true, sorter:intSort"&gt;编号&lt;/th&gt;
&lt;th data-options="field:'score', sortable:true, sorter:numberSort"&gt;评分&lt;/th&gt;</code></pre>
<p>框架提供了intSort,numberSort这些函数用于整数排序或小数排序。也可以自定义函数。示例：</p>
<pre><code>function intSort(a, b)
{
    return parseInt(a) - parseInt(b);
}</code></pre>
<p>注意：</p>
<ul>
<li>指定sorter函数只会影响本地排序。而多数情况下，只要有多页，框架会使用远程排序。<br />
框架逻辑为：如果数据超过一页，使用远程排序, 否则使用本地排序减少请求。</li>
<li>本地排序(localSort)：点击列标题排序时，会重新发请求到服务端，并指定sort/排序字段,order/顺序或倒序参数</li>
<li>远程排序(remoteSort)：点排序时，直接本地计算重排，不会发请求到服务端.</li>
</ul>
<p class="see"><strong>@see <a href="#intSort">intSort</a> <a href="#numberSort">numberSort</a></strong> </p>
<p>如果打开数据表就希望按某一列排序，可设置：</p>
<pre><code>jtbl.datagrid({
    ...
    sortName: 'id',
    sortOrder: 'desc'
});</code></pre>
<p>手工点击列标题栏排序，会自动修改这两个属性。<br />
在添加数据时，如果当前sortOrder是倒序，则新数据显示在表格当前页的最前面，否则显示在最后。</p>
<p>框架对datagrid还做了以下缺省设置：</p>
<ul>
<li>
<p>默认开启datagrid的分页功能。每页缺省显示20条数据。可通过datagrid选项自行重新定义，如：</p>
<pre><code>jtbl.datagrid({
    ...
    pageSize: 20,
    pageList: [20,30,50] // 在分页栏中可以选择分页大小
});</code></pre>
</li>
<li>当数据在一页内可显示完时，自动隐藏分页操作栏。</li>
</ul>
<p>如果需要禁用分页，可以设置：</p>
<pre><code>jtbl.datagrid({
    url: WUI.makeUrl("Ordr.query", {"pagesz": -1}), // -1表示取后端允许的最大数量
    pagination: false, // 禁用分页组件
    ...
});</code></pre>
<h5 id="WUI-1.6 详情页对话框的常见需求">1.6 详情页对话框的常见需求</h5>
<h6 id="WUI-1.6.1 设计模式：关联选择框">1.6.1 设计模式：关联选择框</h6>
<p>示例：下拉框中显示员工列表 (Choose-from-list / 关联选择框)</p>
<p class="see"><strong>@see <a href="#jQuery.fn.mycombobox">jQuery.fn.mycombobox</a></strong> </p>
<h6 id="WUI-1.6.2 picId字段显示图片">1.6.2 picId字段显示图片</h6>
<p class="see"><strong>@see <a href="#hiddenToImg">hiddenToImg</a></strong>  (有示例)</p>
<p class="see"><strong>@see <a href="#imgToHidden">imgToHidden</a></strong> </p>
<h6 id="WUI-1.6.3 List字段显示为多个选项框">1.6.3 List字段显示为多个选项框</h6>
<p class="see"><strong>@see <a href="#hiddenToCheckbox">hiddenToCheckbox</a></strong>  </p>
<p class="see"><strong>@see <a href="#checkboxToHidden　">checkboxToHidden　</a></strong> (有示例)</p>
<h5 id="WUI-1.7 设计模式：展示层次对象">1.7 设计模式：展示层次对象</h5>
<p>例如设计有商品表Item, 每个商品属于特定的商户：</p>
<pre><code>@Item: id, storeId, name
storeId:: Integer. 商品所属商户编号。</code></pre>
<p>也就是说，商户包含商品。要展现商品，可将它放在商户层次之下。<br />
可以这样设计用户操作：在商户列表上增加一个按钮“查看商品”，点击后打开一个新的列表页，显示该商户的商品列表。</p>
<p>定义两个列表页：</p>
<pre><code>&lt;div class="pageStore" title="商户列表" my-initfn="initPageStore"&gt;
&lt;/div&gt;

&lt;div class="pageItem" title="商户商品" my-initfn="initPageItem"&gt;
&lt;/div&gt;</code></pre>
<p>为这两个列表页定义初始化函数：</p>
<pre><code>// 商户列表页
function initPageStore()
{
    function showItemPage()
    {
        var row = jtbl.datagrid('getSelected');
        if(row == null){
            alert("您需要选择需要操作的行");
            return;
        }
        // !!! 调用showPage显示新页 !!!
        WUI.showPage("pageItem", "商户商品-" + row.name, [row.id]);
        // 要使每个商户都打开一个商品页面而不是共享一个页面，必须保证第二个参数（页面标题）根据商户不同而不一样。
        // 第三个参数是传给该页面初始化函数的参数列表，是一个数组。
    }
    var btn1 = {text: "查看商品", iconCls: "icon-search", handler: showPageCloseOrder};

    ...
    jtbl.datagrid({
        ...
        toolbar: WUI.dg_toolbar(jtbl, jdlg, btn1),
    });
}

// 商品列表页，注意有一个参数storeId, 并在查询时使用到它。
function initPageItem(storeId)
{
    jtbl.datagrid({
        // 用参数storeId过滤
        url: WUI.makeUrl("Item.query", {cond: "storeId=" + storeId}),
        ...
    });
}</code></pre>
<p>注意：</p>
<p>调用WUI.showPage时，除了指定页面名，还指定了页面标题(第二参数)和页面初始化参数(第三参数, 一定是一个数组):</p>
<pre><code>WUI.showPage("pageItem", "商户商品-" + row.name, [row.id]);</code></pre>
<p>显然，第二个参数随着商户名称不同而不同，这保证了不同商户打开的商品页面不会共用。<br />
在商品页面初始化时，第三参数将传递给初始化函数：</p>
<pre><code>function initPageItem(storeId) // storeId=row.id</code></pre>
<p class="see"><strong>@see <a href="#WUI.showPage">WUI.showPage</a></strong> </p>
<h4 id="WUI-2 对话框功能">2 对话框功能</h4>
<p>以群发短信功能为例。</p>
<p>假定服务端已有以下接口：</p>
<pre><code>sendSms(phone, content)
phone:: 手机号
content:: 发送内容</code></pre>
<h5 id="WUI-2.1 定义对话框">2.1 定义对话框</h5>
<p>注意：每个带name属性的组件对应接口中的参数。</p>
<pre><code>&lt;div id="dlgSendSms" title="群发短信" style="width:500px;height:300px;"&gt;  
    &lt;form method="POST"&gt;
        手机号：&lt;input name="phone" data-options="required:true"&gt;
        发送内容： &lt;textarea rows=5 cols=30 name="content"&gt;&lt;/textarea&gt;
    &lt;/form&gt;
&lt;/div&gt;</code></pre>
<h5 id="WUI-2.2 显示对话框">2.2 显示对话框</h5>
<p>可以调用WUI.showDlg，写一个显示对话框的函数：</p>
<pre><code>function showDlgSendSms()
{
    var jdlg = $("#dlgSendSms");
    WUI.showDlg(jdlg, {
        url: WUI.makeUrl("sendSms"),
        onOk: function (data) {
            WUI.closeDlg(jdlg);
            app_show('操作成功!');
        }
    });
}</code></pre>
<p>在showDlg的选项url中指定了接口为&quot;sendSms&quot;。操作成功后，显示一个消息。</p>
<p class="see"><strong>@see <a href="#WUI.showDlg">WUI.showDlg</a></strong> </p>
<p class="see"><strong>@see <a href="#app_show">app_show</a></strong> </p>
<p>除了直接调用该函数显示对话框外，还有一种更简单的通过a标签href属性指定打开对话框的做法，如：</p>
<pre><code>&lt;a href="?showDlgSendSms" class="easyui-linkbutton" icon="icon-ok"&gt;群发短信&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;</code></pre>
<p>点击该按钮，即调用了showDlgSendSms函数打开对话框。</p>
<h4 id="WUI-3 模块化开发">3 模块化开发</h4>
<p class="key"><strong>@key <a id="wui-script">wui-script</a></strong> </p>
<p class="key"><strong>@key <a id="WUI.options.pageFolder">WUI.options.pageFolder</a></strong> </p>
<p>允许将逻辑页、对话框的html片段和js片段放在单独的文件中。以前面章节示例中订单对象的列表页（是一个逻辑页）与详情页（是一个对话框）为例：</p>
<ul>
<li>页面名(即class)为pageOrder，UI与js逻辑分别保存在pageOrder.html, pageOrder.js中。</li>
<li>对话框id为dlgOrder, UI与js逻辑分别保存在dlgOrder.html, dlgOrder.js中。</li>
<li>模块所在目录默认为&quot;page&quot;, 可通过在h5应用开头设置 WUI.options.pageFolder 来修改。</li>
</ul>
<p>先在文件page/pageOrder.html中定义逻辑页</p>
<pre><code>&lt;div title="订单管理" wui-script="pageOrder.js" my-initfn="initPageOrder"&gt;
    &lt;table id="tblOrder" style="width:auto;height:auto"&gt;
        ...
    &lt;/table&gt;
&lt;/div&gt;</code></pre>
<p>注意：</p>
<ul>
<li>在html文件中用 wui-script属性 来指定对应的js文件。</li>
<li>无须像之前那样指定class=&quot;pageOrder&quot; / id=&quot;dlgOrder&quot; 这些属性，它们会根据页面文件名称由框架自动设置。</li>
</ul>
<p>在html文件的div中可以添加style样式标签：</p>
<pre><code>&lt;div&gt;
    &lt;style&gt;
    table {
        background-color: #ddd;
    }
    &lt;/style&gt;
    &lt;table&gt;...&lt;/table&gt;
&lt;/div&gt;</code></pre>
<p>注意：其中定义的样式（比如这里的table）只应用于当前页面或对话框，因为框架会在加载它时自动限定样式作用范围。</p>
<p>在文件page/pageOrder.js中定义逻辑：</p>
<pre><code>function initPageOrder() 
{
    var jpage = $(this);
    ...
}</code></pre>
<p>这时，就可以用 WUI.showPage(&quot;#pageOrder&quot;)来显示逻辑页了。</p>
<p>注意：逻辑页的title字段不能和其它页中title重复，否则这两页无法同时显示，因为显示tab页时是按照title来标识逻辑页的。</p>
<p>在文件page/dlgOrder.html中定义对话框UI:</p>
<pre><code>&lt;div wui-script="dlgOrder.js" my-obj="Ordr" my-initfn="initDlgOrder" title="用户订单" style="width:520px;height:500px;"&gt;  
    &lt;form method="POST"&gt;
        ...
    &lt;/form&gt;
&lt;div&gt;</code></pre>
<p>注意：</p>
<ul>
<li>在html文件中用 wui-script属性 来指定对应的js文件。</li>
<li>无须像之前那样指定id=&quot;dlgOrder&quot; 这些属性，它们会根据页面文件名称由框架自动设置。</li>
<li>和上面逻辑页定义一样，对话框专用的样式可以在主div标签内添加style标签来定义，在加载UI后样式作用域自动限定在当前对话框。</li>
</ul>
<p>在文件page/dlgOrder.js中定义js逻辑:</p>
<pre><code>function initDlgOrder()
{
    var jdlg = $(this);
    ...
}</code></pre>
<p>这时，就可以用 WUI.showObjDlg(&quot;#dlgOrder&quot;)来显示逻辑页了。</p></div>
<div class="block">
<h2 id="assert">@fn assert(cond, dscr?)</h2></div>
<div class="block">
<h2 id="parseQuery">@fn parseQuery(str)</h2>
<p>解析url编码格式的查询字符串，返回对应的对象。</p>
<pre><code>if (location.search) {
    var queryStr = location.search.substr(1); // "?id=100&amp;name=abc&amp;val=3.14"去掉"?"号
    var args = parseQuery(queryStr); // {id: 100, name: "abc", val: 3.14}
}</code></pre>
<p>注意：</p>
<p>如果值为整数或小数，则会转成相应类型。如上例中 id为100,不是字符串&quot;100&quot;.</p></div>
<div class="block">
<h2 id="tobool">@fn tobool(v)</h2>
<p>将字符串转成boolean值。除&quot;0&quot;, &quot;1&quot;外，还可以支持字符串 &quot;on&quot;/&quot;off&quot;, &quot;true&quot;/&quot;false&quot;等。</p></div>
<div class="block">
<h2 id="reloadSite">@fn reloadSite()</h2>
<p>重新加载当前页面，但不要#hash部分。</p></div>
<div class="block">
<h2 id="Date.format">@fn Date.format(fmt?=L)</h2>
<p>日期对象格式化字符串。</p>
<p class="param"><strong>@param fmt</strong>  格式字符串。由以下组成：</p>
<pre><code>yyyy - 四位年，如2008, 1999
yy - 两位年，如 08, 99
mm - 两位月，如 02, 12
dd - 两位日，如 01, 30
HH - 两位小时，如 00, 23
MM - 两位分钟，如 00, 59
SS - 两位秒，如 00, 59

支持这几种常用格式：
L - 标准日期时间，相当于 "yyyy-mm-dd HH:MM:SS"
D - 标准日期，相当于 "yyyy-mm-dd"
T - 标准时间，相当于 "HH:MM:SS"</code></pre>
<p>示例：</p>
<pre><code>var dt = new Date();
var dtStr1 = dt.format("D"); // "2009-10-20"
var dtStr2 = dt.format("yyyymmdd-HHMM"); // "20091020-2038"</code></pre></div>
<div class="block">
<h2 id="Date.addDay">@fn Date.addDay(n)</h2></div>
<div class="block">
<h2 id="Date.addHours">@fn Date.addHours(n)</h2></div>
<div class="block">
<h2 id="Date.addMin">@fn Date.addMin(n)</h2></div>
<div class="block">
<h2 id="Date.addMonth">@fn Date.addMonth(n)</h2></div>
<div class="block">
<h2 id="parseTime">@fn parseTime(s)</h2>
<p>将纯时间字符串生成一个日期对象。</p>
<pre><code>var dt1 = parseTime("10:10:00");
var dt2 = parseTime("10:11");</code></pre></div>
<div class="block">
<h2 id="parseDate">@fn parseDate(dateStr)</h2>
<p>将日期字符串转为日期时间格式。其效果相当于<code>new Date(Date.parse(dateStr))</code>，但兼容性更好（例如在safari中很多常见的日期格式无法解析）</p>
<p>示例：</p>
<pre><code>var dt1 = parseDate("2012-01-01");
var dt2 = parseDate("2012/01/01 20:00:09");
var dt3 = parseDate("2012.1.1 20:00");</code></pre>
<p>支持时区，时区格式可以是&quot;+8&quot;, &quot;+08&quot;, &quot;+0800&quot;, &quot;Z&quot;这些，如</p>
<pre><code>parseDate("2012-01-01T09:10:20.328+0800");
parseDate("2012-01-01T09:10:20Z");</code></pre></div>
<div class="block">
<h2 id="Date.add">@fn Date.add(sInterval, n)</h2>
<p>为日期对象加几天/小时等。参数n为整数，可以为负数。</p>
<p class="param"><strong>@param sInterval</strong>  Enum. 间隔单位. d-天; m-月; y-年; h-小时; n-分; s-秒</p>
<p>示例：</p>
<pre><code>var dt = new Date();
dt.add("d", 1); // 1天后
dt.add("m", 1); // 1个月后
dt.add("y", -1); // 1年前
dt.add("h", 3); // 3小时后
dt.add("n", 30); // 30分钟后
dt.add("s", 30); // 30秒后</code></pre>
<p class="see"><strong>@see <a href="#Date.diff">Date.diff</a></strong> </p></div>
<div class="block">
<h2 id="Date.diff">@fn Date.diff(sInterval, dtEnd)</h2>
<p>计算日期到另一日期间的间隔，单位由sInterval指定(具体值列表参见Date.add).</p>
<pre><code>var dt = new Date();
...
var dt2 = new Date();
var days = dt.diff("d", dt2); // 相隔多少天</code></pre>
<p class="see"><strong>@see <a href="#Date.add">Date.add</a></strong> </p></div>
<div class="block">
<h2 id="getTimeDiffDscr">@fn getTimeDiffDscr(tm, tm1)</h2>
<p>从tm到tm1的时间差描述，如&quot;2分钟前&quot;, &quot;3天前&quot;等。</p>
<p>tm和tm1可以为时间对象或时间字符串</p></div>
<div class="block">
<h2 id="setCookie">@fn setCookie(name, value, days?=30)</h2>
<p>设置cookie值。如果只是为了客户端长时间保存值，一般建议使用 setStorage.</p>
<p class="see"><strong>@see <a href="#getCookie">getCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#delCookie">delCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#setStorage">setStorage</a></strong> </p></div>
<div class="block">
<h2 id="getCookie">@fn getCookie(name)</h2>
<p>取cookie值。</p>
<p class="see"><strong>@see <a href="#setCookie">setCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#delCookie">delCookie</a></strong> </p></div>
<div class="block">
<h2 id="delCookie">@fn delCookie(name)</h2>
<p>删除一个cookie项。</p>
<p class="see"><strong>@see <a href="#getCookie">getCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#setCookie">setCookie</a></strong> </p></div>
<div class="block">
<h2 id="setStorage">@fn setStorage(name, value, useSession?=false)</h2>
<p>使用localStorage存储(或使用sessionStorage存储, 如果useSession=true)。<br />
注意只能存储字符串，所以value不可以为数组，对象等，必须序列化后存储。 </p>
<p>如果浏览器不支持Storage，则使用cookie实现.</p>
<p>示例：</p>
<pre><code>setStorage("id", "100");
var id = getStorage("id");
delStorage("id");</code></pre>
<p>示例2：对象需要序列化后存储：</p>
<pre><code>var obj = {id:10, name:"Jason"};
setStorage("obj", JSON.stringify(obj));
var obj2 = getStorage("obj");
alert(obj2.name);</code></pre>
<p class="see"><strong>@see <a href="#getStorage">getStorage</a></strong> </p>
<p class="see"><strong>@see <a href="#delStorage">delStorage</a></strong> </p></div>
<div class="block">
<h2 id="getStorage">@fn getStorage(name, useSession?=false)</h2>
<p>取storage中的一项。<br />
默认使用localStorage存储，如果useSession=true，则使用sessionStorage存储。</p>
<p>如果浏览器不支持Storage，则使用cookie实现.</p>
<p class="see"><strong>@see <a href="#setStorage">setStorage</a></strong> </p>
<p class="see"><strong>@see <a href="#delStorage">delStorage</a></strong> </p></div>
<div class="block">
<h2 id="delStorage">@fn delStorage(name)</h2>
<p>删除storage中的一项。</p>
<p class="see"><strong>@see <a href="#getStorage">getStorage</a></strong> </p>
<p class="see"><strong>@see <a href="#setStorage">setStorage</a></strong> </p></div>
<div class="block">
<h2 id="rs2Array">@fn rs2Array(rs)</h2>
<p class="param"><strong>@param rs=</strong> {h=[header], d=[ @row ]} rs对象(RowSet)</p>
<p class="return"><strong>@return arr=[</strong>  %obj ]</p>
<p>rs对象用于传递表格，包含表头与表内容。<br />
函数用于将服务器发来的rs对象转成数组。</p>
<p>示例：</p>
<pre><code>var rs = {
    h: ["id", "name"], 
    d: [ [100, "Tom"], [101, "Jane"] ] 
};
var arr = rs2Array(rs); 

// 结果为
arr = [
    {id: 100, name: "Tom"},
    {id: 101, name: "Jane"} 
];</code></pre>
<p class="see"><strong>@see <a href="#rs2Hash">rs2Hash</a></strong> </p>
<p class="see"><strong>@see <a href="#rs2MultiHash">rs2MultiHash</a></strong> </p></div>
<div class="block">
<h2 id="rs2Hash">@fn rs2Hash(rs, key)</h2>
<p class="param"><strong>@param rs=</strong> {h, d}  rs对象(RowSet)</p>
<p class="return"><strong>@return hash=</strong> {key => %obj}</p>
<p>示例：</p>
<pre><code>var rs = {
    h: ["id", "name"], 
    d: [ [100, "Tom"], [101, "Jane"] ] 
};
var hash = rs2Hash(rs, "id"); 

// 结果为
hash = {
    100: {id: 100, name: "Tom"},
    101: {id: 101, name: "Jane"}
};</code></pre>
<p class="see"><strong>@see <a href="#rs2Array">rs2Array</a></strong> </p></div>
<div class="block">
<h2 id="rs2MultiHash">@fn rs2MultiHash(rs, key)</h2>
<p class="param"><strong>@param rs=</strong> {h, d}  rs对象(RowSet)</p>
<p class="return"><strong>@return hash=</strong> {key => [ %obj ]}</p>
<p>示例：</p>
<pre><code>var rs = {
    h: ["id", "name"], 
    d: [ [100, "Tom"], [101, "Jane"], [102, "Tom"] ] 
};
var hash = rs2MultiHash(rs, "name");  

// 结果为
hash = {
    "Tom": [{id: 100, name: "Tom"}, {id: 102, name: "Tom"}],
    "Jane": [{id: 101, name: "Jane"}]
};</code></pre>
<p class="see"><strong>@see <a href="#rs2Hash">rs2Hash</a></strong> </p>
<p class="see"><strong>@see <a href="#rs2Array">rs2Array</a></strong> </p></div>
<div class="block">
<h2 id="intSort">@fn intSort(a, b)</h2>
<p>整数排序. 用于datagrid column sorter:</p>
<pre><code>&lt;th data-options="field:'id', sortable:true, sorter:intSort"&gt;编号&lt;/th&gt;</code></pre></div>
<div class="block">
<h2 id="numberSort">@fn numberSort(a, b)</h2>
<p>小数排序. 用于datagrid column sorter:</p>
<pre><code>&lt;th data-options="field:'score', sortable:true, sorter:numberSort"&gt;评分&lt;/th&gt;</code></pre></div>
<div class="block">
<h2 id="getAncestor">@fn getAncestor(o, fn)</h2>
<p>取符合条件(fn)的对象，一般可使用$.closest替代</p></div>
<div class="block">
<h2 id="appendParam">@fn appendParam(url, param)</h2>
<p>示例:</p>
<pre><code>var url = "http://xxx/api.php";
if (a)
    url = appendParam(url, "a=" + a);
if (b)
    url = appendParam(url, "b=" + b);

appendParam(url, $.param({a:1, b:3}));</code></pre>
<p>支持url中带有&quot;?&quot;或&quot;#&quot;，如</p>
<pre><code>var url = "http://xxx/api.php?id=1#order";
appendParam(url, "pay=1"); // "http://xxx/api.php?id=1&amp;pay=1#order";</code></pre></div>
<div class="block">
<h2 id="deleteParam">@fn deleteParam(url, paramName)</h2>
<p>示例:</p>
<pre><code>var url = "http://xxx/api.php?a=1&amp;b=3&amp;c=2";
var url1 = deleteParam(url, "b"); // "http://xxx/api.php?a=1&amp;c=2";</code></pre></div>
<div class="block">
<h2 id="isWeixin">@fn isWeixin()</h2>
<p>当前应用运行在微信中。</p></div>
<div class="block">
<h2 id="isIOS">@fn isIOS()</h2>
<p>当前应用运行在IOS平台，如iphone或ipad中。</p></div>
<div class="block">
<h2 id="isAndroid">@fn isAndroid()</h2>
<p>当前应用运行在安卓平台。</p></div>
<div class="block">
<h2 id="parseValue">@fn parseValue(str)</h2>
<p>如果str符合整数或小数，则返回相应类型。</p></div>
<div class="block">
<h2 id="applyTpl">@fn applyTpl(tpl, data)</h2>
<p>对模板做字符串替换</p>
<pre><code>var tpl = "&lt;li&gt;&lt;p&gt;{name}&lt;/p&gt;&lt;p&gt;{dscr}&lt;/p&gt;&lt;/li&gt;";
var data = {name: 'richard', dscr: 'hello'};
var html = applyTpl(tpl, data);
// &lt;li&gt;&lt;p&gt;richard&lt;/p&gt;&lt;p&gt;hello&lt;/p&gt;&lt;/li&gt;</code></pre></div>
<div class="block">
<h2 id="delayDo">@fn delayDo(fn, delayCnt?=3)</h2>
<p>设置延迟执行。当delayCnt=1时与setTimeout效果相同。<br />
多次置于事件队列最后，一般3次后其它js均已执行完毕，为idle状态</p></div>
<div class="block">
<h2 id="jdModule">@fn jdModule(name, fn)</h2>
<p>定义一个模块，返回该模块对象。</p>
<p class="fn"><strong>@fn <a id="jdModule">jdModule</a></strong> (name)</p>
<p>获取模块对象。</p>
<p class="fn"><strong>@fn <a id="jdModule">jdModule</a></strong> ()</p>
<p>返回模块映射表。</p></div>
<div class="block">
<h2 id="getFormData">@fn getFormData(jo)</h2>
<p>取DOM对象中带name属性的子对象的内容, 放入一个JS对象中, 以便手工调用callSvr.</p>
<p>注意: </p>
<ul>
<li>这里Form不一定是Form标签, 可以是一切DOM对象.</li>
<li>如果DOM对象有disabled属性, 则会忽略它, 这也与form提交时的规则一致.</li>
</ul>
<p>与setFormData配合使用时, 可以只返回变化的数据.</p>
<pre><code>jf.submit(function () {
    var ac = jf.attr("action");
    callSvr(ac, fn, getFormData(jf));
});</code></pre>
<p>如果在jo对象上指定了属性enctype=&quot;multipart/form-data&quot;，则调用getFormData会返回FormData对象而非js对象，<br />
再调用callSvr时，会以&quot;multipart/form-data&quot;格式提交数据。<br />
示例：</p>
<pre><code>&lt;form method="POST" enctype='multipart/form-data'&gt;
    课程文档
    &lt;input name="pdf" type="file" accept="application/pdf"&gt;
&lt;/form&gt;</code></pre>
<p class="see"><strong>@see <a href="#setFormData">setFormData</a></strong> </p></div>
<div class="block">
<h2 id="formItems">@fn formItems(jo, cb)</h2>
<p>遍历jo下带name属性的有效控件，回调cb函数。</p>
<p>注意:</p>
<ul>
<li>忽略有disabled属性的控件</li>
<li>忽略未选中的checkbox/radiobutton</li>
</ul>
<p class="param"><strong>@param cb</strong> (name, val) this=ji=当前jquery对象</p>
<p>当cb返回false时可中断遍历。</p></div>
<div class="block">
<h2 id="setFormData">@fn setFormData(jo, data?, opt?)</h2>
<p>用于为带name属性的DOM对象设置内容为data[name].<br />
要清空所有内容, 可以用 setFormData(jo), 相当于增强版的 form.reset().</p>
<p>注意:</p>
<ul>
<li>DOM项的内容指: 如果是input/textarea/select等对象, 内容为其value值; 如果是div组件, 内容为其innerHTML值.</li>
<li>当data[name]未设置(即值为undefined, 注意不是null)时, 对于input/textarea等组件, 行为与form.reset()逻辑相同,<br />
即恢复为初始化值, 除了input[type=hidden]对象, 它的内容不会变.<br />
对div等其它对象, 会清空该对象的内容.</li>
<li>如果对象设置有属性&quot;noReset&quot;, 则不会对它进行设置.</li>
</ul>
<p class="param"><strong>@param opt</strong>  {setOrigin?=false}</p>
<p>选项 setOrigin: 为true时将data设置为数据源, 这样在getFormData时, 只会返回与数据源相比有变化的数据.<br />
缺省会设置该DOM对象数据源为空.</p>
<p>对象关联的数据源, 可以通过 jo.data(&quot;origin<em>&quot;) 来获取, 或通过 jo.data(&quot;origin</em>&quot;, newOrigin) 来设置.</p>
<p>示例：</p>
<pre><code>&lt;div id="div1"&gt;
    &lt;p&gt;订单描述：&lt;span name="dscr"&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;状态为：&lt;input type=text name="status"&gt;&lt;/p&gt;
    &lt;p&gt;金额：&lt;span name="amount"&gt;&lt;/span&gt;元&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>Javascript:</p>
<pre><code>var data = {
    dscr: "筋斗云教程",
    status: "已付款",
    amount: "100"
};
var jo = $("#div1");
var data = setFormData(jo, data); 
$("[name=status]").html("已完成");
var changedData = getFormData(jo); // 返回 { dscr: "筋斗云教程", status: "已完成", amount: "100" }

var data = setFormData(jo, data, {setOrigin: true}); 
$("[name=status]").html("已完成");
var changedData = getFormData(jo); // 返回 { status: "已完成" }
$.extend(jo.data("origin_"), changedData); // 合并变化的部分到数据源.</code></pre>
<p class="see"><strong>@see <a href="#getFormData">getFormData</a></strong> </p></div>
<div class="block">
<h2 id="loadScript">@fn loadScript(url, fnOK?, ajaxOpt?)</h2>
<p class="param"><strong>@param fnOK</strong>  加载成功后的回调函数</p>
<p class="param"><strong>@param ajaxOpt</strong>  传递给$.ajax的额外选项。</p>
<p>默认未指定ajaxOpt时，简单地使用添加script标签机制异步加载。如果曾经加载过，可以重用cache。</p>
<p>如果指定ajaxOpt，且非跨域，则通过ajax去加载，可以支持同步调用。如果是跨域，仍通过script标签方式加载，注意加载完成后会自动删除script标签。</p>
<p>返回defered对象(与$.ajax类似)，可以用 dfd.then() / dfd.fail() 异步处理。</p>
<p>常见用法：</p>
<ul>
<li>
<p>动态加载一个script，异步执行其中内容：</p>
<pre><code>loadScript("1.js", onload); // onload中可使用1.js中定义的内容
loadScript("http://otherserver/path/1.js"); // 跨域加载</code></pre>
</li>
<li>
<p>加载并立即执行一个script:</p>
<pre><code>loadScript("1.js", {async: false});
// 可立即使用1.js中定义的内容</code></pre>
</li>
</ul>
<p>如果要动态加载script，且使用后删除标签（里面定义的函数会仍然保留），建议直接使用<code>$.getScript</code>，它等同于：</p>
<pre><code>loadScript("1.js", {cache: false});</code></pre></div>
<div class="block">
<h2 id="setDateBox">@fn setDateBox(jo, defDateFn?)</h2>
<p>设置日期框, 如果输入了非法日期, 自动以指定日期(如未指定, 用当前日期)填充.</p>
<pre><code>setDateBox($("#txtComeDt"), function () { return genDefVal()[0]; });</code></pre></div>
<div class="block">
<h2 id="setTimeBox">@fn setTimeBox(jo, defTimeFn?)</h2>
<p>设置时间框, 如果输入了非法时间, 自动以指定时间(如未指定, 用当前时间)填充.</p>
<pre><code>setTimeBox($("#txtComeTime"), function () { return genDefVal()[1]; });</code></pre></div>
<div class="block">
<h2 id="waitFor">@fn waitFor(deferredObj)</h2>
<p>用于简化异步编程. 可将不易读的回调方式改写为易读的顺序执行方式.</p>
<pre><code>var dfd = $.getScript("http://...");
function onSubmit()
{
    dfd.then(function () {
        foo();
        bar();
    });
}</code></pre>
<p>可改写为:</p>
<pre><code>function onSubmit()
{
    if (waitFor(dfd)) return;
    foo();
    bar();
}</code></pre></div>
<div class="block">
<h2 id="jQuery.fn.jdata">@fn jQuery.fn.jdata(val?)</h2>
<p>和使用$.data()差不多，更好用一些. 例：</p>
<pre><code>$(o).jdata().hello = 100;
$(o).jdata({hello:100, world:200});</code></pre></div>
<div class="block">
<h2 id="evalAttr">@fn evalAttr(jo, name)</h2>
<p>返回一个属性做eval后的js值。</p>
<p>示例：读取一个对象值：</p>
<pre><code>var opt = evalAttr(jo, "data-opt");

&lt;div data-opt="{id:1, name:\"data1\"}"&gt;&lt;div&gt;</code></pre>
<p>考虑兼容性，也支持忽略括号的写法，</p>
<pre><code>&lt;div data-opt="id:1, name:\"data1\""&gt;&lt;div&gt;</code></pre>
<p>读取一个数组：</p>
<pre><code>var arr = evalAttr(jo, "data-arr");

&lt;div data-arr="['aa', 'bb']"&gt;&lt;div&gt;</code></pre>
<p>读取一个函数名（或变量）:</p>
<pre><code>var fn = evalAttr(jo, "mui-initfn");

&lt;div mui-initfn="initMyPage"&gt;&lt;div&gt;</code></pre></div>
<div class="block">
<h2 id="app_abort">@fn app_abort()</h2>
<p>中止之后的调用, 直接返回.</p></div>
<div class="block">
<h2 id="DirectReturn">@class DirectReturn</h2>
<p>直接返回. 用法:</p>
<pre><code>throw new DirectReturn();</code></pre>
<p>可直接调用app_abort();</p></div>
<div class="block">
<h2 id="MUI.setOnError">@fn MUI.setOnError()</h2>
<p>一般框架自动设置onerror函数；如果onerror被其它库改写，应再次调用该函数。<br />
allow throw(&quot;abort&quot;) as abort behavior.</p></div>
<div class="block">
<h2 id="MUI.m_enhanceFn">@var MUI.m_enhanceFn</h2></div>
<div class="block">
<h2 id="MUI.enhanceWithin">@fn MUI.enhanceWithin(jparent)</h2></div>
<div class="block">
<h2 id="MUI.getOptions">@fn MUI.getOptions(jo)</h2></div>
<div class="block">
<h2 id="WUI.getQueryCond">@fn WUI.getQueryCond(kvList)</h2>
<p class="param"><strong>@param kvList</strong>  {key=>value}, 键值对，值中支持操作符及通配符。也支持格式 [ [key, value] ], 这时允许key有重复。</p>
<p>根据kvList生成BPQ协议定义的{obj}.query的cond参数。</p>
<p>例如:</p>
<pre><code>var kvList = {phone: "13712345678", id: "&gt;100", addr: "上海*", picId: "null"};
WUI.getQueryCond(kvList);</code></pre>
<p>有多项时，每项之间以&quot;AND&quot;相连，以上定义将返回如下内容：</p>
<pre><code>"phone='13712345678' AND id&gt;100 AND addr LIKE '上海*' AND picId IS NULL"</code></pre>
<p>示例二：</p>
<pre><code>var kvList = [ ["phone", "13712345678"], ["id", "&gt;100"], ["addr", "上海*"], ["picId", "null"] ];
WUI.getQueryCond(kvList); // 结果同上。</code></pre>
<p>设置值时，支持以下格式：</p>
<ul>
<li>{key: &quot;value&quot;} - 表示&quot;key=value&quot;</li>
<li>{key: &quot;&gt;value&quot;} - 表示&quot;key&gt;value&quot;, 类似地，可以用 &gt;=, &lt;, &lt;=, <> 这些操作符。</li>
<li>{key: &quot;value<em>&quot;} - 值中带通配符，表示&quot;key like 'value%'&quot; (以value开头), 类似地，可以用 &quot;</em>value&quot;, &quot;<em>value</em>&quot;, &quot;<em>val</em>ue&quot;等。</li>
<li>{key: &quot;null&quot; } - 表示 &quot;key is null&quot;。要表示&quot;key is not null&quot;，可以用 &quot;<>null&quot;.</li>
<li>{key: &quot;empty&quot; } - 表示 &quot;key=''&quot;.</li>
</ul>
<p>支持简单的and/or查询，但不支持在其中使用括号:</p>
<ul>
<li>{key: &quot;&gt;value and &lt;=value&quot;}  - 表示&quot;key&gt;'value' and key&lt;='value'&quot;</li>
<li>{key: &quot;null or 0 or 1&quot;}  - 表示&quot;key is null or key=0 or key=1&quot;</li>
</ul>
<p>在详情页对话框中，切换到查找模式，在任一输入框中均可支持以上格式。</p></div>
<div class="block">
<h2 id="WUI.getQueryParam">@fn WUI.getQueryParam(kvList)</h2>
<p>根据键值对生成BQP协议中{obj}.query接口需要的cond参数.</p>
<p>示例：</p>
<pre><code>WUI.getQueryParam({phone: '13712345678', id: '&gt;100'})
返回
{cond: "phone='13712345678' AND id&gt;100"}</code></pre>
<p class="see"><strong>@see <a href="#WUI.getQueryCond">WUI.getQueryCond</a></strong> </p></div>
<div class="block">
<h2 id="MUI.lastError">@var MUI.lastError = ctx</h2>
<p>出错时，取出错调用的上下文信息。</p>
<p>ctx: {ac, tm, tv, ret}</p>
<ul>
<li>ac: action 调用接口名</li>
<li>tm: start time 开始调用时间</li>
<li>tv: time interval 从调用到返回的耗时</li>
<li>ret: return value 调用返回的原始数据</li>
</ul></div>
<div class="block">
<h2 id="MUI.disableBatch">@var MUI.disableBatch ?= false</h2>
<p>设置为true禁用batchCall, 仅用于内部测试。</p></div>
<div class="block">
<h2 id="MUI.m_curBatch">@var MUI.m_curBatch</h2>
<p>当前batchCall对象，用于内部调试。</p></div>
<div class="block">
<h2 id="MUI.mockData">@var MUI.mockData  模拟调用后端接口。</h2>
<p>在后端接口尚无法调用时，可以配置MUI.mockData做为模拟接口返回数据。<br />
调用callSvr时，会直接使用该数据，不会发起ajax请求。</p>
<p>mockData={ac =&gt; data/fn}  </p>
<p>mockData中每项可以直接是数据，也可以是一个函数：fn(param, postParam)-&gt;data</p>
<p>例：模拟&quot;User.get(id)&quot;和&quot;User.set()(key=value)&quot;接口：</p>
<pre><code>var user = {
    id: 1001,
    name: "孙悟空",
};
MUI.mockData = {
    // 方式1：直接指定返回数据
    "User.get": [0, user],

    // 方式2：通过函数返回模拟数据
    "User.set": function (param, postParam) {
        $.extend(user, postParam);
        return [0, "OK"];
    }
}

// 接口调用：
var user = callSvrSync("User.get");
callSvr("User.set", {id: user.id}, function () {
    alert("修改成功！");
}, {name: "大圣"});</code></pre>
<p>实例详见文件 mockdata.js。</p>
<p>在mockData的函数中，可以用this变量来取ajax调用参数。<br />
要取HTTP动词可以用<code>this.type</code>，值为GET/POST/PATCH/DELETE之一，从而可模拟RESTful API.</p>
<p>可以通过MUI.options.mockDelay设置模拟调用接口的网络延时。</p>
<p class="see"><strong>@see <a href="#MUI.options.mockDelay">MUI.options.mockDelay</a></strong> </p>
<p>模拟数据可直接返回[code, data]格式的JSON数组，框架会将其序列化成JSON字符串，以模拟实际场景。<br />
如果要查看调用与返回数据日志，可在浏览器控制台中设置 MUI.options.logAction=true，在控制台中查看日志。</p>
<p>如果设置了MUI.callSvrExt，调用名(ac)中应包含扩展(ext)的名字，例：</p>
<pre><code>MUI.callSvrExt['zhanda'] = {...};
callSvr(['token/get-token', 'zhanda'], ...);</code></pre>
<p>要模拟该接口，应设置</p>
<pre><code>MUI.mockData["zhanda:token/get-token"] = ...;</code></pre>
<p class="see"><strong>@see <a href="#MUI.callSvrExt">MUI.callSvrExt</a></strong> </p>
<p>也支持&quot;default&quot;扩展，如：</p>
<pre><code>MUI.callSvrExt['default'] = {...};
callSvr(['token/get-token', 'default'], ...);
或
callSvr('token/get-token', ...);</code></pre>
<p>要模拟该接口，可设置</p>
<pre><code>MUI.mockData["token/get-token"] = ...;</code></pre></div>
<div class="block">
<h2 id="MUI.enterWaiting">@fn MUI.enterWaiting(ctx?)</h2>
<p class="param"><strong>@param ctx</strong>  {ac, tm, tv?, tv2?, noLoadingImg?}</p>
<p class="alias"><strong>@alias <a id="enterWaiting">enterWaiting</a></strong> ()</p></div>
<div class="block">
<h2 id="MUI.leaveWaiting">@fn MUI.leaveWaiting(ctx?)</h2>
<p class="alias"><strong>@alias <a id="leaveWaiting">leaveWaiting</a></strong> </p></div>
<div class="block">
<h2 id="MUI.defDataProc">@fn MUI.defDataProc(rv)</h2>
<p class="param"><strong>@param rv</strong>  BQP协议原始数据，如 "[0, {id: 1}]"，一般是字符串，也可以是JSON对象。</p>
<p class="return"><strong>@return data</strong>  按接口定义返回的数据对象，如 {id: 1}. 如果返回==null，调用函数应直接返回，不回调应用层。</p>
<p>注意：服务端不应返回null, 否则客户回调无法执行; 习惯上返回false表示让回调处理错误。</p></div>
<div class="block">
<h2 id="MUI.getBaseUrl">@fn MUI.getBaseUrl()</h2>
<p>取服务端接口URL对应的目录。可用于拼接其它服务端资源。<br />
相当于dirname(MUI.options.serverUrl);</p>
<p>例如：</p>
<p>serverUrl为&quot;../jdcloud/api.php&quot; 或 &quot;../jdcloud/&quot;，则MUI.baseUrl返回 &quot;../jdcloud/&quot;<br />
serverUrl为&quot;<a href="http://myserver/myapp/api.php">http://myserver/myapp/api.php</a>&quot; 或 &quot;<a href="http://myserver/myapp/"，则MUI.baseUrl返回">http://myserver/myapp/"，则MUI.baseUrl返回</a> &quot;<a href="http://myserver/myapp/">http://myserver/myapp/</a>&quot;</p></div>
<div class="block">
<h2 id="MUI.makeUrl">@fn MUI.makeUrl(action, params?)</h2>
<p>生成对后端调用的url. </p>
<pre><code>var params = {id: 100};
var url = MUI.makeUrl("Ordr.set", params);</code></pre>
<p>注意：函数返回的url是字符串包装对象，可能含有这些属性：{makeUrl=true, action?, params?}<br />
这样可通过url.action得到原始的参数。</p>
<p>支持callSvr扩展，如：</p>
<pre><code>var url = MUI.makeUrl('zhanda:login');</code></pre>
<p>(deprecated) 为兼容旧代码，action可以是一个数组，在WUI环境下表示对象调用:</p>
<pre><code>WUI.makeUrl(['Ordr', 'query']) 等价于 WUI.makeUrl('Ordr.query');</code></pre>
<p>在MUI环境下表示callSvr扩展调用:</p>
<pre><code>MUI.makeUrl(['login', 'zhanda']) 等价于 MUI.makeUrl('zhanda:login');</code></pre>
<p class="see"><strong>@see <a href="#MUI.callSvrExt">MUI.callSvrExt</a></strong> </p></div>
<div class="block">
<h2 id="MUI.callSvr">@fn MUI.callSvr(ac, [params?], fn?, postParams?, userOptions?) -> deferredObject</h2><div class="toc"><p style="margin-left:0em"><a href="#MUI.callSvr-1 调用监控">1 调用监控</a></p>
<p style="margin-left:0em"><a href="#MUI.callSvr-2 文件上传支持(FormData)">2 文件上传支持(FormData)</a></p>
<p style="margin-left:0em"><a href="#MUI.callSvr-3 callSvr扩展">3 callSvr扩展</a></p>
<p style="margin-left:0em"><a href="#MUI.callSvr-4 适配RESTful API">4 适配RESTful API</a></p>
</div>
<p class="alias"><strong>@alias <a id="callSvr">callSvr</a></strong> </p>
<p class="param"><strong>@param ac</strong>  String. action, 交互接口名. 也可以是URL(比如由makeUrl生成)</p>
<p class="param"><strong>@param params</strong>  Object. URL参数（或称HTTP GET参数）</p>
<p class="param"><strong>@param postParams</strong>  Object. POST参数. 如果有该参数, 则自动使用HTTP POST请求(postParams作为POST内容), 否则使用HTTP GET请求.</p>
<p class="param"><strong>@param fn</strong>  Function(data). 回调函数, data参考该接口的返回值定义。</p>
<p class="param"><strong>@param userOptions</strong>  用户自定义参数, 会合并到$.ajax调用的options参数中.可在回调函数中用"this.参数名"引用. </p>
<p>常用userOptions: </p>
<ul>
<li>指定{async:0}来做同步请求, 一般直接用callSvrSync调用来替代.</li>
<li>指定{noex:1}用于忽略错误处理。</li>
<li>指定{noLoadingImg:1}用于忽略loading图标. 要注意如果之前已经调用callSvr显示了图标且图标尚未消失，则该选项无效，图标会在所有调用完成之后才消失(leaveWaiting)。<br />
要使隐藏图标不受本次调用影响，可在callSvr后手工调用<code>--$.active</code>。</li>
</ul>
<p>想为ajax选项设置缺省值，可以用callSvrExt中的beforeSend回调函数，也可以用$.ajaxSetup，<br />
但要注意：ajax的dataFilter/beforeSend选项由于框架已用，最好不要覆盖。</p>
<p class="see"><strong>@see <a href="#MUI.callSvrExt[].beforeSend">MUI.callSvrExt[].beforeSend</a></strong> (opt) 为callSvr选项设置缺省值</p>
<p class="return"><strong>@return deferred对象，与$.ajax相同。</strong> </p>
<p>例如，</p>
<pre><code>var dfd = callSvr(ac, fn1);
dfd.then(fn2);

function fn1(data) {}
function fn2(data) {}</code></pre>
<p>在接口调用成功后，会依次回调fn1, fn2.</p>
<p class="key"><strong>@key <a id="callSvr.noex">callSvr.noex</a></strong>  调用接口时忽略出错，可由回调函数fn自己处理错误。</p>
<p>当后端返回错误时, 回调<code>fn(false)</code>（参数data=false）. 可通过 MUI.lastError.ret 或 this.lastError 取到返回的原始数据。</p>
<p>示例：</p>
<pre><code>callSvr("logout");
callSvr("logout", api_logout);
function api_logout(data) {}

callSvr("login", {wantAll:1}, api_login);
function api_login(data) {}

callSvr("info/hotline.php", {q: '大众'}, api_hotline);
function api_hotline(data) {}

// 也可使用makeUrl生成的URL如:
callSvr(MUI.makeUrl("logout"), api_logout);
callSvr(MUI.makeUrl("logout", {a:1}), api_logout);

callSvr("User.get", function (data) {
    if (data === false) { // 仅当设置noex且服务端返回错误时可返回false
        // var originalData = MUI.lastError.ret; 或
        // var originalData = this.lastError;
        return;
    }
    foo(data);
}, null, {noex:1});</code></pre>
<p class="see"><strong>@see <a href="#MUI.lastError">MUI.lastError</a></strong>  出错时的上下文信息</p>
<h4 id="MUI.callSvr-1 调用监控">1 调用监控</h4>
<p>框架会自动在ajaxOption中增加ctx_属性，它包含 {ac, tm, tv, tv2, ret} 这些信息。<br />
当设置MUI.options.logAction=1时，将输出这些信息。</p>
<ul>
<li>ac: action</li>
<li>tm: start time</li>
<li>tv: time interval (从发起请求到服务器返回数据完成的时间, 单位是毫秒)</li>
<li>tv2: 从接到数据到完成处理的时间，毫秒(当并发处理多个调用时可能不精确)</li>
</ul>
<h4 id="MUI.callSvr-2 文件上传支持(FormData)">2 文件上传支持(FormData)</h4>
<p>callSvr支持FormData对象，可用于上传文件等场景。示例如下：</p>
<p class="key"><strong>@key <a id="example-upload">example-upload</a></strong> </p>
<p>HTML:</p>
<pre><code>file: &lt;input id="file1" type="file" multiple&gt;
&lt;button type="button" id="btn1"&gt;upload&lt;/button&gt;</code></pre>
<p>JS:</p>
<pre><code>jpage.find("#btn1").on('click', function () {
    var fd = new FormData();
    $.each(jpage.find('#file1')[0].files, function (i, e) {
        fd.append('file' + (i+1), e);
    });
    callSvr('upload', api_upload, fd);

    function api_upload(data) { ... }
});</code></pre>
<h4 id="MUI.callSvr-3 callSvr扩展">3 callSvr扩展</h4>
<p class="key"><strong>@key <a id="MUI.callSvrExt">MUI.callSvrExt</a></strong> </p>
<p>当调用第三方API时，也可以使用callSvr扩展来代替$.ajax调用以实现：</p>
<ul>
<li>调用成功时直接可操作数据，不用每次检查返回码；</li>
<li>调用出错时可以统一处理。</li>
</ul>
<p>例：合作方接口使用HTTP协议，格式如（以生成token调用为例）</p>
<pre><code>http://&lt;Host IP Address&gt;:&lt;Host Port&gt;/lcapi/token/get-token?user=用户名&amp;password=密码</code></pre>
<p>返回格式为：{code, msg, data}</p>
<p>成功返回：</p>
<pre><code>{
    "code":"0",
    "msg":"success",
    "data":[ { "token":"xxxxxxxxxxxxxx" } ]
}</code></pre>
<p>失败返回：</p>
<pre><code>{
    "code":"4001",
    "msg":"invalid username or password",
    "data":[]
}</code></pre>
<p>callSvr扩展示例：</p>
<pre><code>MUI.callSvrExt['zhanda'] = {
    makeUrl: function(ac, param) {
        return 'http://hostname/lcapi/' + ac;
    },
    dataFilter: function (data) {
        if ($.isPlainObject(data) &amp;&amp; data.code !== undefined) {
            if (data.code == 0)
                return data.data;
            if (this.noex)
                return false;
            app_alert("操作失败：" + data.msg, "e");
        }
        else {
            app_alert("服务器通讯协议异常!", "e"); // 格式不对
        }
    }
};</code></pre>
<p>在调用时，ac参数传入一个数组：</p>
<pre><code>callSvr(['token/get-token', 'zhanda'], {user: 'test', password: 'test123'}, function (data) {
    console.log(data);
});</code></pre>
<p class="key"><strong>@key <a id="MUI.callSvrExt[].makeUrl">MUI.callSvrExt[].makeUrl</a></strong> (ac, param)</p>
<p>根据调用名ac生成url, 注意无需将param放到url中。</p>
<p>注意：<br />
对方接口应允许JS跨域调用，或调用方支持跨域调用。</p>
<p class="key"><strong>@key <a id="MUI.callSvrExt[].dataFilter">MUI.callSvrExt[].dataFilter</a></strong> (data) = null/false/data</p>
<p>对调用返回数据进行通用处理。返回值决定是否调用callSvr的回调函数以及参数值。</p>
<pre><code>callSvr(ac, callback);</code></pre>
<ul>
<li>返回data: 回调应用层的实际有效数据: <code>callback(data)</code>.</li>
<li>返回null: 一般用于报错后返回。不会回调<code>callback</code>.</li>
<li>返回false: 一般与callSvr的noex选项合用，如<code>callSvr(ac, callback, postData, {noex:1})</code>，表示由应用层回调函数来处理出错: <code>callback(false)</code>。</li>
</ul>
<p>当返回false时，应用层可以通过<code>MUI.lastError.ret</code>来获取服务端返回数据。</p>
<p class="see"><strong>@see <a href="#MUI.lastError">MUI.lastError</a></strong>  出错时的上下文信息</p>
<p class="key"><strong>@key <a id="MUI.callSvrExt['default']">MUI.callSvrExt['default']</a></strong> </p>
<p>(支持版本: v3.1)<br />
如果要修改callSvr缺省调用方法，可以改写 MUI.callSvrExt['default'].<br />
例如，定义以下callSvr扩展：</p>
<pre><code>MUI.callSvrExt['default'] = {
    makeUrl: function(ac) {
        return '../api.php/' + ac;
    },
    dataFilter: function (data) {
        var ctx = this.ctx_ || {};
        if (data &amp;&amp; $.isArray(data) &amp;&amp; data.length &gt;= 2 &amp;&amp; typeof data[0] == "number") {
            if (data[0] == 0)
                return data[1];

            if (this.noex)
            {
                return false;
            }

            if (data[0] == E_NOAUTH) {
                // 如果支持自动重登录
                //if (MUI.tryAutoLogin()) {
                //  $.ajax(this);
                //}
                // 不支持自动登录，则跳转登录页
                MUI.popPageStack(0);
                MUI.showLogin();
                return;
            }
            else if (data[0] == E_AUTHFAIL) {
                app_alert("验证失败，请检查输入是否正确!", "e");
                return;
            }
            else if (data[0] == E_ABORT) {
                console.log("!!! abort call");
                return;
            }
            logError();
            app_alert("操作失败：" + data[1], "e");
        }
        else {
            logError();
            app_alert("服务器通讯协议异常!", "e"); // 格式不对
        }

        function logError()
        {
            console.log("failed call");
            console.log(ctx);
        }
    }
};</code></pre>
<p>这样，以下调用</p>
<pre><code>callSvr(['login', 'default']);</code></pre>
<p>可以简写为：</p>
<pre><code>callSvr('login');</code></pre>
<p class="key"><strong>@key <a id="MUI.callSvrExt[].beforeSend">MUI.callSvrExt[].beforeSend</a></strong> (opt) 为callSvr或$.ajax选项设置缺省值</p>
<p>如果有ajax选项想设置，可以使用beforeSend回调，例如POST参数使用JSON格式：</p>
<pre><code>MUI.callSvrExt['default'] = {
    beforeSend: function (opt) {
        // 示例：设置contentType
        if (opt.contentType == null) {
            opt.contentType = "application/json;charset=utf-8";
            if (opt.data) {
                opt.data = JSON.stringify(opt.data);
            }
        }
        // 示例：添加HTTP头用于认证
        if (g_data.auth) {
            if (opt.headers == null)
                opt.headers = {};
            opt.headers["Authorization"] = "Basic " + g_data.auth;
        }
    }
}</code></pre>
<p>如果要设置请求的HTTP headers，可以用<code>opt.headers = {header1: "value1", header2: "value2"}</code>.<br />
更多选项参考jquery文档：jQuery.ajax的选项。</p>
<h4 id="MUI.callSvr-4 适配RESTful API">4 适配RESTful API</h4>
<p>接口示例：更新订单</p>
<pre><code>PATCH /orders/{ORDER_ID}

调用成功仅返回HTTP状态，无其它内容："200 OK" 或 "204 No Content"
调用失败返回非2xx的HTTP状态及错误信息，无其它内容，如："400 bad id"</code></pre>
<p>为了处理HTTP错误码，应设置：</p>
<pre><code>MUI.callSvrExt["default"] = {
    beforeSend: function (opt) {
        opt.handleHttpError = true;
    },
    dataFilter: function (data) {
        var ctx = this.ctx_;
        if (ctx &amp;&amp; ctx.status) {
            if (this.noex)
                return false;
            app_alert(ctx.statusText, "e");
            return;
        }
        return data;
    }
}</code></pre>
<ul>
<li>在beforeSend回调中，设置handleHttpError为true，这样HTTP错误会由dataFilter处理，而非框架自动处理。</li>
<li>在dataFilter回调中，如果this.ctx<em>.status非空表示是HTTP错误，this.ctx</em>.statusText为错误信息。</li>
<li>如果操作成功但无任何返回数据，回调函数fn(data)中data值为undefined（当HTTP状态码为204）或空串（非204返回）</li>
<li>不要设置ajax调用失败的回调，如<code>$.ajaxSetup({error: fn})</code>，<code>$.ajax({error: fn})</code>，它会覆盖框架的处理.</li>
</ul>
<p>如果接口在出错时，返回固定格式的错误对象如{code, message}，可以这样处理：</p>
<pre><code>MUI.callSvrExt["default"] = {
    beforeSend: function (opt) {
        opt.handleHttpError = true;
    },
    dataFilter: function (data) {
        var ctx = this.ctx_;
        if (ctx &amp;&amp; ctx.status) {
            if (this.noex)
                return false;
            if (data &amp;&amp; data.message) {
                app_alert(data.message, "e");
            }
            else {
                app_alert("操作失败: 服务器错误. status=" + ctx.status + "-" + ctx.statusText, "e");
            }
            return;
        }
        return data;
    }
}</code></pre>
<p>调用接口时，HTTP谓词可以用callSvr的userOptions中给定，如：</p>
<pre><code>callSvr("orders/" + orderId, fn, postParam, {type: "PATCH"});</code></pre>
<p>这种方式简单，但因调用名ac是变化的，不易模拟接口。<br />
如果要模拟接口，可以保持调用名ac不变，像这样调用：</p>
<pre><code>callSvr("orders/{id}", {id: orderId}, fn, postParam, {type: "PATCH"});</code></pre>
<p>于是可以这样做接口模拟：</p>
<pre><code>MUI.mockData = {
    "orders/{id}": function (param, postParam) {
        var ret = "OK";
        // 获取资源
        if (this.type == "GET") {
            ret = orders[param.id];
        }
        // 更新资源
        else if (this.type == "PATCH") {
            $.extend(orders[param.id], postParam);
        }
        // 删除资源
        else if (this.type == "DELETE") {
            delete orders[param.id];
        }
        return [0, ret];
    }
};</code></pre>
<p>不过这种写法需要适配，以生成正确的URL，示例：</p>
<pre><code>MUI.callSvrExt["default"] = {
    makeUrl: function (ac, param) {
        ac = ac.replace(/\{(\w+)\}/g, function (m, m1) {
            var ret = param[m1];
            assert(ret != null, "缺少参数");
            delete param[m1];
            return ret;
        });
        return "./api.php/" + ac;
    }
}</code></pre></div>
<div class="block">
<h2 id="MUI.callSvrSync">@fn MUI.callSvrSync(ac, [params?], fn?, postParams?, userOptions?)</h2>
<p class="alias"><strong>@alias <a id="callSvrSync">callSvrSync</a></strong> </p>
<p class="return"><strong>@return data</strong>  原型规定的返回数据</p>
<p>同步模式调用callSvr.</p>
<p class="see"><strong>@see <a href="#callSvr">callSvr</a></strong> </p></div>
<div class="block">
<h2 id="MUI.setupCallSvrViaForm">@fn MUI.setupCallSvrViaForm($form, $iframe, url, fn, callOpt)</h2>
<p>该方法已不建议使用。上传文件请用FormData。</p>
<p class="see"><strong>@see <a href="#example-upload">example-upload</a> <a href="#callSvr">callSvr</a></strong> </p>
<p class="param"><strong>@param $iframe</strong>  一个隐藏的iframe组件.</p>
<p class="param"><strong>@param callOpt</strong>  用户自定义参数. 参考callSvr的同名参数. e.g. {noex: 1}</p>
<p>一般对后端的调用都使用callSvr函数, 但像上传图片等操作不方便使用ajax调用, 因为要自行拼装multipart/form-data格式的请求数据.<br />
这种情况下可以使用form的提交和一个隐藏的iframe来实现类似的调用.</p>
<p>先定义一个form, 在其中放置文件上传控件和一个隐藏的iframe. form的target属性设置为iframe的名字:</p>
<pre><code>&lt;form data-role="content" action="upload" method=post enctype="multipart/form-data" target="ifrUpload"&gt;
    &lt;input type=file name="file[]" multiple accept="image/*"&gt;
    &lt;input type=submit value="上传"&gt;
    &lt;iframe id='ifrUpload' name='ifrUpload' style="display:none"&gt;&lt;/iframe&gt;
&lt;/form&gt;</code></pre>
<p>然后就像调用callSvr函数一样调用setupCallSvrViaForm:</p>
<pre><code>var url = MUI.makeUrl("upload", {genThumb: 1});
MUI.setupCallSvrViaForm($frm, $frm.find("iframe"), url, onUploadComplete);
function onUploadComplete(data) 
{
    alert("上传成功");
}</code></pre></div>
<div class="block">
<h2 id="MUI.batchCall">@class MUI.batchCall(opt?={useTrans?=0})</h2>
<p>批量调用。将若干个调用打包成一个特殊的batch调用发给服务端。<br />
注意：</p>
<ul>
<li>同步调用callSvrSync不会加入批处理。</li>
<li>对特别几个不符合BPQ协议输出格式规范的接口不可使用批处理，如upload, att等接口。</li>
<li>如果MUI.disableBatch=true, 表示禁用批处理。</li>
</ul>
<p>示例：</p>
<pre><code>var batch = new MUI.batchCall();
callSvr("Family.query", {res: "id,name"}, api_FamilyQuery);
callSvr("User.get", {res: "id,phone"}, api_UserGet);
batch.commit();</code></pre>
<p>以上两条调用将一次发送到服务端。<br />
在批处理中，默认每条调用是一个事务，如果想把批处理中所有调用放到一个事务中，可以用useTrans选项：</p>
<pre><code>var batch = new MUI.batchCall({useTrans: 1});
callSvr("Attachment.add", api_AttAdd, {path: "path-1"});
callSvr("Attachment.add", api_AttAdd, {path: "path-2"});
batch.commit();</code></pre>
<p>在一个事务中，所有调用要么成功要么都取消。<br />
任何一个调用失败，会导致它后面所有调用取消执行，且所有已执行的调用会回滚。</p>
<p>参数中可以引用之前结果中的值，引用部分需要用&quot;{}&quot;括起来，且要在opt.ref参数中指定哪些参数使用了引用：</p>
<pre><code>var batch = new MUI.batchCall({useTrans: 1});
callSvr("Attachment.add", api_AttAdd, {path: "path-1"}); // 假如返回 22
var opt = {ref: ["id"]};
callSvr("Attachment.get", {id: "{$1}"}, api_AttGet, null, opt); // {$1}=22, 假如返回 {id: 22, path: '/data/1.png'}
opt = {ref: ["cond"]};
callSvr("Attachment.query", {res: "count(*) cnt", cond: "path='{$-1.path}'"}, api_AttQuery, null, opt); // {$-1.path}计算出为 '/data/1.png'
batch.commit();</code></pre>
<p>以下为引用格式示例：</p>
<pre><code>{$-2} // 前2次的结果。
{$2[0]} // 取第2次结果（是个数组）的第0个值。
{$-1.path} // 取前一次结果的path属性
{$2 -1}  // 可以做简单的计算</code></pre>
<p>如果值计算失败，则当作&quot;null&quot;填充。</p>
<p class="see"><strong>@see <a href="#MUI.useBatchCall">MUI.useBatchCall</a></strong> </p>
<p class="see"><strong>@see <a href="#MUI.disableBatch">MUI.disableBatch</a></strong> </p>
<p class="see"><strong>@see <a href="#MUI.m_curBatch">MUI.m_curBatch</a></strong> </p></div>
<div class="block">
<h2 id="MUI.useBatchCall">@fn MUI.useBatchCall(opt?={useTrans?=0}, tv?=0)</h2>
<p>之后的callSvr调用都加入批量操作。例：</p>
<pre><code>MUI.useBatchCall();
callSvr("Family.query", {res: "id,name"}, api_FamilyQuery);
callSvr("User.get", {res: "id,phone"}, api_UserGet);</code></pre>
<p>可指定多少毫秒以内的操作都使用批处理，如10ms内：</p>
<pre><code>MUI.useBatchCall(null, 10);</code></pre>
<p>如果MUI.disableBatch=true, 该函数不起作用。</p>
<p class="see"><strong>@see <a href="#MUI.batchCall">MUI.batchCall</a></strong> </p>
<p class="see"><strong>@see <a href="#MUI.disableBatch">MUI.disableBatch</a></strong> </p></div>
<div class="block">
<h2 id="WUI.reload">@fn WUI.reload(jtbl, url?, queryParams?)</h2></div>
<div class="block">
<h2 id="WUI.reloadTmp">@fn WUI.reloadTmp(jtbl, url?, queryParams?) </h2>
<p>临时reload一下，完事后恢复原url</p></div>
<div class="block">
<h2 id="WUI.reloadRow">@fn WUI.reloadRow(jtbl, rowData)</h2>
<p class="param"><strong>@param rowData</strong>  must be the original data from table row</p></div>
<div class="block">
<h2 id="WUI.showPage">@fn WUI.showPage(pageName, title?, paramArr?)</h2>
<p class="param"><strong>@param pageName</strong>  由page上的class指定。</p>
<p class="param"><strong>@param title</strong> ? 如果未指定，则使用page上的title属性.</p>
<p class="param"><strong>@param paramArr</strong> ? 调用initfn时使用的参数，是一个数组。</p>
<p>新页面以title作为id。<br />
注意：每个页面都是根据pages下相应pageName复制出来的，显示在一个新的tab页中。相同的title当作同一页面。<br />
初始化函数由page上的my-initfn属性指定。</p>
<p>page定义示例: </p>
<pre><code>&lt;div id="my-pages" style="display:none"&gt;
    &lt;div class="pageHome" title="首页" my-initfn="initPageHome"&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>page调用示例:</p>
<pre><code>WUI.showPage("pageHome");
WUI.showPage("pageHome", "首页");
WUI.showPage("pageHome", "首页2");</code></pre></div>
<div class="block">
<h2 id="wui-pageFile">@key wui-pageFile</h2>
<p>动态加载的逻辑页(或对话框)具有该属性，值为源文件名。</p></div>
<div class="block">
<h2 id="WUI.closeDlg">@fn WUI.closeDlg(jdlg)</h2></div>
<div class="block">
<h2 id="WUI.showDlg">@fn WUI.showDlg(jdlg, opt?)</h2>
<p class="param"><strong>@param jdlg</strong>  可以是jquery对象，也可以是selector字符串或DOM对象，比如 "#dlgOrder". 注意：当对话框保存为单独模块时，jdlg=$("#dlgOrder") 一开始会为空数组，这时也可以调用该函数，且调用后jdlg会被修改为实际加载的对话框对象。</p>
<p class="param"><strong>@param opt</strong> ?={url, buttons, noCancel=false, okLabel="确定", cancelLabel="取消", modal=true, reset=true, validate=true, data, onOk, onSubmit, onAfterSubmit}</p>
<ul>
<li>url: 点击确定时的操作动作。</li>
<li>data: 如果是object, 则为form自动加载的数据；如果是string, 则认为是一个url, 将自动获取数据。(form的load方法一致)</li>
<li>reset: 在加载数据前清空form</li>
</ul>
<p>特殊class my-reset: 当执行form reset时会将内容清除. (适用于在forSet/forLink模式下添加显示内容, 而在forFind/forAdd模式下时清除内容)</p>
<pre><code>&lt;div class="my-reset"&gt;...&lt;/div&gt;</code></pre>
<p>hidden上的特殊property noReset: (TODO)</p>
<p>在dialog的form中将触发以下事件：</p>
<p class="key"><strong>@key <a id="beforeshow">beforeshow</a></strong>  Function(ev, formMode)  form显示前事件.</p>
<p class="key"><strong>@key <a id="show">show</a></strong>  Function(ev, formMode)  form显示事件.</p>
<p class="key"><strong>@key <a id="initdata">initdata</a></strong>  Function(ev, data, formMode) form加载数据前，可修改要加载的数据即data</p>
<p class="key"><strong>@key <a id="loaddata">loaddata</a></strong>  Function(ev, data, formMode) form加载数据后，一般用于将服务端数据转为界面显示数据</p>
<p class="key"><strong>@key <a id="savedata">savedata</a></strong>  Function(ev, formMode, initData) form提交前事件，用于将界面数据转为提交数据. 返回false或调用ev.preventDefault()可阻止form提交。</p>
<p class="key"><strong>@key <a id="retdata">retdata</a></strong>  Function(ev, data, formMode) form提交后事件，用于处理返回数据</p>
<p>调用此函数后，对话框将加上以下CSS Class:</p>
<p class="key"><strong>@key <a id=".wui-dialog">.wui-dialog</a></strong>  标识WUI对话框的类名。</p>
<p class="see"><strong>@see <a href="#example-dialog">example-dialog</a></strong>  在对话框中使用事件</p></div>
<div class="block">
<h2 id="WUI.getTopDialog">@fn WUI.getTopDialog()</h2>
<p>取处于最上层的对话框。如果没有，返回jo.size() == 0</p></div>
<div class="block">
<h2 id="WUI.unloadPage">@fn WUI.unloadPage(pageName?)</h2>
<p class="param"><strong>@param pageName</strong>  如未指定，表示当前页。</p>
<p>删除一个页面。一般用于开发过程，在修改外部逻辑页后，调用该函数删除页面。此后载入页面，可以看到更新的内容。</p>
<p>注意：对于内部逻辑页无意义。</p></div>
<div class="block">
<h2 id="WUI.reloadPage">@fn WUI.reloadPage()</h2>
<p>重新加载当前页面。一般用于开发过程，在修改外部逻辑页后，调用该函数可刷新页面。</p></div>
<div class="block">
<h2 id="WUI.unloadDialog">@fn WUI.unloadDialog()</h2>
<p class="alias"><strong>@alias <a id="WUI.reloadDialog">WUI.reloadDialog</a></strong> </p>
<p>删除当前激活的对话框。一般用于开发过程，在修改外部对话框后，调用该函数清除以便此后再载入页面，可以看到更新的内容。</p>
<p>注意：</p>
<ul>
<li>对于内部对话框调用本函数无意义。直接关闭对话框即可。</li>
<li>由于不知道打开对话框的参数，reloadDialog无法重新打开对话框，因而它的行为与unloadDialog一样。</li>
</ul></div>
<div class="block">
<h2 id="WUI.showObjDlg">@fn WUI.showObjDlg(jdlg, mode, opt?={jtbl, id})</h2>
<p class="param"><strong>@param jdlg</strong>  可以是jquery对象，也可以是selector字符串或DOM对象，比如 "#dlgOrder". 注意：当对话框保存为单独模块时，jdlg=$("#dlgOrder") 一开始会为空数组，这时也可以调用该函数，且调用后jdlg会被修改为实际加载的对话框对象。</p>
<p class="param"><strong>@param opt.id</strong>  String. mode=link时必设，set/del如缺省则从关联的opt.jtbl中取, add/find时不需要</p>
<p class="param"><strong>@param opt.jdbl</strong>  Datagrid. dialog/form关联的datagrid -- 如果dlg对应多个tbl, 必须每次打开都设置</p>
<p>事件参考：</p>
<p class="see"><strong>@see <a href="#WUI.showDlg">WUI.showDlg</a></strong> </p></div>
<div class="block">
<h2 id="WUI.dg_toolbar">@fn WUI.dg_toolbar(jtbl, jdlg, button_lists...)</h2>
<p class="param"><strong>@param jdlg</strong>  可以是对话框的jquery对象，或selector如"#dlgOrder".</p>
<p>设置easyui-datagrid上toolbar上的按钮。缺省支持的按钮有r(refresh), f(find), a(add), s(set), d(del), 可通过以下设置方式修改：</p>
<pre><code>// jtbl.jdata().toolbar 缺省值为 "rfasd"
jtbl.jdata().toolbar = "rfs"; // 没有a-添加,d-删除</code></pre>
<p>如果要添加自定义按钮，可通过button_lists一一传递.<br />
示例：添加两个自定义按钮查询“今天订单”和“所有未完成订单”。</p>
<pre><code>function getTodayOrders()
{
    var queryParams = WUI.getQueryParam({comeTm: new Date().format("D")});
    WUI.reload(jtbl, null, queryParams);
}
// 显示待服务/正在服务订单
function getTodoOrders()
{
    var queryParams = {cond: "status=" + OrderStatus.Paid + " or status=" + OrderStatus.Started};
    WUI.reload(jtbl, null, queryParams);
}
var btn1 = {text: "今天订单", iconCls:'icon-search', handler: getTodayOrders};
var btn2 = {text: "所有未完成", iconCls:'icon-search', handler: getTodoOrders};

// 默认显示当天订单
var queryParams = WUI.getQueryParam({comeTm: new Date().format("D")});

var dgOpt = {
    url: WUI.makeUrl(["Ordr", "query"]),
    queryParams: queryParams,
    pageList: ...
    pageSize: ...
    // "-" 表示按钮之间加分隔符
    toolbar: WUI.dg_toolbar(jtbl, jdlg, btn1, "-", btn2),
    onDblClickRow: WUI.dg_dblclick(jtbl, jdlg)
};
jtbl.datagrid(dgOpt);</code></pre></div>
<div class="block">
<h2 id="WUI.dg_dblclick">@fn WUI.dg_dblclick(jtbl, jdlg)</h2>
<p class="param"><strong>@param jdlg</strong>  可以是对话框的jquery对象，或selector如"#dlgOrder".</p>
<p>设置双击datagrid行的回调，功能是打开相应的dialog</p></div>
<div class="block">
<h2 id="a[href=#page]">@key a[href=#page]</h2>
<p class="key"><strong>@key <a id="a[href=">a[href=</a></strong> ?fn]</p>
<p>页面中的a[href]字段会被框架特殊处理：</p>
<pre><code>&lt;a href="#pageHome"&gt;首页&lt;/a&gt;
&lt;a href="?logout"&gt;退出登录&lt;/a&gt;</code></pre>
<ul>
<li>href=&quot;#pageXXX&quot;开头的，点击时会调用 WUI.showPage(&quot;#pageXXX&quot;);</li>
<li>href=&quot;?fn&quot;，会直接调用函数 fn();</li>
</ul></div>
<div class="block">
<h2 id="WUI.getExportHandler">@fn WUI.getExportHandler(jtbl, ac, param?={})</h2>
<p>为数据表添加导出Excel菜单，如：</p>
<pre><code>jtbl.datagrid({
    url: WUI.makeUrl("User.query"),
    toolbar: WUI.dg_toolbar(jtbl, jdlg, {text:'导出', iconCls:'icon-save', handler: getExportHandler(jtbl, "User.query") }),
    onDblClickRow: WUI.dg_dblclick(jtbl, jdlg)
});</code></pre>
<p>默认是导出数据表中直接来自于服务端的字段，并应用表上的查询条件及排序。<br />
也可以通过设置param参数手工指定，如：</p>
<pre><code>handler: getExportHandler(jtbl, "User.query", {res: "id 编号, name 姓名, createTm 注册时间", orderby: "createTm DESC"})</code></pre>
<p>注意：由于分页机制影响，会设置参数{pagesz: 9999}以便在一页中返回所有数据，而实际一页能导出的最大数据条数取决于后端设置（默认1000，参考后端文档 AccessControl::$maxPageSz）。</p>
<p class="see"><strong>@see <a href="#WUI.getParamFromTable">WUI.getParamFromTable</a></strong> </p></div>
<div class="block">
<h2 id="WUI.getParamFromTable">@fn WUI.getParamFromTable(jtbl, param?)</h2>
<p>根据数据表当前设置，获取查询参数。<br />
可能会设置{cond, orderby, res}参数。</p>
<p>res参数从列设置中获取，如&quot;id 编号,name 姓名&quot;, 特别地，如果列对应字段以&quot;_&quot;结尾，不会加入res参数。</p>
<p class="see"><strong>@see <a href="#WUI.getExportHandler">WUI.getExportHandler</a></strong>  导出Excel</p></div>
<div class="block">
<h2 id=".easyui-validatebox">@key .easyui-validatebox</h2>
<p>为form中的组件加上该类，可以限制输入类型，如：</p>
<pre><code>&lt;input name="amount" class="easyui-validatebox" data-options="required:true,validType:'number'" &gt;</code></pre>
<p>validType还支持：</p>
<ul>
<li>number: 数字</li>
<li>uname: 4-16位用户名，字母开头</li>
<li>cellphone: 11位手机号</li>
<li>datetime: 格式为&quot;年-月-日 时:分:秒&quot;，时间部分可忽略</li>
</ul>
<p>其它自定义规则(或改写上面规则)，可通过下列方式扩展：</p>
<pre><code>$.extend($.fn.validatebox.defaults.rules, {
    workday: {
        validator: function(value) {
            return value.match(/^[1-7,abc]+$/);
        },
        message: '格式例："1,3a,5b"表示周一,周三上午,周五下午.'
    }
});</code></pre></div>
<div class="block">
<h2 id="isBusy">@var isBusy</h2>
<p>标识应用当前是否正在与服务端交互。一般用于自动化测试。</p></div>
<div class="block">
<h2 id="g_args">@var g_args</h2>
<p>应用参数。</p>
<p>URL参数会自动加入该对象，例如URL为 <code>http://{server}/{app}/index.html?orderId=10&amp;dscr=上门洗车</code>，则该对象有以下值：</p>
<pre><code>g_args.orderId=10; // 注意：如果参数是个数值，则自动转为数值类型，不再是字符串。
g_args.dscr="上门洗车"; // 对字符串会自动进行URL解码。</code></pre>
<p>此外，框架会自动加一些参数：</p>
<p class="var"><strong>@var <a id="g_args._app">g_args._app</a></strong> ?="user" 应用名称，由 WUI.options.appName 指定。</p>
<p class="see"><strong>@see <a href="#parseQuery">parseQuery</a></strong>  URL参数通过该函数获取。</p></div>
<div class="block">
<h2 id="g_data">@var g_data = {userInfo?}</h2>
<p>应用全局共享数据。</p>
<p>在登录时，会自动设置userInfo属性为个人信息。所以可以通过 g_data.userInfo==null 来判断是否已登录。</p>
<p class="key"><strong>@key <a id="g_data.userInfo">g_data.userInfo</a></strong> </p></div>
<div class="block">
<h2 id="BASE_URL">@var BASE_URL</h2>
<p>TODO: remove</p>
<p>设置应用的基本路径, 应以&quot;/&quot;结尾.</p></div>
<div class="block">
<h2 id="WUI.options">@var WUI.options</h2>
<p>{appName=user, title=&quot;客户端&quot;, onShowLogin, pageHome=&quot;pageHome&quot;, pageFolder=&quot;page&quot;}</p>
<ul>
<li>appName: 用于与后端通讯时标识app.</li>
<li>pageHome: 首页的id, 默认为&quot;pageHome&quot;</li>
<li>pageFolder: 子页面或对话框所在文件夹, 默认为&quot;page&quot;</li>
</ul></div>
<div class="block">
<h2 id="WUI.app_alert">@fn WUI.app_alert(msg, [type?=i], [fn?], opt?={timeoutInterval?, defValue?, onCancel()?})</h2>
<p class="param"><strong>@param type</strong>  对话框类型: "i": info, 信息提示框; "e": error, 错误框; "w": warning, 警告框; "q"(与app_confirm一样): question, 确认框(会有"确定"和"取消"两个按钮); "p": prompt, 输入框</p>
<p class="param"><strong>@param fn</strong>  Function(text?) 回调函数，当点击确定按钮时调用。当type="p" (prompt)时参数text为用户输入的内容。</p>
<p class="param"><strong>@param opt</strong>  Object. 可选项。 timeoutInterval表示几秒后自动关闭对话框。defValue用于输入框(type=p)的缺省值.</p>
<p>使用jQuery easyui弹出提示对话框.</p>
<p>示例:</p>
<pre><code>// 信息框，3s后自动点确定
app_alert("操作成功", function () {
    WUI.showPage("pageGenStat");
}, {timeoutInterval: 3000});

// 错误框
app_alert("操作失败", "e");

// 确认框(确定/取消)
app_alert("立即付款?", "q", function () {
    WUI.showPage("#pay");
});

// 输入框
app_alert("输入要查询的名字:", "p", function (text) {
    callSvr("Book.query", {cond: "name like '%" + text + "%'"});
});</code></pre></div>
<div class="block">
<h2 id="app_confirm">@fn app_confirm(msg, fn?)</h2>
<p class="param"><strong>@param fn</strong>  Function(isOk). 用户点击确定或取消后的回调。</p>
<p>使用jQuery easyui弹出确认对话框.</p></div>
<div class="block">
<h2 id="app_show">@fn app_show(msg)</h2>
<p>使用jQuery easyui弹出对话框.</p></div>
<div class="block">
<h2 id="makeLinkTo">@fn makeLinkTo(dlg, id, text?=id)</h2>
<p>生成一个链接的html代码，点击该链接可以打开指定对象的对话框。</p>
<p>示例：根据订单号，生成一个链接，点击链接打开订单详情对话框。</p>
<pre><code>var orderId = 101;
var html = makeLinkTo("#dlgOrder", orderId, "订单" + orderId);</code></pre></div>
<div class="block">
<h2 id="WUI.tryAutoLogin">@fn WUI.tryAutoLogin(onHandleLogin, reuseCmd?)</h2>
<p class="param"><strong>@param onHandleLogin</strong>  Function(data). 调用后台login()成功后的回调函数(里面使用this为ajax options); 可以直接使用WUI.handleLogin</p>
<p class="param"><strong>@param reuseCmd</strong>  String. 当session存在时替代后台login()操作的API, 如"User.get", "Employee.get"等, 它们在已登录时返回与login相兼容的数据. 因为login操作比较重, 使用它们可减轻服务器压力. </p>
<p class="return"><strong>@return Boolean.</strong>  true=登录成功; false=登录失败.</p>
<p>该函数一般在页面加载完成后调用，如</p>
<pre><code>function main()
{
    $.extend(WUI.options, {
        appName: APP_NAME,
        title: APP_TITLE,
        onShowLogin: showDlgLogin
    });

    WUI.tryAutoLogin(WUI.handleLogin, "whoami");
}

$(main);</code></pre></div>
<div class="block">
<h2 id="WUI.handleLogin">@fn WUI.handleLogin(data)</h2>
<p class="param"><strong>@param data</strong>  调用API "login"成功后的返回数据.</p>
<p>处理login相关的操作, 如设置g_data.userInfo, 保存自动登录的token等等.</p></div>
<div class="block">
<h2 id="WUI.initClient">@fn WUI.initClient()</h2></div>
<div class="block">
<h2 id="Plugins">@class Plugins</h2></div>
<div class="block">
<h2 id="Plugins.exists">@fn Plugins.exists(pluginName)</h2></div>
<div class="block">
<h2 id="Plugins.list">@fn Plugins.list()</h2></div>
<div class="block">
<h2 id="WUI.setApp">@fn WUI.setApp(opt)</h2>
<p class="see"><strong>@see <a href="#WUI.options">WUI.options</a></strong> </p>
<p>TODO: remove. use $.extend instead.</p></div>
<div class="block">
<h2 id="WUI.logout">@fn WUI.logout(dontReload?=0)</h2>
<p class="param"><strong>@param dontReload</strong>  如果非0, 则注销后不刷新页面.</p>
<p>注销当前登录, 成功后刷新页面(除非指定dontReload=1)</p></div>
<div class="block">
<h2 id="WUI.tabClose">@fn WUI.tabClose(idx?)</h2>
<p>关闭指定idx的标签页。如果未指定idx，则关闭当前标签页.</p></div>
<div class="block">
<h2 id="WUI.getActivePage">@fn WUI.getActivePage()</h2>
<p>返回当前激活的逻辑页jpage，注意可能为空: jpage.size()==0。</p></div>
<div class="block">
<h2 id="MUI.showLoading">@fn MUI.showLoading()</h2></div>
<div class="block">
<h2 id="MUI.hideLoading">@fn MUI.hideLoading()</h2></div>
<div class="block">
<h2 id="WUI.tabMain">@var WUI.tabMain</h2>
<p>标签页组件。为jquery-easyui的tabs插件，可以参考easyui文档调用相关命令进行操作，如关闭当前Tab：</p>
<pre><code>var jtab = WUI.tabMain.tabs("getSelected");
var idx = WUI.tabMain.tabs("getTabIndex", jtab);
WUI.tabMain.tabs("close", idx);</code></pre>
<p>注：要关闭当前Tab，可以直接用WUI.tabClose().</p></div>
<div class="block">
<h2 id="jQuery.fn.mycombobox">@fn jQuery.fn.mycombobox(force?=false)</h2>
<p class="key"><strong>@key <a id=".my-combobox">.my-combobox</a></strong>  关联选择框</p>
<p class="var"><strong>@var <a id="ListOptions">ListOptions</a></strong>  定义关联选择框的数据源</p>
<p class="param"><strong>@param force</strong> ?=false 如果为true, 则调用时强制重新初始化。默认只初始化一次。</p>
<p>关联选择框组件。</p>
<p>用法：先定义select组件：</p>
<pre><code>&lt;select name="empId" class="my-combobox" data-options="valueField: 'id', ..."&gt;&lt;/select&gt;</code></pre>
<p>通过data-options可设置选项: { valueField, textField, url, formatter(row), loadFilter(data) }</p>
<p>初始化：</p>
<pre><code>var jo = $(".my-combobox").mycombobox();</code></pre>
<p>注意：使用WUI.showDlg显示的对话框中如果有.my-combobox组件，会在调用WUI.showDlg时自动初始化，无须再调用上述代码。</p>
<p>操作：</p>
<ul>
<li>刷新列表： jo.trigger(&quot;refresh&quot;);</li>
<li>标记刷新（下次打开时刷新）： jo.trigger(&quot;markRefresh&quot;);</li>
</ul>
<p>特性：</p>
<ul>
<li>初始化时调用url指定接口取数据并生成下拉选项。</li>
<li>双击可刷新列表。</li>
<li>支持数据缓存，不必每次打开都刷新。</li>
</ul>
<p>例如，在订单上设计有empId字段：</p>
<pre><code>@Ordr: id, ... empId

empId:: Integer. 员工编号，关联Employee.id字段。</code></pre>
<p>在显示订单详情对话框时，这列显示为“分派给员工”，是一个列出所有员工的下拉列表框，可以这样写：</p>
<pre><code>&lt;tr&gt;
    &lt;td&gt;分派给&lt;/td&gt;
    &lt;td&gt;&lt;select name="empId" class="my-combobox" data-options="valueField:'id',textField:'name',url:WUI.makeUrl('Employee.query', {res:'id,name',pagesz:-1})"&gt;&lt;/select&gt;&lt;/td&gt;  
&lt;/tr&gt;</code></pre>
<p>注意查询默认是有分页的（页大小一般为20条），用参数<code>{pagesz:-1}</code>使用服务器设置的最大的页大小（后端最大pagesz默认100，可使用maxPageSz参数调节）。<br />
为了精确控制返回字段与显示格式，data-options可能更加复杂，一般建议写一个返回这些属性的函数，像这样：</p>
<pre><code>    &lt;td&gt;&lt;select name="empId" class="my-combobox" data-options="ListOptions.Emp()"&gt;&lt;/select&gt;&lt;/td&gt;  </code></pre>
<p>习惯上，可以把函数统一放在ListOptions变量中：</p>
<pre><code>var ListOptions = {
    // ListOptions.Emp()
    Emp: function () {
        var opts = {
            valueField: "id",
            textField: "name",
            url: WUI.makeUrl('Employee.query', {
                res: 'id,name,uname',
                cond: 'storeId=' + g_data.userInfo.storeId,
                pagesz:-1
            }),
            formatter: function (row) { return row.name + '(' + row.uname + ')'; }
        };
        return opts;
    },
    ...
};</code></pre>
<p>另一个例子：在返回列表后，可通过loadFilter修改列表，例如添加一项：</p>
<pre><code>&lt;select name="brandId" class="my-combobox" data-options="ListOptions.Brand()" &gt;&lt;/select&gt;</code></pre>
<p>JS代码ListOptions.Brand:</p>
<pre><code>var ListOptions = {
    ...
    // ListOptions.Brand()
    Brand: function () {
        var opts = {
            valueField: 'id',
            textField:'name',
            url:WUI.makeUrl('queryBrand', {pagesz:-1}),
            loadFilter: function(data) {
                data.unshift({id:'0', name:'所有品牌'});
                return data;
            }
        };
        return opts;
    }
};</code></pre></div>
<div style="text-align:center">Generated by jdcloud-gendoc</div>
</body>

</html>

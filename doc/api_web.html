<html>
<head>
<meta charset="utf-8">
<title>API参考 - 筋斗云前端（桌面Web版）</title>
<style>
h3,h4,h5,h6 {
	font-size: 1em;
}

pre {
	border-left: 1px solid #ccc;
	margin: 0 1em;
	padding: 0 0.5em;
	tab-size:4;
}

code {
	font-family: "Courier New";
    padding: 0px 3px;
    display: inline-block;
}

.toc {
	margin: 2em;
}

.toc p {
	margin: 0.3em 0;
}

.block {
	border-bottom: 1px solid #ccc;
}

</style>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="doc.css" />
<script src="refdoc.js"></script>
</head>

<body>
<h1>API参考 - 筋斗云前端（桌面Web版）</h1>
<div>最后更新：2021-10-15</div>
<div id="menu">
<h2>Modules</h2>
<div class="toc">
<p><a href="#WUI">WUI (module)</a></p>
<p><a href="#jquery-mycombobox">jquery-mycombobox (module)</a></p>
<p><a href="#JdcloudExt">JdcloudExt (module)</a></p>
<p><a href="#ObjLog">ObjLog (module)</a></p>
<p><a href="#JdcloudStat">JdcloudStat (module)</a></p>
<p><a href="#pageSimple">pageSimple (module)</a></p>
<p><a href="#dlgReportCond">dlgReportCond (module)</a></p>
</div><hr>
<h2>Keywords</h2>
<div class="toc">
<p><a href="##menu">#menu (key)</a></p>
<p><a href="##my-pages">#my-pages (key)</a></p>
<p><a href="#$.Deferred">$.Deferred (fn)</a></p>
<p><a href="#$.ajax">$.ajax (key)</a></p>
<p><a href="#.combo-f">.combo-f (key)</a></p>
<p><a href="#.easyui-validatebox">.easyui-validatebox (key)</a></p>
<p><a href="#.my-combobox">.my-combobox (key)</a></p>
<p><a href="#.my-reset">.my-reset (key)</a></p>
<p><a href="#.noData">.noData (key)</a></p>
<p><a href="#.notForFind">.notForFind (key)</a></p>
<p><a href="#.wui-checkList">.wui-checkList (key)</a></p>
<p><a href="#.wui-combogrid">.wui-combogrid (key)</a></p>
<p><a href="#.wui-dialog">.wui-dialog (key)</a></p>
<p><a href="#.wui-field">.wui-field (key)</a></p>
<p><a href="#.wui-find-field">.wui-find-field (key)</a></p>
<p><a href="#.wui-fixedField">.wui-fixedField (key)</a></p>
<p><a href="#.wui-form-table">.wui-form-table (key)</a></p>
<p><a href="#.wui-labels">.wui-labels (key)</a></p>
<p><a href="#.wui-more">.wui-more (key)</a></p>
<p><a href="#.wui-notCond">.wui-notCond (key)</a></p>
<p><a href="#.wui-page">.wui-page (key)</a></p>
<p><a href="#.wui-picker">.wui-picker (key)</a></p>
<p><a href="#.wui-readonly">.wui-readonly (key)</a></p>
<p><a href="#.wui-subobj">.wui-subobj (key)</a></p>
<p><a href="#.wui-upload">.wui-upload (key)</a></p>
<p><a href="#BASE_URL">BASE_URL (var)</a></p>
<p><a href="#Date.add">Date.add (fn)</a></p>
<p><a href="#Date.addDay">Date.addDay (fn)</a></p>
<p><a href="#Date.addHours">Date.addHours (fn)</a></p>
<p><a href="#Date.addMin">Date.addMin (fn)</a></p>
<p><a href="#Date.addMonth">Date.addMonth (fn)</a></p>
<p><a href="#Date.diff">Date.diff (fn)</a></p>
<p><a href="#Date.format">Date.format (fn)</a></p>
<p><a href="#DirectReturn">DirectReturn (class)</a></p>
<p><a href="#Formatter.atts">Formatter.atts (fn)</a></p>
<p><a href="#Formatter.enum">Formatter.enum (fn)</a></p>
<p><a href="#Formatter.enumFnStyler">Formatter.enumFnStyler (fn)</a></p>
<p><a href="#Formatter.enumStyler">Formatter.enumStyler (fn)</a></p>
<p><a href="#Formatter.flag">Formatter.flag (fn)</a></p>
<p><a href="#Formatter.pics">Formatter.pics (fn)</a></p>
<p><a href="#Formatter.pics1">Formatter.pics1 (fn)</a></p>
<p><a href="#Formatter.progress">Formatter.progress (fn)</a></p>
<p><a href="#GridHeaderMenu">GridHeaderMenu (var)</a></p>
<p><a href="#JdcloudExt">JdcloudExt (module)</a></p>
<p><a href="#JdcloudStat">JdcloudStat (module)</a></p>
<p><a href="#JdcloudStat.tmUnit">JdcloudStat.tmUnit (key)</a></p>
<p><a href="#ListOptions">ListOptions (var)</a></p>
<p><a href="#ObjLog">ObjLog (module)</a></p>
<p><a href="#Plugins">Plugins (class)</a></p>
<p><a href="#Plugins.exists">Plugins.exists (fn)</a></p>
<p><a href="#Plugins.list">Plugins.list (fn)</a></p>
<p><a href="#Promise">Promise (alias)</a></p>
<p><a href="#Q">Q (fn)</a></p>
<p><a href="#STORAGE_PREFIX">STORAGE_PREFIX (var)</a></p>
<p><a href="#WUI">WUI (module)</a></p>
<p><a href="#WUI.applyPermission">WUI.applyPermission (fn)</a></p>
<p><a href="#WUI.fname">WUI.fname (fn)</a></p>
<p><a href="#WUI.getTmRange">WUI.getTmRange (fn)</a></p>
<p><a href="#WUI.initChart">WUI.initChart (fn)</a></p>
<p><a href="#WUI.initPageStat">WUI.initPageStat (fn)</a></p>
<p><a href="#WUI.makeLink">WUI.makeLink (fn)</a></p>
<p><a href="#WUI.options">WUI.options (var)</a></p>
<p><a href="#WUI.options.moduleExt">WUI.options.moduleExt (var)</a></p>
<p><a href="#WUI.options.statFormatter">WUI.options.statFormatter (var)</a></p>
<p><a href="#WUI.pivot">WUI.pivot (fn)</a></p>
<p><a href="#WUI.rs2Stat">WUI.rs2Stat (fn)</a></p>
<p><a href="#WUI.showByType">WUI.showByType (fn)</a></p>
<p><a href="#WUI.toggleTab">WUI.toggleTab (fn)</a></p>
<p><a href="#[noReset]">[noReset] (key)</a></p>
<p><a href="#a[href=">a[href= (key)</a></p>
<p><a href="#a[href=#page]">a[href=#page] (key)</a></p>
<p><a href="#ajaxOpt.jdFilter">ajaxOpt.jdFilter (key)</a></p>
<p><a href="#app_abort">app_abort (fn)</a></p>
<p><a href="#app_alert">app_alert (fn)</a></p>
<p><a href="#app_confirm">app_confirm (fn)</a></p>
<p><a href="#app_progress">app_progress (fn)</a></p>
<p><a href="#app_show">app_show (fn)</a></p>
<p><a href="#appendParam">appendParam (fn)</a></p>
<p><a href="#applyTpl">applyTpl (fn)</a></p>
<p><a href="#assert">assert (fn)</a></p>
<p><a href="#batchCall">batchCall (class)</a></p>
<p><a href="#batchOp">batchOp (fn)</a></p>
<p><a href="#callSvr">callSvr (fn)</a></p>
<p><a href="#callSvr.noex">callSvr.noex (key)</a></p>
<p><a href="#callSvrExt">callSvrExt (key)</a></p>
<p><a href="#callSvrExt['default']">callSvrExt['default'] (key)</a></p>
<p><a href="#callSvrExt[].beforeSend">callSvrExt[].beforeSend (key)</a></p>
<p><a href="#callSvrExt[].dataFilter">callSvrExt[].dataFilter (key)</a></p>
<p><a href="#callSvrExt[].makeUrl">callSvrExt[].makeUrl (key)</a></p>
<p><a href="#callSvrSync">callSvrSync (fn)</a></p>
<p><a href="#canDo">canDo (fn)</a></p>
<p><a href="#closeDlg">closeDlg (fn)</a></p>
<p><a href="#compressImg">compressImg (fn)</a></p>
<p><a href="#data-options">data-options (key)</a></p>
<p><a href="#datagrid.formatter">datagrid.formatter (key)</a></p>
<p><a href="#datagrid.quickAutoSize">datagrid.quickAutoSize (key)</a></p>
<p><a href="#datagrid.sortable">datagrid.sortable (key)</a></p>
<p><a href="#datagrid.sorter">datagrid.sorter (key)</a></p>
<p><a href="#datagrid.styler">datagrid.styler (key)</a></p>
<p><a href="#defDataProc">defDataProc (fn)</a></p>
<p><a href="#defaultFormItems">defaultFormItems (key)</a></p>
<p><a href="#delCookie">delCookie (fn)</a></p>
<p><a href="#delStorage">delStorage (fn)</a></p>
<p><a href="#delayDo">delayDo (fn)</a></p>
<p><a href="#deleteParam">deleteParam (fn)</a></p>
<p><a href="#dg_dblclick">dg_dblclick (fn)</a></p>
<p><a href="#dg_toolbar">dg_toolbar (fn)</a></p>
<p><a href="#diffObj">diffObj (fn)</a></p>
<p><a href="#disableBatch">disableBatch (var)</a></p>
<p><a href="#dlgReportCond">dlgReportCond (module)</a></p>
<p><a href="#doFind">doFind (fn)</a></p>
<p><a href="#doSpecial">doSpecial (fn)</a></p>
<p><a href="#easyui-tabs">easyui-tabs (key)</a></p>
<p><a href="#enhanceWithin">enhanceWithin (fn)</a></p>
<p><a href="#enterWaiting">enterWaiting (fn)</a></p>
<p><a href="#evalAttr">evalAttr (fn)</a></p>
<p><a href="#event-beforeshow">event-beforeshow (key)</a></p>
<p><a href="#event-initdata">event-initdata (key)</a></p>
<p><a href="#event-loaddata">event-loaddata (key)</a></p>
<p><a href="#event-pagecreate,pageshow,pagedestroy">event-pagecreate,pageshow,pagedestroy (key)</a></p>
<p><a href="#event-retdata">event-retdata (key)</a></p>
<p><a href="#event-savedata">event-savedata (key)</a></p>
<p><a href="#event-show">event-show (key)</a></p>
<p><a href="#event-validate">event-validate (key)</a></p>
<p><a href="#example-dialog">example-dialog (key)</a></p>
<p><a href="#example-upload">example-upload (key)</a></p>
<p><a href="#extendNoOverride">extendNoOverride (fn)</a></p>
<p><a href="#formItems">formItems (fn)</a></p>
<p><a href="#formatter">formatter (var)</a></p>
<p><a href="#g_args">g_args (var)</a></p>
<p><a href="#g_data">g_data (var)</a></p>
<p><a href="#g_data.userInfo">g_data.userInfo (key)</a></p>
<p><a href="#getActivePage">getActivePage (fn)</a></p>
<p><a href="#getAncestor">getAncestor (fn)</a></p>
<p><a href="#getBaseUrl">getBaseUrl (fn)</a></p>
<p><a href="#getCookie">getCookie (fn)</a></p>
<p><a href="#getDataOptions">getDataOptions (fn)</a></p>
<p><a href="#getDgInfo">getDgInfo (fn)</a></p>
<p><a href="#getExportHandler">getExportHandler (fn)</a></p>
<p><a href="#getFormData">getFormData (fn)</a></p>
<p><a href="#getFormData_vf">getFormData_vf (fn)</a></p>
<p><a href="#getOptions">getOptions (fn)</a></p>
<p><a href="#getParamFromTable">getParamFromTable (alias)</a></p>
<p><a href="#getQueryCond">getQueryCond (fn)</a></p>
<p><a href="#getQueryParam">getQueryParam (fn)</a></p>
<p><a href="#getQueryParamFromTable">getQueryParamFromTable (fn)</a></p>
<p><a href="#getRow">getRow (fn)</a></p>
<p><a href="#getStorage">getStorage (fn)</a></p>
<p><a href="#getTimeDiffDscr">getTimeDiffDscr (fn)</a></p>
<p><a href="#getTopDialog">getTopDialog (fn)</a></p>
<p><a href="#handleLogin">handleLogin (fn)</a></p>
<p><a href="#hideLoading">hideLoading (fn)</a></p>
<p><a href="#initClient">initClient (fn)</a></p>
<p><a href="#intSort">intSort (fn)</a></p>
<p><a href="#isAndroid">isAndroid (fn)</a></p>
<p><a href="#isBusy">isBusy (var)</a></p>
<p><a href="#isIOS">isIOS (fn)</a></p>
<p><a href="#isSmallScreen">isSmallScreen (fn)</a></p>
<p><a href="#isTreegrid">isTreegrid (fn)</a></p>
<p><a href="#isWeixin">isWeixin (fn)</a></p>
<p><a href="#jQuery.fn.jdata">jQuery.fn.jdata (fn)</a></p>
<p><a href="#jQuery.fn.mycombobox">jQuery.fn.mycombobox (fn)</a></p>
<p><a href="#jdEnumMap">jdEnumMap (key)</a></p>
<p><a href="#jdModule">jdModule (fn)</a></p>
<p><a href="#jquery-mycombobox">jquery-mycombobox (module)</a></p>
<p><a href="#kvList2Str">kvList2Str (fn)</a></p>
<p><a href="#lastError">lastError (var)</a></p>
<p><a href="#leaveWaiting">leaveWaiting (fn)</a></p>
<p><a href="#list2varr">list2varr (fn)</a></p>
<p><a href="#loadCss">loadCss (fn)</a></p>
<p><a href="#loadJson">loadJson (fn)</a></p>
<p><a href="#loadScript">loadScript (fn)</a></p>
<p><a href="#logout">logout (fn)</a></p>
<p><a href="#m_curBatch">m_curBatch (var)</a></p>
<p><a href="#m_enhanceFn">m_enhanceFn (var)</a></p>
<p><a href="#makeLinkTo">makeLinkTo (fn)</a></p>
<p><a href="#makeUrl">makeUrl (fn)</a></p>
<p><a href="#mockData">mockData (var)</a></p>
<p><a href="#my-initfn">my-initfn (key)</a></p>
<p><a href="#my-obj">my-obj (key)</a></p>
<p><a href="#numberSort">numberSort (fn)</a></p>
<p><a href="#objParam">objParam (key)</a></p>
<p><a href="#objarr2list">objarr2list (fn)</a></p>
<p><a href="#options.pageFolder">options.pageFolder (key)</a></p>
<p><a href="#pageSimple">pageSimple (module)</a></p>
<p><a href="#parseDate">parseDate (fn)</a></p>
<p><a href="#parseKvList">parseKvList (fn)</a></p>
<p><a href="#parseQuery">parseQuery (fn)</a></p>
<p><a href="#parseTime">parseTime (fn)</a></p>
<p><a href="#parseValue">parseValue (fn)</a></p>
<p><a href="#permission">permission (key)</a></p>
<p><a href="#queryHint">queryHint (var)</a></p>
<p><a href="#randInt">randInt (fn)</a></p>
<p><a href="#randInt">randInt (fn)</a></p>
<p><a href="#reload">reload (fn)</a></p>
<p><a href="#reloadDialog">reloadDialog (alias)</a></p>
<p><a href="#reloadPage">reloadPage (fn)</a></p>
<p><a href="#reloadRow">reloadRow (fn)</a></p>
<p><a href="#reloadSite">reloadSite (fn)</a></p>
<p><a href="#reloadTmp">reloadTmp (fn)</a></p>
<p><a href="#rgb">rgb (fn)</a></p>
<p><a href="#rgb2hex">rgb2hex (fn)</a></p>
<p><a href="#rs2Array">rs2Array (fn)</a></p>
<p><a href="#rs2Hash">rs2Hash (fn)</a></p>
<p><a href="#rs2MultiHash">rs2MultiHash (fn)</a></p>
<p><a href="#setApp">setApp (fn)</a></p>
<p><a href="#setCookie">setCookie (fn)</a></p>
<p><a href="#setDateBox">setDateBox (fn)</a></p>
<p><a href="#setFormData">setFormData (fn)</a></p>
<p><a href="#setOnError">setOnError (fn)</a></p>
<p><a href="#setStorage">setStorage (fn)</a></p>
<p><a href="#setTimeBox">setTimeBox (fn)</a></p>
<p><a href="#setupCallSvrViaForm">setupCallSvrViaForm (fn)</a></p>
<p><a href="#showDataReport">showDataReport (fn)</a></p>
<p><a href="#showDlg">showDlg (fn)</a></p>
<p><a href="#showDlgByMeta">showDlgByMeta (fn)</a></p>
<p><a href="#showDlgChart">showDlgChart (fn)</a></p>
<p><a href="#showDlgQuery">showDlgQuery (fn)</a></p>
<p><a href="#showLoading">showLoading (fn)</a></p>
<p><a href="#showObjDlg">showObjDlg (fn)</a></p>
<p><a href="#showPage">showPage (fn)</a></p>
<p><a href="#tabClose">tabClose (fn)</a></p>
<p><a href="#tabMain">tabMain (var)</a></p>
<p><a href="#text2html">text2html (fn)</a></p>
<p><a href="#tobool">tobool (fn)</a></p>
<p><a href="#toggleCol">toggleCol (fn)</a></p>
<p><a href="#toggleFields">toggleFields (fn)</a></p>
<p><a href="#treegrid">treegrid (key)</a></p>
<p><a href="#triggerAsync">triggerAsync (fn)</a></p>
<p><a href="#tryAutoLogin">tryAutoLogin (fn)</a></p>
<p><a href="#unloadDialog">unloadDialog (fn)</a></p>
<p><a href="#unloadPage">unloadPage (fn)</a></p>
<p><a href="#useBatchCall">useBatchCall (fn)</a></p>
<p><a href="#waitFor">waitFor (fn)</a></p>
<p><a href="#wui-deferred">wui-deferred (key)</a></p>
<p><a href="#wui-find-hint">wui-find-hint (key)</a></p>
<p><a href="#wui-pageFile">wui-pageFile (key)</a></p>
<p><a href="#wui-pageName">wui-pageName (key)</a></p>
<p><a href="#wui-perm">wui-perm (key)</a></p>
<p><a href="#wui-script">wui-script (key)</a></p>
</div><hr>
</div>
<div class="block">
<h2 id="WUI">@module WUI</h2><div class="toc"><p style="margin-left:0em"><a href="#WUI-1 对象管理功能">1 对象管理功能</a></p>
<p style="margin-left:2em"><a href="#WUI-1.1 定义列表页和详情页">1.1 定义列表页和详情页</a></p>
<p style="margin-left:2em"><a href="#WUI-1.2 添加入口按钮">1.2 添加入口按钮</a></p>
<p style="margin-left:2em"><a href="#WUI-1.3 定义页面初始化函数">1.3 定义页面初始化函数</a></p>
<p style="margin-left:2em"><a href="#WUI-1.4 定义对话框的初始化函数">1.4 定义对话框的初始化函数</a></p>
<p style="margin-left:2em"><a href="#WUI-1.5 列表页中的常见需求">1.5 列表页中的常见需求</a></p>
<p style="margin-left:4em"><a href="#WUI-1.5.1 列表页中的列，以特定格式展现">1.5.1 列表页中的列，以特定格式展现</a></p>
<p style="margin-left:4em"><a href="#WUI-1.5.2 排序与分页">1.5.2 排序与分页</a></p>
<p style="margin-left:4em"><a href="#WUI-1.5.3 列表导出Excel文件">1.5.3 列表导出Excel文件</a></p>
<p style="margin-left:4em"><a href="#WUI-1.5.4 datagrid增强项">1.5.4 datagrid增强项</a></p>
<p style="margin-left:4em"><a href="#WUI-1.5.5 treegrid集成">1.5.5 treegrid集成</a></p>
<p style="margin-left:2em"><a href="#WUI-1.6 详情页对话框的常见需求">1.6 详情页对话框的常见需求</a></p>
<p style="margin-left:4em"><a href="#WUI-1.6.1 通用查询">1.6.1 通用查询</a></p>
<p style="margin-left:4em"><a href="#WUI-1.6.2 设计模式：关联选择框">1.6.2 设计模式：关联选择框</a></p>
<p style="margin-left:4em"><a href="#WUI-1.6.3 picId字段显示图片">1.6.3 picId字段显示图片</a></p>
<p style="margin-left:4em"><a href="#WUI-1.6.4 List字段显示为多个选项框">1.6.4 List字段显示为多个选项框</a></p>
<p style="margin-left:2em"><a href="#WUI-1.7 设计模式：展示层次对象">1.7 设计模式：展示层次对象</a></p>
<p style="margin-left:2em"><a href="#WUI-1.8 设计模式：页面间调用">1.8 设计模式：页面间调用</a></p>
<p style="margin-left:0em"><a href="#WUI-2 对话框功能">2 对话框功能</a></p>
<p style="margin-left:2em"><a href="#WUI-2.1 定义对话框">2.1 定义对话框</a></p>
<p style="margin-left:2em"><a href="#WUI-2.2 显示对话框">2.2 显示对话框</a></p>
<p style="margin-left:2em"><a href="#WUI-2.3 页面传参数给对话框">2.3 页面传参数给对话框</a></p>
<p style="margin-left:2em"><a href="#WUI-2.4 示例：页面与对话框复用 (v5.1)">2.4 示例：页面与对话框复用 (v5.1)</a></p>
<p style="margin-left:2em"><a href="#WUI-2.5 只读对话框">2.5 只读对话框</a></p>
<p style="margin-left:2em"><a href="#WUI-2.6 只读字段：使用disabled和readonly属性">2.6 只读字段：使用disabled和readonly属性</a></p>
<p style="margin-left:0em"><a href="#WUI-3 模块化开发">3 模块化开发</a></p>
<p style="margin-left:2em"><a href="#WUI-3.1 批量更新、批量删除">3.1 批量更新、批量删除</a></p>
<p style="margin-left:2em"><a href="#WUI-3.1 页面模板支持">3.1 页面模板支持</a></p>
<p style="margin-left:2em"><a href="#WUI-3.2 按需加载依赖库">3.2 按需加载依赖库</a></p>
<p style="margin-left:0em"><a href="#WUI-4 参考文档说明">4 参考文档说明</a></p>
</div>
<p>筋斗云前端框架-Web应用桌面版</p>
<p>此框架实现与筋斗云服务端接口的无缝整合。在界面上以jquery-easyui库为基础展示列表、Tab页等。<br />
参考应用 web/store.html - 商户管理端应用。</p>
<h4 id="WUI-1 对象管理功能">1 对象管理功能</h4>
<p>设计模式：列表页与详情页。</p>
<p>以订单对象Order为例：为订单对象增加“列表页”和“详情页”。</p>
<p>列表页应包含分页功能，默认只显示“未完成”订单。<br />
点击列表中一项（一个订单），可显示详情页，即订单详情，并可进行查找、更新等功能。</p>
<h5 id="WUI-1.1 定义列表页和详情页">1.1 定义列表页和详情页</h5>
<p class="key"><strong>@key <a id="#my-pages">#my-pages</a></strong>   包含所有页面、对话框定义的容器。</p>
<p class="key"><strong>@key <a id="my-obj">my-obj</a></strong>  DOM属性，标识服务端对象</p>
<p class="key"><strong>@key <a id="my-initfn">my-initfn</a></strong>  DOM属性，标识页面或对话框的初始化函数，首次显示页面/对话框时调用。</p>
<p>列表页使用逻辑页面定义如下（放在div#my-pages之下），它最终展示为一个tab页：</p>
<pre><code>&lt;div id="my-pages" style="display:none"&gt;
    ...
    &lt;script type="text/html" id="tpl_pageOrder"&gt;
        &lt;div class="pageOrder" title="订单管理" my-initfn="initPageOrder"&gt;
            &lt;table id="tblOrder" style="width:auto;height:auto"&gt;
                &lt;thead&gt;&lt;tr&gt;
                    &lt;th data-options="field:'id', sortable:true, sorter:intSort"&gt;订单号&lt;/th&gt;
                    &lt;th data-options="field:'userPhone', sortable:true"&gt;用户联系方式&lt;/th&gt;
                    &lt;th data-options="field:'createTm', sortable:true"&gt;创建时间&lt;/th&gt;
                    &lt;th data-options="field:'status', jdEnumMap: OrderStatusMap, formatter:Formatter.enum(OrderStatusMap), styler:Formatter.enumStyler({PA:'Warning'}), sortable:true"&gt;状态&lt;/th&gt;
                    &lt;th data-options="field:'dscr', sortable:true"&gt;描述&lt;/th&gt;
                    &lt;th data-options="field:'cmt'"&gt;用户备注&lt;/th&gt;
                &lt;/tr&gt;&lt;/thead&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/script&gt;
&lt;/div&gt;</code></pre>
<p>注意：</p>
<ul>
<li>逻辑页的定义建议放在script标签中，便于按需加载，性能更佳（后面模块化时还会讲到放到单独文件中）。模板id为&quot;tpl_pageOrder&quot;，应与页面名相对应，否则无法加载。</li>
<li>逻辑页面div.pageOrder，属性class=&quot;pageOrder&quot;定义了该逻辑页面的名字。它将作为页面模板，在WUI.showPage(&quot;pageOrder&quot;)时复制一份显示出来。</li>
<li>属性my-initfn定义了该页面的初始化函数. 在初次调用WUI.showPage时，会执行该初始化函数，用于初始化列表，设定事件处理等。</li>
<li>逻辑页面下包含了一个table，用于显示订单列表。里面每列对应订单的相关属性。</li>
<li>table由jquery-easyui的datagrid组件实现，文档参考：<a href="http://www.jeasyui.com/documentation/datagrid.php">http://www.jeasyui.com/documentation/datagrid.php</a> 此外，data-options中的以jd开头的字段为jdcloud框架定义。</li>
</ul>
<p>详情页展示为一个对话框，也将它也放在 div#my-pages 下。定义如下（此处为展示原理已简化）：</p>
<pre><code>&lt;script type="text/html" id="tpl_dlgOrder"&gt;
    &lt;div id="dlgOrder" my-obj="Ordr" my-initfn="initDlgOrder" title="用户订单" style="width:520px;height:500px;"&gt;  
        &lt;form method="POST"&gt;
            订单号：&lt;input name="id" disabled&gt;&lt;/td&gt;
            订单状态：
                    &lt;select name="status"&gt;
                        &lt;option value=""&gt;&amp;nbsp;&lt;/option&gt;
                        &lt;option value="CR"&gt;未付款&lt;/option&gt;
                        &lt;option value="PA"&gt;待服务(已付款)&lt;/option&gt;
                        &lt;option value="ST"&gt;正在服务&lt;/option&gt;
                        &lt;option value="RE"&gt;已服务(待评价)&lt;/option&gt;
                        &lt;option value="RA"&gt;已评价&lt;/option&gt;
                        &lt;option value="CA"&gt;已取消&lt;/option&gt;
                    &lt;/select&gt;
        用户备注：&lt;textarea name="cmt" rows=3 cols=30&gt;&lt;/textarea&gt;
        &lt;/form&gt;
    &lt;div&gt;
&lt;/script&gt;</code></pre>
<p>注意：</p>
<ul>
<li>对话框的定义建议放在script标签中，便于按需加载，性能更佳（后面模块化时还会讲到放到单独文件中）。模板id为&quot;tpl_dlgOrder&quot;应与对话框名相应，否则无法加载。</li>
<li>对话框div#dlgOrder. 与列表页使用class标识名称不同，详情页对话框以id标识（因为全局共用一个对话框，而列表页可以复制为多个同时显示）。</li>
<li>对话框上定义了 &quot;my-obj&quot;属性，用于标识它对应的服务端对象名。对象增删改查操作都会用到它。</li>
<li>对话框的属性 my-initfn 定义了初始化函数，在首次显示时调用。</li>
<li>调用 WUI.showObjDlg($(&quot;#dlgOrder&quot;), formMode) 可显示该对话框，一般由列表页自动调用。</li>
<li>对话框中包含一个form用于向服务端发起请求。form中每个带name属性的对象，都对应订单对象的一个属性，在添加、查找、显示或更新时都将用到，除非它上面加了disabled属性（这样就不会提交该字段）</li>
<li>对话框一般不用加“提交”按钮，框架会自动为它添加“确定”、“取消”按钮。</li>
</ul>
<p class="see"><strong>@see <a href="#showObjDlg">showObjDlg</a></strong> </p>
<p class="see"><strong>@see <a href="#showDlg">showDlg</a></strong> </p>
<p>以上定义了订单对象的列表页和详情页，围绕对象&quot;Order&quot;, 按规范，我们定义了以下名字：</p>
<ul>
<li>列表页面（Tab页） div.pageOrder，列表 table#tblOrder，页面初始化函数 initPageOrder</li>
<li>详情页（对话框）div#dlgOrder，其中包含一个form。对话框初始化函数</li>
</ul>
<h5 id="WUI-1.2 添加入口按钮">1.2 添加入口按钮</h5>
<pre><code>&lt;a href="#pageOrder" class="easyui-linkbutton" icon="icon-ok"&gt;订单管理&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;</code></pre>
<h5 id="WUI-1.3 定义页面初始化函数">1.3 定义页面初始化函数</h5>
<p>打开页面后，页面的生存周期如下：</p>
<p class="key"><strong>@key <a id="event-pagecreate,pageshow,pagedestroy">event-pagecreate,pageshow,pagedestroy</a></strong>  页面事件</p>
<p class="key"><strong>@key <a id="wui-pageName">wui-pageName</a></strong>  属性：页面名</p>
<p class="key"><strong>@key <a id=".wui-page">.wui-page</a></strong>  页面类</p>
<ul>
<li>页面加载成功后，会为页面添加类&quot;wui-page&quot;, 并将属性wui-pageName设置为页面名，然后调用 my-initfn指定的初始化函数，如initPageOrder</li>
<li>触发pagecreate事件</li>
<li>触发pageshow事件, 以后每次页面切换到当前页面，也会触发pageshow事件。</li>
<li>在关闭页面时，触发pagedestroy事件</li>
<li>注意：没有pagebeforeshow, pagehide事件</li>
</ul>
<p>订单列表页的初始化，需要将列表页(代码中jpage)、列表(代码中jtbl)与详情页(代码中jdlg)关联起来，实现对话增删改查各项功能。</p>
<pre><code>function initPageOrder() 
{
    var jpage = $(this);
    var jtbl = jpage.find("#tblOrder");
    var jdlg = $("#dlgOrder");

    // 注意：此处定义显示哪些缺省操作按钮：
    // r-refresh/刷新, f-find/查找, s-set/更新。参考 WUI.dg_toolbar.
    // 如果不定义则所有操作按钮都展示。
    jtbl.jdata().toolbar = "rfs";

    // 当天订单
    var query1 = {cond: "createTm between '" + new Date().format("D") + "' and '" + new Date().addDay(1).format("D") + "'"};
    // var query1 = WUI.getQueryParam({createTm: new Date().format("D") + "~" + new Date().addDay(1).format("D")});
    // 显示待服务/正在服务订单
    var query2 = {cond: "status='CR' OR status='PA' OR status='ST'"};
    // var query2 = WUI.getQueryParam({status: "CR,PA,ST"});

    function getTodoOrders()
    {
        WUI.reload(jtbl, null, query2);
    }
    function getTodayOrders()
    {
        WUI.reload(jtbl, null, query1);
    }
    var btn1 = {text: "今天订单", iconCls:'icon-search', handler: getTodayOrders};
    var btn2 = {text: "所有未完成", iconCls:'icon-search', handler: getTodoOrders};

    var dgOpt = {
        // 设置查询接口
        url: WUI.makeUrl(["Ordr", "query"], {res:"*,createTm,userPhone"}),
        // 设置缺省查询条件
        queryParams: query1,
        // 设置工具栏上的按钮，默认有增删改查按钮，"export"表示"导出到Excel"的按钮，btn1, btn2是自定义按钮，"-"表示按钮分隔符。
        toolbar: WUI.dg_toolbar(jtbl, jdlg, "export", "-", btn1, btn2),
        // 双击一行，应展示详情页对话框
        onDblClickRow: WUI.dg_dblclick(jtbl, jdlg)
    };
    jtbl.datagrid(dgOpt);
}</code></pre>
<p class="see"><strong>@see <a href="#showPage">showPage</a></strong> </p>
<p class="see"><strong>@see <a href="#dg_toolbar">dg_toolbar</a></strong> </p>
<p class="see"><strong>@see <a href="#dg_dblclick">dg_dblclick</a></strong> </p>
<p class="see"><strong>@see <a href="#makeUrl">makeUrl</a></strong> </p>
<h5 id="WUI-1.4 定义对话框的初始化函数">1.4 定义对话框的初始化函数</h5>
<p class="key"><strong>@key <a id="example-dialog">example-dialog</a></strong> </p>
<p>默认对话框中由于设定了底层对象(my-obj)及属性关联（form中带name属性的组件，已关联对象属性），因而可自动显示和提交数据。</p>
<p>特别地，某些属性不宜直接展示，例如属性“人物头像”，服务器存储的是图片id(picId)，而展示时应显示为图片而不是一个数字；<br />
或者如“权限列表”属性，服务器存储的是逗号分隔的一组权限比如&quot;emp,mgr&quot;，而展示时需要为每项显示一个勾选框。<br />
这类需求就需要编码控制。</p>
<p>相关事件：</p>
<p class="see"><strong>@see <a href="#beforeshow">beforeshow</a> <a href="#show">show</a></strong>  对话框中form显示前后</p>
<p>对话框类名：</p>
<p class="see"><strong>@see <a href="#.wui-dialog">.wui-dialog</a></strong> </p>
<pre><code>function initDlgOrder()
{
    var jdlg = $(this);
    jdlg.on("beforeshow", onBeforeShow)
        .on("show", onShow)
        .on("validate", onValidate)
        .on("retdata", onRetData);

    function onBeforeShow(ev, formMode, opt) {
        // beforeshow用于设置字段是否隐藏、是否可编辑；或是设置opt(即WUI.showDlg的opt)。

        var objParam = opt.objParam;
        var forAdd = formMode == FormMode.forAdd;
        var forSet = formMode == FormMode.forSet;

        jdlg.find(".notForFind").toggle(formMode != FormMode.forFind);

        // WUI.toggleFields也常用于控制jfrm上字段显示或jtbl上列显示
        var type = opt.objParam &amp;&amp; opt.objParam.type;
        var isMgr = g_data.hasRole("mgr"); // 最高管理员
        var isAdm = g_data.hasRole("mgr,emp"); // 管理员
        WUI.toggleFields(jfrm, {
            type: !type,
            status: !type || type!="公告",
            atts: isAdm
        });

        // 根据权限控制字段是否可编辑。注意：find模式下一般不禁用。
        if (formMode != FormMode.forFind) {
            $(frm.empId).prop("disabled", !isMgr);
            $(frm.status).prop("disabled", forAdd || !isAdm);
            $(frm.code).prop("disabled", !isAdm);
        }
    }
    function onShow(ev, formMode, initData) {
        // 常用于add模式下设置初值，或是set模式下将原值转换并显示。
        // initData是列表页中一行对应的数据，框架自动根据此数据将对应属性填上值。
        // 如果界面上展示的字段无法与属性直接对应，可以在该事件回调中设置。
        // hiddenToCheckbox(jdlg.find("#divPerms"));
        if (forAdd) {
            $(frm.status).val("CR");
        }
        else if (forSet) {
            // 显示成表格
            jdlg.find("#tbl1").datagrid(...);
        }
    }
    function onValidate(ev, formMode, initData, newData) {
        // 在form提交时，所有带name属性且不带disabled属性的对象值会被发往服务端。
        // 此事件回调可以设置一些界面上无法与属性直接对应的内容。
        // 额外要提交的数据可放在隐藏的input组件中，或(v5.1)这里直接设置到newData对象中。
        // checkboxToHidden(jdlg.find("#divPerms"));
    }
    function onRetData(ev, data, formMode) {
        var formMode = jdlg.jdata().mode;
        if (formMode == FormMode.forAdd) {
            alert('返回ID: ' + data);
        }
    }
}</code></pre>
<p>在onBeforeShow中一般设置字段是否显示(show/hide/toggle)或只读(disabled)，以及在forAdd/forFind模式时为opt.data设置初始值(forSet模式下opt.data已填上业务数据)；<br />
之后框架用opt.data数据填充相应字段，如需要补填或修改些字段（比如显示图片），可在onShow中处理，也可以直接在onBeforeShow中用setTimeout来指定，如：</p>
<pre><code>function onBeforeShow(ev, formMode, opt) {
    // ... 根据formMode等参数控制某些字段显示隐藏、启用禁用等...
    var frm = jdlg.find("form")[0];
    var isFind = formMode == FormMode.forFind;
    frm.type.disabled = !isFind;
    // 这里可以对opt.data赋值，但不要直接为组件设置值，因为接下来组件值会被opt.data中的值覆盖。

    setTimeout(onShow);
    function onShow() {
        // 这里可根据opt.data直接为input等组件设置值。便于使用onBeforeShow中的变量
    }
}</code></pre>
<p class="see"><strong>@see <a href="#checkboxToHidden">checkboxToHidden</a></strong>  (有示例)</p>
<p class="see"><strong>@see <a href="#hiddenToCheckbox">hiddenToCheckbox</a></strong>  </p>
<p class="see"><strong>@see <a href="#imgToHidden">imgToHidden</a></strong> </p>
<p class="see"><strong>@see <a href="#hiddenToImg">hiddenToImg</a></strong>  (有示例)</p>
<h5 id="WUI-1.5 列表页中的常见需求">1.5 列表页中的常见需求</h5>
<p>框架中，对象列表通过easyui-datagrid来展现。<br />
注意：由于历史原因，我们没有使用datagrid中的编辑功能。</p>
<p>参考：<a href="http://www.jeasyui.net/plugins/183.html">http://www.jeasyui.net/plugins/183.html</a><br />
教程：<a href="http://www.jeasyui.net/tutorial/148.html">http://www.jeasyui.net/tutorial/148.html</a></p>
<h6 id="WUI-1.5.1 列表页中的列，以特定格式展现">1.5.1 列表页中的列，以特定格式展现</h6>
<p class="key"><strong>@key <a id="datagrid.formatter">datagrid.formatter</a></strong> </p>
<p class="key"><strong>@key <a id="datagrid.styler">datagrid.styler</a></strong> </p>
<p>示例一：显示名称及颜色</p>
<p>订单状态字段定义为：</p>
<pre><code>- status: 订单状态. Enum(CR-新创建,RE-已服务,CA-已取消). </code></pre>
<p>在显示时，要求显示其中文名称，且根据状态不同，显示不同的背景颜色。</p>
<p>在table中设置formatter与styler选项：</p>
<pre><code>&lt;div class="pageOrder" title="订单管理" my-initfn="initPageOrder"&gt;
    &lt;table id="tblOrder" style="width:auto;height:auto" title="订单列表"&gt;
        &lt;thead&gt;&lt;tr&gt;
            &lt;th data-options="field:'id', sortable:true, sorter:intSort"&gt;订单号&lt;/th&gt;
            ...
            &lt;th data-options="field:'status', jdEnumMap: OrderStatusMap, formatter:Formatter.enum(OrderStatusMap), styler:Formatter.enumStyler({PA:'Warning', RE:'Disabled', CR:'#00ff00', null: 'Error'}), sortable:true"&gt;状态&lt;/th&gt;
        &lt;/tr&gt;&lt;/thead&gt;
    &lt;/table&gt;
&lt;/div&gt;</code></pre>
<p>formatter用于控制Cell中的HTML标签，styler用于控制Cell自己的CSS style, 常用于标记颜色.<br />
在JS中定义：</p>
<pre><code>var OrderStatusMap = {
    CR: "未付款", 
    RE: "已服务", 
    CA: "已取消"
};
Formatter = $.extend(WUI.formatter, Formatter);</code></pre>
<p>上面Formatter.enum及Formatter.enumStyler是框架预定义的常用项，也可自定义formatter或styler，例：</p>
<pre><code>var OrderColumns = {
    status: function (value, row) {
        if (! value)
            return;
        return OrderStatusMap[value] || value;
    },
    statusStyler: function (value, row) {
        var colors = {
            CR: "#000",
            RE: "#0f0",
            CA: "#ccc"
        };
        var color = colors[value];
        if (color)
            return "background-color: " + color;
    },
    ...
}</code></pre>
<p>注意：</p>
<ul>
<li>WUI.formatter已经定义了常用的formatter. 通常定义一个全局Formatter继承WUI.formatter，用于各页面共享的字段设定.</li>
<li>习惯上，对同一个对象的字段的设定，都放到一个名为　{Obj}Columns 的变量中一起定义。</li>
</ul>
<p class="see"><strong>@see <a href="#formatter">formatter</a></strong>  通用格式化函数</p>
<p>一些其它示例：</p>
<pre><code>var Formatter = {
    // 显示数值
    number: function (value, row) {
        return parseFloat(value);
    },
    // 订单编号，显示为一个链接，点击就打开订单对话框该订单。
    orderId: function (value, row) {
        if (value) {
            return WUI.makeLinkTo("#dlgOrder", row.orderId, value);
        }
    },
    // 显示状态的同时，设置另一个本地字段，这种字段一般以"_"结尾，表示不是服务器传来的字段，例如
    // &lt;th data-options="field:'hint_'"&gt;提醒事项&lt;/th&gt;
    status: function (value, row) {
        if (value) {
            if (value == "PA") {
                row.hint_ = "请于2小时内联系";
            }
            return StatusMap[value] || value;
        }
    }
};</code></pre>
<p class="see"><strong>@see <a href="#makeLinkTo">makeLinkTo</a></strong>  生成对象链接，以便点击时打开该对象的详情对话框。</p>
<h6 id="WUI-1.5.2 排序与分页">1.5.2 排序与分页</h6>
<p class="key"><strong>@key <a id="datagrid.sortable">datagrid.sortable</a></strong> </p>
<p class="key"><strong>@key <a id="datagrid.sorter">datagrid.sorter</a></strong> </p>
<p>使用sortable:true指定该列可排序（可点击列头排序），用sorter指定排序算法（缺省是字符串排序），例如：</p>
<pre><code>&lt;th data-options="field:'name', sortable:true"&gt;姓名&lt;/th&gt;
&lt;th data-options="field:'id', sortable:true, sorter:intSort"&gt;编号&lt;/th&gt;
&lt;th data-options="field:'score', sortable:true, sorter:numberSort"&gt;评分&lt;/th&gt;</code></pre>
<p>框架提供了intSort,numberSort这些函数用于整数排序或小数排序。也可以自定义函数。示例：</p>
<pre><code>function intSort(a, b)
{
    return parseInt(a) - parseInt(b);
}</code></pre>
<p>注意：</p>
<ul>
<li>指定sorter函数只会影响本地排序。而多数情况下，只要有多页，框架会使用远程排序。<br />
框架逻辑为：如果数据超过一页，使用远程排序, 否则使用本地排序减少请求。</li>
<li>本地排序(localSort)：点击列标题排序时，会重新发请求到服务端，并指定sort/排序字段,order/顺序或倒序参数</li>
<li>远程排序(remoteSort)：点排序时，直接本地计算重排，不会发请求到服务端.</li>
</ul>
<p class="see"><strong>@see <a href="#intSort">intSort</a> <a href="#numberSort">numberSort</a></strong> </p>
<p>如果打开数据表就希望按某一列排序，可设置：</p>
<pre><code>jtbl.datagrid({
    ...
    sortName: 'id',
    sortOrder: 'desc'
});</code></pre>
<p>手工点击列标题栏排序，会自动修改这两个属性。<br />
在添加数据时，如果当前sortOrder是倒序，则新数据显示在表格当前页的最前面，否则显示在最后。</p>
<p>框架对datagrid还做了以下缺省设置：</p>
<ul>
<li>
<p>默认开启datagrid的分页功能。每页缺省显示20条数据。可通过datagrid选项自行重新定义，如：</p>
<pre><code>jtbl.datagrid({
    ...
    pageSize: 20,
    pageList: [20,30,50] // 在分页栏中可以选择分页大小
});</code></pre>
</li>
<li>当数据在一页内可显示完时，自动隐藏分页操作栏。</li>
</ul>
<p>如果需要禁用分页，可以设置：</p>
<pre><code>jtbl.datagrid({
    url: WUI.makeUrl("Ordr.query", {"pagesz": -1}), // -1表示取后端允许的最大数量
    pagination: false, // 禁用分页组件
    ...
});</code></pre>
<h6 id="WUI-1.5.3 列表导出Excel文件">1.5.3 列表导出Excel文件</h6>
<p>(支持版本5.0)</p>
<p>除了默认地增删改查，还可为数据表添加标准的“导出Excel”操作，可自动按表格当前的显示字段、搜索条件、排序条件等，导出表格。<br />
只需在dg_toolbar函数的参数中加上&quot;export&quot;（表示导出按钮），如：</p>
<pre><code>jtbl.datagrid({
    url: WUI.makeUrl("User.query"),
    toolbar: WUI.dg_toolbar(jtbl, jdlg, "export"),
    onDblClickRow: WUI.dg_dblclick(jtbl, jdlg)
});</code></pre>
<p>导出字段由jtbl对应的表格的表头定义，如下面表格定义：</p>
<pre><code>&lt;table id="tblOrder" style="width:auto;height:auto" title="订单列表"&gt;
    ...
    &lt;th data-options="field:'id'"&gt;编号&lt;/th&gt;
    &lt;th data-options="field:'status'"&gt;状态&lt;/th&gt;
    &lt;th data-options="field:'hint_'"&gt;友情提示&lt;/th&gt;
&lt;/table&gt;</code></pre>
<p>它生成的res参数为&quot;id 编号, status 状态&quot;。&quot;hint_&quot;字段以下划线结尾，它会被当作是本地虚拟字段，不会被导出。</p>
<p>table上的title属性可用于控制列表导出时的默认文件名，如本例导出文件名为&quot;订单列表.xls&quot;。<br />
如果想导出表中没有显示的列，可以设置该列为隐藏，如：</p>
<pre><code>    &lt;th data-options="field:'userId', hidden:true"&gt;用户编号&lt;/th&gt;</code></pre>
<p class="key"><strong>@key <a id="jdEnumMap">jdEnumMap</a></strong>  datagrid中th选项, 在导出文件时，枚举变量可显示描述</p>
<p>对于枚举字段，可在th的data-options用<code>formatter:WUI.formatter.enum(map)</code>来显示描述，在导出Excel时，需要设置<code>jdEnumMap:map</code>属性来显示描述，如</p>
<pre><code>    &lt;th data-options="field:'status', jdEnumMap: OrderStatusMap, formatter: WUI.formatter.enum(OrderStatusMap)"&gt;状态&lt;/th&gt;</code></pre>
<p>OrderStatusMap在代码中定义如下</p>
<pre><code>var OrderStatusMap = {
    CR: "未付款", 
    PA: "待服务"
}</code></pre>
<p>它生成的res参数为&quot;id 编号, status 状态=CR:未付款;PA:待服务&quot;。筋斗云后端支持这种res定义方式将枚举值显示为描述。</p>
<p class="see"><strong>@see <a href="#dg_toolbar">dg_toolbar</a></strong>  指定列表上的操作按钮</p>
<p class="see"><strong>@see <a href="#getExportHandler">getExportHandler</a></strong>  自定义导出Excel功能</p>
<p class="see"><strong>@see <a href="#getQueryParamFromTable">getQueryParamFromTable</a></strong>  根据当前datagrid状态取query接口参数</p>
<p>HINT: 点“导出”时会直接下载文件，看不到请求和调用过程，如果需要调试导出功能，可在控制台中设置  window.open=$.get 即可在chrome中查看请求响应过程。</p>
<h6 id="WUI-1.5.4 datagrid增强项">1.5.4 datagrid增强项</h6>
<p>easyui-datagrid已适配筋斗云协议调用，底层将发起callSvr调用请求（参考dgLoader）。<br />
此外，增加支持<code>url_</code>属性，以便初始化时不发起调用，直到调用&quot;load&quot;/&quot;reload&quot;方法时才发起调用：</p>
<pre><code>jtbl.datagrid({
    url_: WUI.makeUrl("Item.query", {res:"id,name"}), // 如果用url则会立即用callSvr发起请求。
    ...
});
// ...
jtbl.datagrid("load", {cond: "itemId=" + itemId});
jtbl.datagrid("reload");</code></pre>
<p>如果接口返回格式不符合，则可以使用loadData方法：</p>
<pre><code>// 接口 Item.get() -&gt; {item1=[{srcItemId, qty}]}
callSvr("Item.get", {res:"item1"}, function (data) {
    jtbl.datagrid("loadData", data.item1); // 是一个对象数组
});</code></pre>
<p>datagrid默认加载数据要求格式为<code>{total, rows}</code>，框架已对返回数据格式进行了默认处理，兼容筋斗云协议格式（参考dgLoadFilter）。</p>
<pre><code>var rows = [ {id:1, name:"name1"}, {id:2, name:"name2"} ];
jtbl.datagrid("loadData", {tota:2, rows: rows});
// 还支持以下三种格式
jtbl.datagrid("loadData", rows);
jtbl.datagrid("loadData", {h: ["id","name"], d: [ [1, "name1"], [2, "name2"]}); // 筋斗云query接口默认返回格式。
jtbl.datagrid("loadData", {list: rows}); // 筋斗云query接口指定fmt=list参数时，返回这种格式</code></pre>
<h6 id="WUI-1.5.5 treegrid集成">1.5.5 treegrid集成</h6>
<p class="key"><strong>@key <a id="treegrid">treegrid</a></strong> </p>
<p>后端数据模型若要支持树类型，须在表中有父节点字段（默认为fatherId）, 即可适配treegrid. 典型的表设计如下：</p>
<pre><code>@Dept: id, code, name, fatherId, level</code></pre>
<ul>
<li>支持一次全部加载和分层次加载两种模式。</li>
<li>支持查询时，只展示部分行。</li>
<li>点添加时，如果当前有选中行，当这一行是展开的父结点（或是叶子结点，也相当于是展开的），则默认行为是为选中行添加子项，预置fatherId, level字段；<br />
如果是未展开的父结点，则是加同级的结点。</li>
<li>更新时如果修改了父结点, 它将移动到新的父结点下。否则直接刷新这行。</li>
<li>支持排序和导出。</li>
</ul>
<p>在初始化页面时, 与datagrid类似: pageItemType.js</p>
<pre><code>var dgOpt = {
    // treegrid查询时不分页. 设置pagesz=-1. (注意后端默认返回1000条, 可设置放宽到10000条. 再多应考虑按层级展开)
    url: WUI.makeUrl("ItemType.query", {pagesz: -1}),
    toolbar: WUI.dg_toolbar(jtbl, jdlg),
    onDblClickRow: WUI.dg_dblclick(jtbl, jdlg)
    // treeField: "code"  // 树表专用，表示在哪个字段上显示折叠，默认为"id"
    // fatherField: "id" // 树表专用，WUI扩展字段，表示父节点字段，默认为"fatherId"
};
// 用treegrid替代常规的datagrid
jtbl.treegrid(dgOpt);</code></pre>
<p>如果数据量非常大, 可以只显示第一层级, 展开时再查询.<br />
仅需增加初始查询条件(只查第一级)以及一个判断是否终端结点的回调函数isLeaf (否则都当作终端结点将无法展开):</p>
<pre><code>var dgOpt = {
    queryParams: {cond: "fatherId is null"},
    isLeaf: function (row) {
        return row.level&gt;1;
    },
    ...
};
jtbl.treegrid(dgOpt);</code></pre>
<p><strong>[通过非id字段关联父节点的情况]</strong></p>
<p>比如通过fatherCode字段关联到父节点的code字段：</p>
<pre><code>@Dept: id, code, fatherCode</code></pre>
<p>则可以指定idField, 这样调用：</p>
<pre><code>var dgOpt = {
    idField: "code",
    fatherField: "fatherCode",
    ...
};
jtbl.treegrid(dgOpt);</code></pre>
<h5 id="WUI-1.6 详情页对话框的常见需求">1.6 详情页对话框的常见需求</h5>
<h6 id="WUI-1.6.1 通用查询">1.6.1 通用查询</h6>
<p>在对话框中按快捷键&quot;Ctrl-F&quot;可进入查询模式。<br />
详情页提供通用查询，如：</p>
<pre><code>手机号: &lt;input name="phone"&gt;  
注册时间: &lt;input name="createTm"&gt;</code></pre>
<p>可在手机号中输入&quot;137*&quot;，在注册时间中输入&quot;&gt;=2017-1-1 and &lt;2018-1-1&quot; (或用 &quot;2017-1-1~2018-1-1&quot;)，这样生成的查询参数为：</p>
<pre><code>{ cond: "phone like '137%' and (createTm&gt;='2017-1-1' and createTm&lt;'2018-1-1')" }</code></pre>
<p class="see"><strong>@see <a href="#getQueryCond">getQueryCond</a></strong>  查询条件支持</p>
<p class="see"><strong>@see <a href="#getQueryParam">getQueryParam</a></strong>  生成查询条件</p>
<p class="key"><strong>@key <a id=".wui-find-field">.wui-find-field</a></strong>  用于查找的字段样式</p>
<p>可设置该样式来标识哪些字段可以查找。一般设置为黄色。</p>
<p class="key"><strong>@key <a id=".notForFind">.notForFind</a></strong>  指定非查询条件</p>
<p>不参与查询的字段，可以用notForFind类标识(为兼容，也支持属性notForFind)，如：</p>
<pre><code>登录密码: &lt;input class="notForFind" type="password" name="pwd"&gt;
或者: &lt;input notForFind type="password" name="pwd"&gt;</code></pre>
<p class="key"><strong>@key <a id=".wui-notCond">.wui-notCond</a></strong>  指定独立查询条件</p>
<p>如果查询时不想将条件放在cond参数中，可以设置wui-notCond类标识，如：</p>
<pre><code>状态: &lt;select name="status" class="my-combobox wui-notCond" data-options="jdEnumList:'0:可用;1:禁用'"&gt;&lt;/select&gt;</code></pre>
<p>如果不加wui-notCond类，生成的查询参数为：<code>{cond: "status=0"}</code>；加上后，生成查询参数如：<code>{status: 0}</code>.</p>
<p>(v5.3)</p>
<ul>
<li>在对话框中三击（2秒内）字段标题栏，可快速按查询该字段。Ctrl+三击为追加过滤条件。</li>
<li>在页面工具栏中，按住Ctrl(batch模式)点击“刷新”按钮，可清空当前查询条件。</li>
</ul>
<p class="key"><strong>@key <a id="wui-find-hint">wui-find-hint</a></strong>  控制查询条件的生成。(v5.5) </p>
<ul>
<li>设置为&quot;s&quot;，表示是字符串，禁用数值区间或日期区间。</li>
<li>设置为&quot;tm&quot;或&quot;dt&quot;，表示是日期时间或日期，可匹配日期匹配。</li>
</ul>
<p>示例：</p>
<pre><code>视频代码 &lt;input name="code" wui-find-hint="s"&gt;</code></pre>
<p>当输入'126231-191024'时不会当作查询126231到191024的区间。</p>
<h6 id="WUI-1.6.2 设计模式：关联选择框">1.6.2 设计模式：关联选择框</h6>
<p>示例：下拉框中显示员工列表 (Choose-from-list / 关联选择框)</p>
<p class="see"><strong>@see <a href="#jQuery.fn.mycombobox">jQuery.fn.mycombobox</a></strong> </p>
<h6 id="WUI-1.6.3 picId字段显示图片">1.6.3 picId字段显示图片</h6>
<p class="see"><strong>@see <a href="#hiddenToImg">hiddenToImg</a></strong>  (有示例)</p>
<p class="see"><strong>@see <a href="#imgToHidden">imgToHidden</a></strong> </p>
<h6 id="WUI-1.6.4 List字段显示为多个选项框">1.6.4 List字段显示为多个选项框</h6>
<p class="see"><strong>@see <a href="#hiddenToCheckbox">hiddenToCheckbox</a></strong>  </p>
<p class="see"><strong>@see <a href="#checkboxToHidden　">checkboxToHidden　</a></strong> (有示例)</p>
<h5 id="WUI-1.7 设计模式：展示层次对象">1.7 设计模式：展示层次对象</h5>
<p>例如设计有商品表Item, 每个商品属于特定的商户：</p>
<pre><code>@Item: id, storeId, name
storeId:: Integer. 商品所属商户编号。</code></pre>
<p>也就是说，商户包含商品。要展现商品，可将它放在商户层次之下。<br />
可以这样设计用户操作：在商户列表上增加一个按钮“查看商品”，点击后打开一个新的列表页，显示该商户的商品列表。</p>
<p>定义两个列表页：</p>
<pre><code>&lt;div class="pageStore" title="商户列表" my-initfn="initPageStore"&gt;
&lt;/div&gt;

&lt;div class="pageItem" title="商户商品" my-initfn="initPageItem"&gt;
&lt;/div&gt;</code></pre>
<p>为这两个列表页定义初始化函数：</p>
<pre><code>// 商户列表页
function initPageStore()
{
    function showItemPage()
    {
        var row = jtbl.datagrid('getSelected');
        if(row == null){
            alert("您需要选择需要操作的行");
            return;
        }
        // !!! 调用showPage显示新页 !!!
        WUI.showPage("pageItem", "商户商品-" + row.name, [row.id]);
        // 要使每个商户都打开一个商品页面而不是共享一个页面，必须保证第二个参数（页面标题）根据商户不同而不一样。
        // 第三个参数是传给该页面初始化函数的参数列表，是一个数组。
    }
    var btn1 = {text: "查看商品", iconCls: "icon-search", handler: showItemPage};

    ...
    jtbl.datagrid({
        ...
        toolbar: WUI.dg_toolbar(jtbl, jdlg, btn1),
    });
}

// 商品列表页，注意有一个参数storeId, 并在查询时使用到它。
function initPageItem(storeId)
{
    jtbl.datagrid({
        // 用参数storeId过滤
        url: WUI.makeUrl("Item.query", {cond: "storeId=" + storeId}),
        ...
    });
}</code></pre>
<p>注意：</p>
<p>调用WUI.showPage时，除了指定页面名，还指定了页面标题(第二参数)和页面初始化参数(第三参数, 一定是一个数组):</p>
<pre><code>WUI.showPage("pageItem", "商户商品-" + row.name, [row.id]);</code></pre>
<p>显然，第二个参数随着商户名称不同而不同，这保证了不同商户打开的商品页面不会共用。<br />
在商品页面初始化时，第三参数将传递给初始化函数：</p>
<pre><code>function initPageItem(storeId) // storeId=row.id</code></pre>
<p class="see"><strong>@see <a href="#showPage">showPage</a></strong> </p>
<p class="key"><strong>@key <a id=".wui-fixedField">.wui-fixedField</a></strong>  固定值字段</p>
<p>当打开对话框时, 标识为.wui-fixedField类的字段会自动从传入的opt.objParam中取值, 如果取到值则将自己设置为只读.</p>
<p>此外，在Item页对应的详情对话框上（dlgItem.html页面中），还应设置storeId字段是只读的，在添加、设置和查询时不可被修改，在添加时还应自动填充值。<br />
(v5.3) 只要在字段上添加wui-fixedField类即可：</p>
<pre><code>&lt;select name="storeId" class="my-combobox wui-fixedField" data-options="ListOptions.Store()"&gt;&lt;/select&gt;</code></pre>
<p>注意：wui-fixedField在v5.3引入，之前方法是应先设置字段为readonly:</p>
<pre><code>&lt;select name="storeId" class="my-combobox" data-options="ListOptions.Store()" readonly&gt;&lt;/select&gt;</code></pre>
<p>（select组件默认不支持readonly属性，框架定义了CSS：为select[readonly]设置<code>pointer-events:none</code>达到类似效果。）</p>
<p>然后，在initDlgItem函数中(dlgItem.js文件)，应设置在添加时自动填好该字段：</p>
<pre><code>function onBeforeShow(ev, formMode, opt)
    if (formMode == FormMode.forAdd &amp;&amp; objParam.storeId) {
        opt.data.storeId = objParam.storeId;
    }</code></pre>
<h5 id="WUI-1.8 设计模式：页面间调用">1.8 设计模式：页面间调用</h5>
<p>仍以上节数据结构为例，上节是在每个商品行上点“查看商品”，就打开一个新的该商户下的商品列表页，<br />
现在我们换一种操作方法，改成只用一个商品列表页（默认打开时显示所有商户的商品，可以手工查找过滤），在商户页中点“查看商品”，就自动打开商品列表页并做条件过滤。</p>
<p>先在主页面逻辑中为商品页定义一个接口：（比如在store.js中）</p>
<pre><code>var PageItem = {
    // param?: {storeId}
    show: function (param) {
        this.filterParam_ = param;
        WUI.showPage("pageItem");
    },
    filterParam_: null
};</code></pre>
<p>在商户页中，点击“查看商品”按钮时做过滤：</p>
<pre><code>function initPageStore()
{
    function showItemPage()
    {
        var row = jtbl.datagrid('getSelected');
        ...
        PageItem.show({storeId: row.id});
    }
    var btn1 = {text: "查看商品", iconCls: "icon-search", handler: showItemPage};

    ...
    jtbl.datagrid({
        ...
        toolbar: WUI.dg_toolbar(jtbl, jdlg, btn1),
    });
}</code></pre>
<p>在商品页中，处理PageItem.filterParam_参数，实现过滤，我们在pageshow回调中处理它，同时把初始化datagrid也移到pageshow中：</p>
<pre><code>function initPageItem()
{
    var isInit = true;
    jpage.on("pageshow", pageShow);

    function pageShow() {
        // 接口变量PageItem.filterParam_用后即焚
        var param = null;
        if (PageItem.filterParam_) {
            param = WUI.getQueryParam(PageItem.filterParam_);
            PageItem.filterParam_ = null;
        }
        // 保证表格初始化只调用一次
        if (isInit) {
            jtbl.datagrid({
                url: WUI.makeUrl("Item.query"),
                queryParams: param,
                toolbar: WUI.dg_toolbar(jtbl, jdlg, "export"),
                onDblClickRow: WUI.dg_dblclick(jtbl, jdlg),
                sortName: "id",
                sortOrder: "desc"
            });
            isInit = false;
        }
        else if (param) {
            WUI.reload(jtbl, null, param);
        }
    }
}</code></pre>
<p>注意：</p>
<ul>
<li>例子中通过页面接口，实现页面间的调用请求。</li>
<li>上面用了WUI.reload，在点击列表上的“刷新”时，只会按当前条件刷新，不会刷新出所有数据来，必须点“查找”，清除所有条件后查找，才可以看到所有数据；<br />
若想点“刷新”时显示所有数据，则可以将WUI.reload换成调用WUI.reloadTmp。</li>
</ul>
<h4 id="WUI-2 对话框功能">2 对话框功能</h4>
<p>以群发短信功能为例。</p>
<p>假定服务端已有以下接口：</p>
<pre><code>sendSms(phone, content)
phone:: 手机号
content:: 发送内容</code></pre>
<h5 id="WUI-2.1 定义对话框">2.1 定义对话框</h5>
<p>注意：每个带name属性的组件对应接口中的参数。</p>
<pre><code>&lt;div id="dlgSendSms" title="群发短信" style="width:500px;height:300px;"&gt;  
    &lt;form method="POST"&gt;
        手机号：&lt;input name="phone" class="easyui-validatebox" data-options="required:true"&gt;
        发送内容： &lt;textarea rows=5 cols=30 name="content" class="easyui-validatebox"  data-options="required:true"&gt;&lt;/textarea&gt;
    &lt;/form&gt;
&lt;/div&gt;</code></pre>
<p>在form中带name属性的字段上，可以设置class=&quot;easyui-validatebox&quot;对输入进行验证。</p>
<h5 id="WUI-2.2 显示对话框">2.2 显示对话框</h5>
<p>可以调用WUI.showDlg，写一个显示对话框的函数：</p>
<pre><code>function showDlgSendSms()
{
    var jdlg = $("#dlgSendSms");
    WUI.showDlg(jdlg, {
        url: WUI.makeUrl("sendSms"),
        onOk: function (data) {
            WUI.closeDlg(jdlg);
            app_show('操作成功!');
        }
    });
}</code></pre>
<p>在showDlg的选项url中指定了接口为&quot;sendSms&quot;。操作成功后，显示一个消息。</p>
<p>(v5.5) 新的编程惯例，建议使用定义对话框接口的方式，写在主应用（如store.js）的接口区域，如：</p>
<pre><code>// 把showDlgSendSms换成DlgSendSms.show
var DlgSendSms = {
    show: function () {
        // 同showDlgSendSms
    }
};</code></pre>
<p class="see"><strong>@see <a href="#showDlg">showDlg</a></strong> </p>
<p class="see"><strong>@see <a href="#app_show">app_show</a></strong> </p>
<p>除了直接调用该函数显示对话框外，还有一种更简单的通过a标签href属性指定打开对话框的做法，如：</p>
<pre><code>&lt;a href="?showDlgSendSms" class="easyui-linkbutton" icon="icon-ok"&gt;群发短信&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;</code></pre>
<p>点击该按钮，即调用了showDlgSendSms函数打开对话框。</p>
<p>可以通过my-initfn属性为对话框指定初始化函数。复杂对话框的逻辑一般都写在初始化函数中。习惯上命令名initDlgXXX，如：</p>
<pre><code>&lt;div id="dlgSendSms" title="群发短信" style="width:500px;height:300px;" my-initfn="initDlgSendSms"&gt;

function initDlgSendSms() {
    var jdlg = $(this);
    // 处理对话框事件
    jdlg.on("beforeshow", onBeforeShow)
        .on("validate", onValidate);
    // 处理内部组件事件
    jdlg.find("#btn1").click(btn1_click);
    ...
}</code></pre>
<h5 id="WUI-2.3 页面传参数给对话框">2.3 页面传参数给对话框</h5>
<p>(v5.1)<br />
可以通过showObjDlg(jdlg, mode, opt)中的opt参数，或jdlg.objParam来给对话框传参。<br />
在对话框的beforeshow事件处理中，可通过opt.objParam拿到参数，如：</p>
<pre><code>function initPageBizPartner() {
    var jdlg = $("#dlgSupplier");
    // 设置objParam参数供对话框使用。
    jdlg.objParam = {type: "C", obj: "Customer", title: "客户"}; // opt.title参数可直接设置对话框的标题。参考showObjDlg.
    jtbl.datagrid(toolbar: dg_toolbar(jtbl, jdlg, ...));
    // 点表格上的菜单或双击行时会调用 WUI.showObjDlg
}

function initDlgBizPartner() {
    // ...
    jdlg.on("beforeshow", onBeforeShow);

    function onBeforeShow(ev, formMode, opt) {
        // opt.objParam 中包含前面定义的type, obj, 以及id, mode等参数。
    }
}</code></pre>
<h5 id="WUI-2.4 示例：页面与对话框复用 (v5.1)">2.4 示例：页面与对话框复用 (v5.1)</h5>
<p>设计有客户(Customer)和供应商(Supplier)两个虚拟的逻辑对象，它们物理底层都是业务伙伴对象(BizPartner)。<br />
现在只设计一个页面pageBizPartner和一个对话框dlgBizPartner。</p>
<p>菜单中两项：<br />
默认pageBizPartner是供应商，如果要显示为&quot;客户&quot;页，需要明确调用showPage。</p>
<pre><code>&lt;a href="#pageBizPartner"&gt;供应商&lt;/a&gt;
&lt;a href="javascript:WUI.showPage('pageBizPartner', '客户', ['C']);"&gt;客户&lt;/a&gt;</code></pre>
<p>在initPageBizPartner函数中，为对话框传递参数objParam：</p>
<pre><code>type = type || "S";
var obj = "type=="S"? "Supplier": "Customer";
jdlg.objParam = {type: type, obj: obj};
// ...</code></pre>
<p>在对话框的beforeshow事件处理中，根据opt.objParam.type确定标题栏:</p>
<pre><code>jdlg.on("beforeshow", function (ev, formMode, opt) {
    opt.title = opt.objParam.type == "C"? "客户": "供应商";
});</code></pre>
<h5 id="WUI-2.5 只读对话框">2.5 只读对话框</h5>
<p>(v5.1)</p>
<p class="key"><strong>@key <a id=".wui-readonly">.wui-readonly</a></strong>  只读对话框类名</p>
<p>设置是否为只读对话框只要加上该类：</p>
<pre><code>jdlg.addClass("wui-readonly");
jdlg.removeClass("wui-readonly");
jdlg.toggleClass("wui-readonly", isReadonly);</code></pre>
<p>只读对话框不可输入(在style.css中设定pointer-events为none)，点击确定按钮后直接关闭。</p>
<p>注意：在dialog beforeshow事件中，不应直接设置wui-readonly类，因为框架之后会自动设置，导致前面设置无效。正确做法是设置<code>opt.objParam.readonly=true</code>，示例：</p>
<pre><code>jdlg.on("beforeshow", onBeforeShow);
function onBeforeShow(ev, formMode, opt)
{
    var objParam = opt.objParam;
    var ro = (formMode == FormMode.forSet &amp;&amp; !!opt.data.usedFlag);
    // beforeshow中设置对话框只读
    objParam.readonly = ro;
}</code></pre>
<h5 id="WUI-2.6 只读字段：使用disabled和readonly属性">2.6 只读字段：使用disabled和readonly属性</h5>
<ul>
<li>
<p>disabled：不可添加或更新该字段，但可查询（即forAdd/forSet模式下只显示不提交，forFind时可设置和提交)，例如编号字段、计算字段。示例：</p>
<pre><code>&lt;input name="id" disabled&gt;
&lt;input name="userName" disabled&gt;</code></pre>
</li>
<li>
<p>readonly：不可手工添加、更新和查询（但可通过代码设置）。示例：</p>
<pre><code>&lt;input name="total" readonly&gt;</code></pre>
</li>
</ul>
<p>(v5.3) 如果是在展示层次对象（参考[[设计模式：展示层次对象]]章节），某些字段是外部传入的固定值，这时用wui-fixedField类标识：</p>
<pre><code>&lt;select name="storeId" class="my-combobox wui-fixedField" data-options="ListOptions.Store()"&gt;&lt;/select&gt;</code></pre>
<p class="see"><strong>@see <a href="#.wui-fixedField">.wui-fixedField</a></strong> </p>
<h4 id="WUI-3 模块化开发">3 模块化开发</h4>
<p class="key"><strong>@key <a id="wui-script">wui-script</a></strong> </p>
<p class="key"><strong>@key <a id="options.pageFolder">options.pageFolder</a></strong> </p>
<p>允许将逻辑页、对话框的html片段和js片段放在单独的文件中。以前面章节示例中订单对象的列表页（是一个逻辑页）与详情页（是一个对话框）为例：</p>
<ul>
<li>页面名(即class)为pageOrder，UI与js逻辑分别保存在pageOrder.html, pageOrder.js中。</li>
<li>对话框id为dlgOrder, UI与js逻辑分别保存在dlgOrder.html, dlgOrder.js中。</li>
<li>模块所在目录默认为&quot;page&quot;, 可通过在h5应用开头设置 WUI.options.pageFolder 来修改。</li>
</ul>
<p>先在文件page/pageOrder.html中定义逻辑页</p>
<pre><code>&lt;div title="订单管理" wui-script="pageOrder.js" my-initfn="initPageOrder"&gt;
    &lt;table id="tblOrder" style="width:auto;height:auto"&gt;
        ...
    &lt;/table&gt;
&lt;/div&gt;</code></pre>
<p>注意：</p>
<ul>
<li>在html文件中用 wui-script属性 来指定对应的js文件。</li>
<li>无须像之前那样指定class=&quot;pageOrder&quot; / id=&quot;dlgOrder&quot; 这些属性，它们会根据页面文件名称由框架自动设置。</li>
</ul>
<p>在html文件的div中可以添加style样式标签：</p>
<pre><code>&lt;div&gt;
    &lt;style&gt;
    table {
        background-color: #ddd;
    }
    &lt;/style&gt;
    &lt;table&gt;...&lt;/table&gt;
&lt;/div&gt;</code></pre>
<p>注意：其中定义的样式（比如这里的table）只应用于当前页面或对话框，因为框架会在加载它时自动限定样式作用范围。</p>
<p>在文件page/pageOrder.js中定义逻辑：</p>
<pre><code>function initPageOrder() 
{
    var jpage = $(this);
    ...
}</code></pre>
<p>这时，就可以用 WUI.showPage(&quot;#pageOrder&quot;)来显示逻辑页了。</p>
<p>注意：逻辑页的title字段不能和其它页中title重复，否则这两页无法同时显示，因为显示tab页时是按照title来标识逻辑页的。</p>
<p>动态加载页面时，先加载逻辑页html和js文件，再将逻辑页插入应用程序并做系统初始化（如增强mui组件或easyui组件等），然后调用页面的用户初始化函数。<br />
若希望在系统初始化之前做一些操作，应放在用户初始化函数之外。<br />
例如，初始化过程中的服务调用使用批处理：</p>
<pre><code>functio initPageOrder() 
{
    ...
}
WUI.useBatchCall();</code></pre>
<p>在文件page/dlgOrder.html中定义对话框UI:</p>
<pre><code>&lt;div wui-script="dlgOrder.js" my-obj="Ordr" my-initfn="initDlgOrder" title="用户订单" style="width:520px;height:500px;"&gt;  
    &lt;form method="POST"&gt;
        ...
    &lt;/form&gt;
&lt;div&gt;</code></pre>
<p>注意：</p>
<ul>
<li>在html文件中用 wui-script属性 来指定对应的js文件。</li>
<li>无须像之前那样指定id=&quot;dlgOrder&quot; 这些属性，它们会根据页面文件名称由框架自动设置。</li>
<li>和上面逻辑页定义一样，对话框专用的样式可以在主div标签内添加style标签来定义，在加载UI后样式作用域自动限定在当前对话框。</li>
</ul>
<p>在文件page/dlgOrder.js中定义js逻辑:</p>
<pre><code>function initDlgOrder()
{
    var jdlg = $(this);
    ...
}</code></pre>
<p>这时，就可以用 WUI.showObjDlg(&quot;#dlgOrder&quot;)来显示逻辑页了。</p>
<h6 id="WUI-3.1 批量更新、批量删除">3.1 批量更新、批量删除</h6>
<p>(v5.2)<br />
列表页支持两种批量操作模式。</p>
<ul>
<li>基于多选行
<ul>
<li>在数据表中按Ctrl多选；或按Shift连续选择。</li>
<li>点击删除菜单，或在修改对话框点确定时，一旦发现是多选，则执行批量删除或批量更新。</li>
</ul></li>
<li>基于过滤条件
<ul>
<li>先搜索出要更新或删除的记录：</li>
<li>批量更新：双击任意一行打开对话框，修改后按住Ctrl点击确定按钮，批量更新所有表中的内容。</li>
<li>批量删除：按住Ctrl键点数据表上面的“删除”按钮，即是批量删除所有表中的内容。</li>
</ul></li>
</ul>
<p>服务端应支持<code>{obj}.setIf(cond)</code>及<code>{obj}.delIf(cond)</code>接口。</p>
<h5 id="WUI-3.1 页面模板支持">3.1 页面模板支持</h5>
<p>定义一个逻辑页面，可以在#my-pages下直接定义，也可以在单独的文件中定义，还可以在一个模板中定义，如：</p>
<pre><code>&lt;script type="text/html" id="tpl_pageOrder"&gt;
&lt;div class="pageOrder" title="订单管理" my-initfn="initPageOrder"&gt;
...
&lt;/div&gt;
&lt;/script&gt;</code></pre>
<p>模板用script标签定义，其id属性必须命名为<code>tpl_{逻辑页面名}</code>。<br />
这样就定义了逻辑页pageOrder，且在用到时才加载。与从外部文件加载类似，可以不设置class=&quot;pageOrder&quot;，框架会自动处理。</p>
<p>定义对话框也类似：</p>
<pre><code>&lt;script type="text/html" id="tpl_dlgOrder"&gt;
&lt;div id="dlgOrder" my-obj="Ordr" my-initfn="initDlgOrder" title="用户订单" style="width:520px;height:500px;"&gt;  
...
&lt;/div&gt;
&lt;/script&gt;</code></pre>
<p>定义了对话框dlgOrder，这个id属性也可以不设置。<br />
模板用script标签定义，其id属性必须命名为<code>tpl_{对话框名}</code>。</p>
<p>注意：</p>
<p>如果将script标签制作的页面模板内嵌在主页中，可能会造成加载时闪烁。<br />
在chrome中，在easyui-layout之后定义任意script标签（哪怕是空内容），会导致加载首页时闪烁，标题栏是黑色尤其明显。<br />
测试发现，将这些个script模板放在head标签中不会闪烁。</p>
<p>这个特性可用于未来WEB应用编译打包。</p>
<h5 id="WUI-3.2 按需加载依赖库">3.2 按需加载依赖库</h5>
<p class="key"><strong>@key <a id="wui-deferred">wui-deferred</a></strong> </p>
<p>(v5.5)</p>
<p>如果页面或对话框依赖一个或一组库，且这些库不想在主页面中用script默认加载，这时可以使用<code>wui-deferred</code>属性。<br />
页面或对话框初始化函数wui-initfn将在该deferred对象操作成功后执行。</p>
<p>示例：想在工艺对话框上使用mermaid库显示流程图，该库比较大，只在这一处使用，故不想在应用入口加载。<br />
可在app.js中添加库的加载函数：</p>
<pre><code>var m_dfdMermaid;
function loadMermaidLib()
{
    if (m_dfdMermaid == null)
        m_dfdMermaid = WUI.loadScript("lib/mermaid.min.js");
    return m_dfdMermaid;
}</code></pre>
<p>在对话框html中用wui-deferred引入依赖库：</p>
<pre><code>&lt;form my-obj="Flow" title="工艺" ... wui-deferred="loadMermaidLib()"&gt;</code></pre>
<p>在对话框模块（初始化函数）中就可以直接使用这个库了：</p>
<pre><code>function initDlgFlow()
{
    ...
    mermaid.render("graph", def, function (svg) {
        jdlg.find(".graph").html(svg);
    });
}</code></pre>
<h4 id="WUI-4 参考文档说明">4 参考文档说明</h4>
<p>以下参考文档介绍WUI模块提供的方法/函数(fn)、属性/变量(var)等，示例如下：</p>
<pre><code>@fn showPage(pageName, title?, paramArr?)  一个函数。参数说明中问号表示参数可缺省。
@var options 一个属性。
@class batchCall(opt?={useTrans?=0}) 一个JS类。
@key example-dialog key表示一般关键字。前缀为"example-"用于示例讲解。
@key .wui-page 一个CSS类名"wui-page"，关键字以"."开头。
@key #wui-pages 一个DOM对象，id为"wui-pages"，关键字以"#"开头。</code></pre>
<p>对于模块下的fn,var,class这些类别，如非特别说明，调用时应加WUI前缀，如</p>
<pre><code>WUI.showPage("#pageOrder");
var opts = WUI.options;
var batch = new WUI.batchCall();
batch.commit();</code></pre>
<p>以下函数可不加WUI前缀：</p>
<pre><code>intSort
numberSort
callSvr
callSvrSync
app_alert
app_confirm
app_show</code></pre>
<p>参考wui-name.js模块。</p></div>
<div class="block">
<h2 id="assert">@fn assert(cond, dscr?)</h2></div>
<div class="block">
<h2 id="randInt">@fn randInt(from, to)</h2>
<p>生成指定区间的随机整数。示例：</p>
<pre><code>var i = randInt(1, 10); // 1-10之间的整数，包含1或10</code></pre></div>
<div class="block">
<h2 id="randInt">@fn randInt(from, to)</h2>
<p>生成随机字符串，包含字母或数字，不包含易混淆的0或O。示例：</p>
<pre><code>var dynCode = randChr(4); // e.g. "9BZ3"</code></pre></div>
<div class="block">
<h2 id="parseQuery">@fn parseQuery(str)</h2>
<p>解析url编码格式的查询字符串，返回对应的对象。</p>
<pre><code>if (location.search) {
    var queryStr = location.search.substr(1); // "?id=100&amp;name=abc&amp;val=3.14"去掉"?"号
    var args = parseQuery(queryStr); // {id: 100, name: "abc", val: 3.14}
}</code></pre>
<p>注意：</p>
<p>如果值为整数或小数，则会转成相应类型。如上例中 id为100,不是字符串&quot;100&quot;.</p></div>
<div class="block">
<h2 id="tobool">@fn tobool(v)</h2>
<p>将字符串转成boolean值。除&quot;0&quot;, &quot;1&quot;外，还可以支持字符串 &quot;on&quot;/&quot;off&quot;, &quot;true&quot;/&quot;false&quot;等。</p></div>
<div class="block">
<h2 id="reloadSite">@fn reloadSite()</h2>
<p>重新加载当前页面，但不要#hash部分。</p></div>
<div class="block">
<h2 id="Date.format">@fn Date.format(fmt?=L)</h2>
<p>日期对象格式化字符串。</p>
<p class="param"><strong>@param fmt</strong>  格式字符串。由以下组成：</p>
<pre><code>yyyy - 四位年，如2008, 1999
yy - 两位年，如 08, 99
mm - 两位月，如 02, 12
dd - 两位日，如 01, 30
HH - 两位小时，如 00, 23
MM - 两位分钟，如 00, 59
SS - 两位秒，如 00, 59

支持这几种常用格式：
L - 标准日期时间，相当于 "yyyy-mm-dd HH:MM:SS"
D - 标准日期，相当于 "yyyy-mm-dd"
T - 标准时间，相当于 "HH:MM:SS"</code></pre>
<p>示例：</p>
<pre><code>var dt = new Date();
var dtStr1 = dt.format("D"); // "2009-10-20"
var dtStr2 = dt.format("yyyymmdd-HHMM"); // "20091020-2038"</code></pre></div>
<div class="block">
<h2 id="Date.addDay">@fn Date.addDay(n)</h2></div>
<div class="block">
<h2 id="Date.addHours">@fn Date.addHours(n)</h2></div>
<div class="block">
<h2 id="Date.addMin">@fn Date.addMin(n)</h2></div>
<div class="block">
<h2 id="Date.addMonth">@fn Date.addMonth(n)</h2></div>
<div class="block">
<h2 id="parseTime">@fn parseTime(s)</h2>
<p>将纯时间字符串生成一个日期对象。</p>
<pre><code>var dt1 = parseTime("10:10:00");
var dt2 = parseTime("10:11");</code></pre></div>
<div class="block">
<h2 id="parseDate">@fn parseDate(dateStr)</h2>
<p>将日期字符串转为日期时间格式。其效果相当于<code>new Date(Date.parse(dateStr))</code>，但兼容性更好（例如在safari中很多常见的日期格式无法解析）</p>
<p>示例：</p>
<pre><code>var dt1 = parseDate("2012-01-01");
var dt2 = parseDate("2012/01/01 20:00:09");
var dt3 = parseDate("2012.1.1 20:00");</code></pre>
<p>支持时区，时区格式可以是&quot;+8&quot;, &quot;+08&quot;, &quot;+0800&quot;, &quot;Z&quot;这些，如</p>
<pre><code>parseDate("2012-01-01T09:10:20.328+0800");
parseDate("2012-01-01T09:10:20Z");</code></pre></div>
<div class="block">
<h2 id="Date.add">@fn Date.add(sInterval, n)</h2>
<p>为日期对象加几天/小时等。参数n为整数，可以为负数。</p>
<p class="param"><strong>@param sInterval</strong>  Enum. 间隔单位. d-天; m-月; y-年; h-小时; n-分; s-秒</p>
<p>示例：</p>
<pre><code>var dt = new Date();
dt.add("d", 1); // 1天后
dt.add("m", 1); // 1个月后
dt.add("y", -1); // 1年前
dt.add("h", 3); // 3小时后
dt.add("n", 30); // 30分钟后
dt.add("s", 30); // 30秒后</code></pre>
<p class="see"><strong>@see <a href="#Date.diff">Date.diff</a></strong> </p></div>
<div class="block">
<h2 id="Date.diff">@fn Date.diff(sInterval, dtEnd)</h2>
<p>计算日期到另一日期间的间隔，单位由sInterval指定(具体值列表参见Date.add).</p>
<pre><code>var dt = new Date();
...
var dt2 = new Date();
var days = dt.diff("d", dt2); // 相隔多少天</code></pre>
<p class="see"><strong>@see <a href="#Date.add">Date.add</a></strong> </p></div>
<div class="block">
<h2 id="getTimeDiffDscr">@fn getTimeDiffDscr(tm, tm1)</h2>
<p>从tm到tm1的时间差描述，如&quot;2分钟前&quot;, &quot;3天前&quot;等。</p>
<p>tm和tm1可以为时间对象或时间字符串</p></div>
<div class="block">
<h2 id="WUI.getTmRange">@fn WUI.getTmRange(dscr, now?)</h2>
<p>根据时间段描述得到<code>[起始时间，结束时间)</code>，注意结束时间是开区间（即不包含）。<br />
假设今天是2015-9-9 周三：</p>
<pre><code>getTmRange("本周", "2015-9-9") -&gt; ["2015-9-7"(本周一), "2015-9-14")
getTmRange("上周") -&gt; ["2015-8-31", "2015-9-7")  // 或"前1周"

getTmRange("本月") -&gt; ["2015-9-1", "2015-10-1")
getTmRange("上月") -&gt; ["2015-8-1", "2015-9-1")

getTmRange("今年") -&gt; ["2015-1-1", "2016-1-1") // 或"本年"
getTmRange("去年") -&gt; ["2014-1-1", "2015-1-1") // 或"上年"

getTmRange("本季度") -&gt; ["2015-7-1", "2015-10-1") // 7,8,9三个月
getTmRange("上季度") -&gt; ["2015-4-1", "2015-7-1")

getTmRange("上半年") -&gt; ["2015-1-1", "2015-7-1")
getTmRange("下半年") -&gt; ["2015-7-1", "2016-1-1")

getTmRange("今天") -&gt; ["2015-9-9", "2015-9-10") // 或"本日"
getTmRange("昨天") -&gt; ["2015-9-8", "2015-9-9") // 或"昨日"

getTmRange("前1周") -&gt; ["2015-8-31"(上周一)，"2015-9-7"(本周一))
getTmRange("前3月") -&gt; ["2015-6-1", "2015-9-1")
getTmRange("前3天") -&gt; ["2015-9-6", "2015-9-9")

getTmRange("近1周") -&gt; ["2015-9-3"，"2015-9-10")
getTmRange("近3月") -&gt; ["2015-6-10", "2015-9-10")
getTmRange("近3天") -&gt; ["2015-9-6", "2015-9-10")  // "前3天"+今天</code></pre>
<p>dscr可以是 </p>
<pre><code>"近|前|上" N "个"? "小时|日|周|月|年|季度"
"本|今" "小时|日/天|周|月|年|季度"</code></pre>
<p>注意：&quot;近X周&quot;包括今天（即使尚未过完）。</p>
<p>示例：快捷填充</p>
<pre><code>    &lt;td&gt;
        &lt;select class="cboTmRange"&gt;
            &lt;option value ="本月"&gt;本月&lt;/option&gt;
            &lt;option value ="上月"&gt;上月&lt;/option&gt;
            &lt;option value ="本周"&gt;本周&lt;/option&gt;
            &lt;option value ="上周"&gt;上周&lt;/option&gt;
            &lt;option value ="今年"&gt;今年&lt;/option&gt;
            &lt;option value ="去年"&gt;去年&lt;/option&gt;
        &lt;/select&gt;
    &lt;/td&gt;

var txtTmRange = jdlg.find(".cboTmRange");
txtTmRange.change(function () {
    var range = WUI.getTmRange(this.value);
    if (range) {
        WUI.setFormData(jfrm, {tm1: range[0], tm2: range[1]}, {setOnlyDefined: true});
    }
});
// 初始选中
setTimeout(function () {
    txtTmRange.change();
});</code></pre></div>
<div class="block">
<h2 id="setCookie">@fn setCookie(name, value, days?=30)</h2>
<p>设置cookie值。如果只是为了客户端长时间保存值，一般建议使用 setStorage.</p>
<p class="see"><strong>@see <a href="#getCookie">getCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#delCookie">delCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#setStorage">setStorage</a></strong> </p></div>
<div class="block">
<h2 id="getCookie">@fn getCookie(name)</h2>
<p>取cookie值。</p>
<p class="see"><strong>@see <a href="#setCookie">setCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#delCookie">delCookie</a></strong> </p></div>
<div class="block">
<h2 id="delCookie">@fn delCookie(name)</h2>
<p>删除一个cookie项。</p>
<p class="see"><strong>@see <a href="#getCookie">getCookie</a></strong> </p>
<p class="see"><strong>@see <a href="#setCookie">setCookie</a></strong> </p></div>
<div class="block">
<h2 id="setStorage">@fn setStorage(name, value, useSession?=false)</h2>
<p>使用localStorage存储(或使用sessionStorage存储, 如果useSession=true)。<br />
value可以是简单类型，也可以为数组，对象等，后者将自动在序列化后存储。 </p>
<p>如果设置了window.STORAGE_PREFIX, 则键值(name)会加上该前缀.</p>
<p>示例：</p>
<pre><code>setStorage("id", "100");
var id = getStorage("id");
delStorage("id");</code></pre>
<p>示例2：存储对象:</p>
<pre><code>window.STORAGE_PREFIX = "jdcloud_"; // 一般在app.js中全局设置
var obj = {id:10, name:"Jason"};
setStorage("obj", obj);   // 实际存储键值为 "jdcloud_obj"
var obj2 = getStorage("obj");
alert(obj2.name);</code></pre>
<p class="var"><strong>@var <a id="STORAGE_PREFIX">STORAGE_PREFIX</a></strong>  本地存储的键值前缀</p>
<p>如果指定, 则调用setStorage/getStorage/delStorage时都将自动加此前缀, 避免不同项目的存储项冲突.</p>
<p class="see"><strong>@see <a href="#getStorage">getStorage</a></strong> </p>
<p class="see"><strong>@see <a href="#delStorage">delStorage</a></strong> </p></div>
<div class="block">
<h2 id="getStorage">@fn getStorage(name, useSession?=false)</h2>
<p>取storage中的一项。<br />
默认使用localStorage存储，如果useSession=true，则使用sessionStorage存储。</p>
<p>如果浏览器不支持Storage，则使用cookie实现.</p>
<p class="see"><strong>@see <a href="#setStorage">setStorage</a></strong> </p>
<p class="see"><strong>@see <a href="#delStorage">delStorage</a></strong> </p></div>
<div class="block">
<h2 id="delStorage">@fn delStorage(name)</h2>
<p>删除storage中的一项。</p>
<p class="see"><strong>@see <a href="#getStorage">getStorage</a></strong> </p>
<p class="see"><strong>@see <a href="#setStorage">setStorage</a></strong> </p></div>
<div class="block">
<h2 id="rs2Array">@fn rs2Array(rs)</h2>
<p class="param"><strong>@param rs=</strong> {h=[header], d=[ @row ]} rs对象(RowSet)</p>
<p class="return"><strong>@return arr=[</strong>  %obj ]</p>
<p>rs对象用于传递表格，包含表头与表内容。<br />
函数用于将服务器发来的rs对象转成数组。</p>
<p>示例：</p>
<pre><code>var rs = {
    h: ["id", "name"], 
    d: [ [100, "Tom"], [101, "Jane"] ] 
};
var arr = rs2Array(rs); 

// 结果为
arr = [
    {id: 100, name: "Tom"},
    {id: 101, name: "Jane"} 
];</code></pre>
<p class="see"><strong>@see <a href="#rs2Hash">rs2Hash</a></strong> </p>
<p class="see"><strong>@see <a href="#rs2MultiHash">rs2MultiHash</a></strong> </p></div>
<div class="block">
<h2 id="rs2Hash">@fn rs2Hash(rs, key)</h2>
<p class="param"><strong>@param rs=</strong> {h, d}  rs对象(RowSet)</p>
<p class="return"><strong>@return hash=</strong> {key => %obj}</p>
<p>示例：</p>
<pre><code>var rs = {
    h: ["id", "name"], 
    d: [ [100, "Tom"], [101, "Jane"] ] 
};
var hash = rs2Hash(rs, "id"); 

// 结果为
hash = {
    100: {id: 100, name: "Tom"},
    101: {id: 101, name: "Jane"}
};</code></pre>
<p>key可以为一个函数，返回实际key值，示例：</p>
<pre><code>var hash = rs2Hash(rs, function (o) {
    return "USER-" + o.id;
}); 

// 结果为
hash = {
    "USER-100": {id: 100, name: "Tom"},
    "USER-101": {id: 101, name: "Jane"}
};</code></pre>
<p>key函数也可以返回[key, value]数组：</p>
<pre><code>var hash = rs2Hash(rs, function (o) {
    return ["USER-" + o.id, o.name];
}); 

// 结果为
hash = {
    "USER-100": "Tom",
    "USER-101": "Jane"
};</code></pre>
<p class="see"><strong>@see <a href="#rs2Array">rs2Array</a></strong> </p></div>
<div class="block">
<h2 id="rs2MultiHash">@fn rs2MultiHash(rs, key)</h2>
<p>数据分组(group by).</p>
<p class="param"><strong>@param rs=</strong> {h, d}  rs对象(RowSet)</p>
<p class="return"><strong>@return hash=</strong> {key => [ %obj ]}</p>
<p>示例：</p>
<pre><code>var rs = {
    h: ["id", "name"], 
    d: [ [100, "Tom"], [101, "Jane"], [102, "Tom"] ] 
};
var hash = rs2MultiHash(rs, "name");  

// 结果为
hash = {
    "Tom": [{id: 100, name: "Tom"}, {id: 102, name: "Tom"}],
    "Jane": [{id: 101, name: "Jane"}]
};</code></pre>
<p>key也可以是一个函数，返回实际的key值，示例，按生日年份分组：</p>
<pre><code>var rs = {
    h: ["id", "name", "birthday"], 
    d: [ [100, "Tom", "1998-10-1"], [101, "Jane", "1999-1-10"], [102, "Tom", "1998-3-8"] ] 
};
// 按生日年份分组
var hash = rs2MultiHash(rs, function (o) {
    var m = o.birthday.match(/^\d+/);
    return m &amp;&amp; m[0];
});

// 结果为
hash = {
    "1998": [{id: 100, name: "Tom", birthday: "1998-10-1"}, {id: 102, name: "Tom", birthday:"1998-3-8"}],
    "1999": [{id: 101, name: "Jane", birthday: "1999-1-10"}]
};</code></pre>
<p>key作为函数，也可返回[key, value]:</p>
<pre><code>var hash = rs2MultiHash(rs, function (o) {
    return [o.name, [o.id, o.birthday]];
});

// 结果为
hash = {
    "Tom": [[100, "1998-10-1"], [102, "1998-3-8"]],
    "Jane": [[101, "1999-1-10"]]
};</code></pre>
<p class="see"><strong>@see <a href="#rs2Hash">rs2Hash</a></strong> </p>
<p class="see"><strong>@see <a href="#rs2Array">rs2Array</a></strong> </p></div>
<div class="block">
<h2 id="list2varr">@fn list2varr(ls, colSep=':', rowSep=',')</h2>
<ul>
<li>ls: 代表二维表的字符串，有行列分隔符。</li>
<li>colSep, rowSep: 列分隔符，行分隔符。</li>
</ul>
<p>将字符串代表的压缩表(&quot;v1:v2:v3,...&quot;)转成对象数组。</p>
<p>e.g.</p>
<pre><code>var users = "101:andy,102:beddy";
var varr = list2varr(users);
// varr = [["101", "andy"], ["102", "beddy"]];
var arr = rs2Array({h: ["id", "name"], d: varr});
// arr = [ {id: 101, name: "andy"}, {id: 102, name: "beddy"} ];

var cmts = "101\thello\n102\tgood";
var varr = list2varr(cmts, "\t", "\n");
// varr=[["101", "hello"], ["102", "good"]]</code></pre></div>
<div class="block">
<h2 id="objarr2list">@fn objarr2list(objarr, fields, sep=':', sep2=',')</h2>
<p>将对象数组转成字符串代表的压缩表(&quot;v1:v2:v3,...&quot;)。</p>
<p>示例：</p>
<pre><code>var objarr = [
    {id:100, name:'name1', qty:2},
    {id:101, name:'name2', qty:3}
];
var list = objarr2list(objarr, ["id","qty"]);
// 返回"100:2,101:3"

var list2 = objarr2list(objarr, function (e, i) { return e.id + ":" + e.qty; });
// 结果同上</code></pre></div>
<div class="block">
<h2 id="intSort">@fn intSort(a, b)</h2>
<p>整数排序. 用于datagrid column sorter:</p>
<pre><code>&lt;th data-options="field:'id', sortable:true, sorter:intSort"&gt;编号&lt;/th&gt;</code></pre></div>
<div class="block">
<h2 id="numberSort">@fn numberSort(a, b)</h2>
<p>小数排序. 用于datagrid column sorter:</p>
<pre><code>&lt;th data-options="field:'score', sortable:true, sorter:numberSort"&gt;评分&lt;/th&gt;</code></pre></div>
<div class="block">
<h2 id="getAncestor">@fn getAncestor(o, fn)</h2>
<p>取符合条件(fn)的对象，一般可使用$.closest替代</p></div>
<div class="block">
<h2 id="appendParam">@fn appendParam(url, param)</h2>
<p>示例:</p>
<pre><code>var url = "http://xxx/api.php";
if (a)
    url = appendParam(url, "a=" + a);
if (b)
    url = appendParam(url, "b=" + b);

appendParam(url, $.param({a:1, b:3}));</code></pre>
<p>支持url中带有&quot;?&quot;或&quot;#&quot;，如</p>
<pre><code>var url = "http://xxx/api.php?id=1#order";
appendParam(url, "pay=1"); // "http://xxx/api.php?id=1&amp;pay=1#order";</code></pre></div>
<div class="block">
<h2 id="deleteParam">@fn deleteParam(url, paramName)</h2>
<p>示例:</p>
<pre><code>var url = "http://xxx/api.php?a=1&amp;b=3&amp;c=2";
var url1 = deleteParam(url, "b"); // "http://xxx/api.php?a=1&amp;c=2";

var url = "http://server/jdcloud/m2/?logout#me";
var url1 = deleteParam(url, "logout"); // "http://server/jdcloud/m2/?#me"</code></pre></div>
<div class="block">
<h2 id="isWeixin">@fn isWeixin()</h2>
<p>当前应用运行在微信中。</p></div>
<div class="block">
<h2 id="isIOS">@fn isIOS()</h2>
<p>当前应用运行在IOS平台，如iphone或ipad中。</p></div>
<div class="block">
<h2 id="isAndroid">@fn isAndroid()</h2>
<p>当前应用运行在安卓平台。</p></div>
<div class="block">
<h2 id="parseValue">@fn parseValue(str)</h2>
<p>如果str符合整数或小数，则返回相应类型。</p></div>
<div class="block">
<h2 id="applyTpl">@fn applyTpl(tpl, data)</h2>
<p>对模板做字符串替换</p>
<pre><code>var tpl = "&lt;li&gt;&lt;p&gt;{name}&lt;/p&gt;&lt;p&gt;{dscr}&lt;/p&gt;&lt;/li&gt;";
var data = {name: 'richard', dscr: 'hello'};
var html = applyTpl(tpl, data);
// &lt;li&gt;&lt;p&gt;richard&lt;/p&gt;&lt;p&gt;hello&lt;/p&gt;&lt;/li&gt;</code></pre></div>
<div class="block">
<h2 id="delayDo">@fn delayDo(fn, delayCnt?=3)</h2>
<p>设置延迟执行。当delayCnt=1时与setTimeout效果相同。<br />
多次置于事件队列最后，一般3次后其它js均已执行完毕，为idle状态</p></div>
<div class="block">
<h2 id="kvList2Str">@fn kvList2Str(kv, sep, sep2)</h2>
<p>e.g.</p>
<pre><code>var str = kvList2Str({"CR":"Created", "PA":"Paid"}, ';', ':');
// str="CR:Created;PA:Paid"</code></pre></div>
<div class="block">
<h2 id="parseKvList">@fn parseKvList(kvListStr, sep, sep2, doReverse?) -> kvMap</h2>
<p>解析key-value列表字符串，返回kvMap。</p>
<ul>
<li>doReverse: 设置为true时返回反向映射</li>
</ul>
<p>示例：</p>
<pre><code>var map = parseKvList("CR:新创建;PA:已付款", ";", ":");
// map: {"CR": "新创建", "PA":"已付款"}

var map = parseKvList("CR:新创建;PA:已付款", ";", ":", true);
// map: {"新创建":"CR", "已付款":"PA"}</code></pre></div>
<div class="block">
<h2 id="Q">@fn Q(str, q?="'")</h2>
<pre><code>Q("abc") -&gt; 'abc'
Q("a'bc") -&gt; 'a\'bc'</code></pre></div>
<div class="block">
<h2 id="text2html">@fn text2html(str, pics)</h2>
<p>将文本或图片转成html，常用于将筋斗云后端返回的图文内容转成html在网页中显示。示例：</p>
<pre><code>var item = {id: 1, name: "商品1", content: "商品介绍内容", pics: "100,102"};
var html = MUI.text2html(item.content, item.pics);
jpage.find("#content").html(html);</code></pre>
<p>文字转html示例：</p>
<pre><code>var html = MUI.text2html("hello\nworld");</code></pre>
<p>生成html为</p>
<pre><code>&lt;p&gt;hello&lt;/p&gt;
&lt;p&gt;world&lt;/p&gt;</code></pre>
<p>支持简单的markdown格式，如&quot;# &quot;,&quot;## &quot;分别表示一二级标题, &quot;- &quot;表示列表（注意在&quot;#&quot;或&quot;-&quot;后面有英文空格）：</p>
<pre><code># 标题1
内容1
# 标题2
内容2

- 列表1
- 列表2</code></pre>
<p>函数可将图片编号列表转成img列表，如：</p>
<pre><code>var html = MUI.text2html(null, "100,102");</code></pre>
<p>生成</p>
<pre><code>&lt;img src="../api.php/att?thumbId=100"&gt;
&lt;img src="../api.php/att?thumbId=102"&gt;</code></pre></div>
<div class="block">
<h2 id="extendNoOverride">@fn extendNoOverride(a, b, ...)</h2>
<pre><code>var a = {a: 1};
WUI.extendNoOverride(a, {b: 'aa'}, {a: 99, b: '33', c: 'bb'});
// a = {a: 1, b: 'aa', c: 'bb'}</code></pre></div>
<div class="block">
<h2 id="jdModule">@fn jdModule(name?, fn?)</h2>
<p>定义JS模块。这是一个全局函数。</p>
<p>定义一个模块:</p>
<pre><code>jdModule("jdcloud.common", JdcloudCommon);
function JdcloudCommon() {
    var self = this;

    // 对外提供一个方法
    self.rs2Array = rs2Array;
    function rs2Array(rs)
    {
        return ...;
    }
}</code></pre>
<p>获取模块对象:</p>
<pre><code>var mCommon = jdModule("jdcloud.common");
var arr = mCommon.rs2Array(rs);</code></pre>
<p>返回模块映射列表。</p>
<pre><code>var moduleMap = jdModule(); // 返回 { "jdcloud.common": JdcloudCommon, ... }</code></pre></div>
<div class="block">
<h2 id="getFormData">@fn getFormData(jo, doGetAll)</h2>
<p>取DOM对象中带name属性的子对象的内容, 放入一个JS对象中, 以便手工调用callSvr.</p>
<p>注意: </p>
<ul>
<li>这里Form不一定是Form标签, 可以是一切DOM对象.</li>
<li>如果DOM对象有disabled属性, 则会忽略它, 这也与form提交时的规则一致.</li>
</ul>
<p>与setFormData配合使用时, 可以只返回变化的数据.</p>
<pre><code>jf.submit(function () {
    var ac = jf.attr("action");
    callSvr(ac, fn, getFormData(jf));
});</code></pre>
<p>在dialog的onValidate/onOk回调中，由于在显示对话框时自动调用过setFormData，所以用getFormData只返回有修改变化的数据。如果要取所有数据可设置参数doGetAll=true:</p>
<pre><code>var data = WUI.getFormData(jfrm, true);</code></pre>
<p>如果在jo对象中存在有name属性的file组件(input[type=file][name])，或指定了属性enctype=&quot;multipart/form-data&quot;，则调用getFormData会返回FormData对象而非js对象，<br />
再调用callSvr时，会以&quot;multipart/form-data&quot;格式提交数据。一般用于上传文件。<br />
示例：</p>
<pre><code>&lt;div&gt;
    课程文档
    &lt;input name="pdf" type="file" accept="application/pdf"&gt;
&lt;/div&gt;</code></pre>
<p>或传统地：</p>
<pre><code>&lt;form method="POST" enctype='multipart/form-data'&gt;
    课程文档
    &lt;input name="pdf" type="file" accept="application/pdf"&gt;
&lt;/form&gt;</code></pre>
<p>如果有多个同名组件（name相同，且非disabled状态），最终值将以最后组件为准。<br />
如果想要以数组形式返回所有值，应在名字上加后缀&quot;[]&quot;，示例：</p>
<pre><code>行统计字段: &lt;select name="gres[]" class="my-combobox fields"&gt;&lt;/select&gt;
行统计字段2: &lt;select name="gres[]" class="my-combobox fields"&gt;&lt;/select&gt;
列统计字段: &lt;select name="gres2" class="my-combobox fields"&gt;&lt;/select&gt;
列统计字段2: &lt;select name="gres2" class="my-combobox fields"&gt;&lt;/select&gt;</code></pre>
<p>取到的结果示例：</p>
<pre><code>{ gres: ["id", "name"], gres2: "name" }</code></pre>
<p class="see"><strong>@see <a href="#setFormData">setFormData</a></strong> </p></div>
<div class="block">
<h2 id="getFormData_vf">@fn getFormData_vf(jo)</h2>
<p>专门取虚拟字段的值。例如：</p>
<pre><code>&lt;select name="whId" class="my-combobox" data-options="url:..., jd_vField:'whName'"&gt;&lt;/select&gt;</code></pre>
<p>用WUI.getFormData可取到<code>{whId: xxx}</code>，而WUI.getFormData_vf遍历带name属性且设置了jd_vField选项的控件，调用接口getValue_vf(ji)来取其显示值。<br />
因而，为支持取虚拟字段值，控件须定义getValue_vf接口。</p>
<pre><code>&lt;input name="orderType" data-options="jd_vField:'orderType'" disabled&gt;</code></pre>
<p>注意：与getFormData不同，它不忽略有disabled属性的控件。</p>
<p class="see"><strong>@see <a href="#defaultFormItems">defaultFormItems</a></strong> </p></div>
<div class="block">
<h2 id="formItems">@fn formItems(jo, cb)</h2>
<p>表单对象遍历。对表单jo（实际可以不是form标签）下带name属性的控件，交给回调cb处理。<br />
可通过扩展<code>WUI.formItems[sel]</code>来为表单扩展其它类型控件，参考 <code>WUI.defaultFormItems</code>来查看要扩展的接口方法。</p>
<p>注意:</p>
<ul>
<li>通过取getDisabled接口判断，可忽略有disabled属性的控件以及未选中的checkbox/radiobutton。</li>
</ul>
<p>对于checkbox，设置时根据val确定是否选中；取值时如果选中取value属性否则取value-off属性。<br />
缺省value为&quot;on&quot;, value-off为空(非标准属性，本框架支持)，可以设置：</p>
<pre><code>&lt;input type="checkbox" name="flag" value="1"&gt;
&lt;input type="checkbox" name="flag" value="1" value-off="0"&gt;</code></pre>
<p class="param"><strong>@param cb</strong> (ji, name, it) it.getDisabled/setDisabled/getValue/setValue/getShowbox</p>
<p>当cb返回false时可中断遍历。</p>
<p>示例：</p>
<pre><code>WUI.formItems(jdlg.find(".my-fixedField"), function (ji, name, it) {
    var fixedVal = ...
    if (fixedVal || fixedVal == '') {
        it.setReadonly(ji, true);
        var forAdd = beforeShowOpt.objParam.mode == FormMode.forAdd;
        if (forAdd) {
            it.setValue(ji, fixedVal);
        }
    }
    else {
        it.setReadonly(ji, false);
    }
});</code></pre>
<p class="key"><strong>@key <a id="defaultFormItems">defaultFormItems</a></strong> </p></div>
<div class="block">
<h2 id="setFormData">@fn setFormData(jo, data?, opt?)</h2>
<p>用于为带name属性的DOM对象设置内容为data[name].<br />
要清空所有内容, 可以用 setFormData(jo), 相当于增强版的 form.reset().</p>
<p>注意:</p>
<ul>
<li>DOM项的内容指: 如果是input/textarea/select等对象, 内容为其value值; 如果是div组件, 内容为其innerHTML值.</li>
<li>当data[name]未设置(即值为undefined, 注意不是null)时, 对于input/textarea等组件, 行为与form.reset()逻辑相同,<br />
即恢复为初始化值。（特别地，form.reset无法清除input[type=hidden]对象的内容, 而setFormData可以)<br />
对div等其它对象, 会清空该对象的内容.</li>
<li>如果对象设置有属性&quot;noReset&quot;, 则不会对它进行设置.</li>
</ul>
<p class="param"><strong>@param opt</strong>  {setOrigin?=false, setOnlyDefined?=false}</p>
<p class="param"><strong>@param opt.setOrigin</strong>  为true时将data设置为数据源, 这样在getFormData时, 只会返回与数据源相比有变化的数据.</p>
<p>缺省会设置该DOM对象数据源为空.</p>
<p class="param"><strong>@param opt.setOnlyDefined</strong>  设置为true时，只设置form中name在data中存在的项，其它项保持不变；而默认是其它项会清空。</p>
<p>对象关联的数据源, 可以通过 jo.data(&quot;origin<em>&quot;) 来获取, 或通过 jo.data(&quot;origin</em>&quot;, newOrigin) 来设置.</p>
<p>示例：</p>
<pre><code>&lt;div id="div1"&gt;
    &lt;p&gt;订单描述：&lt;span name="dscr"&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;状态为：&lt;input type=text name="status"&gt;&lt;/p&gt;
    &lt;p&gt;金额：&lt;span name="amount"&gt;&lt;/span&gt;元&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>Javascript:</p>
<pre><code>var data = {
    dscr: "筋斗云教程",
    status: "已付款",
    amount: "100"
};
var jo = $("#div1");
var data = setFormData(jo, data); 
$("[name=status]").html("已完成");
var changedData = getFormData(jo); // 返回 { dscr: "筋斗云教程", status: "已完成", amount: "100" }

var data = setFormData(jo, data, {setOrigin: true}); 
$("[name=status]").html("已完成");
var changedData = getFormData(jo); // 返回 { status: "已完成" }
$.extend(jo.data("origin_"), changedData); // 合并变化的部分到数据源.</code></pre>
<p class="see"><strong>@see <a href="#getFormData">getFormData</a></strong> </p></div>
<div class="block">
<h2 id="loadScript">@fn loadScript(url, fnOK?, ajaxOpt?)</h2>
<p class="param"><strong>@param fnOK</strong>  加载成功后的回调函数</p>
<p class="param"><strong>@param ajaxOpt</strong>  传递给$.ajax的额外选项。</p>
<p>默认未指定ajaxOpt时，简单地使用添加script标签机制异步加载。如果曾经加载过，可以重用cache。</p>
<p>注意：再次调用时是否可以从cache中取，是由服务器的cache-control决定的，在web和web/page目录下的js文件一般是禁止缓存的，再次调用时会从服务器再取，若文件无更改，服务器会返回304状态。<br />
这是因为默认我们使用Apache做服务器，在相应目录下.htaccess中配置有缓存策略。</p>
<p>如果指定ajaxOpt，且非跨域，则通过ajax去加载，可以支持同步调用。如果是跨域，仍通过script标签方式加载，注意加载完成后会自动删除script标签。</p>
<p>返回defered对象(与$.ajax类似)，可以用 dfd.then() / dfd.fail() 异步处理。</p>
<p>常见用法：</p>
<ul>
<li>
<p>动态加载一个script，异步执行其中内容：</p>
<pre><code>loadScript("1.js", onload); // onload中可使用1.js中定义的内容
loadScript("http://otherserver/path/1.js"); // 跨域加载</code></pre>
</li>
<li>
<p>加载并立即执行一个script:</p>
<pre><code>loadScript("1.js", {async: false});
// 可立即使用1.js中定义的内容</code></pre>
<p>注意：如果是跨域加载，不支持同步调用（$.ajax的限制），如：</p>
<pre><code>loadScript("http://oliveche.com/1.js", {async: false});
// 一旦跨域，选项{async:false}指定无效，不可立即使用1.js中定义的内容。</code></pre>
</li>
</ul>
<p>示例：在菜单中加一项“工单工时统计”，动态加载并执行一个JS文件：<br />
store.html中设置菜单：</p>
<pre><code>            &lt;a href="javascript:WUI.loadScript('page/mod_工单工时统计.js')"&gt;工单工时统计&lt;/a&gt;</code></pre>
<p>在<code>page/mod_工单工时统计.js</code>文件中写报表逻辑，<code>mod</code>表示一个JS模块文件，示例：</p>
<pre><code>function show工单工时统计()
{
    DlgReportCond.show(function (data) {
        var queryParams = WUI.getQueryParam({createTm: [data.tm1, data.tm2]});
        var url = WUI.makeUrl("Ordr.query", { res: 'id 工单号, code 工单码, createTm 生产日期, itemCode 产品编码, itemName 产品名称, cate2Name 产品系列, itemCate 产品型号, qty 数量, mh 理论工时, mh1 实际工时', pagesz: -1 });
        WUI.showPage("pageSimple", "工单工时统计!", [url, queryParams, onInitGrid]);
    });
}
show工单工时统计();</code></pre>
<p>如果JS文件修改了，点菜单时可以实时执行最新的内容。</p>
<p>如果要动态加载script，且使用后删除标签（里面定义的函数会仍然保留），建议直接使用<code>$.getScript</code>，它等同于：</p>
<pre><code>loadScript("1.js", {cache: false});</code></pre>
<p><strong>[小技巧]</strong></p>
<p>在index.js/app.js等文件中写代码，必须刷新整个页面才能加载生效。<br />
可以先把代码写在比如 web/test.js 中，这样每次修改后不用大刷新，直接在chrome控制台上加载运行：</p>
<pre><code>WUI.loadScript("test.js")</code></pre>
<p>等改好了再拷贝到真正想放置这块代码的地方。修改已有的框架中函数也可以这样来快速迭代。</p></div>
<div class="block">
<h2 id="loadJson">@fn loadJson(url, fnOK, options)</h2>
<p>从远程获取JSON结果.<br />
注意: 与$.getJSON不同, 本函数不直接调用JSON.parse解析结果, 而是将返回当成JS代码使用eval执行得到JSON结果再回调fnOK.</p>
<p>示例:</p>
<pre><code>WUI.loadJson("1.js", function (data) {
    // handle json value `data`
});</code></pre>
<p>1.js可以是返回任意JS对象的代码, 如:</p>
<pre><code>{
    a: 2 * 3600,
    b: "hello",
    // c: {}
}</code></pre>
<p>如果不处理结果, 则该函数与$.getScript效果类似.</p></div>
<div class="block">
<h2 id="loadCss">@fn loadCss(url)</h2>
<p>动态加载css文件, 示例:</p>
<pre><code>WUI.loadCss("lib/bootstrap.min.css");</code></pre></div>
<div class="block">
<h2 id="setDateBox">@fn setDateBox(jo, defDateFn?)</h2>
<p>设置日期框, 如果输入了非法日期, 自动以指定日期(如未指定, 用当前日期)填充.</p>
<pre><code>setDateBox($("#txtComeDt"), function () { return genDefVal()[0]; });</code></pre></div>
<div class="block">
<h2 id="setTimeBox">@fn setTimeBox(jo, defTimeFn?)</h2>
<p>设置时间框, 如果输入了非法时间, 自动以指定时间(如未指定, 用当前时间)填充.</p>
<pre><code>setTimeBox($("#txtComeTime"), function () { return genDefVal()[1]; });</code></pre></div>
<div class="block">
<h2 id="waitFor">@fn waitFor(deferredObj)</h2>
<p>用于简化异步编程. 可将不易读的回调方式改写为易读的顺序执行方式.</p>
<pre><code>var dfd = $.getScript("http://...");
function onSubmit()
{
    dfd.then(function () {
        foo();
        bar();
    });
}</code></pre>
<p>可改写为:</p>
<pre><code>function onSubmit()
{
    if (waitFor(dfd)) return;
    foo();
    bar();
}</code></pre></div>
<div class="block">
<h2 id="rgb">@fn rgb(r,g,b)</h2>
<p>生成&quot;#112233&quot;形式的颜色值.</p>
<pre><code>rgb(255,255,255) -&gt; "#ffffff"</code></pre></div>
<div class="block">
<h2 id="rgb2hex">@fn rgb2hex(rgb)</h2>
<p>将jquery取到的颜色转成16进制形式，如：&quot;rgb(4, 190, 2)&quot; -&gt; &quot;#04be02&quot;</p>
<p>示例：</p>
<pre><code>var color = rgb2hex( $(".mui-container").css("backgroundColor") );</code></pre></div>
<div class="block">
<h2 id="jQuery.fn.jdata">@fn jQuery.fn.jdata(val?)</h2>
<p>和使用$.data()差不多，更好用一些. 例：</p>
<pre><code>$(o).jdata().hello = 100;
$(o).jdata({hello:100, world:200});</code></pre></div>
<div class="block">
<h2 id="compressImg">@fn compressImg(img, cb, opt)</h2>
<p>通过限定图片大小来压缩图片，用于图片预览和上传。<br />
不支持IE8及以下版本。</p>
<ul>
<li>img: Image对象</li>
<li>cb: Function(picData) 回调函数</li>
<li>opt: {quality=0.8, maxSize=1280, mimeType?=&quot;image/jpeg&quot;}</li>
<li>opt.maxSize: 压缩完后宽、高不超过该值。为0表示不压缩。</li>
<li>opt.quality: 0.0-1.0之间的数字。</li>
<li>opt.mimeType: 输出MIME格式。</li>
</ul>
<p>函数cb的回调参数: picData={b64src,blob,w,h,w0,h0,quality,name,mimeType,size0,size,b64size,info}</p>
<p>b64src为base64格式的Data URL, 如 &quot;data:image/jpeg;base64,/9j/4AAQSk...&quot;, 用于给image或background-image赋值显示图片；</p>
<p>可以赋值给Image.src:</p>
<pre><code>var img = new Image();
img.src = picData.b64src;</code></pre>
<p>或</p>
<pre><code>$("&lt;div&gt;").css("background-image", "url(" + picData.b64src + ")");</code></pre>
<p>blob用于放到FormData中上传：</p>
<pre><code>fd.append('file', picData.blob, picData.name);</code></pre>
<p>其它picData属性：</p>
<ul>
<li>w0,h0,size0分别为原图宽、高、大小; w,h,size为压缩后图片的宽、高、大小。</li>
<li>quality: jpeg压缩质量,0-1之间。</li>
<li>mimeType: 输出的图片格式</li>
<li>info: 提示信息，会在console中显示。用于调试。</li>
</ul>
<p><strong>[预览和上传示例]</strong></p>
<p>HTML:</p>
<pre><code>&lt;form action="upfile.php"&gt;
    &lt;div class="img-preview"&gt;&lt;/div&gt;
    &lt;input type="file" /&gt;&lt;br/&gt;
    &lt;input type="submit" &gt;
&lt;/form&gt;</code></pre>
<p>用picData.b64src来显示预览图，并将picData保存在img.picData_属性中，供后面上传用。</p>
<pre><code>var jfrm = $("form");
var jpreview = jfrm.find(".img-preview");
var opt = {maxSize:1280};
jfrm.find("input[type=file]").change(function (ev) {
    $.each(this.files, function (i, fileObj) {
        compressImg(fileObj, function (picData) {
            $("&lt;img&gt;").attr("src", picData.b64src)
                .prop("picData_", picData)
                .appendTo(jpreview);
            //$("&lt;div&gt;").css("background-image", "url("+picData.b64src+")").appendTo(jpreview);
        }, opt);
    });
    this.value = "";
});</code></pre>
<p>上传picData.blob到服务器</p>
<pre><code>jfrm.submit(function (ev) {
    ev.preventDefault();

    var fd = new FormData();
    var idx = 1;
    jpreview.find("img").each(function () {
        // 名字要不一样，否则可能会覆盖
        fd.append('file' + idx, this.picData_.blob, this.picData_.name);
        ++idx;
    });

    $.ajax({
        url: jfrm.attr("action"),
        data: fd,
        processData: false,
        contentType: false,
        type: 'POST',
        // 允许跨域调用
        xhrFields: {
            withCredentials: true
        },
        success: cb
    });
    return false;
});</code></pre>
<p>参考：JIC.js (<a href="https://github.com/brunobar79/J-I-C">https://github.com/brunobar79/J-I-C</a>)</p>
<p>TODO: 用完后及时释放内存，如调用revokeObjectURL等。</p></div>
<div class="block">
<h2 id="getDataOptions">@fn getDataOptions(jo, defVal?)</h2>
<p class="key"><strong>@key <a id="data-options">data-options</a></strong> </p>
<p>读取jo上的data-options属性，返回JS对象。例如：</p>
<pre><code>&lt;div data-options="a:1,b:'hello',c:true"&gt;&lt;/div&gt;</code></pre>
<p>上例可返回 <code>{a:1, b:'hello', c:true}</code>.</p>
<p>也支持各种表达式及函数调用，如：</p>
<pre><code>&lt;div data-options="getSomeOption()"&gt;&lt;/div&gt;</code></pre>
<p class="see"><strong>@see <a href="#getOptions">getOptions</a></strong> </p></div>
<div class="block">
<h2 id="triggerAsync">@fn triggerAsync(jo, ev, paramArr)</h2>
<p>触发含有异步操作的事件，在异步事件完成后继续。兼容同步事件处理函数，或多个处理函数中既有同步又有异步。<br />
返回Deferred对象，或false表示要求取消之后操作。</p>
<p class="param"><strong>@param ev</strong>  事件名，或事件对象$.Event()</p>
<p>示例：以事件触发方式调用jo的异步方法submit:</p>
<pre><code>var dfd = WUI.triggerAsync(jo, 'submit');
if (dfd === false)
    return;
dfd.then(doNext);

function doNext() { }</code></pre>
<p>jQuery对象这样提供异步方法：triggerAsync会用事件对象ev创建一个dfds数组，将Deferred对象存入即可支持异步调用。</p>
<pre><code>jo.on('submit', function (ev) {
    var dfd = $.ajax("upload", ...);
    if (ev.dfds)
        ev.dfds.push(dfd);
});</code></pre></div>
<div class="block">
<h2 id="$.Deferred">@fn $.Deferred</h2>
<p class="alias"><strong>@alias <a id="Promise">Promise</a></strong> </p>
<p>兼容Promise的接口，如then/catch/finally</p></div>
<div class="block">
<h2 id="evalAttr">@fn evalAttr(jo, name)</h2>
<p>返回一个属性做eval后的js值。</p>
<p>示例：读取一个对象值：</p>
<pre><code>var opt = evalAttr(jo, "data-opt");

&lt;div data-opt="{id:1, name:\"data1\"}"&gt;&lt;div&gt;</code></pre>
<p>考虑兼容性，也支持忽略括号的写法，</p>
<pre><code>&lt;div data-opt="id:1, name:\"data1\""&gt;&lt;div&gt;</code></pre>
<p>读取一个数组：</p>
<pre><code>var arr = evalAttr(jo, "data-arr");

&lt;div data-arr="['aa', 'bb']"&gt;&lt;div&gt;</code></pre>
<p>读取一个函数名（或变量）:</p>
<pre><code>var fn = evalAttr(jo, "mui-initfn");

&lt;div mui-initfn="initMyPage"&gt;&lt;div&gt;</code></pre></div>
<div class="block">
<h2 id="app_abort">@fn app_abort()</h2>
<p>中止之后的调用, 直接返回.</p></div>
<div class="block">
<h2 id="DirectReturn">@class DirectReturn</h2>
<p>直接返回. 用法:</p>
<pre><code>throw new DirectReturn();</code></pre>
<p>可直接调用app_abort();</p></div>
<div class="block">
<h2 id="setOnError">@fn setOnError()</h2>
<p>一般框架自动设置onerror函数；如果onerror被其它库改写，应再次调用该函数。<br />
allow throw(&quot;abort&quot;) as abort behavior.</p></div>
<div class="block">
<h2 id="m_enhanceFn">@var m_enhanceFn</h2></div>
<div class="block">
<h2 id="enhanceWithin">@fn enhanceWithin(jparent)</h2></div>
<div class="block">
<h2 id="getOptions">@fn getOptions(jo, defVal?)</h2>
<p>第一次调用，根据jo上设置的data-options属性及指定的defVal初始化，或为<code>{}</code>。<br />
存到jo.prop(&quot;muiOptions&quot;)上。之后调用，直接返回该属性。</p>
<p class="see"><strong>@see <a href="#getDataOptions">getDataOptions</a></strong> </p></div>
<div class="block">
<h2 id="getQueryCond">@fn getQueryCond(kvList)</h2>
<p class="var"><strong>@var <a id="queryHint">queryHint</a></strong>  查询用法提示</p>
<p class="param"><strong>@param kvList</strong>  {key=>value}, 键值对，值中支持操作符及通配符。也支持格式 [ [key, value] ], 这时允许key有重复。</p>
<p>根据kvList生成BPQ协议定义的{obj}.query的cond参数。</p>
<p>例如:</p>
<pre><code>var kvList = {phone: "13712345678", id: "&gt;100", addr: "上海*", picId: "null"};
WUI.getQueryCond(kvList);</code></pre>
<p>有多项时，每项之间以&quot;AND&quot;相连，以上定义将返回如下内容：</p>
<pre><code>"phone='13712345678' AND id&gt;100 AND addr LIKE '上海*' AND picId IS NULL"</code></pre>
<p>示例二：</p>
<pre><code>var kvList = [ ["phone", "13712345678"], ["id", "&gt;100"], ["addr", "上海*"], ["picId", "null"] ];
WUI.getQueryCond(kvList); // 结果同上。</code></pre>
<p>设置值时，支持以下格式：</p>
<ul>
<li>{key: &quot;value&quot;} - 表示&quot;key=value&quot;</li>
<li>{key: &quot;&gt;value&quot;} - 表示&quot;key&gt;value&quot;, 类似地，可以用 &gt;=, &lt;, &lt;=, <>(或! / != 都是不等于) 这些操作符。</li>
<li>{key: &quot;value<em>&quot;} - 值中带通配符，表示&quot;key like 'value%'&quot; (以value开头), 类似地，可以用 &quot;</em>value&quot;, &quot;<em>value</em>&quot;, &quot;<em>val</em>ue&quot;等。</li>
<li>{key: &quot;null&quot; } - 表示 &quot;key is null&quot;。要表示&quot;key is not null&quot;，可以用 &quot;<>null&quot;.</li>
<li>{key: &quot;empty&quot; } - 表示 &quot;key=''&quot;.</li>
</ul>
<p>支持and/or查询，但不支持在其中使用括号:</p>
<ul>
<li>{key: &quot;&gt;value and &lt;=value&quot;}  - 表示&quot;key&gt;'value' and key&lt;='value'&quot;</li>
<li>{key: &quot;null or 0 or 1&quot;}  - 表示&quot;key is null or key=0 or key=1&quot;</li>
<li>{key: &quot;null,0,1,9-100&quot;} - 表示&quot;key is null or key=0 or key=1 or (key&gt;=9 and key&lt;=100)&quot;，即逗号表示or，a-b的形式只支持数值。</li>
<li>{key: &quot;2017-9-1~2017-10-1&quot;} 条件等价于 &quot;&gt;=2017-9-1 and &lt;2017-10-1&quot;<br />
可指定时间，如条件&quot;2017-9-1 10:00~2017-10-1&quot;等价于&quot;&gt;=2017-9-1 10:00 and &lt;2017-10-1&quot;</li>
<li>符号&quot;,&quot;及&quot;~&quot;前后允许有空格，如&quot;已付款, 已完成&quot;, &quot;2017-1-1 ~ 2018-1-1&quot;</li>
<li>可以使用中文逗号</li>
<li>日期区间也可以用&quot;2017/10/01&quot;或&quot;2017.10.01&quot;这些格式，仅用于字段是文本类型，这时输入格式必须与保存的日期格式一致，并且&quot;2017/10/1&quot;应输入&quot;2017/10/01&quot;才能正确比较字符串大小。</li>
</ul>
<p>以下表示的范围相同：</p>
<pre><code>{k1:'1-5,7-10', k2:'1-10 and &lt;&gt;6'}</code></pre>
<p>符号优先级依次为：&quot;-&quot;(类似and) &quot;,&quot;(类似or) and or</p>
<p>在详情页对话框中，切换到查找模式，在任一输入框中均可支持以上格式。</p>
<p>(v5.5) value支持用数组表示范围（前闭后开区间），主要内部使用：</p>
<pre><code>var cond = getQueryCond({tm: ["2019-1-1", "2020-1-1"]}); // 生成 "tm&gt;='2019-1-1' AND tm&lt;'2020-1-1'"
var cond = getQueryCond({tm: [null, "2020-1-1"]}); // 生成 "tm&lt;'2020-1-1'"
var cond = getQueryCond({tm: [null, null]); // 返回null</code></pre>
<p class="see"><strong>@see <a href="#getQueryParam">getQueryParam</a></strong> </p>
<p class="see"><strong>@see <a href="#getQueryParamFromTable">getQueryParamFromTable</a></strong>  获取datagrid的当前查询参数</p>
<p class="see"><strong>@see <a href="#doFind">doFind</a></strong> </p>
<p>(v5.5) 支持在key中包含查询提示。如&quot;code/s&quot;表示不要自动猜测数值区间或日期区间。<br />
比如输入'126231-191024'时不会当作查询126231到191024的区间。</p>
<p>(v6) 日期、时间字段查询时，可使用<code>WUI.getTmRange</code>函数支持的时间区间如&quot;今天&quot;，&quot;本周&quot;，&quot;本月&quot;, &quot;今年&quot;, &quot;近3天(小时|周|月|季度|年)”，&quot;前3天(小时|周|月|季度|年)”等。</p>
<p class="see"><strong>@see <a href="#wui-find-hint">wui-find-hint</a></strong> </p></div>
<div class="block">
<h2 id="getQueryParam">@fn getQueryParam(kvList)</h2>
<p>根据键值对生成BQP协议中{obj}.query接口需要的cond参数.<br />
即 <code>{cond: WUI.getQueryCond(kvList) }</code></p>
<p>示例：</p>
<pre><code>WUI.getQueryParam({phone: '13712345678', id: '&gt;100'})
返回
{cond: "phone='13712345678' AND id&gt;100"}</code></pre>
<p class="see"><strong>@see <a href="#getQueryCond">getQueryCond</a></strong> </p>
<p class="see"><strong>@see <a href="#getQueryParamFromTable">getQueryParamFromTable</a></strong>  获取datagrid的当前查询参数</p></div>
<div class="block">
<h2 id="doSpecial">@fn doSpecial(jo, filter, fn, cnt=5, interval=2s)</h2>
<p>连续5次点击某处，每次点击间隔不超过2s, 执行隐藏动作。</p>
<p>例：<br />
// 连续5次点击当前tab标题，重新加载页面. ev为最后一次点击事件.<br />
var self = WUI;<br />
self.doSpecial(self.tabMain.find(&quot;.tabs-header&quot;), &quot;.tabs-selected&quot;, function (ev) {<br />
self.reloadPage();<br />
self.reloadDialog(true);</p>
<pre><code>    // 弹出菜单
    //jmenu.menu('show', {left: ev.pageX, top: ev.pageY});
    return false;
});</code></pre>
<p>连续3次点击对话框中的字段标题，触发查询：</p>
<pre><code>WUI.doSpecial(jdlg, ".wui-form-table td", fn, 3);</code></pre></div>
<div class="block">
<h2 id="lastError">@var lastError = ctx</h2>
<p>出错时，取出错调用的上下文信息。</p>
<p>ctx: {ac, tm, tv, ret}</p>
<ul>
<li>ac: action 调用接口名</li>
<li>tm: start time 开始调用时间</li>
<li>tv: time interval 从调用到返回的耗时</li>
<li>ret: return value 调用返回的原始数据</li>
</ul></div>
<div class="block">
<h2 id="disableBatch">@var disableBatch ?= false</h2>
<p>设置为true禁用batchCall, 仅用于内部测试。</p></div>
<div class="block">
<h2 id="m_curBatch">@var m_curBatch</h2>
<p>当前batchCall对象，用于内部调试。</p></div>
<div class="block">
<h2 id="mockData">@var mockData  模拟调用后端接口。</h2>
<p>在后端接口尚无法调用时，可以配置MUI.mockData做为模拟接口返回数据。<br />
调用callSvr时，会直接使用该数据，不会发起ajax请求。</p>
<p>mockData={ac =&gt; data/fn}  </p>
<p>mockData中每项可以直接是数据，也可以是一个函数：fn(param, postParam)-&gt;data</p>
<p>例：模拟&quot;User.get(id)&quot;和&quot;User.set()(key=value)&quot;接口：</p>
<pre><code>var user = {
    id: 1001,
    name: "孙悟空",
};
MUI.mockData = {
    // 方式1：直接指定返回数据
    "User.get": [0, user],

    // 方式2：通过函数返回模拟数据
    "User.set": function (param, postParam) {
        $.extend(user, postParam);
        return [0, "OK"];
    }
}

// 接口调用：
var user = callSvrSync("User.get");
callSvr("User.set", {id: user.id}, function () {
    alert("修改成功！");
}, {name: "大圣"});</code></pre>
<p>实例详见文件 mockdata.js。</p>
<p>在mockData的函数中，可以用this变量来取ajax调用参数。<br />
要取HTTP动词可以用<code>this.type</code>，值为GET/POST/PATCH/DELETE之一，从而可模拟RESTful API.</p>
<p>可以通过MUI.options.mockDelay设置模拟调用接口的网络延时。</p>
<p class="see"><strong>@see <a href="#options.mockDelay">options.mockDelay</a></strong> </p>
<p>模拟数据可直接返回[code, data]格式的JSON数组，框架会将其序列化成JSON字符串，以模拟实际场景。<br />
如果要查看调用与返回数据日志，可在浏览器控制台中设置 MUI.options.logAction=true，在控制台中查看日志。</p>
<p>如果设置了MUI.callSvrExt，调用名(ac)中应包含扩展(ext)的名字，例：</p>
<pre><code>MUI.callSvrExt['zhanda'] = {...};
callSvr(['token/get-token', 'zhanda'], ...);</code></pre>
<p>要模拟该接口，应设置</p>
<pre><code>MUI.mockData["zhanda:token/get-token"] = ...;</code></pre>
<p class="see"><strong>@see <a href="#callSvrExt">callSvrExt</a></strong> </p>
<p>也支持&quot;default&quot;扩展，如：</p>
<pre><code>MUI.callSvrExt['default'] = {...};
callSvr(['token/get-token', 'default'], ...);
或
callSvr('token/get-token', ...);</code></pre>
<p>要模拟该接口，可设置</p>
<pre><code>MUI.mockData["token/get-token"] = ...;</code></pre></div>
<div class="block">
<h2 id="$.ajax">@key $.ajax</h2>
<p class="key"><strong>@key <a id="ajaxOpt.jdFilter">ajaxOpt.jdFilter</a></strong>  禁用返回格式合规检查.</p>
<p>以下调用, 如果1.json符合<code>[code, data]</code>格式, 则只返回处理data部分; 否则将报协议格式错误:</p>
<pre><code>$.ajax("1.json", {dataType: "json"})
$.get("1.json", null, console.log, "json")
$.getJSON("1.json", null, console.log)</code></pre>
<p>对于ajax调用($.ajax,$.get,$.post,$.getJSON等), 若明确指定dataType为&quot;json&quot;或&quot;text&quot;, 且未指定jdFilter为false,<br />
则框架按筋斗云返回格式即<code>[code, data]</code>来处理只返回data部分, 不符合该格式, 则报协议格式错误.</p>
<p>以下调用未指定dataType, 或指定了jdFilter=false, 则不会应用筋斗云协议格式:</p>
<pre><code>$.ajax("1.json")
$.get("1.json", null, console.log)
$.ajax("1.json", {jdFilter: false}) // jdFilter选项明确指定了不应用筋斗云协议格式</code></pre></div>
<div class="block">
<h2 id="enterWaiting">@fn enterWaiting(ctx?)</h2>
<p class="param"><strong>@param ctx</strong>  {ac, tm, tv?, tv2?, noLoadingImg?}</p></div>
<div class="block">
<h2 id="leaveWaiting">@fn leaveWaiting(ctx?)</h2></div>
<div class="block">
<h2 id="defDataProc">@fn defDataProc(rv)</h2>
<p class="param"><strong>@param rv</strong>  BQP协议原始数据，如 "[0, {id: 1}]"，一般是字符串，也可以是JSON对象。</p>
<p class="return"><strong>@return data</strong>  按接口定义返回的数据对象，如 {id: 1}. 如果返回值===RV_ABORT，调用函数应直接返回，不回调应用层。</p>
<p>注意：如果callSvr设置了<code>noex:1</code>选项，则当调用失败时返回false。</p></div>
<div class="block">
<h2 id="getBaseUrl">@fn getBaseUrl()</h2>
<p>取服务端接口URL对应的目录。可用于拼接其它服务端资源。<br />
相当于dirname(MUI.options.serverUrl);</p>
<p>例如：</p>
<p>serverUrl为&quot;../jdcloud/api.php&quot; 或 &quot;../jdcloud/&quot;，则MUI.baseUrl返回 &quot;../jdcloud/&quot;<br />
serverUrl为&quot;<a href="http://myserver/myapp/api.php">http://myserver/myapp/api.php</a>&quot; 或 &quot;<a href="http://myserver/myapp/"，则MUI.baseUrl返回">http://myserver/myapp/"，则MUI.baseUrl返回</a> &quot;<a href="http://myserver/myapp/">http://myserver/myapp/</a>&quot;</p></div>
<div class="block">
<h2 id="makeUrl">@fn makeUrl(action, params?)</h2>
<p>生成对后端调用的url. </p>
<pre><code>var params = {id: 100};
var url = MUI.makeUrl("Ordr.set", params);</code></pre>
<p>注意：函数返回的url是字符串包装对象，可能含有这些属性：{makeUrl=true, action?, params?}<br />
这样可通过url.action得到原始的参数。</p>
<p>支持callSvr扩展，如：</p>
<pre><code>var url = MUI.makeUrl('zhanda:login');</code></pre>
<p>(deprecated) 为兼容旧代码，action可以是一个数组，在WUI环境下表示对象调用:</p>
<pre><code>WUI.makeUrl(['Ordr', 'query']) 等价于 WUI.makeUrl('Ordr.query');</code></pre>
<p>在MUI环境下表示callSvr扩展调用:</p>
<pre><code>MUI.makeUrl(['login', 'zhanda']) 等价于 MUI.makeUrl('zhanda:login');</code></pre>
<p>特别地, 如果action是相对路径, 或是'.php'文件, 则不会自动拼接WUI.options.serverUrl:</p>
<pre><code>callSvr("./1.json"); // 如果是callSvr("1.json") 则url可能是 "../api.php/1.json"这样.
callSvr("./1.php");</code></pre>
<p class="see"><strong>@see <a href="#callSvrExt">callSvrExt</a></strong> </p></div>
<div class="block">
<h2 id="callSvr">@fn callSvr(ac, [params?], fn?, postParams?, userOptions?) -> deferredObject</h2><div class="toc"><p style="margin-left:0em"><a href="#callSvr-1 调用监控">1 调用监控</a></p>
<p style="margin-left:0em"><a href="#callSvr-2 文件上传支持(FormData)">2 文件上传支持(FormData)</a></p>
<p style="margin-left:0em"><a href="#callSvr-3 callSvr扩展">3 callSvr扩展</a></p>
<p style="margin-left:0em"><a href="#callSvr-4 适配RESTful API">4 适配RESTful API</a></p>
<p style="margin-left:0em"><a href="#callSvr-5 ES6支持：jQuery的$.Deferred兼容Promise接口 / 使用await">5 ES6支持：jQuery的$.Deferred兼容Promise接口 / 使用await</a></p>
<p style="margin-left:0em"><a href="#callSvr-6 直接取json类文件">6 直接取json类文件</a></p>
</div>
<p class="param"><strong>@param ac</strong>  String. action, 交互接口名. 也可以是URL(比如由makeUrl生成)</p>
<p class="param"><strong>@param params</strong>  Object. URL参数（或称HTTP GET参数）</p>
<p class="param"><strong>@param postParams</strong>  Object. POST参数. 如果有该参数, 则自动使用HTTP POST请求(postParams作为POST内容), 否则使用HTTP GET请求.</p>
<p class="param"><strong>@param fn</strong>  Function(data). 回调函数, data参考该接口的返回值定义。</p>
<p class="param"><strong>@param userOptions</strong>  用户自定义参数, 会合并到$.ajax调用的options参数中.可在回调函数中用"this.参数名"引用. </p>
<p>常用userOptions: </p>
<ul>
<li>指定{async:0}来做同步请求, 一般直接用callSvrSync调用来替代.</li>
<li>指定{noex:1}用于忽略错误处理。</li>
<li>指定{noLoadingImg:1} 静默调用，忽略loading图标，不设置busy状态。</li>
</ul>
<p>指定contentType和设置自定义HTTP头(headers)示例:</p>
<pre><code>var opt = {
    contentType: "text/xml",
    headers: {
        Authorization: "Basic aaa:bbb"
    }
};
callSvr("hello", $.noop, "&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;return&gt;&lt;code&gt;0&lt;/code&gt;&lt;/return&gt;", opt);</code></pre>
<p>想为ajax选项设置缺省值，可以用callSvrExt中的beforeSend回调函数，也可以用$.ajaxSetup，<br />
但要注意：ajax的dataFilter/beforeSend选项由于框架已用，最好不要覆盖。</p>
<p class="see"><strong>@see <a href="#callSvrExt[].beforeSend">callSvrExt[].beforeSend</a></strong> (opt) 为callSvr选项设置缺省值</p>
<p class="return"><strong>@return deferred对象，在Ajax调用成功后回调。</strong> </p>
<p>例如，</p>
<pre><code>var dfd = callSvr(ac, fn1);
dfd.then(fn2);

function fn1(data) {}
function fn2(data) {}</code></pre>
<p>在接口调用成功后，会依次回调fn1, fn2. 在回调函数中this表示ajax参数。例如：</p>
<pre><code>callSvr(ac, function (data) {
    // 可以取到传入的参数。
    console.log(this.key1);
}, null, {key1: 'val1'});</code></pre>
<p>(v5.4) 支持失败时回调：</p>
<pre><code>var dfd = callSvr(ac);
dfd.fail(function (data) {
    console.log('error', data);
    console.log(this.ctx_.ret); // 和设置选项{noex:1}时回调中取MUI.lastError.ret 或 this.lastError相同。
});</code></pre>
<p class="key"><strong>@key <a id="callSvr.noex">callSvr.noex</a></strong>  调用接口时忽略出错，可由回调函数fn自己处理错误。</p>
<p>当后端返回错误时, 回调<code>fn(false)</code>（参数data=false）. 可通过 MUI.lastError.ret 或 this.lastError 取到返回的原始数据。</p>
<p>示例：</p>
<pre><code>callSvr("logout");
callSvr("logout", api_logout);
function api_logout(data) {}

callSvr("login", api_login);
function api_login(data) {}

callSvr("info/hotline.php", {q: '大众'}, api_hotline);
function api_hotline(data) {}

// 也可使用makeUrl生成的URL如:
callSvr(MUI.makeUrl("logout"), api_logout);
callSvr(MUI.makeUrl("logout", {a:1}), api_logout);

callSvr("User.get", function (data) {
    if (data === false) { // 仅当设置noex且服务端返回错误时可返回false
        // var originalData = MUI.lastError.ret; 或
        // var originalData = this.lastError;
        return;
    }
    foo(data);
}, null, {noex:1});</code></pre>
<p class="see"><strong>@see <a href="#lastError">lastError</a></strong>  出错时的上下文信息</p>
<h4 id="callSvr-1 调用监控">1 调用监控</h4>
<p>框架会自动在ajaxOption中增加ctx_属性，它包含 {ac, tm, tv, tv2, ret} 这些信息。<br />
当设置MUI.options.logAction=1时，将输出这些信息。</p>
<ul>
<li>ac: action</li>
<li>tm: start time</li>
<li>tv: time interval (从发起请求到服务器返回数据完成的时间, 单位是毫秒)</li>
<li>tv2: 从接到数据到完成处理的时间，毫秒(当并发处理多个调用时可能不精确)</li>
</ul>
<h4 id="callSvr-2 文件上传支持(FormData)">2 文件上传支持(FormData)</h4>
<p>callSvr支持FormData对象，可用于上传文件等场景。示例如下：</p>
<p class="key"><strong>@key <a id="example-upload">example-upload</a></strong> </p>
<p>HTML:</p>
<pre><code>file: &lt;input id="file1" type="file" multiple&gt;
&lt;button type="button" id="btn1"&gt;upload&lt;/button&gt;</code></pre>
<p>JS:</p>
<pre><code>jpage.find("#btn1").on('click', function () {
    var fd = new FormData();
    $.each(jpage.find('#file1')[0].files, function (i, e) {
        fd.append('file' + (i+1), e);
    });
    callSvr('upload', api_upload, fd);

    function api_upload(data) { ... }
});</code></pre>
<h4 id="callSvr-3 callSvr扩展">3 callSvr扩展</h4>
<p class="key"><strong>@key <a id="callSvrExt">callSvrExt</a></strong> </p>
<p>当调用第三方API时，也可以使用callSvr扩展来代替$.ajax调用以实现：</p>
<ul>
<li>调用成功时直接可操作数据，不用每次检查返回码；</li>
<li>调用出错时可以统一处理。</li>
</ul>
<p>例：合作方接口使用HTTP协议，格式如（以生成token调用为例）</p>
<pre><code>http://&lt;Host IP Address&gt;:&lt;Host Port&gt;/lcapi/token/get-token?user=用户名&amp;password=密码</code></pre>
<p>返回格式为：{code, msg, data}</p>
<p>成功返回：</p>
<pre><code>{
    "code":"0",
    "msg":"success",
    "data":[ { "token":"xxxxxxxxxxxxxx" } ]
}</code></pre>
<p>失败返回：</p>
<pre><code>{
    "code":"4001",
    "msg":"invalid username or password",
    "data":[]
}</code></pre>
<p>callSvr扩展示例：</p>
<pre><code>MUI.callSvrExt['zhanda'] = {
    makeUrl: function(ac, param) {
        // 只需要返回接口url即可，不必拼接param
        return 'http://hostname/lcapi/' + ac;
    },
    dataFilter: function (data) {
        if ($.isPlainObject(data) &amp;&amp; data.code !== undefined) {
            if (data.code == 0)
                return data.data;
            if (this.noex)
                return false;
            app_alert("操作失败：" + data.msg, "e");
        }
        else {
            app_alert("服务器通讯协议异常!", "e"); // 格式不对
        }
    }
};</code></pre>
<p>在调用时，ac参数使用&quot;{扩展名}:{调用名}&quot;的格式：</p>
<pre><code>callSvr('zhanda:token/get-token', {user: 'test', password: 'test123'}, function (data) {
    console.log(data);
});</code></pre>
<p>旧的调用方式ac参数使用数组，现在已不建议使用：</p>
<pre><code>callSvr(['token/get-token', 'zhanda'], ...);</code></pre>
<p class="key"><strong>@key <a id="callSvrExt[].makeUrl">callSvrExt[].makeUrl</a></strong> (ac, param)</p>
<p>根据调用名ac生成url, 注意无需将param放到url中。</p>
<p>注意：<br />
对方接口应允许JS跨域调用，或调用方支持跨域调用。</p>
<p class="key"><strong>@key <a id="callSvrExt[].dataFilter">callSvrExt[].dataFilter</a></strong> (data) = null/false/data</p>
<p>对调用返回数据进行通用处理。返回值决定是否调用callSvr的回调函数以及参数值。</p>
<pre><code>callSvr(ac, callback);</code></pre>
<ul>
<li>返回data: 回调应用层的实际有效数据: <code>callback(data)</code>.</li>
<li>返回null: 一般用于报错后返回。不会回调<code>callback</code>.</li>
<li>返回false: 一般与callSvr的noex选项合用，如<code>callSvr(ac, callback, postData, {noex:1})</code>，表示由应用层回调函数来处理出错: <code>callback(false)</code>。</li>
</ul>
<p>当返回false时，应用层可以通过<code>MUI.lastError.ret</code>来获取服务端返回数据。</p>
<p class="see"><strong>@see <a href="#lastError">lastError</a></strong>  出错时的上下文信息</p>
<p class="key"><strong>@key <a id="callSvrExt['default']">callSvrExt['default']</a></strong> </p>
<p>(支持版本: v3.1)<br />
如果要修改callSvr缺省调用方法，可以改写 MUI.callSvrExt['default']。示例：</p>
<pre><code>MUI.callSvrExt['default'] = {
    makeUrl: function(ac) {
        return '../api.php/' + ac;
    },
    dataFilter: function (data) {
        var ctx = this.ctx_ || {};
        if (data &amp;&amp; $.isArray(data) &amp;&amp; data.length &gt;= 2 &amp;&amp; typeof data[0] == "number") {
            if (data[0] == 0)
                return data[1];

            if (this.noex)
            {
                return false;
            }

            if (data[0] == E_NOAUTH) {
                // 如果支持自动重登录
                //if (MUI.tryAutoLogin()) {
                //  $.ajax(this);
                //}
                // 不支持自动登录，则跳转登录页
                MUI.popPageStack(0);
                MUI.showLogin();
                return;
            }
            else if (data[0] == E_AUTHFAIL) {
                app_alert("验证失败，请检查输入是否正确!", "e");
                return;
            }
            else if (data[0] == E_ABORT) {
                console.log("!!! abort call");
                return;
            }
            logError();
            app_alert("操作失败：" + data[1], "e");
        }
        else {
            logError();
            app_alert("服务器通讯协议异常!", "e"); // 格式不对
        }

        function logError()
        {
            console.log("failed call");
            console.log(ctx);
        }
    }
};</code></pre>
<p class="key"><strong>@key <a id="callSvrExt[].beforeSend">callSvrExt[].beforeSend</a></strong> (opt) 为callSvr或$.ajax选项设置缺省值</p>
<p>如果有ajax选项想设置，可以使用beforeSend回调，例如POST参数使用JSON格式：</p>
<pre><code>MUI.callSvrExt['default'] = {
    beforeSend: function (opt) {
        // 示例：设置contentType
        if (opt.contentType == null) {
            opt.contentType = "application/json;charset=utf-8";
        }
        // 示例：添加HTTP头用于认证
        if (g_data.auth) {
            if (opt.headers == null)
                opt.headers = {};
            opt.headers["Authorization"] = "Basic " + g_data.auth;
        }
    }
}</code></pre>
<p>可以从opt.ctx<em>中取到{ac, ext, noex, dfd}等值（如opt.ctx</em>.ac），可以从opt.url中取到{ac, params}值。</p>
<p>如果要设置请求的HTTP headers，可以用<code>opt.headers = {header1: "value1", header2: "value2"}</code>.<br />
更多选项参考jquery文档：jQuery.ajax的选项。</p>
<h4 id="callSvr-4 适配RESTful API">4 适配RESTful API</h4>
<p>接口示例：更新订单</p>
<pre><code>PATCH /orders/{ORDER_ID}

调用成功仅返回HTTP状态，无其它内容："200 OK" 或 "204 No Content"
调用失败返回非2xx的HTTP状态及错误信息，无其它内容，如："400 bad id"</code></pre>
<p>为了处理HTTP错误码，应设置：</p>
<pre><code>MUI.callSvrExt["default"] = {
    beforeSend: function (opt) {
        opt.handleHttpError = true;
    },
    dataFilter: function (data) {
        var ctx = this.ctx_;
        if (ctx &amp;&amp; ctx.status) {
            if (this.noex)
                return false;
            app_alert(ctx.statusText, "e");
            return;
        }
        return data;
    }
}</code></pre>
<ul>
<li>在beforeSend回调中，设置handleHttpError为true，这样HTTP错误会由dataFilter处理，而非框架自动处理。</li>
<li>在dataFilter回调中，如果this.ctx<em>.status非空表示是HTTP错误，this.ctx</em>.statusText为错误信息。</li>
<li>如果操作成功但无任何返回数据，回调函数fn(data)中data值为undefined（当HTTP状态码为204）或空串（非204返回）</li>
<li>不要设置ajax调用失败的回调，如<code>$.ajaxSetup({error: fn})</code>，<code>$.ajax({error: fn})</code>，它会覆盖框架的处理.</li>
</ul>
<p>如果接口在出错时，返回固定格式的错误对象如{code, message}，可以这样处理：</p>
<pre><code>MUI.callSvrExt["default"] = {
    beforeSend: function (opt) {
        opt.handleHttpError = true;
    },
    dataFilter: function (data) {
        var ctx = this.ctx_;
        if (ctx &amp;&amp; ctx.status) {
            if (this.noex)
                return false;
            if (data &amp;&amp; data.message) {
                app_alert(data.message, "e");
            }
            else {
                app_alert("操作失败: 服务器错误. status=" + ctx.status + "-" + ctx.statusText, "e");
            }
            return;
        }
        return data;
    }
}</code></pre>
<p>调用接口时，HTTP谓词可以用callSvr的userOptions中给定，如：</p>
<pre><code>callSvr("orders/" + orderId, fn, postParam, {type: "PATCH"});</code></pre>
<p>这种方式简单，但因调用名ac是变化的，不易模拟接口。<br />
如果要模拟接口，可以保持调用名ac不变，像这样调用：</p>
<pre><code>callSvr("orders/{id}", {id: orderId}, fn, postParam, {type: "PATCH"});</code></pre>
<p>于是可以这样做接口模拟：</p>
<pre><code>MUI.mockData = {
    "orders/{id}": function (param, postParam) {
        var ret = "OK";
        // 获取资源
        if (this.type == "GET") {
            ret = orders[param.id];
        }
        // 更新资源
        else if (this.type == "PATCH") {
            $.extend(orders[param.id], postParam);
        }
        // 删除资源
        else if (this.type == "DELETE") {
            delete orders[param.id];
        }
        return [0, ret];
    }
};</code></pre>
<p>不过这种写法需要适配，以生成正确的URL，示例：</p>
<pre><code>MUI.callSvrExt["default"] = {
    makeUrl: function (ac, param) {
        ac = ac.replace(/\{(\w+)\}/g, function (m, m1) {
            var ret = param[m1];
            assert(ret != null, "缺少参数");
            delete param[m1];
            return ret;
        });
        return "./api.php/" + ac;
    }
}</code></pre>
<h4 id="callSvr-5 ES6支持：jQuery的$.Deferred兼容Promise接口 / 使用await">5 ES6支持：jQuery的$.Deferred兼容Promise接口 / 使用await</h4>
<p>支持Promise/Deferred编程风格:</p>
<pre><code>var dfd = callSvr("...");
dfd.then(function (data) {
    console.log(data);
})
.catch(function (err) {
    app_alert(err);
})
.finally(...)</code></pre>
<p>支持catch/finally等Promise类接口。接口逻辑失败时，dfd.reject()触发fail/catch链。</p>
<p>支持await编程风格，上例可写为：</p>
<pre><code>// 使用await时callSvr调用失败是无法返回的，加{noex:1}选项可让失败时返回false
var rv = callSvr("...", $.noop, null, {noex:1});
if (rv === false) {
    // 失败逻辑 dfd.catch. 取错误信息用WUI.lastError={ac, tm, tv, ret}
    console.log(WUI.lastError.ret)
}
else {
    // 成功逻辑 dfd.then
}
// finally逻辑</code></pre>
<p>示例：</p>
<pre><code>let rv = await callSvr("Ordr.query", {res:"count(*) cnt", fmt:"one"})
let cnt = rv.cnt</code></pre>
<h4 id="callSvr-6 直接取json类文件">6 直接取json类文件</h4>
<p>(v5.5) 如果ac是调用相对路径, 则直接当成最终路径, 不做url拼接处理:</p>
<pre><code>callSvr("./1.json"); // 如果是callSvr("1.json") 则实际url可能是 "../api.php/1.json"这样.
callSvr("../1.php");</code></pre>
<p>相当于调用</p>
<pre><code>$.ajax("../1.php", {dataType: "json", success: callback})
或
$.getJSON("../1.php", callback);</code></pre>
<p>注意下面调用未指定dataType, 不会按筋斗云协议格式处理:</p>
<pre><code>$.ajax("../1.php", {success: callback})</code></pre>
<p class="see"><strong>@see <a href="#$.ajax">$.ajax</a></strong> </p></div>
<div class="block">
<h2 id="callSvrSync">@fn callSvrSync(ac, [params?], fn?, postParams?, userOptions?)</h2>
<p class="return"><strong>@return data</strong>  原型规定的返回数据</p>
<p>同步模式调用callSvr.</p>
<p class="see"><strong>@see <a href="#callSvr">callSvr</a></strong> </p></div>
<div class="block">
<h2 id="setupCallSvrViaForm">@fn setupCallSvrViaForm($form, $iframe, url, fn, callOpt)</h2>
<p>该方法已不建议使用。上传文件请用FormData。</p>
<p class="see"><strong>@see <a href="#example-upload">example-upload</a> <a href="#callSvr">callSvr</a></strong> </p>
<p class="param"><strong>@param $iframe</strong>  一个隐藏的iframe组件.</p>
<p class="param"><strong>@param callOpt</strong>  用户自定义参数. 参考callSvr的同名参数. e.g. {noex: 1}</p>
<p>一般对后端的调用都使用callSvr函数, 但像上传图片等操作不方便使用ajax调用, 因为要自行拼装multipart/form-data格式的请求数据.<br />
这种情况下可以使用form的提交和一个隐藏的iframe来实现类似的调用.</p>
<p>先定义一个form, 在其中放置文件上传控件和一个隐藏的iframe. form的target属性设置为iframe的名字:</p>
<pre><code>&lt;form data-role="content" action="upload" method=post enctype="multipart/form-data" target="ifrUpload"&gt;
    &lt;input type=file name="file[]" multiple accept="image/*"&gt;
    &lt;input type=submit value="上传"&gt;
    &lt;iframe id='ifrUpload' name='ifrUpload' style="display:none"&gt;&lt;/iframe&gt;
&lt;/form&gt;</code></pre>
<p>然后就像调用callSvr函数一样调用setupCallSvrViaForm:</p>
<pre><code>var url = MUI.makeUrl("upload", {genThumb: 1});
MUI.setupCallSvrViaForm($frm, $frm.find("iframe"), url, onUploadComplete);
function onUploadComplete(data) 
{
    alert("上传成功");
}</code></pre></div>
<div class="block">
<h2 id="batchCall">@class batchCall(opt?={useTrans?=0})</h2>
<p>批量调用。将若干个调用打包成一个特殊的batch调用发给服务端。<br />
注意：</p>
<ul>
<li>同步调用callSvrSync不会加入批处理。</li>
<li>对特别几个不符合BPQ协议输出格式规范的接口不可使用批处理，如upload, att等接口。</li>
<li>如果MUI.disableBatch=true, 表示禁用批处理。</li>
</ul>
<p>示例：</p>
<pre><code>var batch = new MUI.batchCall();
callSvr("Family.query", {res: "id,name"}, api_FamilyQuery);
callSvr("User.get", {res: "id,phone"}, api_UserGet);
batch.commit();</code></pre>
<p>以上两条调用将一次发送到服务端。<br />
在批处理中，默认每条调用是一个事务，如果想把批处理中所有调用放到一个事务中，可以用useTrans选项：</p>
<pre><code>var batch = new MUI.batchCall({useTrans: 1});
callSvr("Attachment.add", api_AttAdd, {path: "path-1"});
callSvr("Attachment.add", api_AttAdd, {path: "path-2"});
batch.commit();</code></pre>
<p>在一个事务中，所有调用要么成功要么都取消。<br />
任何一个调用失败，会导致它后面所有调用取消执行，且所有已执行的调用会回滚。</p>
<p>参数中可以引用之前结果中的值，引用部分需要用&quot;{}&quot;括起来，且要在opt.ref参数中指定哪些参数使用了引用：</p>
<pre><code>MUI.useBatchCall();
callSvr("..."); // 这个返回值的结果将用于以下调用
callSvr("Ordr.query", {
    res: "id,dscr",
    status: "{$-1.status}",  // 整体替换，结果可以是一个对象
    cond: "id&gt;{$-1.id}" // 部分替换，其结果只能是字符串
}, api_OrdrQuery, {
    ref: ["status", "cond"] // 须在ref中指定需要处理的key
});</code></pre>
<p>特别地，当get/post整个是一个字符串时，直接整体替换，无须在ref中指定，如：</p>
<pre><code>callSvr("Ordr.add", $.noop, "{$-1}", {contentType:"application/json"});</code></pre>
<p>以下为引用格式示例：</p>
<pre><code>{$1} // 第1次调用的结果。
{$-1} // 前1次调用的结果。
{$-1.path} // 取前一次调用结果的path属性
{$1[0]} // 取第1次调用结果（是个数组）的第0个值。
{$1[0].amount}
{$-1.price * $-1.qty} // 可以做简单的数值计算</code></pre>
<p>如果值计算失败，则当作&quot;null&quot;填充。</p>
<p>综合示例：</p>
<pre><code>MUI.useBatchCall();
callSvr("Ordr.completeItem", $.noop, {itemId:1})
callSvr("Ordr.completeItem", $.noop, {itemId:2, qty:2})
callSvr("Ordr.calc", $.noop, {items:["{$1}", "{$2}"]}, {contentType:"application/json", ref:["items"] });
callSvr("Ordr.add", $.noop, "{$3}", {contentType:"application/json"});</code></pre>
<p class="see"><strong>@see <a href="#useBatchCall">useBatchCall</a></strong> </p>
<p class="see"><strong>@see <a href="#disableBatch">disableBatch</a></strong> </p>
<p class="see"><strong>@see <a href="#m_curBatch">m_curBatch</a></strong> </p></div>
<div class="block">
<h2 id="useBatchCall">@fn useBatchCall(opt?={useTrans?=0}, tv?=0)</h2>
<p>之后的callSvr调用都加入批量操作。例：</p>
<pre><code>MUI.useBatchCall();
callSvr("Family.query", {res: "id,name"}, api_FamilyQuery);
callSvr("User.get", {res: "id,phone"}, api_UserGet);</code></pre>
<p>可指定多少毫秒以内的操作都使用批处理，如10ms内：</p>
<pre><code>MUI.useBatchCall(null, 10);</code></pre>
<p>如果MUI.disableBatch=true, 该函数不起作用。</p>
<p class="see"><strong>@see <a href="#batchCall">batchCall</a></strong> </p>
<p class="see"><strong>@see <a href="#disableBatch">disableBatch</a></strong> </p></div>
<div class="block">
<h2 id="getRow">@fn getRow(jtbl) -> row</h2>
<p>用于列表中选择一行来操作，返回该行数据。如果未选则报错，返回null。</p>
<pre><code>var row = WUI.getRow(jtbl);
if (row == null)
    return;</code></pre></div>
<div class="block">
<h2 id="isTreegrid">@fn isTreegrid(jtbl)</h2>
<p>判断是treegrid还是datagrid。<br />
示例：</p>
<pre><code>var datagrid = WUI.isTreegrid(jtbl)? "treegrid": "datagrid";
var opt = jtbl[datagrid]("options");</code></pre></div>
<div class="block">
<h2 id="reload">@fn reload(jtbl, url?, queryParams?, doAppendFilter?) </h2>
<p>刷新数据表，或用指定查询条件重新查询。</p>
<p>url和queryParams都可以指定查询条件，url通过makeUrl指定查询参数，它是基础查询一般不改变；<br />
queryParams在查询对话框做查询时会被替换、或是点Ctrl-刷新时会被清除；如果doAppendFilter为true时会叠加之前的查询条件。<br />
在明细对话框上三击字段标题可查询，按住Ctrl后三击则是追加查询模式。</p></div>
<div class="block">
<h2 id="reloadTmp">@fn reloadTmp(jtbl, url?, queryParams?) </h2>
<p>临时reload一下，完事后恢复原url</p></div>
<div class="block">
<h2 id="reloadRow">@fn reloadRow(jtbl, rowData?)</h2>
<p class="param"><strong>@param rowData</strong>  通过原始数据指定行，可通过WUI.getRow(jtbl)获取当前所选择的行数据。</p>
<p>rowData如果未指定，则使用当前选择的行。</p>
<p>示例：</p>
<pre><code>var row = WUI.getRow(jtbl);
if (row == null)
    return;
...
WUI.reloadRow(jtbl, row);</code></pre>
<p>如果要刷新整个表，可用WUI.reload(jtbl)。<br />
刷新整个页面可用WUI.reloadPage()，但一般只用于调试，不用于生产环境。</p></div>
<div class="block">
<h2 id="showPage">@fn showPage(pageName, title?, paramArr?)</h2>
<p class="param"><strong>@param pageName</strong>  由page上的class指定。</p>
<p class="param"><strong>@param title</strong> ? 如果未指定，则使用page上的title属性.</p>
<p class="param"><strong>@param paramArr</strong> ? 调用initfn时使用的参数，是一个数组。</p>
<p>新页面以title作为id。<br />
注意：每个页面都是根据pages下相应pageName复制出来的，显示在一个新的tab页中。相同的title当作同一页面。<br />
初始化函数由page上的my-initfn属性指定。</p>
<p>page定义示例: </p>
<pre><code>&lt;div id="my-pages" style="display:none"&gt;
    &lt;div class="pageHome" title="首页" my-initfn="initPageHome"&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>page调用示例:</p>
<pre><code>WUI.showPage("pageHome");
WUI.showPage("pageHome", "我的首页"); // 默认标题是"首页"，这里指定显示标题为"我的首页"。</code></pre>
<p>(v5.4) 如果标题中含有&quot;%s&quot;，将替换成原始标题，同时传参到initPage:</p>
<pre><code>WUI.showPage("pageHome", "%s-" + cityName, [{cityName: cityName}]); //e.g. 显示 "首页-上海"</code></pre>
<p>title用于唯一标识tab，即如果相同title的tab存在则直接切换过去。除非：<br />
(v5.5) 如果标题以&quot;!&quot;结尾, 则每次都打开新的tab页。</p>
<p>(v6) 支持通过paramArr第二参数指定列表页过滤条件(PAGE_FILTER)，示例</p>
<pre><code>WUI.showPage("pageEmployee", "员工", [null, {cond: {status: "在职"}}]);</code></pre>
<p>它直接影响页面中的datagrid的查询条件。</p>
<p>选项<code>_pageFilterOnly</code>用于影响datagrid查询只用page filter的条件。</p>
<pre><code>WUI.showPage("pageEmployee", "员工", [null, {cond: {status: "在职"}, _pageFilterOnly: true}]);</code></pre></div>
<div class="block">
<h2 id="wui-pageFile">@key wui-pageFile</h2>
<p>动态加载的逻辑页(或对话框)具有该属性，值为源文件名。</p></div>
<div class="block">
<h2 id="closeDlg">@fn closeDlg(jdlg)</h2></div>
<div class="block">
<h2 id="isSmallScreen">@fn isSmallScreen</h2>
<p>判断是否为手机小屏显示. 宽度低于640当作小屏处理.</p></div>
<div class="block">
<h2 id="showDlg">@fn showDlg(jdlg, opt?)</h2><div class="toc"><p style="margin-left:0em"><a href="#showDlg-1 对话框加载">1 对话框加载</a></p>
<p style="margin-left:0em"><a href="#showDlg-2 对话框编程模式">2 对话框编程模式</a></p>
<p style="margin-left:0em"><a href="#showDlg-3 对象型对话框与formMode">3 对象型对话框与formMode</a></p>
<p style="margin-left:0em"><a href="#showDlg-4 对话框事件">4 对话框事件</a></p>
<p style="margin-left:0em"><a href="#showDlg-5 reset控制">5 reset控制</a></p>
<p style="margin-left:0em"><a href="#showDlg-6 控制底层jquery-easyui对话框">6 控制底层jquery-easyui对话框</a></p>
<p style="margin-left:0em"><a href="#showDlg-7 复用dialog模板">7 复用dialog模板</a></p>
<p style="margin-left:0em"><a href="#showDlg-8 动态生成字段的对话框">8 动态生成字段的对话框</a></p>
</div>
<p class="param"><strong>@param jdlg</strong>  可以是jquery对象，也可以是selector字符串或DOM对象，比如 "#dlgOrder".</p>
<p>注意：当对话框动态从外部加载时，jdlg=$(&quot;#dlgOrder&quot;) 一开始会为空数组，这时也可以调用该函数，且调用后jdlg会被修改为实际加载的对话框对象。</p>
<p class="param"><strong>@param opt</strong> ?={url, buttons, noCancel=false, okLabel="确定", cancelLabel="取消", modal=true, reset=true, validate=true, data, onOk, onSubmit, title}</p>
<ul>
<li>opt.url: String. 点击确定后，提交到后台的URL。如果设置则自动提交数据，否则应在opt.onOk回调或validate事件中手动提交。</li>
<li>opt.buttons: Object数组。用于添加“确定”、“取消”按钮以外的其它按钮，如<code>[{text: '下一步', iconCls:'icon-ok', handler: btnNext_click}]</code>。<br />
用opt.okLabel/cancelLabel可修改“确定”、“取消”按钮的名字，用opt.noCancel=true可不要“取消”按钮。</li>
<li>opt.modal: Boolean.模态对话框，这时不可操作对话框外其它部分，如登录框等。设置为false改为非模态对话框。</li>
<li>opt.data: Object. 自动加载的数据, 将自动填充到对话框上带name属性的DOM上。在修改对象时，仅当与opt.data有差异的数据才会传到服务端。</li>
<li>opt.reset: Boolean. 显示对话框前先清空。默认为true.</li>
<li>opt.validate: Boolean. 是否提交前用easyui-form组件验证数据。内部使用。</li>
<li>opt.onSubmit: Function(data) 自动提交前回调。用于验证或补齐提交数据，返回false可取消提交。opt.url为空时不回调。</li>
<li>opt.onOk: Function(jdlg, data?) 如果自动提交(opt.url非空)，则服务端接口返回数据后回调，data为返回数据。如果是手动提交，则点确定按钮时回调，没有data参数。</li>
<li>opt.title: String. 如果指定，则更新对话框标题。</li>
<li>opt.dialogOpt: 底层jquery-easyui dialog选项。参考http://www.jeasyui.net/plugins/159.html</li>
<li>opt.reload: (v5.5) 先重置再加载。只用于开发环境，方便在Chrome控制台中调试。</li>
<li>opt.meta: (v6) 指定通过meta自动生成的输入项</li>
<li>opt.metaParent: (v6) 指定meta自动生成项的父结点，默认为对话框下第一个table，仅当meta存在时有效</li>
</ul>
<h4 id="showDlg-1 对话框加载">1 对话框加载</h4>
<p>示例1：静态加载（在web/store.html中的my-pages中定义），通过对话框的id属性标识。</p>
<pre><code>&lt;div id="my-pages" style="display:none"&gt;
    &lt;div id="dlgLogin" title="商户登录"&gt;  
        ...
    &lt;/div&gt;
&lt;div&gt;</code></pre>
<p>加载：<code>WUI.showDlg($("#dlgLogin"))</code>。对话框顶层DOM用div或form都可以。用form更简单些。<br />
除了少数内置对话框，一般不建议这样用，而是建议从外部文件动态加载（模块化）。</p>
<p>示例2：从内部模板动态加载，模板id须为&quot;tpl_{对话框id}&quot;，对话框上不用指定id</p>
<pre><code>&lt;script type="text/template" id="tpl_dlgLogin"&gt;
    &lt;div title="商户登录"&gt;  
        ...
    &lt;/div&gt;
&lt;/script&gt;</code></pre>
<p>加载：<code>WUI.showDlg($("#dlgLogin"))</code>或<code>WUI.showDlg("#dlgLogin")</code>。<br />
比示例1要好些，但一般也不建议这样用。目前是webcc编译优化机制使用该技术做发布前常用对话框的合并压缩。</p>
<p>示例3：从外部模板动态加载，模板是个文件如web/page/dlgLogin.html，对话框上不用指定id</p>
<pre><code>&lt;div title="商户登录"&gt;  
    ...
&lt;/div&gt;</code></pre>
<p>加载：<code>WUI.showDlg($("#dlgLogin"))</code>或<code>WUI.showDlg("#dlgLogin")</code>。<br />
这是目前使用对话框的主要方式。</p>
<p>示例4：不用HTML，直接JS中创建DOM：</p>
<pre><code>var jdlg = $('&lt;div title="商户登录"&gt;Hello World&lt;/div&gt;');
WUI.showDlg(jdlg);</code></pre>
<p>适合编程动态实现的对话框。参考使用更简单的WUI.showDlgByMeta或WUI.showDlg的meta选项。</p>
<h4 id="showDlg-2 对话框编程模式">2 对话框编程模式</h4>
<p>对话框有两种编程模式，一是通过opt参数在启动对话框时设置属性及回调函数(如onOk)，另一种是在dialog初始化函数中处理事件(如validate事件)实现逻辑，有利于独立模块化。</p>
<p>对话框显示时会触发以下事件：</p>
<pre><code>事件beforeshow
事件show</code></pre>
<p>对于自动提交数据的对话框(设置了opt.url)，提交数据过程中回调函数及事件执行顺序为：</p>
<pre><code>事件validate; // 提交前，用于验证或设置提交数据。返回false或ev.preventDefault()可取消提交，中止以下代码执行。
opt.onSubmit(); // 提交前，验证或设置提交数据，返回false将阻止提交。
... 框架通过callSvr自动提交数据，如添加、更新对象等。
opt.onOk(data); // 提交且服务端返回数据后。回调函数中this为对话框jdlg, data是服务端返回数据。
事件retdata; // 与onOk类似。</code></pre>
<p>对于手动提交数据的对话框(opt.url为空)，执行顺序为：</p>
<pre><code>事件validate; // 用于验证、设置提交数据、提交数据。
opt.onOk(); // 同上. 回调函数中this为jdlg.</code></pre>
<p>注意：</p>
<ul>
<li>参数opt可在beforeshow事件中设置，这样便于在对话框模块中自行设置选项，包括okLabel, onOk回调等等。</li>
<li>旧版本中的回调 opt.onAfterSubmit() 回调已删除，请用opt.onOk()替代。</li>
</ul>
<p>调用此函数后，对话框将加上以下CSS Class:</p>
<p class="key"><strong>@key <a id=".wui-dialog">.wui-dialog</a></strong>  标识WUI对话框的类名。</p>
<p>示例：显示一个对话框，点击确定后调用后端接口。</p>
<pre><code>WUI.showDlg("#dlgCopyTo", {
    modal: false, 
    reset: false,
    url: WUI.makeUrl("Category.copyTo", {cond: ...}),
    onSubmit: ..., // 提交前验证，返回False则取消提交
    onOk: function (retdata) {
        var jdlgCopyTo = this; // this是当前对话框名
        // 自动提交后处理返回数据retdata
    }
});</code></pre>
<ul>
<li>在对话框HTML中以带name属性的输入框作为参数，如<code>用户名:&lt;input name="uname"&gt;</code>.</li>
<li>默认为模态框(只能操作当前对话框，不能操作页面中其它组件)，指定modal:false使它成为非模态；</li>
<li>默认每次打开都清空数据，指定reset:false使输入框保留初值或上次填写内容。</li>
<li>设置了url属性，点击确定自动提交时相当于调用<code>callSvr(url, 回调onOk(retdata), POST内容为WUI.getFormData(dlg))</code>。</li>
</ul>
<p>如果不使用url选项，也可实现如下：</p>
<pre><code>WUI.showDlg("#dlgCopyTo", {
    modal: false, 
    reset: false,
    onOk: function () {
        var jdlgCopyTo = this; // this是当前对话框名
        var data = WUI.getFormData(jdlgCopyTo);
        callSvr("Category.copyTo", {cond: ...}, function (retdata) { ... }, data);
    }
});</code></pre>
<p>如果要做更多的初始化配置，比如处理对话框事件，则使用初始化函数机制，即在对话框DOM上设置<code>my-initfn</code>属性：</p>
<pre><code>&lt;div title="复制到" my-initfn="initDlgCopyTo"&gt; ... &lt;/div&gt;</code></pre>
<p>初始化函数示例：</p>
<pre><code>function initDlgCopyTo()
{
    var jdlg = $(this);

    jdlg.on("beforeshow", onBeforeShow)
        .on("validate", onValidate);

    function onBeforeShow(ev, formMode, opt) {
    }
    function onValidate(ev, mode, oriData, newData) {
    }
}</code></pre>
<h4 id="showDlg-3 对象型对话框与formMode">3 对象型对话框与formMode</h4>
<p>函数showObjDlg()会调用本函数显示对话框，称为对象型对话框，用于对象增删改查，它将以下操作集中在一起。<br />
打开窗口时，会设置窗口模式(formMode):</p>
<ul>
<li>查询(FormMode.forFind)</li>
<li>显示及更新(FormMode.forSet)</li>
<li>添加(FormMode.forAdd)</li>
<li>删除(FormMode.forDel)，但实际上不会打开对话框</li>
</ul>
<p>注意：</p>
<ul>
<li>可通过<code>var formMode = jdlg.jdata().mode;</code>来获取当前对话框模式。</li>
<li>非对象型对话框的formMode为空。</li>
<li>对象型对话框由框架自动设置各opt选项，一般不应自行修改opt，而是通过处理对话框事件实现逻辑。</li>
</ul>
<p>初始数据与对话框中带name属性的对象相关联，显示对话框时，带name属性的DOM对象将使用数据opt.data自动赋值(对话框show事件中可修改)，在点“确定”按钮提交时将改动的数据发到服务端(validate事件中可修改)，详见</p>
<p class="see"><strong>@see <a href="#setFormData">setFormData</a> <a href="#getFormData">getFormData</a></strong> </p>
<h4 id="showDlg-4 对话框事件">4 对话框事件</h4>
<p>操作对话框时会发出以下事件供回调：</p>
<pre><code>beforeshow - 对话框显示前。常用来处理对话框显示参数opt或初始数据opt.data.
show - 显示对话框后。常用来设置字段值或样式，隐藏字段、初始化子表datagrid或隐藏子表列等。
validate - 用于提交前验证、补齐数据等。返回false可取消提交。(v5.2) 支持其中有异步操作.
retdata - 服务端返回结果时触发。用来根据服务器返回数据继续处理，如再次调用接口。</code></pre>
<p>注意：</p>
<ul>
<li>旧版本中的initdata, loaddata, savedata将废弃，应分别改用beforeshow, show, validate事件替代，注意事件参数及检查对话框模式。</li>
</ul>
<p class="key"><strong>@key <a id="event-beforeshow">event-beforeshow</a></strong> (ev, formMode, opt)</p>
<p>显示对话框前触发。</p>
<ul>
<li>opt参数即showDlg的opt参数，可在此处修改，例如修改opt.title可以设置对话框标题。</li>
<li>opt.objParam参数是由showObjDlg传入给dialog的参数，比如opt.objParam.obj, opt.objParam.formMode等。</li>
<li>通过修改opt.data可为字段设置缺省值。注意forFind模式下opt.data为空。</li>
<li>可以通过在beforeshow中用setTimeout延迟执行某些动作，这与在show事件中回调操作效果基本一样。</li>
<li>(v6) 设置opt.cancel=true可取消显示对话框.</li>
</ul>
<p>注意：每次调用showDlg()都会回调，可能这时对话框已经在显示。</p>
<p class="key"><strong>@key <a id="event-show">event-show</a></strong> (ev, formMode, initData)</p>
<p>对话框显示后事件，用于设置DOM组件。<br />
注意如果在beforeshow事件中设置DOM，对于带name属性的组件会在加载数据时值被覆盖回去，对它们在beforeshow中只能通过设置opt.data来指定缺省值。</p>
<p class="key"><strong>@key <a id="event-validate">event-validate</a></strong> (ev, formMode, initData, newData)</p>
<p>initData为初始数据，如果要验证或修改待提交数据，应直接检查form中相应DOM元素的值。如果需要增加待提交字段，可加到newData中去。示例：添加参数: newData.mystatus='CR';</p>
<p>(v5.2) validate事件支持返回Deferred对象支持异步操作.<br />
示例: 在提交前先弹出对话框询问. 由于app_alert是异步对话框, 需要将一个Deferred对象放入ev.dfds数组, 告诉框架等待ev.dfds中的延迟对象都resolve后再继续执行.</p>
<pre><code>jdlg.on("validate", onValidate);
function onValidate(ev, mode, oriData, newData) 
{
    var dfd = $.Deferred();
    app_alert("确认?", "q", function () {
        console.log("OK!");
        dfd.resolve();
    });
    ev.dfds.push(dfd.promise());
}</code></pre>
<p>常用于在validate中异步调用接口(比如上传文件).</p>
<p class="key"><strong>@key <a id="event-retdata">event-retdata</a></strong> (ev, data, formMode)</p>
<p>form提交后事件，用于处理返回数据</p>
<p>以下事件将废弃：</p>
<p class="key"><strong>@key <a id="event-initdata">event-initdata</a></strong> (ev, initData, formMode) 加载数据前触发。可修改要加载的数据initData, 用于为字段设置缺省值。将废弃，改用beforeshow事件。</p>
<p class="key"><strong>@key <a id="event-loaddata">event-loaddata</a></strong> (ev, initData, formMode) form加载数据后，一般用于将服务端数据转为界面显示数据。将废弃，改用show事件。</p>
<p class="key"><strong>@key <a id="event-savedata">event-savedata</a></strong> (ev, formMode, initData) 对于设置了opt.url的窗口，将向后台提交数据，提交前将触发该事件，用于验证或补足数据（修正某个）将界面数据转为提交数据. 返回false或调用ev.preventDefault()可阻止form提交。将废弃，改用validate事件。</p>
<p class="see"><strong>@see <a href="#example-dialog">example-dialog</a></strong>  在对话框中使用事件</p>
<h4 id="showDlg-5 reset控制">5 reset控制</h4>
<p>对话框上有name属性的组件在显示对话框时会自动清除（除非设置opt.reset=false或组件设置有noReset属性）。</p>
<p class="key"><strong>@key <a id=".my-reset">.my-reset</a></strong>  标识在显示对话框时应清除</p>
<p>对于没有name属性（不与数据关联）的组件，可加该CSS类标识要求清除。<br />
例如，想在forSet模式下添加显示内容, 而在forFind/forAdd模式下时清除内容这样的需求。</p>
<pre><code>&lt;div class="my-reset"&gt;...&lt;/div&gt;</code></pre>
<p class="key"><strong>@key <a id="[noReset]">[noReset]</a></strong> </p>
<p>某些字段希望设置后一直保留，不要被清空，可以设置noReset属性，例如：</p>
<pre><code>&lt;input type="hidden" name="status" value="PA" noReset&gt;</code></pre>
<h4 id="showDlg-6 控制底层jquery-easyui对话框">6 控制底层jquery-easyui对话框</h4>
<p>示例：关闭对话框时回调事件：</p>
<pre><code>var dialogOpt = {  
    onClose:function(){
        console.log("close");
    }  
};

jfrm.on("beforeshow",function(ev, formMode, opt) {
    opt.dialogOpt = dialogOpt;
})</code></pre>
<h4 id="showDlg-7 复用dialog模板">7 复用dialog模板</h4>
<p>(v5.3引入，v6修改) 该机制可用于自定义表(UDT, 对话框动态生成)。</p>
<p>如 dlgUDT_inst_A 与 dlgUDT_inst_B 会共用dlgUDT对话框模板，只要用&quot;<em>inst</em>&quot;分隔对话框模板文件和后缀名。</p>
<pre><code>WUI.showDlg("dlgUDT_inst_A"); // 自动加载page/dlgUDT.html文件</code></pre>
<p>若涉及重用其它模块中的页面或对话框，请参考 WUI.options.moduleExt</p>
<h4 id="showDlg-8 动态生成字段的对话框">8 动态生成字段的对话框</h4>
<p>(v6) 该机制可用于为已有对话框动态追加字段（比如用于用户自定义字段UDF)，或是只用纯JS而不用html来创建对话框。</p>
<p>示例：为对话框dlgReportCond追加两个输入字段。</p>
<pre><code>var itemArr = [
    // title, dom, hint?
    {title: "状态", dom: '&lt;select name="status" class="my-combobox" data-options="jdEnumMap:OrderStatusMap"&gt;&lt;/select&gt;'},
    {title: "订单号", dom: "&lt;textarea name='param' rows=5&gt;&lt;/textarea&gt;", hint: '每行一个订单号'}
];
WUI.showDlg("#dlgReportCond", {
    meta: itemArr,
    onOk: function (data) {
        console.log(data)
    },
    // metaParent: "table:first" // 也可指定插入点父结点
});</code></pre>
<p>通过指定opt.meta动态生成字段，这些字段默认放置于对话框中的第一个table下。<br />
一般详情对话框DOM模型均为&quot;<form><table></table></form>&quot;。</p>
<p>注意由于对话框有id，只会创建一次。之后再调用也不会再创建。如果希望能创建多的对话框互不影响，可以用&quot;#dlgReportCond_inst_A&quot;这种方式指定是用它的一个实例。</p>
<p>示例2：动态创建一个登录对话框</p>
<pre><code>var jdlg = $('&lt;form title="商户登录"&gt;&lt;table&gt;&lt;/table&gt;&lt;/form&gt;');
var meta = [
    {title: "用户名", dom: '&lt;input name="uname" class="easyui-validatebox" required&gt;', hint: "字母开头或11位手机号"},
    {title: "密码", dom: '&lt;input type="password" name="pwd" class="easyui-validatebox" required&gt;'}
];
WUI.showDlg(jdlg, {
    meta: meta,
    onOk: function (data) {
        console.log(data); // 根据meta中每个带name项的输入框生成：{uname, pwd}
        callSvr("login", function () {
            app_show("登录成功");
            WUI.closeDlg(jdlg);
        }, data);
    }
});</code></pre>
<p class="see"><strong>@see <a href="#showDlgByMeta">showDlgByMeta</a></strong> </p>
<p class="see"><strong>@see <a href="#showObjDlg">showObjDlg</a></strong> </p></div>
<div class="block">
<h2 id="showDlgByMeta">@fn showDlgByMeta(meta, opt)</h2>
<p>WUI.showDlg的简化版本，通过直接指定组件创建对话框。</p>
<ul>
<li>meta: [{title, dom, hint?}]</li>
<li>opt: 同showDlg的参数</li>
</ul>
<p>示例：</p>
<pre><code>var itemArr = [
    // title, dom, hint?
    {title: "接口名", dom: "&lt;input name='ac' required&gt;", hint: "示例: Ordr.query"},
    {title: "参数", dom: "&lt;textarea name='param' rows=5&gt;&lt;/textarea&gt;", hint: '示例: {cond: {createTm: "&gt;2020-1-1"}, res: "count(*) cnt", gres: "status"}'}
];
WUI.showDlgByMeta(meta, {
    title: "通用查询",
    modal: false,
    onOk: function (data) {
        app_alert(JSON.stringify(data));
    }
});</code></pre>
<p class="see"><strong>@see <a href="#showDlg">showDlg</a></strong>  参考opt.meta选项</p></div>
<div class="block">
<h2 id="batchOp">@fn batchOp(obj, ac, jtbl, opt={data, acName="操作", onBatchDone, batchOpMode=0, queryParam})</h2><div class="toc"><p style="margin-left:0em"><a href="#batchOp-1 示例1: 无须对话框填写额外信息的批量操作">1 示例1: 无须对话框填写额外信息的批量操作</a></p>
<p style="margin-left:0em"><a href="#batchOp-2 示例2：打开对话框，批量设置一些信息">2 示例2：打开对话框，批量设置一些信息</a></p>
<p style="margin-left:0em"><a href="#batchOp-3 示例3：打开对话框，先上传文件再批量操作">3 示例3：打开对话框，先上传文件再批量操作</a></p>
<p style="margin-left:0em"><a href="#batchOp-4 示例4: 基于查询条件的批量操作">4 示例4: 基于查询条件的批量操作</a></p>
</div>
<p>基于列表的批量处理逻辑：(v6支持基于查询条件的批量处理逻辑，见下面opt.queryParam)</p>
<p>对表格jtbl中的多选数据进行批量处理，先调用<code>$obj.query(cond)</code>接口查询符合条件的数据条数（cond条件根据jtbl上的过滤条件及当前多选项自动得到），弹出确认框(<code>opt.acName</code>可定制弹出信息)，<br />
确认后调用<code>ac(cond)</code>接口对多选数据进行批量处理，处理完成后回调<code>opt.onBatchDone</code>，并刷新jtbl表格。</p>
<p>其行为与框架内置的批量更新、批量删除相同。</p>
<p class="param"><strong>@param ac</strong>  对象接口名, 如"Task.setIf"/"Task.delIf"，也可以是函数接口，如"printSn"</p>
<p class="param"><strong>@param opt.acName</strong>  操作名称, 如"更新"/"删除"/"打印"等, 一个动词. 用于拼接操作提示语句.</p>
<p class="param"><strong>@param opt.data</strong>   调用支持批量的接口的POST参数</p>
<p>opt.data也可以是一个函数dataFn(batchCnt)，参数batchCnt为当前批量操作的记录数(必定大于0)。<br />
该函数返回data或一个Deferred对象(该对象适时应调用dfd.resolve(data)做批量操作)。dataFn返回false表示不做后续处理。</p>
<p class="return"><strong>@return 如果返回false，表示当前非批量操作模式，或参数不正确无法操作。</strong> </p>
<p>为支持批量操作，服务端须支持以下接口:</p>
<pre><code>// 对象obj的标准查询接口:
$obj.query($queryParam, res:"count(*) cnt") -&gt; {cnt}
// 批量操作接口ac, 接受过滤查询条件(可通过$obj.query接口查询), 返回实际操作的数量.
$ac($queryParam)($data) -&gt; $cnt</code></pre>
<p>其中obj, ac, data(即POST参数)由本函数参数传入(data也可以是个函数, 返回POST参数), queryParam根据表格jtbl的选择行或过滤条件自动生成.</p>
<p>基于列表的批量操作，完成时会自动刷新表格, 无须手工刷新. 在列表上支持以下批量操作方式:</p>
<ol>
<li>
<p>基于多选: 按Ctrl/Shift在表上选择多行，然后点操作按钮(如&quot;删除&quot;按钮, 更新时的&quot;确定&quot;按钮)，批量操作选中行；生成过滤条件形式是<code>{cond: "id IN (100,101)"}</code>, </p>
</li>
<li>
<p>基于表格当前过滤条件: 按住Ctrl键(进入批量操作模式)点操作按钮, 批量操作表格过滤条件下的所有行. 若无过滤条件, 自动以<code>{cond: "id&gt;0"}</code>做为过滤条件.</p>
</li>
<li>如果未按Ctrl键, 且当前未选行或是单选行, 函数返回false表示当前非批量处理模式，不予处理。</li>
</ol>
<p class="param"><strong>@param batchOpMode</strong>  定制批量操作行为, 比如是否需要按Ctrl激活批量模式, 未按Ctrl时如何处理未选行或单选行。</p>
<ul>
<li>batchOpMode未指定或为0时, 使用上面所述的默认批量操作方式.</li>
<li>如果值为1: 总是批量操作, 无须按Ctrl键, 无论选择了0行或1行, 都使用当前的过滤条件.</li>
<li>如果值为2: 按住Ctrl键时与默认行为相同; 没按Ctrl时, 若选了0行则报错, 若选了1行, 则按批量操作对这1行操作, 过滤条件形式是是<code>{cond:"id=100"}</code></li>
</ul>
<p>简单来说, 默认模式对单个记录不处理, 返回false留给调用者处理; 模式2是对单个记录也按批量处理; 模式1是无须按Ctrl键就批量处理.</p>
<h4 id="batchOp-1 示例1: 无须对话框填写额外信息的批量操作">1 示例1: 无须对话框填写额外信息的批量操作</h4>
<p>工件列表页(pageSn)中，点&quot;打印条码&quot;按钮, 打印选中的1行或多行的标签, 如果未选则报错. 如果按住Ctrl点击, 则按表格过滤条件批量打印所有行的标签.</p>
<p>显然, 这是一个batchOpMode=2的操作模式, 调用后端<code>Sn.print</code>接口, 对一行或多行数据统一处理，在列表页pageSn.js中为操作按钮指定操作:</p>
<pre><code>// function initPageSn
var btn1 = {text: "打印条码", iconCls:'icon-ok', handler: function () {
    WUI.batchOp("Sn", "printSn", jtbl, {
        acName: "打印", 
        batchOpMode: 2
    });
}};

jtbl.datagrid({
    ...
    toolbar: WUI.dg_toolbar(jtbl, jdlg, "export", btn1),
});</code></pre>
<p>后端应实现接口<code>printSn(cond)</code>, 实现示例:</p>
<pre><code>function api_printSn() {
    // 通过query接口查询操作对象内容. 
    $param = array_merge($_GET, ["res"=&gt;"code", "fmt"=&gt;"array" ]);
    $arr = callSvcInt("Sn.query", $param);
    addLog($rv);
    foreach ($arr as $one) {
        // 处理每个对象
    }
    // 应返回操作数量
    return count($arr);
}</code></pre>
<p class="param"><strong>@param opt.queryParam</strong> </p>
<p>(v6) 基于查询条件的批量处理，即指定opt.queryParam，这时jtbl参数传null，与表格操作无关，只根据指定条件查询数量和批量操作。<br />
注意jtbl和opt.queryParam必须指定其一。参见下面示例4。</p>
<h4 id="batchOp-2 示例2：打开对话框，批量设置一些信息">2 示例2：打开对话框，批量设置一些信息</h4>
<p>在列表页上添加操作按钮，pageXXX.js:</p>
<pre><code>// 点按钮打开批量上传对话框
var btn1 = {text: "批量设置", iconCls:'icon-add', handler: function () {
    WUI.showDlg("#dlgUpload", {modal:false, jtbl: jtbl}); // 注意：为对话框传入特别参数jtbl即列表的jQuery对象，在batchOp函数中要使用它。
}};
jtbl.datagrid({
    ...
    toolbar: WUI.dg_toolbar(jtbl, jdlg, "export", btn1),
});</code></pre>
<p>对批量设置页面上调用接口，dlgUpload.js:</p>
<pre><code>var jtbl;
jdlg.on("validate", onValidate)
    on("beforeshow", onBeforeShow);

function onBeforeShow(ev, formMode, opt) {
    jtbl = opt.jtbl; // 记录传入的参数
}
function onValidate(ev, mode, oriData, newData) 
{
    WUI.batchOp("Item", "batchSetItemPrice", jtbl, {
        batchOpMode: 1,  // 无须按Ctrl键, 一律当成批量操作
        data: WUI.getFormData(jfrm),
        onBatchDone: function () {
            WUI.closeDlg(jdlg);
        }
    });
}</code></pre>
<p>注意：对主表字段的设置都可在通用的详情对话框上解决（若要批量设置子表，也可通过在set/setIf接口里处理虚拟字段解决）。一般无须编写批量设置操作。</p>
<h4 id="batchOp-3 示例3：打开对话框，先上传文件再批量操作">3 示例3：打开对话框，先上传文件再批量操作</h4>
<p>在安装任务列表页上，点&quot;批量上传&quot;按钮, 打开上传文件对话框(dlgUpload), 选择上传并点击&quot;确定&quot;按钮后, 先上传文件, 再将返回的附件编号批量更新到行记录上.</p>
<p>先选择操作模式batchOpMode=1, 点确定按钮时总是批量处理.</p>
<p>与示例2不同，上传文件是个异步操作，可为参数data传入一个返回Deferred对象（简称dfd）的函数(onGetData)用于生成POST参数，<br />
以支持异步上传文件操作，在dfd.resolve(data)之后才会执行真正的批量操作.</p>
<p>pageTask.js:</p>
<pre><code>// 点按钮打开批量上传对话框
var btn2 = {text: "批量上传附件", iconCls:'icon-add', handler: function () {
    WUI.showDlg("#dlgUpload", {modal:false, jtbl: jtbl}); // 注意：为对话框传入特别参数jtbl即列表的jQuery对象，在batchOp函数中要使用它。
}};</code></pre>
<p>dlgUpload.js:</p>
<pre><code>var jtbl;
jdlg.on("validate", onValidate)
    on("beforeshow", onBeforeShow);

function onBeforeShow(ev, formMode, opt) {
    jtbl = opt.jtbl; // 记录传入的参数
}
function onValidate(ev, mode, oriData, newData) 
{
    WUI.batchOp("Task", "Task.setIf", jtbl, {
        batchOpMode: 1,  // 无须按Ctrl键, 一律当成批量操作
        data: onGetData,
        onBatchDone: function () {
            WUI.closeDlg(jdlg);
        }
    });
}

// 一定batchCnt&gt;0. 若batchCnt=0即没有操作数据时, 会报错结束, 不会回调该函数.
function onGetData(batchCnt)
{
    var dfd = $.Deferred();
    app_alert("批量上传附件到" + batchCnt + "行记录?", "q", function () {
        var dfd1 = triggerAsync(jdlg.find(".wui-upload"), "submit"); // 异步上传文件，返回Deferred对象
        dfd1.then(function () {
            var data = WUI.getFormData(jfrm);
            if ($.isEmptyObject(data)) {
                app_alert("没有需要更新的内容。");
                return false;
            }
            dfd.resolve(data);
        });
    });
    return dfd.promise();
}</code></pre>
<p class="see"><strong>@see <a href="#triggerAsync">triggerAsync</a></strong>  异步事件调用</p>
<p>上面函数中处理异步调用链，不易理解，可以简单理解为：</p>
<pre><code>if (confirm("确认操作?") == no)
    return;
jupload.submit();
return getFormData(jfrm);</code></pre>
<h4 id="batchOp-4 示例4: 基于查询条件的批量操作">4 示例4: 基于查询条件的批量操作</h4>
<p>示例：在工单列表页，批量为工单中的所有工件打印跟踪码。</p>
<p>工单为Ordr对象，工件为Sn对象。注意：此时是操作Sn对象，而非当前Ordr对象，所以不传jtbl，而是直接传入查询条件.</p>
<pre><code>WUI.batchOp("Sn", "printSn", null, {
    acName: "打印", 
    queryParam: {cond: "orderId=80"},
    data: {tplId: 10}
});</code></pre>
<p>后端批量打印接口设计为：</p>
<pre><code>printSn(cond, tplId) -&gt; cnt</code></pre>
<p>上例中，查询操作数量时将调用接口<code>callSvr("Sn.query", {cond: "orderId=80", res: "count(*) cnt"})</code>，<br />
在批量操作时调用接口<code>callSvr("printSn", {cond: "orderId=80"}, $.noop, {tplId: 10})</code>。</p></div>
<div class="block">
<h2 id="getTopDialog">@fn getTopDialog()</h2>
<p>取处于最上层的对话框。如果没有，返回jo.size() == 0</p></div>
<div class="block">
<h2 id="unloadPage">@fn unloadPage(pageName?)</h2>
<p class="param"><strong>@param pageName</strong>  如未指定，表示当前页。</p>
<p>删除一个页面。一般用于开发过程，在修改外部逻辑页后，调用该函数删除页面。此后载入页面，可以看到更新的内容。</p>
<p>注意：对于内部逻辑页无意义。</p></div>
<div class="block">
<h2 id="reloadPage">@fn reloadPage()</h2>
<p>重新加载当前页面。一般用于开发过程，在修改外部逻辑页后，调用该函数可刷新页面。</p></div>
<div class="block">
<h2 id="unloadDialog">@fn unloadDialog(jdlg?)</h2>
<p class="alias"><strong>@alias <a id="reloadDialog">reloadDialog</a></strong> </p>
<p>删除指定对话框jdlg，如果不指定jdlg，则删除当前激活的对话框。一般用于开发过程，在修改外部对话框后，调用该函数清除以便此后再载入页面，可以看到更新的内容。</p>
<pre><code>WUI.reloadDialog(jdlg);
WUI.reloadDialog();
WUI.reloadDialog(true); // 重置所有外部加载的对话框(v5.1)</code></pre>
<p>注意：</p>
<ul>
<li>对于内部对话框调用本函数无意义。直接关闭对话框即可。</li>
<li>由于不知道打开对话框的参数，reloadDialog无法重新打开对话框，因而它的行为与unloadDialog一样。</li>
</ul></div>
<div class="block">
<h2 id="canDo">@fn canDo(topic, cmd=null, defaultVal=null)</h2><div class="toc"><p style="margin-left:0em"><a href="#canDo-1 关于页面与对话框">1 关于页面与对话框</a></p>
</div>
<p>权限检查回调，支持以下场景：</p>
<ol>
<li>
<p>页面上的操作（按钮）</p>
<p>canDo(页面标题, 按钮标题);// 返回false则不显示该按钮</p>
</li>
<li>
<p>对话框上的操作</p>
<p>canDo(对话框标题, &quot;对话框&quot;); // 返回false表示对话框只读<br />
canDo(对话框标题, 按钮标题); // 返回false则不显示该按钮</p>
</li>
</ol>
<p>特别地：如果对话框或页面上有wui-readonly类，则：</p>
<pre><code>canDo("只读对象", 按钮标题); // 返回false则不显示该按钮</code></pre>
<p>topic可理解为数据对象（页面、对话框对应的数据模型），cmd可理解为操作（增加、修改、删除、只读等，常常是工具栏按钮）。</p>
<p>TODO:通过设置 WUI.options.canDo(topic, cmd) 可扩展定制权限。</p>
<p>默认情况下，所有菜单不显示，其它操作均允许。<br />
如果指定了&quot;*&quot;权限，则显示所有菜单。<br />
如果指定了&quot;不可XX&quot;权限，则topic或cmd匹配XX则不允许。</p>
<p class="key"><strong>@key <a id="wui-perm">wui-perm</a></strong> </p>
<ul>
<li>topic: 通过菜单、页面、对话框、按钮的wui-perm属性指定（按钮参考dg_toolbar函数），如果未指定，则取其text.</li>
<li>cmd: 对话框，新增，修改，删除，导出，自定义的按钮</li>
</ul>
<p>示例：假设有菜单结构如下（不包含最高管理员专有的“系统设置”）</p>
<pre><code>主数据管理
    企业
    用户

运营管理
    活动
    公告
    积分商城</code></pre>
<p>只显示“公告”菜单项：</p>
<pre><code>公告</code></pre>
<p>只显示“运营管理”菜单组：</p>
<pre><code>运营管理</code></pre>
<p>显示除了“运营管理”外的所有内容：</p>
<pre><code>* 不可运营管理</code></pre>
<p>其中<code>*</code>表示显示所有菜单项。<br />
显示所有内容（与管理员权限相同），但只能查看不可操作</p>
<pre><code>* 只读</code></pre>
<p>“只读”权限排除了“新增”、“修改”等操作。<br />
特别地，“只读”权限也不允许“导出”操作（虽然导出是读操作，但一般要求较高权限），假如要允许导出公告，可以设置：</p>
<pre><code>* 只读 公告.导出</code></pre>
<p>显示“运营管理”，在列表页中不显示“删除”、“导出”按钮：</p>
<pre><code>运营管理 不可删除 不可导出</code></pre>
<p>显示“运营管理”，在列表页中，不显示“删除”、“导出”按钮，但“公告”中显示“删除”按钮：</p>
<pre><code>运营管理 不可删除 不可导出 公告.删除</code></pre>
<p>或等价于：</p>
<pre><code>运营管理 不可导出 活动.不可删除 积分商城.不可删除</code></pre>
<p>显示“运营管理”和“主数据管理”菜单组，但“主数据管理”下面内容均是只读的：</p>
<pre><code>运营管理 主数据管理 企业.只读 用户.只读</code></pre>
<h4 id="canDo-1 关于页面与对话框">1 关于页面与对话框</h4>
<p>假如在“活动”页面中链接了“用户”对话框（或“活动”页面上某操作按钮会打开“用户”页面），即使该角色只有“活动”权限而没有“用户”的权限，也能正常打开用户对话框或页面并修改用户。<br />
这是一个潜在安全漏洞，在配置权限时应特别注意。</p>
<p>这样设计是因为用户权限主要是针对菜单项的，而且可以只指定到父级菜单（表示下面子菜单均可显示）；这样就导致对未指定的权限，也无法判断是否可用（因为可能是菜单子项），目前处理为默认可用（可通过权限<code>不可*</code>来指定默认不可用）。</p>
<p>以指定运营管理下所有功能为例，解决办法：</p>
<ul>
<li>
<p>简单的处理方式是对于所有链接的内容，分别加入黑名单，如特别指定“不可用户”（或指定“用户.只读”），这时链接的对话框或页面将以只读模式打开（对话框不可设置，页面无操作按钮）。最终权限指定为<code>运营管理 不可用户</code></p>
</li>
<li>还有一种拒绝优先+精确指定的处理方式，即先指定<code>不可*</code>，然后再精确指定该角色可用的所有权限（通常是列举所有子菜单项供打勾选择）。最终权限指定为<code>不可* 活动 公告 积分商城</code>。这时应注意：<br />
如果菜单项、页面、对话框的权限名不相同的，则可能出现菜单项能显示，而页面和对话框显示为只读。这种情况应确保菜单、页面、对话框的权限名（标题名或设置菜单的wui-perm属性）应一致。<br />
例如菜单项叫“活动管理”而对话框和页面名为“活动”，则可将菜单的wui-perm属性设置为“活动”。<br />
还有种比较常见的情况是页面和对话框为多个对象共用的（如客户和供应商共用一个页面和对话框），也是确保菜单名、页面名、对话框一致，在处理时往往是以showPage将菜单名传到页面，从页面打开对话框时则以页面标题指定对话框标题。</li>
</ul></div>
<div class="block">
<h2 id="doFind">@fn doFind(jo, jtbl?, doAppendFilter?=false)</h2>
<p>根据对话框中jo部分内容查询，结果显示到表格(jtbl)中。<br />
jo一般为对话框内的form或td，也可以为dialog自身。<br />
查询时，取jo内部带name属性的字段作为查询条件。如果有多个字段，则生成AND条件。</p>
<p>如果查询条件为空，则不做查询；但如果指定jtbl的话，则强制查询。</p>
<p>jtbl未指定时，自动取对话框关联的表格；如果未关联，则不做查询。<br />
doAppendFilter=true时，表示追加过滤条件。</p>
<p class="see"><strong>@see <a href="#.wui-notCond">.wui-notCond</a></strong>  指定独立查询条件</p></div>
<div class="block">
<h2 id="showObjDlg">@fn showObjDlg(jdlg, mode, opt?={jtbl, id, obj})</h2>
<p class="param"><strong>@param jdlg</strong>  可以是jquery对象，也可以是selector字符串或DOM对象，比如 "#dlgOrder". 注意：当对话框保存为单独模块时，jdlg=$("#dlgOrder") 一开始会为空数组，这时也可以调用该函数，且调用后jdlg会被修改为实际加载的对话框对象。</p>
<p class="param"><strong>@param opt.id</strong>  String. 对话框set模式(mode=FormMode.forSet)时必设，set/del如缺省则从关联的opt.jtbl中取, add/find时不需要</p>
<p class="param"><strong>@param opt.jtbl</strong>  Datagrid. 指定对话框关联的列表(datagrid)，用于从列表中取值，或最终自动刷新列表。 -- 如果dlg对应多个tbl, 必须每次打开都设置</p>
<p class="param"><strong>@param opt.obj</strong>  String. (v5.1) 对象对话框的对象名，如果未指定，则从my-obj属性获取。通过该参数可动态指定对象名。</p>
<p class="param"><strong>@param opt.offline</strong>  Boolean. (v5.1) 不与后台交互。</p>
<p class="param"><strong>@param opt.readonly</strong>  String. (v5.5) 指定对话框只读。即设置wui-readonly类。</p>
<p>showObjDlg底层通过showDlg实现，(v5.5)showObjDlg的opt会合并到showDlg的opt参数中，同时showDlg的opt.objParam将保留showObjDlg的原始opt。在每次打开对话框时，可以从beforeshow回调事件参数中以opt.objParam方式取出.<br />
以下代码帮助你理解这几个参数的关系：</p>
<pre><code>function showObjDlg(jdlg, mode, opt)
{
    opt = $.extend({}, jdlg.objParam, opt);
    var showDlgOpt = $.extend({}, opt, {
        ...
        objParam: opt
    });
    showDlg(jdlg, showDlgOpt);
}
jdlg.on("beforeshow", function (ev, formMode, opt) {
    // opt即是上述showDlgOpt
    // opt.objParam为showObjDlg的原始opt，或由jdlg.objParam传入
});</code></pre>
<p class="param"><strong>@param opt.title</strong>  String. (v5.1) 指定对话框标题。</p>
<p class="param"><strong>@param opt.data</strong>  Object. (v5.5) 为对话框指定初始数据，对话框中name属性匹配的控件会在beforeshow事件后且show事件前自动被赋值。</p>
<p>注意：如果是forSet模式的对话框，即更新数据时，只有与原始数据不同的字段才会提交后端。</p>
<p>其它参数可参考showDlg函数的opt参数。</p>
<p class="key"><strong>@key <a id="objParam">objParam</a></strong>  对象对话框的初始参数。</p>
<p>(v5.1)<br />
此外，通过设置jdlg.objParam，具有和设置opt参数一样的功能，常在initPageXXX中使用，因为在page中不直接调用showObjDlg，无法直接传参数opt.<br />
示例：</p>
<pre><code>var jdlg = $("#dlgSupplier");
jdlg.objParam = {type: "C", obj: "Customer"};
showObjDlg(jdlg, FormMode.forSet, {id:101});
// 等价于 showObjDlg(jdlg, FormMode.forSet, {id:101, obj: "Customer", type: "C"});</code></pre>
<p>在dialog的事件beforeshow(ev, formMode, opt)中，可以通过opt.objParam取出showObjDlg传入的所有参数opt。<br />
(v5.3) 可在对象对话框的初始化函数中使用 initDlgXXX(opt)，注意：非对象对话框初始化函数的opt参数与此不同。</p>
<p class="param"><strong>@param opt.onCrud</strong>  Function(). (v5.1) 对话框操作完成时回调。</p>
<p>一般用于点击表格上的增删改查工具按钮完成操作时插入逻辑。<br />
在回调函数中this对象就是objParam，可通过this.mode获取操作类型。示例：</p>
<pre><code>jdlg1.objParam = {
    offline: true,
    onCrud: function () {
        if (this.mode == FormMode.forDel) {
            // after delete row
        }

        // ... 重新计算金额
        var rows = jtbl.datagrid("getData").rows, amount = 0;
        $.each(rows, function(e) {
            amount += e.price * e.qty;
        })
        frm.amount.value = amount.toFixed(2);
        // ... 刷新关联的表格行
        // opt.objParam.reloadRow();
    }
};
jtbl.datagrid({
    toolbar: WUI.dg_toolbar(jtbl, jdlg1), // 添加增删改查工具按钮，点击则调用showObjDlg，这时objParam生效。
    onDblClickRow: WUI.dg_dblclick(jtbl, jdlg1),
    ...
});</code></pre>
<p>在dialog逻辑中使用objParam:</p>
<pre><code>function initDlgXXX() {
    // ...
    jdlg.on("beforeshow", onBeforeShow);

    function onBeforeShow(ev, formMode, opt) {
        var objParam = opt.objParam; // {id, mode, jtbl?, offline?...}
    }
}</code></pre>
<p class="param"><strong>@param opt.reloadRow</strong> () 可用于刷新本对话框关联的表格行数据</p>
<p>事件参考：</p>
<p class="see"><strong>@see <a href="#showDlg">showDlg</a></strong> </p></div>
<div class="block">
<h2 id="dg_toolbar">@fn dg_toolbar(jtbl, jdlg, button_lists...)</h2>
<p class="param"><strong>@param jdlg</strong>  可以是对话框的jquery对象，或selector如"#dlgOrder".</p>
<p>设置easyui-datagrid上toolbar上的按钮。缺省支持的按钮有r(refresh), f(find), a(add), s(set), d(del), 可通过以下设置方式修改：</p>
<pre><code>// jtbl.jdata().toolbar 缺省值为 "rfasd"
jtbl.jdata().toolbar = "rfs"; // 没有a-添加,d-删除.
// (v5.5) toolbar也可以是数组, 如 ["r", "f", "s", "export"]; 空串或空数组表示没有按钮.</code></pre>
<p>如果要添加自定义按钮，可通过button_lists一一传递.<br />
示例：添加两个自定义按钮查询“今天订单”和“所有未完成订单”。</p>
<pre><code>function getTodayOrders()
{
    var queryParams = WUI.getQueryParam({comeTm: new Date().format("D")});
    WUI.reload(jtbl, null, queryParams);
}
// 显示待服务/正在服务订单
function getTodoOrders()
{
    var queryParams = {cond: "status=" + OrderStatus.Paid + " or status=" + OrderStatus.Started};
    WUI.reload(jtbl, null, queryParams);
}
var btn1 = {text: "今天订单", iconCls:'icon-search', handler: getTodayOrders};
var btn2 = {text: "所有未完成", iconCls:'icon-search', handler: getTodoOrders};

// 默认显示当天订单
var queryParams = WUI.getQueryParam({comeTm: new Date().format("D")});

var dgOpt = {
    url: WUI.makeUrl(["Ordr", "query"]),
    queryParams: queryParams,
    pageList: ...
    pageSize: ...
    // "-" 表示按钮之间加分隔符
    toolbar: WUI.dg_toolbar(jtbl, jdlg, btn1, "-", btn2),
    onDblClickRow: WUI.dg_dblclick(jtbl, jdlg)
};
jtbl.datagrid(dgOpt);</code></pre>
<p>特别地，要添加导出数据到Excel文件的功能按钮，可以增加参数&quot;export&quot;作为按钮定义：<br />
导入可以用&quot;import&quot;, 快速查询可以用&quot;qsearch&quot; (这两个以扩展方式在jdcloud-wui-ext.js中定义):</p>
<pre><code>var dgOpt = {
    ...
    toolbar: WUI.dg_toolbar(jtbl, jdlg, "import", "export", "-", btn1, btn2, "qsearch"),
}</code></pre>
<p>如果想自行定义导出行为参数，可以参考WUI.getExportHandler</p>
<p class="see"><strong>@see <a href="#getExportHandler">getExportHandler</a></strong>  导出按钮设置</p>
<p>按钮的权限（即是否显示）取决于wui-perm和text属性。优先使用wui-perm。系统内置的常用的有：&quot;新增&quot;, &quot;修改&quot;, &quot;删除&quot;, &quot;导出&quot;<br />
下面例子，把“导入”特别设置为内置的权限“新增”，这样不仅不必在角色管理中设置，且设置了“只读”等权限也可自动隐藏它。</p>
<pre><code>var btnImport = {text: "导入", "wui-perm": "新增", iconCls:'icon-ok', handler: function () {
    DlgImport.show({obj: "Ordr"}, function () {
        WUI.reload(jtbl);
    });
}};</code></pre>
<p>支持定义扩展，比如importOrdr:</p>
<pre><code>// ctx = {jtbl, jp, jdlg} // jp是jpage或jdlg，为上一层容器。jdlg是表格关联的对话框，
// 注意jdlg在调用时可能尚未初始化，可以访问 jdlg.selector和jdlg.objParam等。
dg_toolbar.importOrdr = function (ctx) {
    return {text: "导入", "wui-perm": "新增", iconCls:'icon-ok', handler: function () {
        DlgImport.show({obj: "Ordr"}, function () {
            WUI.reload(jtbl);
        });
    }}
};</code></pre>
<p>这时就可以直接这样来指定导入按钮（便于全局重用）：</p>
<pre><code>WUI.dg_toolbar(jtbl, jdlg, ..., "importOrdr")</code></pre></div>
<div class="block">
<h2 id="dg_dblclick">@fn dg_dblclick(jtbl, jdlg)</h2>
<p class="param"><strong>@param jdlg</strong>  可以是对话框的jquery对象，或selector如"#dlgOrder".</p>
<p>设置双击datagrid行的回调，功能是打开相应的dialog</p></div>
<div class="block">
<h2 id="a[href=#page]">@key a[href=#page]</h2>
<p class="key"><strong>@key <a id="a[href=">a[href=</a></strong> ?fn]</p>
<p>页面中的a[href]字段会被框架特殊处理：</p>
<pre><code>&lt;a href="#pageHome"&gt;首页&lt;/a&gt;
&lt;a href="?logout"&gt;退出登录&lt;/a&gt;</code></pre>
<ul>
<li>href=&quot;#pageXXX&quot;开头的，点击时会调用 WUI.showPage(&quot;#pageXXX&quot;);</li>
<li>href=&quot;?fn&quot;，会直接调用函数 fn(); 函数中this对象为当前DOM对象</li>
</ul></div>
<div class="block">
<h2 id="getExportHandler">@fn getExportHandler(jtbl, ac?, param?={})</h2>
<p>为数据表添加导出Excel菜单，如：</p>
<pre><code>jtbl.datagrid({
    url: WUI.makeUrl("User.query"),
    toolbar: WUI.dg_toolbar(jtbl, jdlg, {text:'导出', iconCls:'icon-save', handler: WUI.getExportHandler(jtbl) }),
    onDblClickRow: WUI.dg_dblclick(jtbl, jdlg)
});</code></pre>
<p>默认是导出数据表中直接来自于服务端的字段，并应用表上的查询条件及排序。<br />
也可以通过设置param参数手工指定，如：</p>
<pre><code>handler: WUI.getExportHandler(jtbl, "User.query", {res: "id 编号, name 姓名, createTm 注册时间", orderby: "createTm DESC"})</code></pre>
<p>注意：由于分页机制影响，会设置参数{pagesz: -1}以便在一页中返回所有数据，而实际一页能导出的最大数据条数取决于后端设置（默认1000，参考后端文档 AccessControl::$maxPageSz）。</p>
<p>会根据datagrid当前设置，自动为query接口添加res(输出字段), cond(查询条件), fname(导出文件名), orderby(排序条件)参数。</p>
<p>若是已有url，希望从datagrid获取cond, fname等参数，而不要覆盖res参数，可以这样做：</p>
<pre><code>var url = WUI.makeUrl("PdiRecord.query", ...); // makeUrl生成的url具有params属性，为原始查询参数
var btnExport = {text:'导出', iconCls:'icon-save', handler: WUI.getExportHandler(jtbl, null, {res: url.params.res || null}) };</code></pre>
<p class="see"><strong>@see <a href="#getQueryParamFromTable">getQueryParamFromTable</a></strong>  获取datagrid的当前查询参数</p></div>
<div class="block">
<h2 id="getQueryParamFromTable">@fn getQueryParamFromTable(jtbl, param?)</h2>
<p class="alias"><strong>@alias <a id="getParamFromTable">getParamFromTable</a></strong> </p>
<p>根据数据表当前设置，获取查询参数。<br />
可能会设置{cond, orderby, res, fname}参数。</p>
<p>res参数从列设置中获取，如&quot;id 编号,name 姓名&quot;, 特别地，如果列对应字段以&quot;_&quot;结尾，不会加入res参数。</p>
<p>(v5.2)<br />
如果表上有多选行，则导出条件为cond=&quot;t0.id IN (id1, id2)&quot;这种形式。</p>
<p>fname自动根据当前页面的title以及datagrid当前的queryParam自动拼接生成。<br />
如title是&quot;检测记录报表&quot;, queryParam为&quot;tm&gt;='2020-1-1' and tm&lt;='2020-7-1&quot;，则生成文件名fname=&quot;检测记录报表-2020-1-1-2020-7-1&quot;.</p>
<p class="see"><strong>@see <a href="#getExportHandler">getExportHandler</a></strong>  导出Excel</p></div>
<div class="block">
<h2 id="getDgInfo">@fn getDgInfo(jtbl, res?) -> { opt, isTreegrid, datagrid, url, param, ac, obj, sel?, selArr?, res? }</h2>
<p>取datagrid关联信息. 返回字段标记?的须显式指定，如：</p>
<pre><code>var dg = WUI.getDgInfo(jtbl); // {opt, url, ...}
var dg = WUI.getDgInfo(jtbl, {res: null}); // 多返回res字段
var data = jtbl[dg.datagrid]("getData"); // 相当于jtbl.datagrid(...), 但兼容treegrid调用。</code></pre>
<ul>
<li>opt: 数据表option</li>
<li>url: 关联的查询URL</li>
<li>param: 额外查询参数</li>
<li>ac: 关联的后端接口，比如&quot;Ordr.query&quot;</li>
<li>obj: 关联的对象，比如&quot;Ordr&quot;</li>
<li>isTreegrid: 是否为treegrid</li>
<li>
<p>datagrid: &quot;datagrid&quot;或&quot;treegrid&quot;</p>
</li>
<li>sel: 当前选中行的数据，无选中时为null</li>
<li>selArr: 当前所有所中行的数据数据，无选中时为[]</li>
<li>res: 字段信息，{ field =&gt; {field, title, jdEnumMap?} }</li>
</ul></div>
<div class="block">
<h2 id="Formatter.atts">@fn Formatter.atts</h2>
<p>列表中显示附件（支持多个）, 每个附件一个链接，点击后可下载该附件。（使用服务端att接口）</p></div>
<div class="block">
<h2 id="Formatter.pics1">@fn Formatter.pics1</h2>
<p>显示图片（支持多图）, 显示为一个链接，点击后在新页面打开并依次显示所有的图片。（使用服务端pic接口）</p></div>
<div class="block">
<h2 id="Formatter.pics">@fn Formatter.pics</h2>
<p>显示图片（支持多图）, 每个图有预览, 点击后在新页面打开并依次显示所有的图片.（使用服务端pic接口）</p></div>
<div class="block">
<h2 id="Formatter.flag">@fn Formatter.flag(yes, no)</h2>
<p>显示flag类的值，示例：</p>
<pre><code>&lt;th data-options="field:'clearFlag', sortable:true, formatter:Formatter.flag("已结算", "未结算"), styler:Formatter.enumStyler({1:'Disabled',0:'Warning'}, 'Warning')"&gt;结算状态&lt;/th&gt;</code></pre>
<p>注意flag字段建议用Formatter.enum和jdEnumMap，因为在导出表格时，只用flag的话，导出值还是0,1无法被转换，还不如定义一个Map来的更清晰。</p>
<p class="see"><strong>@see <a href="#datagrid.formatter">datagrid.formatter</a></strong> </p>
<p class="see"><strong>@see <a href="#Formatter.enum">Formatter.enum</a></strong> </p></div>
<div class="block">
<h2 id="Formatter.enum">@fn Formatter.enum(enumMap, sep=',')</h2>
<p>将字段的枚举值显示为描述信息。示例：</p>
<pre><code>    &lt;th data-options="field:'status', jdEnumMap: OrderStatusMap, formatter: WUI.formatter.enum(OrderStatusMap)"&gt;状态&lt;/th&gt;</code></pre>
<p>如果状态值为&quot;CR&quot;，则显示为&quot;未付款&quot;. 全局变量OrderStatusMap在代码中定义如下（一般在web/app.js中定义）</p>
<pre><code>var OrderStatusMap = {
    CR: "未付款", 
    PA: "待服务"
}</code></pre>
<p>常用的YesNoMap是预定义的<code>0-否,1-是</code>映射，示例：</p>
<pre><code>&lt;th data-options="field:'clearFlag', sortable:true, jdEnumMap:YesNoMap, formatter:Formatter.enum(YesNoMap), styler:Formatter.enumStyler({1:'Disabled',0:'Warning'}, 'Warning')"&gt;已结算&lt;/th&gt;</code></pre>
<p class="see"><strong>@see <a href="#datagrid.formatter">datagrid.formatter</a></strong> </p>
<p class="see"><strong>@see <a href="#Formatter.enumStyler">Formatter.enumStyler</a></strong> </p></div>
<div class="block">
<h2 id="Formatter.enumStyler">@fn Formatter.enumStyler(colorMap, defaultColor?, field?)</h2>
<p>为列表的单元格上色，示例：</p>
<pre><code>&lt;th data-options="field:'status', jdEnumMap: OrderStatusMap, formatter:Formatter.enum(OrderStatusMap), styler:Formatter.enumStyler({PA:'Warning', RE:'Disabled', CR:'#00ff00', null: 'Error'}), sortable:true"&gt;状态&lt;/th&gt;</code></pre>
<p>颜色可以直接用rgb表示如'#00ff00'，或是颜色名如'red'等，最常用是用系统预定的几个常量'Warning'（黄）, 'Error'（红）, 'Info'（绿）, 'Disabled'（灰）.<br />
缺省值可通过defaultColor传入。</p>
<p>如果是根据其它字段来判断，使用field选项指定字段，示例: 显示statusStr字段，但根据status字段值来显示颜色（默认'Info'颜色）</p>
<pre><code>&lt;th data-options="field:'statusStr', styler:Formatter.enumStyler({PA:'Warning'}, 'Info', 'status'), sortable:true"&gt;状态&lt;/th&gt;</code></pre>
<p class="see"><strong>@see <a href="#datagrid.styler">datagrid.styler</a></strong> </p>
<p class="see"><strong>@see <a href="#Formatter.enumFnStyler">Formatter.enumFnStyler</a></strong>  比enumStyler更强大</p></div>
<div class="block">
<h2 id="Formatter.enumFnStyler">@fn Formatter.enumFnStyler(colorMap, defaultColor)</h2>
<p>为列表的单元格上色，示例：</p>
<pre><code>&lt;th data-options="field:'id', sortable:true, sorter:intSort, styler:Formatter.enumFnStyler({'v&lt;10': 'Error', 'v&gt;=10&amp;&amp;v&lt;20': 'Warning'}, 'Info')"&gt;编号&lt;/th&gt;</code></pre>
<p>每个键是个表达式（其实是个函数），特殊变量v和row分别表示当前列值和当前行。缺省值可通过defaultColor传入。</p>
<p class="see"><strong>@see <a href="#Formatter.enumStyler">Formatter.enumStyler</a></strong> </p></div>
<div class="block">
<h2 id="Formatter.progress">@fn Formatter.progress</h2>
<p>以进度条方式显示百分比，传入数值value为[0,1]间小数：</p>
<pre><code>&lt;th data-options="field:'progress', formatter: Formatter.progress"&gt;工单进度&lt;/th&gt;</code></pre></div>
<div class="block">
<h2 id="formatter">@var formatter = {dt, number, pics, flag(yes?=是,no?=否), enum(enumMap), linkTo(field, dlgRef, showId?=false) }</h2>
<p>常常应用定义Formatter变量来扩展WUI.formatter，如</p>
<pre><code>var Formatter = {
    userId: WUI.formatter.linkTo("userId", "#dlgUser"), // 显示用户名(value)，点击后打开用户明细框
    storeId: WUI.formatter.linkTo("storeId", "#dlgStore", true), // 显示"商户id-商户名", 点击后打开商户明细框
    orderStatus: WUI.formatter.enum({CR: "新创建", CA: "已取消"}) // 将CR,CA这样的值转换为显示文字。
};
Formatter = $.extend(WUI.formatter, Formatter);</code></pre>
<p>可用值：</p>
<ul>
<li>dt/number: 显示日期、数值</li>
<li>pics/pics1: 显示一张或一组图片链接，点一个链接可以在新页面上显示原图片。(v5.4) pics直接显示图片(最多3张，可通过Formatter.pics.maxCnt设置)，更直观；pics1只显示图片编号，效率更好。</li>
<li>atts: (v5.4) 显示一个或一组附件，点链接可下载附件。</li>
<li>enum(enumMap): 根据一个map为枚举值显示描述信息，如 <code>enum({CR:"创建", CA:"取消"})</code>。<br />
(v5.1) 也支持枚举值列表，如设置为 <code>enumList({emp:"员工", mgr:"经理"})</code>，则会将&quot;emp&quot;和&quot;emp,mgr&quot;分别解析为&quot;员工&quot;, &quot;员工,经理&quot;</li>
<li>flag(yes?, no?): 显示yes-no字段，如 <code>flag("禁用","启用")</code>，也可以用enum，如<code>enum({0:"启用",1:"禁用"})</code></li>
<li>linkTo: 生成链接，点击打开对象详情对话框</li>
</ul>
<p>在datagrid中使用：</p>
<pre><code>&lt;th data-options="field:'createTm', sortable:true, formatter:Formatter.dt"&gt;创建时间&lt;/th&gt;
&lt;th data-options="field:'amount', sortable:true, sorter: numberSort, formatter:Formatter.number"&gt;金额&lt;/th&gt;
&lt;th data-options="field:'userName', sortable:true, formatter:Formatter.linkTo('userId', '#dlgUser')"&gt;用户&lt;/th&gt;
&lt;th data-options="field:'status', sortable:true, jdEnumMap: OrderStatusMap, formatter: Formatter.orderStatus"&gt;状态&lt;/th&gt;
&lt;th data-options="field:'done', sortable:true, formatter: Formatter.flag()"&gt;已处理&lt;/th&gt;</code></pre></div>
<div class="block">
<h2 id="datagrid.quickAutoSize">@key datagrid.quickAutoSize</h2>
<p>扩展属性quickAutoSize。当行很多且列很多时，表格加载极慢。如果是简单表格（全部列都显示且自动大小，没有多行表头等），可以用这个属性优化。<br />
在pageSimple中默认quickAutoSize为true。</p>
<pre><code>var dgOpt = {
    ...
    pageSize: 200, // 默认一页20，改为200后，默认性能将显著下降; 设置为500后，显示将超过10秒
    pageList: [200, 500, 1000],
    quickAutoSize: true // WUI对easyui-datagrid的扩展属性，用于大量列时提升性能. 参考: jquery.easyui.min.js
};
jtbl.datagrid(dgOpt);</code></pre>
<p>其原因是easyui-datagrid的autoSizeColumn方法有性能问题。当一页行数很多时可尝试使用quickAutoSize选项。</p></div>
<div class="block">
<h2 id=".noData">@key .noData</h2>
<p>CSS类, 可定义无数据提示的样式</p></div>
<div class="block">
<h2 id="GridHeaderMenu">@var GridHeaderMenu</h2>
<p>表头左上角右键菜单功能。</p>
<p>扩展示例：</p>
<pre><code>WUI.GridHeaderMenu.items.push('&lt;div id="showObjLog"&gt;操作日志&lt;/div&gt;');
WUI.GridHeaderMenu.showObjLog = function (jtbl) {
    var row = WUI.getRow(jtbl);
    if (!row)
        return;
    ...
    WUI.showPage("pageObjLog", "操作日志!", [null, param]);
};</code></pre></div>
<div class="block">
<h2 id="showDlgQuery">@fn showDlgQuery(data?={ac, param})</h2></div>
<div class="block">
<h2 id=".easyui-validatebox">@key .easyui-validatebox</h2>
<p>为form中的组件加上该类，可以限制输入类型，如：</p>
<pre><code>&lt;input name="amount" class="easyui-validatebox" data-options="required:true,validType:'number'" &gt;</code></pre>
<p>validType还支持：</p>
<ul>
<li>number: 数字</li>
<li>uname: 4-16位用户名，字母开头</li>
<li>cellphone: 11位手机号</li>
<li>datetime: 格式为&quot;年-月-日 时:分:秒&quot;，时间部分可忽略</li>
</ul>
<p>其它自定义规则(或改写上面规则)，可通过下列方式扩展：</p>
<pre><code>$.extend($.fn.validatebox.defaults.rules, {
    workday: {
        validator: function(value) {
            return value.match(/^[1-7,abc]+$/);
        },
        message: '格式例："1,3a,5b"表示周一,周三上午,周五下午.'
    }
});</code></pre></div>
<div class="block">
<h2 id=".wui-form-table">@key .wui-form-table</h2>
<p>在wui-dialog上，对于form下直接放置的table，一般用于字段列表排列，框架对它添加类wui-form-table并自动对列设置百分比宽度，以自适应显示。</p>
<p>在非对话框上，也可手工添加此类来应用该功能。</p></div>
<div class="block">
<h2 id="isBusy">@var isBusy</h2>
<p>标识应用当前是否正在与服务端交互。一般用于自动化测试。</p></div>
<div class="block">
<h2 id="g_args">@var g_args</h2>
<p>应用参数。</p>
<p>URL参数会自动加入该对象，例如URL为 <code>http://{server}/{app}/index.html?orderId=10&amp;dscr=上门洗车</code>，则该对象有以下值：</p>
<pre><code>g_args.orderId=10; // 注意：如果参数是个数值，则自动转为数值类型，不再是字符串。
g_args.dscr="上门洗车"; // 对字符串会自动进行URL解码。</code></pre>
<p>框架会自动处理一些参数：</p>
<ul>
<li>g_args._debug: 在测试模式下，指定后台的调试等级，有效值为1-9. 参考：后端测试模式 P_TEST_MODE，调试等级 P_DEBUG.</li>
<li>g_args.autoLogin: 记住登录信息(token)，下次自动登录；注意：如果是在手机模式下打开，此行为是默认的。示例：<a href="http://server/jdcloud/web/?autoLogin">http://server/jdcloud/web/?autoLogin</a></li>
<li>g_args.phpdebug: (v6) 设置为1时，以调用接口时激活PHP调试，与vscode/netbeans/vim-vdebug等PHP调试器联合使用。参考：<a href="http://oliveche.com/jdcloud-site/phpdebug.html">http://oliveche.com/jdcloud-site/phpdebug.html</a></li>
</ul>
<p class="see"><strong>@see <a href="#parseQuery">parseQuery</a></strong>  URL参数通过该函数获取。</p></div>
<div class="block">
<h2 id="g_data">@var g_data = {userInfo?}</h2>
<p>应用全局共享数据。</p>
<p>在登录时，会自动设置userInfo属性为个人信息。所以可以通过 g_data.userInfo==null 来判断是否已登录。</p>
<p class="key"><strong>@key <a id="g_data.userInfo">g_data.userInfo</a></strong> </p></div>
<div class="block">
<h2 id="BASE_URL">@var BASE_URL</h2>
<p>TODO: remove</p>
<p>设置应用的基本路径, 应以&quot;/&quot;结尾.</p></div>
<div class="block">
<h2 id="WUI.options">@var WUI.options</h2>
<p>{appName=user, title=&quot;客户端&quot;, onShowLogin, pageHome=&quot;pageHome&quot;, pageFolder=&quot;page&quot;}</p>
<ul>
<li>appName: 用于与后端通讯时标识app.</li>
<li>pageHome: 首页的id, 默认为&quot;pageHome&quot;</li>
<li>pageFolder: 子页面或对话框所在文件夹, 默认为&quot;page&quot;</li>
<li>closeAfterAdd: (=false) 设置为true时，添加数据后关闭窗口。默认行为是添加数据后保留并清空窗口以便连续添加。</li>
<li>closeAfterFind: (=false) (v6)设置为true时，查询后关闭窗口。默认行为是查询后窗口不关闭。</li>
<li>fuzzyMatch: (=false) 设置为true时，则查询对话框中的文本查询匹配字符串任意部分。</li>
</ul></div>
<div class="block">
<h2 id="WUI.options.moduleExt">@var WUI.options.moduleExt</h2>
<p>用于模块扩展。有两个回调函数选项：</p>
<pre><code>// 定制模块的页面路径
WUI.options.moduleExt.showPage = function (name) {
    // name为showPage或showDlg函数调用时的页面/对话框；返回实际页面地址；示例：
    var map = {
        "pageOrdr__Mes.html": "page/mes/pageOrdr.html",
        "pageOrdr__Mes.js": "page/mes/pageOrdr.js",
    };
    return map[name] || name;
}
// 定制模块的接口调用地址
WUI.options.moduleExt.callSvr = function (name) {
    // name为callSvr调用的接口名，返回实际URL地址；示例：
    var map = {
        "Ordr__Mes.query" =&gt; "../../mes/api/Ordr.query",
        "Ordr__Item.query" =&gt; "../../mes/api/Item.query"
    }
    return map[name] || name;
}</code></pre>
<p>详细用法案例，可参考：筋斗云开发实例讲解 - 系统复用与微服务方案。</p></div>
<div class="block">
<h2 id="app_alert">@fn app_alert(msg, [type?=i], [fn?], opt?={timeoutInterval?, defValue?, onCancel()?})</h2>
<p class="param"><strong>@param type</strong>  对话框类型: "i": info, 信息提示框; "e": error, 错误框; "w": warning, 警告框; "q"(与app_confirm一样): question, 确认框(会有"确定"和"取消"两个按钮); "p": prompt, 输入框</p>
<p class="param"><strong>@param fn</strong>  Function(text?) 回调函数，当点击确定按钮时调用。当type="p" (prompt)时参数text为用户输入的内容。</p>
<p class="param"><strong>@param opt</strong>  Object. 可选项。 timeoutInterval表示几秒后自动关闭对话框。defValue用于输入框(type=p)的缺省值.</p>
<p>使用jQuery easyui弹出提示对话框.</p>
<p>示例:</p>
<pre><code>// 信息框，3s后自动点确定
app_alert("操作成功", function () {
    WUI.showPage("pageGenStat");
}, {timeoutInterval: 3000});

// 错误框
app_alert("操作失败", "e");

// 确认框(确定/取消)
app_alert("立即付款?", "q", function () {
    WUI.showPage("#pay");
});

// 输入框
app_alert("输入要查询的名字:", "p", function (text) {
    callSvr("Book.query", {cond: "name like '%" + text + "%'"});
});</code></pre></div>
<div class="block">
<h2 id="app_confirm">@fn app_confirm(msg, fn?)</h2>
<p class="param"><strong>@param fn</strong>  Function(isOk). 用户点击确定或取消后的回调。</p>
<p>使用jQuery easyui弹出确认对话框.</p></div>
<div class="block">
<h2 id="app_show">@fn app_show(msg)</h2>
<p>使用jQuery easyui弹出对话框.</p></div>
<div class="block">
<h2 id="app_progress">@fn app_progress(value, msg?)</h2>
<p class="param"><strong>@param value</strong>  0-100间数值.</p>
<p>显示进度条对话框. 达到100%后自动关闭.</p>
<p>注意：同一时刻只能显示一个进度条。</p></div>
<div class="block">
<h2 id="makeLinkTo">@fn makeLinkTo(dlg, id, text?=id, obj?)</h2>
<p>生成一个链接的html代码，点击该链接可以打开指定对象的对话框。</p>
<p>示例：根据订单号，生成一个链接，点击链接打开订单详情对话框。</p>
<pre><code>var orderId = 101;
var html = makeLinkTo("#dlgOrder", orderId, "订单" + orderId);</code></pre>
<p>(v5.1)<br />
示例：如果供应商(obj=Supplier)和客户(obj=Customer)共用一个对话框BizPartner，要显示一个id=101的客户，必须指定obj参数：</p>
<pre><code>var html = makeLinkTo("#dlgBizPartner", 101, "客户-101", "Customer");</code></pre>
<p>点击链接将调用</p>
<pre><code>WUI.showObjDlg("#dlgBizPartner", FormMode.forSet, {id: 101, obj: "Customer"};</code></pre></div>
<div class="block">
<h2 id="tryAutoLogin">@fn tryAutoLogin(onHandleLogin, reuseCmd?)</h2>
<p class="param"><strong>@param onHandleLogin</strong>  Function(data). 调用后台login()成功后的回调函数(里面使用this为ajax options); 可以直接使用WUI.handleLogin</p>
<p class="param"><strong>@param reuseCmd</strong>  String. 当session存在时替代后台login()操作的API, 如"User.get", "Employee.get"等, 它们在已登录时返回与login相兼容的数据. 因为login操作比较重, 使用它们可减轻服务器压力. </p>
<p class="return"><strong>@return Boolean.</strong>  true=登录成功; false=登录失败.</p>
<p>该函数一般在页面加载完成后调用，如</p>
<pre><code>function main()
{
    $.extend(WUI.options, {
        appName: APP_NAME,
        title: APP_TITLE,
        onShowLogin: showDlgLogin
    });

    WUI.tryAutoLogin(WUI.handleLogin, "Employee.get");
}

$(main);</code></pre>
<p>该函数同步调用后端接口。如果要异步调用，请改用tryAutoLoginAsync函数，返回Deferred对象，resolve表示登录成功，reject表示登录失败。</p></div>
<div class="block">
<h2 id="handleLogin">@fn handleLogin(data)</h2>
<p class="param"><strong>@param data</strong>  调用API "login"成功后的返回数据.</p>
<p>处理login相关的操作, 如设置g_data.userInfo, 保存自动登录的token等等.</p>
<p>(v5.5) 如果URL中包含hash（即&quot;#pageIssue&quot;这样），且以&quot;#page&quot;开头，则登录后会自动打开同名的列表页（如&quot;pageIssue&quot;页面）。</p></div>
<div class="block">
<h2 id="initClient">@fn initClient()</h2></div>
<div class="block">
<h2 id="Plugins">@class Plugins</h2></div>
<div class="block">
<h2 id="Plugins.exists">@fn Plugins.exists(pluginName)</h2></div>
<div class="block">
<h2 id="Plugins.list">@fn Plugins.list()</h2></div>
<div class="block">
<h2 id="setApp">@fn setApp(opt)</h2>
<p class="see"><strong>@see <a href="#options">options</a></strong> </p>
<p>TODO: remove. use $.extend instead.</p></div>
<div class="block">
<h2 id="logout">@fn logout(dontReload?=0)</h2>
<p class="param"><strong>@param dontReload</strong>  如果非0, 则注销后不刷新页面.</p>
<p>注销当前登录, 成功后刷新页面(除非指定dontReload=1)<br />
返回logout调用的deferred对象</p></div>
<div class="block">
<h2 id="tabClose">@fn tabClose(idx?)</h2>
<p>关闭指定idx的标签页。如果未指定idx，则关闭当前标签页.</p></div>
<div class="block">
<h2 id="getActivePage">@fn getActivePage()</h2>
<p>返回当前激活的逻辑页jpage，注意可能为空: jpage.size()==0。</p></div>
<div class="block">
<h2 id="showLoading">@fn showLoading()</h2></div>
<div class="block">
<h2 id="hideLoading">@fn hideLoading()</h2></div>
<div class="block">
<h2 id="tabMain">@var tabMain</h2>
<p>标签页组件。为jquery-easyui的tabs插件，可以参考easyui文档调用相关命令进行操作，如关闭当前Tab：</p>
<pre><code>var jtab = WUI.tabMain.tabs("getSelected");
var idx = WUI.tabMain.tabs("getTabIndex", jtab);
WUI.tabMain.tabs("close", idx);</code></pre>
<p>注：要关闭当前Tab，可以直接用WUI.tabClose().</p></div>
<div class="block">
<h2 id="jquery-mycombobox">@module jquery-mycombobox</h2><div class="toc"><p style="margin-left:0em"><a href="#jquery-mycombobox-1 用url选项加载下拉列表">1 用url选项加载下拉列表</a></p>
<p style="margin-left:0em"><a href="#jquery-mycombobox-2 用jdEnumMap选项指定下拉列表">2 用jdEnumMap选项指定下拉列表</a></p>
<p style="margin-left:0em"><a href="#jquery-mycombobox-3 用loadFilter调整返回数据">3 用loadFilter调整返回数据</a></p>
<p style="margin-left:0em"><a href="#jquery-mycombobox-4 动态列表 - setOption">4 动态列表 - setOption</a></p>
<p style="margin-left:2em"><a href="#jquery-mycombobox-4.1 动态修改固定下拉列表">4.1 动态修改固定下拉列表</a></p>
<p style="margin-left:2em"><a href="#jquery-mycombobox-4.2 旧方案(不建议使用)">4.2 旧方案(不建议使用)</a></p>
<p style="margin-left:0em"><a href="#jquery-mycombobox-5 级联列表支持">5 级联列表支持</a></p>
<p style="margin-left:0em"><a href="#jquery-mycombobox-6 自动感知对象变动并刷新列表">6 自动感知对象变动并刷新列表</a></p>
</div>
<p class="fn"><strong>@fn <a id="jQuery.fn.mycombobox">jQuery.fn.mycombobox</a></strong> (force?=false)</p>
<p class="key"><strong>@key <a id=".my-combobox">.my-combobox</a></strong>  关联选择框</p>
<p class="var"><strong>@var <a id="ListOptions">ListOptions</a></strong>  定义关联选择框的数据源</p>
<p class="param"><strong>@param force</strong> ?=false 如果为true, 则调用时强制重新初始化。默认只初始化一次。</p>
<p>关联选择框组件。</p>
<p>用法：先定义select组件：</p>
<pre><code>&lt;select name="empId" class="my-combobox" data-options="valueField: 'id', ..."&gt;&lt;/select&gt;</code></pre>
<p>通过data-options可设置选项: { url, formatter(row), loadFilter(data), valueField, textField, jdEnumMap/jdEnumList }</p>
<p>初始化：</p>
<pre><code>var jo = $(".my-combobox").mycombobox();</code></pre>
<p>注意：使用WUI.showPage或WUI.showDlg显示的逻辑页或对话框中如果有my-combobox组件，会自动初始化，无须再调用上述代码。</p>
<p>操作：</p>
<ul>
<li>刷新列表： jo.trigger(&quot;refresh&quot;);</li>
<li>标记刷新（下次打开时刷新）： jo.trigger(&quot;markRefresh&quot;, [obj?]); 如果指定obj，则仅当URL匹配obj的查询接口时才刷新。<br />
（注意：在其它页面进行修改操作时，会自动触发markRefresh事件，以便下拉框能自动刷新。）</li>
<li>(v5.2)加载列表：jo.trigger(&quot;loadOptions&quot;, param);  一般用于级联列表，即url带参数的情况。(注意：v6起不再使用，改用setOption事件)</li>
<li>(v6) 重新设置选项：jo.trigger(&quot;setOption&quot;, opt); 而且仅当点击到下拉框时才会加载选项列表。</li>
</ul>
<p>特性：</p>
<ul>
<li>初始化时调用url指定接口取数据并生成下拉选项。</li>
<li>双击可刷新列表。</li>
<li>支持数据缓存，不必每次打开都刷新。</li>
<li>也支持通过key-value列表初始化(jdEnumMap/jdEnumList选项)</li>
<li>自动添加一个空行</li>
</ul>
<p>注意：</p>
<ul>
<li>(v5.0) 接口调用由同步改为异步，以便提高性能并支持batch操作。同步(callSvrSync)便于加载下拉列表后立即为它赋值，改成异步请求(callSvr)后仍支持立即设置值。</li>
<li>(v5.0) HTML select组件的jQuery.val()方法被改写。当设置不在范围内的值时，虽然下拉框显示为空，其实际值存储在 value<em> 字段中，(v5.2) 通过jQuery.val()方法仍可获取到。<br />
用原生JS可以分别取 this.value 和 this.value</em> 字段。</li>
</ul>
<p class="param"><strong>@param opt</strong>  {url, jdEnumMap/jdEnumList, formatter, textField, valueField, loadFilter, urlParams, isLoaded_, url_, emptyText}</p>
<p class="param"><strong>@param opt.url</strong>  动态加载使用的url，或一个返回URL的函数（这时会调用opt.url(opt.urlParams)得到实际URL，并保存在opt.url_中）</p>
<p>所以要取URL可以用</p>
<pre><code>var opt = WUI.getOptions(jo);
url = opt.url_ || opt.url;</code></pre>
<p class="param"><strong>@param opt.emptyText</strong>  设置首个空行（值为null）对应的显示文字。</p>
<h4 id="jquery-mycombobox-1 用url选项加载下拉列表">1 用url选项加载下拉列表</h4>
<p>例如，想显示所有员工(Employee)的下拉列表，绑定员工编号字段(id)，显示是员工姓名(name):</p>
<pre><code>分派给 &lt;select name="empId" class="my-combobox" data-options="url:WUI.makeUrl('Employee.query', {res:'id,name',pagesz:-1})"&gt;&lt;/select&gt;</code></pre>
<p>(v6)也可以用input来代替select，组件会自动处理.</p>
<p>注意查询默认是有分页的（页大小一般为20条），用参数<code>{pagesz:-1}</code>使用服务器设置的最大的页大小（后端最大pagesz默认100，可使用maxPageSz参数调节）。<br />
为了精确控制返回字段与显示格式，data-options可能更加复杂，习惯上定义一个ListOptions变量包含各种下拉框的数据获取方式，便于多个页面上共享，像这样：</p>
<pre><code>&lt;select name="empId" class="my-combobox" data-options="ListOptions.Emp()"&gt;&lt;/select&gt;

var ListOptions = {
    // ListOptions.Emp()
    Emp: function () {
        var opts = {
            url: WUI.makeUrl('Employee.query', {
                res: 'id,name,uname',
                cond: 'storeId=' + g_data.userInfo.storeId,
                pagesz:-1
            }),
            formatter: function (row) { return row.name + '(' + row.uname + ')'; }
        };
        return opts;
    },
    ...
};</code></pre>
<p>返回对象的前两个字段被当作值字段(valueField)和显示字段(textField)，上例中分别是id和name字段。<br />
如果返回对象只有一个字段，则valueField与textField相同，都是这个字段。<br />
如果指定了formatter，则显示内容由它决定，textField此时无意义。</p>
<p>可以显式指定这两个字段，如：</p>
<pre><code>var opts = {
    valueField: "id",
    textField: "name",
    url: ...
}</code></pre>
<p>示例2：下拉框绑定User.city字段，可选项为该列已有的值：</p>
<pre><code>&lt;select name="city" class="my-combobox" data-options="ListOptions.City()"&gt;&lt;/select&gt;

var ListOptions = {
    City: function () {
        var opts = {
            url: WUI.makeUrl('User.query', {
                res: 'city',
                cond: 'city IS NOT NULL'
                distinct: 1,
                pagesz:-1
            })
        };
        return opts;
    },
    ...
};</code></pre>
<p>(v5.2) url还可以是一个函数。如果带一个参数，一般用于<strong>动态列表</strong>或<strong>级联列表</strong>。参考后面相关章节。</p>
<h4 id="jquery-mycombobox-2 用jdEnumMap选项指定下拉列表">2 用jdEnumMap选项指定下拉列表</h4>
<p>也支持通过key-value列表用jdEnumMap选项或jdEnumList选项来初始化下拉框，如：</p>
<pre><code>订单状态： &lt;select name="status" class="my-combobox" data-options="jdEnumMap:OrderStatusMap"&gt;&lt;/select&gt;
或者：
订单状态： &lt;select name="status" class="my-combobox" data-options="jdEnumList:'CR:未付款;CA:已取消'"&gt;&lt;/select&gt;
或者：(key-value相同时, 只用';'间隔)
订单状态： &lt;select name="status" class="my-combobox" data-options="jdEnumList:'未付款;已取消'"&gt;&lt;/select&gt;</code></pre>
<p>其中OrderStatusMap定义如下：</p>
<pre><code>var OrderStatusMap = {
    "CR": "未付款",
    "CA": "已取消"
};</code></pre>
<h4 id="jquery-mycombobox-3 用loadFilter调整返回数据">3 用loadFilter调整返回数据</h4>
<p>另一个例子：在返回列表后，可通过loadFilter修改列表，例如添加或删除项：</p>
<pre><code>&lt;select name="brandId" class="my-combobox" data-options="ListOptions.Brand()" &gt;&lt;/select&gt;</code></pre>
<p>JS代码ListOptions.Brand:</p>
<pre><code>var ListOptions = {
    ...
    // ListOptions.Brand()
    Brand: function () {
        var opts = {
            url:WUI.makeUrl('queryBrand', {res: "id,name", pagesz:-1}),
            loadFilter: function(data) {
                data.unshift({id:'0', name:'所有品牌'});
                return data;
            }
        };
        return opts;
    }
};</code></pre>
<p>更简单地，这个需求还可以通过同时使用jdEnumMap和url来实现：</p>
<pre><code>var ListOptions = {
    ...
    // ListOptions.Brand()
    Brand: function () {
        var opts = {
            url:WUI.makeUrl('queryBrand', {res: "id,name", pagesz:-1}),
            jdEnumMap: {0: '所有品牌'}
        };
        return opts;
    }
};</code></pre>
<p>注意：jdEnumMap指定的固定选项会先出现。</p>
<h4 id="jquery-mycombobox-4 动态列表 - setOption">4 动态列表 - setOption</h4>
<p>(v6) url选项使用函数，之后调用loadOptions方法刷新</p>
<p>示例：在安装任务明细对话框(dlgTask)中，根据品牌(brand)过滤显示相应的门店列表(Store).</p>
<pre><code>var ListOptions = {
    // 带个cond参数，为query接口的查询条件参数，支持 "brand='xxx'" 或 {brand: 'xxx'}两种格式。
    Store: function (cond) {
        var opts = {
            valueField: "id",
            textField: "name",
            url: WUI.makeUrl('Store.query', {
                res: 'id,name',
                cond: cond,
                pagesz: -1
            },
            formatter: function (row) { return row.id + "-" + row.name; }
        };
        return opts;
    }
};</code></pre>
<p>在明细对话框HTML中不指定options而是代码中动态设置：</p>
<pre><code>&lt;form&gt;
    品牌 &lt;input name="brand"&gt;
    门店 &lt;select name="storeId" class="my-combobox"&gt;&lt;/select&gt;
&lt;/form&gt;</code></pre>
<p>对话框初始化函数：在显示对话框或修改品牌后刷新门店列表</p>
<pre><code>function initDlgTask()
{
    ...

    $(frm.brand).on("change", function () {
        if (this.value) {
            // 用setOption动态修改设置。注意trigger函数第二个参数须为数组，作为参数传递给用on监听该事件的处理函数。
            $(frm.storeId).trigger("setOption", [ ListOptions.Store({brand: this.value}) ]);
        }
    });

    function onShow() {
        $(frm.brand).trigger("change");
    }
}</code></pre>
<h5 id="jquery-mycombobox-4.1 动态修改固定下拉列表">4.1 动态修改固定下拉列表</h5>
<p>(v6) 示例：根据type决定下拉列表用哪个，通过setOption来设置。</p>
<pre><code>function onBeforeShow(ev, formMode, opt) {
    var type = opt.objParam &amp;&amp; opt.objParam.type || opt.data &amp;&amp; opt.data.type;

    var comboOpt = type == "入库" ? { jdEnumMap: MoveTypeMap } :
        type == "出库"? { jdEnumMap: MoveTypeMap2 } : null
    jdlg.find("[name=moveType]").trigger("setOption", [comboOpt]);
}</code></pre>
<p>如果setOption给的参数是null，则忽略不处理。</p>
<h5 id="jquery-mycombobox-4.2 旧方案(不建议使用)">4.2 旧方案(不建议使用)</h5>
<p>(v5.2起, v6前) url选项使用函数，之后调用loadOptions方法刷新:</p>
<pre><code>var ListOptions = {
    Store: function () {
        var opts = {
            valueField: "id",
            textField: "name",
            // !!! url使用函数指定, 之后手工给参数调用loadOptions方法刷新 !!!
            url: function (brand) {
                return WUI.makeUrl('Store.query', {
                    res: 'id,name',
                    cond: "brand='" + brand + "'",
                    pagesz: -1
                })
            },
            formatter: function (row) { return row.id + "-" + row.name; }
        };
        return opts;
    }
};</code></pre>
<p>在明细对话框HTML中：</p>
<pre><code>&lt;form&gt;
    品牌 &lt;input name="brand"&gt;
    门店 &lt;select name="storeId" class="my-combobox" data-options="ListOptions.Store()"&gt;&lt;/select&gt;
&lt;/form&gt;</code></pre>
<p>对话框初始化函数：在显示对话框或修改品牌后刷新门店列表</p>
<pre><code>function initDlgTask()
{
    ...

    $(frm.brand).on("change", function () {
        if (this.value)
            $(frm.storeId).trigger("loadOptions", this.value);
    });

    function onShow() {
        $(frm.brand).trigger("change");
    }
}</code></pre>
<h4 id="jquery-mycombobox-5 级联列表支持">5 级联列表支持</h4>
<p>(v5.2引入, v6使用新方案) 与动态列表机制相同。</p>
<p>示例：缺陷类型(defectTypeId)与缺陷代码(defectId)二级关系：选一个缺陷类型，缺陷代码自动刷新为该类型下的代码。<br />
在初始化时，如果字段有值，下拉框应分别正确显示。</p>
<p>在一级内容切换时，二级列表自动从后台查询获取。同时如果是已经获取过的，缓存可以生效不必反复获取。<br />
双击仍支持刷新。</p>
<p>对话框上HTML如下：（defectId是用于提交的字段，所以用name属性；defectTypeId不用提交，所以用了id属性）</p>
<pre><code>&lt;select id="defectTypeId" class="my-combobox" data-options="ListOptions.DefectType()" style="width:45%"&gt;&lt;/select&gt;
&lt;select name="defectId" class="my-combobox" data-options="" style="width:45%"&gt;&lt;/select&gt;</code></pre>
<p>defectId上暂时不设置，之后传参动态设置。</p>
<p>其中，DefectType()与传统设置无区别，在Defect()函数中，应设置url为一个带参函数：</p>
<pre><code>var ListOptions = {
    DefectType: function () {
        var opts = {
            valueField: "id",
            textField: "code",
            url: WUI.makeUrl('Defect.query', {
                res: 'id,code,name',
                cond: 'typeId is null',
                pagesz: -1
            }),
            formatter: function (row) { return row.code + "-" + row.name; }
        };
        return opts;
    },
    // ListOptions.Defect
    Defect: function (typeId) {
        var opts = {
            valueField: "id",
            textField: "code",
            url: WUI.makeUrl('Defect.query', {
                res: 'id,code,name',
                cond: "typeId=" + typeId,
                pagesz: -1
            },
            formatter: function (row) { return row.code + "-" + row.name; }
        };
        return opts;
    }
}</code></pre>
<p>在对话框上设置关联动作，调用setOption事件：</p>
<pre><code>$(frm.defectTypeId).on("change", function () {
    var typeId = $(this).val();
    if (typeId)
        $(frm.defectId).trigger("setOption", [ ListOptions.Defect(typeId) ]);
});</code></pre>
<p>注意jQuery的trigger发起事件函数第二个参数须为数组。</p>
<p>对话框加载时，手工设置defectTypeId的值：</p>
<pre><code>function onShow() {
    $(frm.defectTypeId).val(defectTypeId).trigger("change");
}</code></pre>
<h4 id="jquery-mycombobox-6 自动感知对象变动并刷新列表">6 自动感知对象变动并刷新列表</h4>
<p>假如某mycombobox组件查询Employee对象列表。当在Employee页面新建、修改、删除对象后，回到组件的页面，点击组件时将自动刷新列表。<br />
(wui-combogrid也具有类似功能)</p></div>
<div class="block">
<h2 id="JdcloudExt">@module JdcloudExt</h2>
<p>框架扩展功能或常用函数.</p></div>
<div class="block">
<h2 id=".wui-upload">@key .wui-upload</h2><div class="toc"><p style="margin-left:0em"><a href="#.wui-upload-1 右键菜单">1 右键菜单</a></p>
<p style="margin-left:0em"><a href="#.wui-upload-2 音频等文件上传">2 音频等文件上传</a></p>
<p style="margin-left:0em"><a href="#.wui-upload-3 压缩参数">3 压缩参数</a></p>
<p style="margin-left:0em"><a href="#.wui-upload-4 动态设置选项">4 动态设置选项</a></p>
<p style="margin-left:0em"><a href="#.wui-upload-5 定制上传接口">5 定制上传接口</a></p>
</div>
<p>对话框上的上传文件组件。</p>
<p>用于在对象详情对话框中，展示关联图片字段。图片可以为单张或多张。<br />
除显示图片外，也可以展示其它用户上传的文件，如视频、文本等。</p>
<p>预览图样式在style.css中由 <code>.wui-upload img</code>定义。<br />
点击一张预览图，如果有jqPhotoSwipe插件，则全屏显示图片且可左右切换；否则在新窗口打开大图。</p>
<p>示例：只需要标注wui-upload类及指定data-options，即可实现图片预览、上传等操作。</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;上传多图&lt;/td&gt;
        &lt;td class="wui-upload"&gt;
            &lt;input name="pics"&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;上传单图&lt;/td&gt;
        &lt;td class="wui-upload" data-options="multiple:false"&gt;
            &lt;input name="picId"&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;上传附件&lt;/td&gt;
        &lt;td class="wui-upload" data-options="pic:false,fname:'attName'"&gt; &lt;!-- v5.5: 显示使用虚拟字段attName,须后端提供,也可以用 fname=1将显示内容保存到atts字段 --&gt;
            &lt;input name="atts"&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;上传单个附件&lt;/td&gt;
        &lt;td class="wui-upload" data-options="multiple:false,pic:false,fname:'attName'"&gt;
            &lt;input name="attId"&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</code></pre>
<ul>
<li>带name组件的input绑定到后端字段，并被自动隐藏。允许有多个带name的input组件，仅第一个input被处理。</li>
<li>options中可以设置：{ nothumb, pic, fname  }</li>
</ul>
<p>组件会自动添加预览区及文件选择框等，完整的DOM大体如下：</p>
<pre><code>&lt;div class="wui-upload"&gt;
    &lt;input name="atts"&gt;
    &lt;div class="imgs"&gt;&lt;/div&gt;
    &lt;input type="file" multiple&gt;
    &lt;p class="hint"&gt;&lt;a href="javascript:;" class="btnEditAtts"&gt;编辑&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</code></pre>
<p>其中imgs为预览区，内部DOM结构为 <code>.imgs - a标签 - img或p标签</code>。<br />
在上传图片或文件后，会在imgs下创建<code>&lt;a&gt;</code>标签，对于图片a标签里面是img标签，否则是p标签。<br />
a标签上数据如下：</p>
<ul>
<li>attr(&quot;attId&quot;)为当前图片的缩略图编号，如&quot;100&quot;。如果无该属性，表示尚未上传。</li>
<li>attr(&quot;att&quot;)为当前预览图的原始数据。在opt.fname=1时包含文件名，如&quot;100:file1.pdf&quot;。</li>
<li>prop(&quot;fileObj_&quot;) 当上传无缩略图图片(opt.nothumb=1)或上传附件(opt.pic=false)时，fileObj_中保存了文件对象，用于之后上传。</li>
</ul>
<p>在a下的img标签上，有以下数据：</p>
<ul>
<li>attr(&quot;picId&quot;)保存图片缩略图ID。如果无该属性，表示尚未上传。</li>
<li>prop(&quot;picData_&quot;)保存图片压缩信息。仅当新选择的图片才有。</li>
</ul>
<p class="param"><strong>@param opt.multiple=true</strong>  设置false限制只能选一张图。</p>
<p class="param"><strong>@param opt.nothumb=false</strong>  设置为true表示不生成缩略图，且不做压缩（除非指定maxSize参数，这时不生成缩略图，但仍然压缩）。</p>
<pre><code>&lt;td class="wui-upload" data-options="nothumb:true"&gt;...&lt;/td&gt;</code></pre>
<p class="param"><strong>@param opt.pic=true</strong>  设置为false，用于上传视频或其它非图片文件</p>
<p>如果为false, 在.imgs区域内显示文件名链接而非图片。</p>
<p class="param"><strong>@param opt.fname</strong>  是否显示文件名。默认为0。目前不用于图片，只用于附件（即pic=false时有效）。</p>
<p>(v5.5) </p>
<ul>
<li>当值为0时，字段只保存文件编号或编号列表，如&quot;100&quot;, &quot;100,101&quot;。</li>
<li>当值为1时，字段保存文件编号及文件名（可当备注使用），如&quot;100:合同.docx&quot;, &quot;100:合同.docx,101:合同附件.xlsx&quot;</li>
<li>还可以指定一个虚拟字段名，表示字段虽然只保存编号，但显示时可使用指定的虚拟字段，且其格式与fname=1时相同。这样看到的效果与fname=1类似。</li>
</ul>
<p>示例：用attId字段保存单个附件，并显示附件名</p>
<p>由于attId是数值字段，不可存额外字符串信息，所以不能设置fname=1。<br />
这时在后端做一个虚拟字段如attName，格式为&quot;{attId}:{fileName}&quot;:</p>
<pre><code>    protected $vcolDefs = [
        [
            "res" =&gt; ["concat(att.id,':',att.orgName) attName"],
            "join" =&gt; "LEFT JOIN Attachment att ON att.id=t0.attId",
            "default" =&gt; true
        ]
        ...
    ];</code></pre>
<p>列表页中展示使用虚拟字段attName而非attId：</p>
<pre><code>        &lt;th data-options="field:'attName', formatter:Formatter.atts"&gt;模板文件&lt;/th&gt;</code></pre>
<p>在详情对话框中指定fname为虚拟字段&quot;att&quot;：</p>
<pre><code>        &lt;td&gt;模板文件&lt;/td&gt;
        &lt;td class="wui-upload" data-options="multiple:false,pic:false,fname:'attName'"&gt;
            &lt;input name="attId"&gt;
        &lt;/td&gt;</code></pre>
<p>示例：用atts存多个附件。</p>
<p>这时，可设置fname=1，即把文件名也存到atts字段。<br />
也可以设置fname='attName'(虚拟字段)，其格式为&quot;{attId}:{filename},{attId2}:{filename2}&quot;，后端实现参考如下(使用find_in_set)：</p>
<pre><code>        [
            "res" =&gt; ["(SELECT group_concat(concat(att.id,':',att.orgName)) FROM Attachment att WHERE find_in_set(id, t0.atts)) attName"],
            "default" =&gt; true
        ]</code></pre>
<p class="param"><strong>@param opt.manual=false</strong>  是否自动上传提交</p>
<p>默认无须代码即可自动上传文件。如果想要手工操控，可以触发submit事件，<br />
示例：在dialog的validate事件中先确认提示再上传，而不是直接上传：</p>
<p>HTML:</p>
<pre><code>&lt;div class="wui-upload" data-options="manual:true"&gt;...&lt;/div&gt;</code></pre>
<p>JS:</p>
<pre><code>jdlg.on("validate", onValidate);
function onValidate(ev)
{
    var dfd = $.Deferred();
    app_alert("确认上传?", "q", function () {
        var dfd1 = WUI.triggerAsync(jdlg.find(".wui-upload"), "submit");
        dfd1.then(doNext);
    });
    // dialog的validate方法支持异步，故设置ev.dfds数组来告知调用者等异步操作结束再继续
    ev.dfds.push(dfd.promise());

    function doNext() {
        dfd.resolve();
    }
}</code></pre>
<h4 id=".wui-upload-1 右键菜单">1 右键菜单</h4>
<p class="param"><strong>@param opt.menu</strong>  设置右键菜单</p>
<p>在预览区右键单击会出现菜单，默认有“删除”菜单。<br />
示例：商品可以上传多张照片，其中选择一张作为商品头像。<br />
我们在右键中添加一个“设置为缺省头像”菜单，点击后将该图片圈出，将其图片编号保存到字段中。<br />
数据结构为：</p>
<pre><code>@Item: id, picId, pics</code></pre>
<p>上面表Item中，picId为头像的图片ID，pics为逗号分隔的图片列表。</p>
<p>HTML: 在data-options中指定菜单的ID和显示文字。缺省头像将添加&quot;active&quot;类：</p>
<pre><code>&lt;style&gt;
.wui-upload img.active {
    border: 5px solid red;
}
&lt;/style&gt;

&lt;tr&gt;
    &lt;td&gt;门店照片&lt;/td&gt;
    &lt;td class="wui-upload" data-options="menu:{mnuSetDefault:'设置为缺省头像'}"&gt;
        &lt;input name="pics"&gt;
        &lt;input type="input" style="display:none" name="picId"&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
<p>在右键点击菜单时，wui-upload组件会触发onMenu事件，其中参数item为当前预览项（.imgs区域下的a标签，在它下面才是img或p标签）</p>
<pre><code>// 在initDlgXXX中：
jdlg.on("menu", onMenu);
function onMenu(ev, menuId, item)
{
    if (menuId == "mnuSetDefault") {
        var ja = $(item);
        if (ja.attr("attId")) {
            ja.closest(".wui-upload").find("img").removeClass("active");
            var jimg = ja.find("img");
            jimg.addClass("active");

            frm = jdlg.find("form")[0];
            frm.picId.value = jimg.attr("picId");
        }
    }
}
// 高亮显示选中的头像picId。
// 注意：要用jdlg而不是jfrm的show事件。否则wui-upload尚未初始化完成
jdlg.on("show", function (ev, formMode, initData) {
    if (initData &amp;&amp; initData.picId) {
        jdlg.find(".wui-upload img[picId=" + initData.picId + "]").addClass("active");
    }
});</code></pre>
<h4 id=".wui-upload-2 音频等文件上传">2 音频等文件上传</h4>
<p class="param"><strong>@param opt.accept</strong>  指定可上传的文件类型</p>
<p>示例：上传单个音频文件，如m4a, mp3等格式。</p>
<pre><code>&lt;td&gt;文件&lt;/td&gt;
&lt;td class="wui-upload" data-options="multiple:false,pic:false,accept:'audio/*'"&gt;
    &lt;input name="attId"&gt;
    &lt;p class="hint"&gt;要求格式m4a,mp3,wav; 采样率为16000&lt;/p&gt;
&lt;/td&gt;</code></pre>
<h4 id=".wui-upload-3 压缩参数">3 压缩参数</h4>
<p class="param"><strong>@param opt.maxSize</strong> ?=1280 指定压缩后图片的最大长或宽</p>
<p class="param"><strong>@param opt.quality</strong> ?=0.8 指定压缩质量, 一般不用修改.</p>
<p>示例：默认1280像素不够, 增加到2000像素:</p>
<pre><code>&lt;tr&gt;
    &lt;td&gt;图片&lt;/td&gt;
    &lt;td class="wui-upload" data-options="maxSize:2000"&gt;
        &lt;input name="pics"&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
<h4 id=".wui-upload-4 动态设置选项">4 动态设置选项</h4>
<p>示例：在dialog的beforeshow事件回调中，根据情况设置upload组件的选项，如是否压缩图片：</p>
<pre><code>// function initDlgXXX
//
jdlg.on("beforeshow", onBeforeShow);

function onBeforeShow(ev, formMode, opt) 
{
    var objParam = opt.objParam;
    var jo = jpage.find(".picId");
    // 获取和动态设置选项：
    var uploadOpt = WUI.getOptions(jo);
    uploadOpt.nothumb = (objParam.type === "A");
}</code></pre>
<h4 id=".wui-upload-5 定制上传接口">5 定制上传接口</h4>
<ul>
<li>opt.onGetQueryParam: Function() -&gt; {ac?, ...} 定义上传接口名和接口参数。</li>
<li>
<p>opt.onGetData: Function(ret)  处理接口返回结果ret。</p>
<p>示例：调用<code>upload1(resource, version) -&gt; [{id, ..., url}]</code> 接口。<br />
该接口扩展了默认的upload接口，需要传入resource等参数，返回的url字段需要设置到form相应字段上。</p>
<p>// function initDlgVersion<br />
var jo = jdlg.find(&quot;.uploadFile&quot;);<br />
var uploadOpt = WUI.getOptions(jo);<br />
uploadOpt.onGetQueryParam = function () {<br />
return {<br />
ac: &quot;upload1&quot;,<br />
resource: $(frm.resourceId).val(),<br />
version: $(frm.name).val()<br />
}<br />
}<br />
uploadOpt.onGetData = function (ret) {<br />
var resUrl = ret[0].url;<br />
$(frm.url).val(resUrl);<br />
}</p>
</li>
</ul></div>
<div class="block">
<h2 id=".wui-checkList">@key .wui-checkList</h2>
<p>用于在对象详情对话框中，以一组复选框(checkbox)来对应一个逗号分隔式列表的字段。<br />
例如对象Employee中有一个“权限列表”字段perms定义如下：</p>
<pre><code>perms:: List(perm)。权限列表，可用值为: item-上架商户管理权限, emp-普通员工权限, mgr-经理权限。</code></pre>
<p>现在以一组checkbox来在表达perms字段，希望字段中有几项就将相应的checkbox选中，例如值&quot;emp,mgr&quot;表示同时具有emp与mgr权限，显示时应选中这两项。<br />
定义HTML如下：</p>
<pre><code>&lt;tr&gt;
    &lt;td&gt;权限&lt;/td&gt;
    &lt;td class="wui-checkList"&gt;
        &lt;input type="hidden" name="perms"&gt;
        &lt;label&gt;&lt;input type="checkbox" value="emp" checked&gt;员工(默认)&lt;/label&gt;&lt;br&gt;
        &lt;label&gt;&lt;input type="checkbox" value="item"&gt;上架商品管理&lt;/label&gt;&lt;br&gt;
        &lt;label&gt;&lt;input type="checkbox" value="mgr"&gt;经理&lt;/label&gt;&lt;br&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
<p>wui-checkList块中包含一个hidden对象和一组checkbox. hidden对象的name设置为字段名, 每个checkbox的value字段设置为每一项的内部名字。</p></div>
<div class="block">
<h2 id=".wui-labels">@key .wui-labels</h2>
<p>标签字段（labels）是空白分隔的一组词，每个词是一个标签（label）。<br />
可以在字段下方将常用标签列出供用户选择，点一下标签则添加到文本框中，再点一下删除它。(v6) 或者点一下就设置为选中标签(设置opt.simple=true)。</p>
<p>示例1：列出各种类型，点一下类型标签就追加到对话框。</p>
<pre><code>&lt;tr&gt;
    &lt;td&gt;标签&lt;/td&gt;
    &lt;td class="wui-labels"&gt;
        &lt;input name="label" &gt;
        &lt;p class="hint"&gt;企业类型：&lt;span class="labels" dfd="StoreDialog.dfdLabel"&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;p class="hint"&gt;行业标签：&lt;span class="labels"&gt;IT 金融 工业&lt;/span&gt;&lt;/p&gt;
        &lt;p class="hint"&gt;位置标签：&lt;span class="labels"&gt;一期 二期 三期 四期&lt;/span&gt;&lt;/p&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
<ul>
<li>具有CSS类&quot;labels&quot;的组件，内容以空白分隔的多个标签，如`IT 金融 工业&quot;。如果有dfd设置，则表示值是异步编程设置的（参考下面&quot;异步获取示例&quot;）。</li>
</ul>
<p>示例2：设置配置项，并配以说明和示例</p>
<pre><code>&lt;tr&gt;
    &lt;td&gt;配置项名称&lt;/td&gt;
    &lt;td class="wui-labels"&gt;
        &lt;input name="name" class="easyui-validatebox" data-options="required:true"&gt;
        &lt;div class="hint"&gt;可选项和示例值：
            &lt;p class="easyui-tooltip" title="在移动端提交缺陷问题时，可从下拉列表中选择问题类型，就是在此处配置的，多个值以英文分号分隔。"&gt;&lt;span class="labels"&gt;常见问题&lt;/span&gt; 内饰;轮胎&lt;/p&gt;
            &lt;p class="easyui-tooltip" title="多个值以英文空格分隔"&gt;&lt;span class="labels"&gt;集市品类&lt;/span&gt; 办公用品 书籍 卡票券&lt;/p&gt;
            &lt;p class="easyui-tooltip" title="格式为`姓名,电话`"&gt;&lt;span class="labels"&gt;会议室预订联系人&lt;/span&gt; Candy,13917091068&lt;/p&gt;
        &lt;/div&gt;
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
<ul>
<li>最终操作的文本字段是.wui-labels下带name属性的输入框。</li>
<li>在.labels中的文本将被按空白切换，优化显示成一个个标签，可以点击。</li>
<li>支持异步获取，比如要调用接口获取内容，可以指定<code>dfd</code>属性是一个Deferred对象。</li>
<li>添加的标签具有<code>labelMark</code>类(label太常用，没有用它以免冲突)，默认已设置样式。</li>
</ul>
<p>异步获取示例：</p>
<pre><code>var StoreDialog = {
    dfdLabel: $.Deferred()
}
callSvr("Conf.query", {cond: "name='企业分类'", fmt: "one", res: "value"}, function (data) {
    StoreDialog.dfdLabel.resolve(data.value);
})</code></pre>
<p>// TODO: 支持beforeShow时更新</p>
<p>示例3：(v6) 可以从推荐项中选择，也可以直接填写的输入框.</p>
<pre><code>    &lt;tr&gt;
        &lt;td&gt;URL地址&lt;/td&gt;
        &lt;td class="wui-labels" data-options="simple:true"&gt;
            &lt;input name="url" value="http://oliveche.com/mes/"&gt;
            &lt;p class="hint"&gt;
                &lt;span class="labels"&gt;生产环境|http://192.168.10.23/mes/ 测试|http://oliveche.com/mes/&lt;/span&gt;
            &lt;/p&gt;
        &lt;/td&gt;
    &lt;/tr&gt;</code></pre>
<ul>
<li>设置组件选项(data-options内)simple为true</li>
<li>每项标签的格式为&quot;text|value?&quot;(前面例子也适用)，如&quot;生产环境|<a href="http://192.168.10.23/mes/"表示显示"生产环境"，但点击后取值为"http://192.168.10.23/mes/">http://192.168.10.23/mes/"表示显示"生产环境"，但点击后取值为"http://192.168.10.23/mes/</a>&quot;。</li>
</ul></div>
<div class="block">
<h2 id="#menu">@key #menu</h2>
<p>管理端功能菜单，以&quot;menu&quot;作为id:</p>
<pre><code>&lt;div id="menu"&gt;
    &lt;div class="menu-expand-group"&gt;
        &lt;a class="expanded"&gt;&lt;span&gt;&lt;i class="fa fa-pencil-square-o"&gt;&lt;/i&gt;主数据管理&lt;/span&gt;&lt;/a&gt;
        &lt;div class="menu-expandable"&gt;
            &lt;a href="#pageCustomer"&gt;客户管理&lt;/a&gt;
            &lt;a href="#pageStore"&gt;门店管理&lt;/a&gt;
            &lt;a href="#pageVendor"&gt;供应商管理&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 单独的菜单项示例 --&gt;
    &lt;a href="javascript:WUI.showDlg('#dlgImport',{modal:false})"&gt;&lt;span&gt;&lt;i class="fa fa-pencil-square-o"&gt;&lt;/i&gt;批量导入&lt;/span&gt;&lt;/a&gt;
    &lt;a href="javascript:showDlgChpwd()"&gt;&lt;span&gt;&lt;i class="fa fa-user-times"&gt;&lt;/i&gt;修改密码&lt;/span&gt;&lt;/a&gt;
&lt;/div&gt;</code></pre>
<p>菜单组由menu-expand-group标识，第一个a为菜单组标题，可加&quot;expanded&quot;类使其默认展开。<br />
图标使用font awesome库，由<code>&lt;i class="fa fa-xxx"&gt;&lt;/i&gt;</code>指定，图标查询可参考 <a href="http://www.fontawesome.com.cn/faicons/">http://www.fontawesome.com.cn/faicons/</a> 或 <a href="https://fontawesome.com/icons">https://fontawesome.com/icons</a></p></div>
<div class="block">
<h2 id=".wui-combogrid">@key .wui-combogrid</h2><div class="toc"><p style="margin-left:0em"><a href="#.wui-combogrid-1 markRefresh 标记下次打开时刷新列表">1 markRefresh 标记下次打开时刷新列表</a></p>
<p style="margin-left:0em"><a href="#.wui-combogrid-2 动态修改下拉列表">2 动态修改下拉列表</a></p>
</div>
<p>可搜索的下拉列表。<br />
示例：在dialog上，填写门店字段（填写Id，显示名字），从门店列表中选择一个门店。</p>
<pre><code>&lt;form my-obj="Task" title="安装任务" wui-script="dlgTask.js" my-initfn="initDlgTask"&gt;
    &lt;tr&gt;
        &lt;td&gt;门店&lt;/td&gt;
        &lt;td&gt;
            &lt;input class="wui-combogrid" name="storeId" data-options="ListOptions.StoreGrid"&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/form&gt;</code></pre>
<p>选项定义如下：</p>
<pre><code>ListOptions.StoreGrid = {
    jd_vField: "storeName",
    panelWidth: 450,
    width: '95%',
    textField: "name",
    columns: [[
        {field:'id',title:'编号',width:80},
        {field:'name',title:'名称',width:120}
    ]],
    url: WUI.makeUrl('Store.query', {
        res: 'id,name',
    })
};</code></pre>
<p>属性请参考easyui-combogrid相关属性。wui-combogrid扩展属性如下:</p>
<ul>
<li>jd_vField: 显示文本对应的虚拟字段, 用于初始显示和查询。</li>
<li>jd_showId: 默认为true. 显示&quot;idField - textField&quot;格式. 设置为false时只显示textField.</li>
</ul>
<p>在选择一行并返回时，它会触发choose事件：</p>
<pre><code>// 注意要取combogrid对象要用comboname! 而不是用 "[name=storeId]"（原始的input已经变成一个hidden组件，只存储值）
var jo = jdlg.find("[comboname=storeId]"); 
jo.on("choose", function (ev, row) {
    console.log('choose row: ', row);
    ...
});</code></pre>
<p>jo是easyui-combogrid，可以调用它的相应方法，如禁用它：<br />
jo.combogrid({disabled: true});<br />
或<br />
jo.combogrid(&quot;disable&quot;);</p>
<p>在输入时，它会自动以url及参数q向后端发起查询，如<code>callSvr("Store.query", {res:'id,name', q='1'})</code>.<br />
在筋斗云后端须支持相应对象的模糊查询(请查阅文档qsearch)。</p>
<p>特别逻辑：</p>
<ul>
<li>在初始化时，由于尚未从后端查询文本，这时显示jd_vField字段的文本。</li>
<li>如果输入值不在列表中，且不是数字，将当作非法输入被清空。</li>
<li>特别地，在查询模式下（forFind），可以输入任意条件，比如&quot;&gt;10&quot;, &quot;1-10&quot;等。如果输入的是文本，比如&quot;上海*&quot;，则自动以jd_vField字段进行而非数值编号进行查询。</li>
</ul>
<p>示例2：简单的情况，选择时只用名字，不用id。</p>
<pre><code>// var ListOptions 定义中：
// 只用name不用id
CateGrid: {
    jd_vField: "category",
    jd_showId: false,
    panelWidth: 450,
    width: '95%',
    idField: "name",
    textField: "name",
    columns: [[
        {field:'name',title:'类别',width:120},
        {field:'fatherName',title:'父类别',width:120},
    ]],
    url: WUI.makeUrl('Category.query', {
        res: 'id,name,fatherName'
    })
}</code></pre>
<p>在dialog中：</p>
<pre><code>    &lt;input class="wui-combogrid" name="category" data-options="ListOptions.CateGrid"&gt;</code></pre>
<p>设置方法：</p>
<ul>
<li>idField和textField一样，都用name;</li>
<li>jd_showId指定为false即不显示idField;</li>
</ul>
<h4 id=".wui-combogrid-1 markRefresh 标记下次打开时刷新列表">1 markRefresh 标记下次打开时刷新列表</h4>
<p>(v5.5) 与my-combobox类似，组件会在其它页面更新对象后自动刷新列表。<br />
外部想要刷新组件列表，可以触发markRefresh事件：</p>
<pre><code>jo = jdlg.find("[comboname=xxxId]");
jo.trigger("markRefresh", obj); // obj是可选的，若指定则仅当obj匹配组件对应obj时才会刷新。</code></pre>
<h4 id=".wui-combogrid-2 动态修改下拉列表">2 动态修改下拉列表</h4>
<p>(v6) 与my-combobox方法相同，重新设置选项：</p>
<pre><code>jo = jdlg.find("[comboname=xxxId]");
jo.trigger("setOption", opt);</code></pre>
<p>动态修改组件选项示例：</p>
<pre><code>// 比如每打开对话框时，根据type动态显示列表。可在dialog的beforeShow事件中编码：
var cond = type == 'A'? xx: yy...;
// 取出选项，动态修改url
var jo = jdlg.find("[comboname=categoryId]");
jo.trigger("setOption", ListOptions.CategoryGrid(cond));</code></pre></div>
<div class="block">
<h2 id=".combo-f">@key .combo-f</h2>
<p>支持基于easyui-combo的表单扩展控件，如 combogrid/datebox/datetimebox等, 在使用WUI.getFormData时可以获取到控件值.</p>
<p>示例：可以在对话框或页面上使用日期/日期时间选择控件：</p>
<pre><code>&lt;input type="text" name="startDt" class="easyui-datebox"&gt;
&lt;input type="text" name="startTm" data-options="showSeconds:false" class="easyui-datetimebox"&gt;</code></pre>
<p>form提交时能够正确获取它们的值：<br />
var d = WUI.getFormData(jfrm); // {startDt: &quot;2019-10-10&quot;, startTm: &quot;2019-10-10 10:10&quot;}</p>
<p>而且在查询模式下，日期等字段也不受格式限制，可输入诸如&quot;2019-10&quot;, &quot;2019-1-1~2019-7-1&quot;这样的表达式。</p></div>
<div class="block">
<h2 id="toggleCol">@fn toggleCol(jtbl, col, show)</h2>
<p>显示或隐藏datagrid的列。示例：</p>
<pre><code>WUI.toggleCol(jtbl, 'status', false);</code></pre>
<p>如果列不存在将出错。</p></div>
<div class="block">
<h2 id="toggleFields">@fn toggleFields(jtbl_or_jfrm, showMap)</h2>
<p>根据type隐藏datagrid列表或明细页form中的项。示例：</p>
<pre><code>function toggleItemFields(jo, type)
{
    WUI.toggleFields(jo, {
        type: !type,
        status: !type || type!="公告",
        tm: !type || type=="活动" || type=="卡券" || type=="停车券",
        price: !type || type=="集市",
        qty: !type || type=="卡券"
    });
}</code></pre>
<p>列表中调用，控制列显示：pageItem.js</p>
<pre><code>    var type = objParam &amp; objParam.type; // 假设objParam是initPageXX函数的传入参数。
    toggleItemFields(jtbl, type);</code></pre>
<p>明细页中调用，控制字段显示：dlgItem.js</p>
<pre><code>    var type = objParam &amp;&amp; objParam.type; // objParam = 对话框beforeshow事件中的opt.objParam
    toggleItemFields(jfrm, type);</code></pre>
<p class="key"><strong>@key <a id=".wui-field">.wui-field</a></strong> </p>
<p>在隐藏字段时，默认是找到字段所在的行(tr)或标识<code>wui-field</code>类的元素控制其显示或隐藏。示例：</p>
<pre><code>    &lt;tr&gt;
        &lt;td&gt;&lt;/td&gt;
            &lt;label class="wui-field"&gt;&lt;input name="forEnd" type="checkbox" value="1"&gt; 结束打卡&lt;/label&gt;
        &lt;/td&gt;

        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;
            &lt;label class="wui-field"&gt;&lt;input name="repairFlag" type="checkbox" value="1"&gt; 是否维修&lt;/label&gt;
        &lt;/td&gt;
    &lt;/tr&gt;</code></pre>
<p>这里一行有两组字段，以wui-field类来指定字段所在的范围。如果不指定该类，则整行(tr层)将默认当作字段范围。<br />
JS控制：(dialog的onShow时)</p>
<pre><code>    WUI.toggleFields(jfrm, {
        forEnd: formMode == FormMode.forSet &amp;&amp; !frm.tm1.value,
        repairFlag: g_args.repair
    })</code></pre></div>
<div class="block">
<h2 id="WUI.applyPermission">@fn WUI.applyPermission()</h2>
<p class="key"><strong>@key <a id="permission">permission</a></strong>  菜单权限控制</p>
<p>前端通过菜单项来控制不同角色可见项，具体参见store.html中菜单样例。</p>
<pre><code>&lt;div class="perm-mgr" style="display:none"&gt;
    &lt;div class="menu-expand-group"&gt;
        &lt;a&gt;&lt;span&gt;&lt;i class="fa fa-pencil-square-o"&gt;&lt;/i&gt;系统设置&lt;/span&gt;&lt;/a&gt;
        &lt;div class="menu-expandable"&gt;
            &lt;a href="#pageEmployee"&gt;登录帐户管理&lt;/a&gt;
            ...
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>系统默认使用mgr,emp两个角色。一般系统设置由perm-mgr控制，其它菜单组由perm-emp控制。<br />
其它角色则需要在角色表中定义允许的菜单项。</p>
<p>根据用户权限，如&quot;item,mgr&quot;等，菜单中有perm-xxx类的元素会显示，有nperm-xxx类的元素会隐藏</p>
<p>示例：只有mgr权限显示</p>
<pre><code>&lt;div class="perm-mgr" style="display:none"&gt;&lt;/div&gt;</code></pre>
<p>示例：bx权限不显示（其它权限可显示）</p>
<pre><code>&lt;a href="#pageItem" class="nperm-bx"&gt;商品管理&lt;/a&gt;</code></pre>
<p>可通过 g_data.hasRole(roles) 查询是否有某一项或几项角色。注意：由于历史原因，hasRole/hasPerm是同样的函数。</p>
<pre><code>var isMgr = g_data.hasRole("mgr"); // 最高管理员
var isEmp = g_data.hasRole("emp"); // 一般管理员
var isAdm = g_data.hasRole("mgr,emp"); // 管理员(两种都行)
var isKF = g_data.hasRole("客服");</code></pre>
<p>自定义权限规则复杂，一般由框架管理，可以用g_data.permSet[perm]查询，如：</p>
<pre><code>var bval = g_data.permSet["客户管理"];</code></pre></div>
<div class="block">
<h2 id="WUI.fname">@fn WUI.fname(fn)</h2>
<p>为fn生成一个名字。一般用于为a链接生成全局函数。</p>
<pre><code>function onGetHtml(value, row) {
    var fn = WUI.fname(function () {
        console.log(row);
    });
    return '&lt;a href="' + fn + '()"&gt;' + value + '&lt;/a&gt;';
}</code></pre>
<p>或：</p>
<pre><code>function onGetHtml(value, row) {
    return WUI.makeLink(value, function () {
        console.log(row);
    });
}</code></pre>
<p class="see"><strong>@see <a href="#makeLink">makeLink</a></strong> </p></div>
<div class="block">
<h2 id="WUI.makeLink">@fn WUI.makeLink(text, fn)</h2>
<p>生成一个A链接，显示text，点击运行fn.<br />
用于为easyui-datagrid cell提供html.</p>
<pre><code>&lt;table&gt;
    ...
    &lt;th data-options="field:'orderCnt', sortable:true, sorter:intSort, formatter:ItemFormatter.orderCnt"&gt;订单数/报名数&lt;/th&gt;
&lt;/table&gt;</code></pre>
<p>定义formatter:</p>
<pre><code>var ItemFormatter = {
    orderCnt: function (value, row) {
        if (!value)
            return value;
        return WUI.makeLink(value, function () {
            var objParam = {type: row.type, itemId: row.id};
            WUI.showPage("pageOrder", "订单-" + objParam.itemId, [ objParam ]);
        });
    },
};</code></pre>
<p class="see"><strong>@see <a href="#fname">fname</a></strong> </p></div>
<div class="block">
<h2 id=".wui-subobj">@key .wui-subobj</h2><div class="toc"><p style="margin-left:0em"><a href="#.wui-subobj-1 示例：可以增删改查的子表：">1 示例：可以增删改查的子表：</a></p>
<p style="margin-left:0em"><a href="#.wui-subobj-2 动态修改选项">2 动态修改选项</a></p>
<p style="margin-left:0em"><a href="#.wui-subobj-3 定制子对象操作按钮toobar">3 定制子对象操作按钮toobar</a></p>
<p style="margin-left:0em"><a href="#.wui-subobj-4 添加主对象时检查子表">4 添加主对象时检查子表</a></p>
<p style="margin-left:0em"><a href="#.wui-subobj-5 示例2：主表记录添加时不需要展示，添加之后子表/关联表可以增删改查：">5 示例2：主表记录添加时不需要展示，添加之后子表/关联表可以增删改查：</a></p>
<p style="margin-left:0em"><a href="#.wui-subobj-6 示例3：和主表字段一起添加，添加后变成只读不可再新增、更新、删除：">6 示例3：和主表字段一起添加，添加后变成只读不可再新增、更新、删除：</a></p>
<p style="margin-left:0em"><a href="#.wui-subobj-7 示例4: 动态启用/禁用子表">7 示例4: 动态启用/禁用子表</a></p>
<p style="margin-left:0em"><a href="#.wui-subobj-8 示例5：显示为树表(treegrid)">8 示例5：显示为树表(treegrid)</a></p>
<p style="margin-left:0em"><a href="#.wui-subobj-9 示例6：offline模式时显示虚拟字段以及提交时排除虚拟字段">9 示例6：offline模式时显示虚拟字段以及提交时排除虚拟字段</a></p>
</div>
<p>选项：opt={obj, relatedKey, res?, dlg?/关联的明细对话框, datagrid/treegrid}</p>
<p>这些选项在dlg设置时有效：{valueField, readonly, objParam, toolbar, vFields}</p>
<ul>
<li>opt.forceLoad: 显示为Tab页时（即每个Tab页一个子表），为减少后端查询，若该Tab页尚未显示，是不加载该子表的。设置forceLoad为true则无论是否显示均强制加载。</li>
</ul>
<h4 id=".wui-subobj-1 示例：可以增删改查的子表：">1 示例：可以增删改查的子表：</h4>
<pre><code>&lt;div class="wui-subobj" data-options="obj:'CusOrder', relatedKey:'cusId', valueField:'orders', dlg:'dlgCusOrder'"&gt;
    &lt;p&gt;&lt;b&gt;物流订单&lt;/b&gt;&lt;/p&gt;
    &lt;table&gt;
        &lt;thead&gt;&lt;tr&gt;
            &lt;th data-options="field:'tm', sortable:true"&gt;制单时间&lt;/th&gt;
            &lt;th data-options="field:'status', sortable:true, jdEnumMap:CusOrderStatusMap, formatter:Formatter.enum(CusOrderStatusMap), styler:Formatter.enumStyler({CR:'Warning',CL:'Disabled'})"&gt;状态&lt;/th&gt;
            &lt;th data-options="field:'amount', sortable:true, sorter:numberSort"&gt;金额&lt;/th&gt;
        &lt;/tr&gt;&lt;/thead&gt;
    &lt;/table&gt;
&lt;/div&gt;</code></pre>
<p>选项说明：</p>
<ul>
<li>
<p>opt.obj: 子表对象，与relatedKey字段一起自动生成子表查询，即<code>{obj}.query</code>接口。</p>
<pre><code>class AC2_CusOrder extends AccessControl
{
}</code></pre>
</li>
<li>
<p>relatedKey: 关联字段. 指定两表(当前表与obj对应表)如何关联, 用于自动创建子表查询条件以及子表对话框的关联值设置(wui-fixed-field)<br />
值&quot;cusId&quot;与&quot;cusId={id}&quot;等价, 表示<code>主表.id=CusOrder.cusId</code>.<br />
可以明确指定被关联字段, 如relatedKey=&quot;name={name}&quot; 表示<code>主表.name=CusOrder.name</code>.<br />
支持多个关联字段设置, 如<code>relId={id} AND type={type}</code>.<br />
支持in方式关联，如<code>id in ({itemIds})</code>，其中itemIds字段为逗号分割的id列表，如&quot;100,102&quot;</p>
</li>
<li>opt.dlg: 对应子表详情对话框。如果指定，则允许添加、更新、查询操作。</li>
</ul>
<p>以下字段仅当关联对话框（即dlg选项设置）后有效：</p>
<ul>
<li>
<p>opt.valueField: 对应后端子表名称，在随主表一起添加子表时，会用到该字段。如果不指定，则不可在主表添加时一起添加。它对应的后端实现示例如下：</p>
<pre><code>class AC2_Customer extends AccessControl
{
    protected $subobj = [
        "orders" =&gt; [ "obj" =&gt; "CusOrder", "cond" =&gt; "cusId=%d" ]
    ]
}</code></pre>
</li>
<li>
<p>opt.readonly: 默认为false, 设置为true则在主表添加之后，不可对子表进行添加、更新或删除。</p>
</li>
<li>opt.objParam: 关联的明细对象对话框的初始参数, 对应dialogOpt.objParam. 例如有 offline, onCrud()等选项. 
<p class="see"><strong>@see <a href="#objParam">objParam</a></strong> </p></li>
</ul>
<p>示例：在对话框dlgOrder上设置子表关联对话框dlgOrder1:</p>
<pre><code>    &lt;div class="wui-subobj" id="tabOrder1" data-options="..."&gt;</code></pre>
<p>注意：要在onBeforeShow中设置objParam，如果在onShow中设置就晚了：</p>
<pre><code>jdlg.on("beforeshow", onBeforeShow)
function onBeforeShow(ev, formMode, opt)
{
    var type = opt.objParam &amp;&amp; opt.objParam.type;
    var tab1Opt = WUI.getOptions(jdlg.find("#tabOrder1"));
    tab1Opt.objParam = { type: type };
    ...
}</code></pre>
<h4 id=".wui-subobj-2 动态修改选项">2 动态修改选项</h4>
<p>选项可以动态修改，如：</p>
<pre><code>// 在dialog的beforeshow回调中：
var jsub = jdlg.find(".wui-subobj");
WUI.getOptions(jsub).readonly = !g_data.hasRole("emp,mgr");</code></pre>
<h4 id=".wui-subobj-3 定制子对象操作按钮toobar">3 定制子对象操作按钮toobar</h4>
<ul>
<li>opt.toolbar: 指定修改对象时的增删改查按钮, Enum(a-add, s-set, d-del, f-find, r-refresh), 字符串或数组, 缺省是所有按钮, 空串&quot;&quot;或空数组[]表示没有任何按钮.</li>
</ul>
<p>示例：只留下删除和刷新: </p>
<pre><code>&lt;div ... class="wui-subobj" data-options="..., toolbar:'rd'"</code></pre>
<p>示例：为子表定制一个操作按钮“取消”：</p>
<pre><code>// function initPageXXX() 自定义个按钮
var btnCancelOrder = {text: "取消订单", iconCls:'icon-delete', handler: function () {
    var row = WUI.getRow(jtbl);
    if (row == null)
        return;
    callSvc("Ordr.cancel", {id: row.id}, function () {
        app_show("操作完成");
        WUI.reloadRow(jtbl, row);
    })
}};

// 在dialog的beforeshow回调中：
var jsub = jdlg.find(".wui-subobj");
WUI.getOptions(jsub).toolbar = ["r", "f", "s", btnCancelOrder]</code></pre>
<p class="see"><strong>@see <a href="#dg_toolbar">dg_toolbar</a></strong> </p>
<h4 id=".wui-subobj-4 添加主对象时检查子表">4 添加主对象时检查子表</h4>
<p>可以在validate事件中，对添加的子表进行判断处理：</p>
<pre><code>function onValidate(ev, mode, oriData, newData) 
{
    if (mode == FormMode.forAdd) {
        // 由于valueField选项设置为"orders", 子表数组会写在newDate.orders中
        if (newData.orders.length == 0) {
            WUI.app_alert("请添加子表项!", "w");
            return false;
        }
        // 假如需要压缩成一个字符串：
        // newData.orders = WUI.objarr2list(newData.orders, ["type", "amount"]);
    }
}</code></pre>
<p>注意：只有在主对象添加时可以检查子表。在更新模式下，子对象的更改是直接单独提交的，主对象中无法处理。</p>
<h4 id=".wui-subobj-5 示例2：主表记录添加时不需要展示，添加之后子表/关联表可以增删改查：">5 示例2：主表记录添加时不需要展示，添加之后子表/关联表可以增删改查：</h4>
<pre><code>&lt;div class="wui-subobj" data-options="obj:'CusOrder', relatedKey:'cusId', dlg:'dlgCusOrder'&gt;
    ...
&lt;/div&gt;</code></pre>
<h4 id=".wui-subobj-6 示例3：和主表字段一起添加，添加后变成只读不可再新增、更新、删除：">6 示例3：和主表字段一起添加，添加后变成只读不可再新增、更新、删除：</h4>
<pre><code>&lt;div class="wui-subobj" data-options="obj:'CusOrder', relatedKey:'cusId', valueField:'orders', dlg:'dlgCusOrder', readonly: true"&gt;
    ...
&lt;/div&gt;</code></pre>
<p>示例：最简单的只读子表，只查看，也不关联对话框</p>
<pre><code>&lt;div class="wui-subobj" data-options="obj:'CusOrder', res:'id,tm,status,amount', relatedKey:'cusId'"&gt;
&lt;/div&gt;</code></pre>
<ul>
<li>opt.res: 指定返回字段以提高性能，即query接口的res参数。注意在关联详细对话框（即指定dlg选项）时，一般不指定res，否则双击打开对话框时会字段显示不全。</li>
</ul>
<h4 id=".wui-subobj-7 示例4: 动态启用/禁用子表">7 示例4: 动态启用/禁用子表</h4>
<p>启用或禁用可通过事件发送指令:<br />
jo.trigger(&quot;setDisabled&quot;, boolDisabledVal); // 会自动刷新UI</p>
<p>示例: 在物料明细对话框(dlgItem)中, 在Tabs组件中放置&quot;组合&quot;子表, 当下拉框选择&quot;组合&quot;时, 启用&quot;组合&quot;子表Tab页:</p>
<pre><code>&lt;select name="type"&gt;
    &lt;option value=""&gt;(无)&lt;/option&gt;
    &lt;option value="P"&gt;组合&lt;/option&gt;
    &lt;!--&lt;option value="U"&gt;拆卖&lt;/option&gt;--&gt;
&lt;/select&gt;

&lt;div class="easyui-tabs"&gt;
    &lt;div class="wui-subobj" id="tabItem1" data-options="obj:'Item1', valueField:'item1', relatedKey:'itemId', dlg:'dlgItem1'" title="组合"&gt;
        &lt;table&gt;
            &lt;thead&gt;&lt;tr&gt;
                &lt;th data-options="field:'srcItemName'"&gt;源商品&lt;/th&gt;
                &lt;th data-options="field:'qty', formatter:WUI.formatter.number"&gt;数量&lt;/th&gt;
            &lt;/tr&gt;&lt;/thead&gt;
        &lt;/table&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>设置&quot;组合&quot;页随着type选择启用禁用:</p>
<pre><code>$(frm.type).change(function () {
    toggleItem1(this.value);
});

jdlg.on("beforeshow", onBeforeShow)
    .on("validate", onValidate);

function onBeforeShow(ev, formMode, opt) 
{
    toggleItem1(opt.data &amp;&amp; opt.data.type);
}

function onValidate(ev, mode, oriData, newData) 
{
    // 添加时验证子表值
    if (mode == FormMode.forAdd) {
        var type = frm.type.value;
        if (type == "P") {
            console.log(newData.item1);
            if (newData.item1 == null || newData.item1.length == 0) {
                app_alert("请添加组合明细!", "w");
                // 自动切换到该页
                jdlg.find(".easyui-tabs").tabs("select", "组合");
                return false;
            }
        }
    }
}

// 启用或禁用子表的Tab
function toggleItem1(type)
{
    var dis = type!="P";
    jdlg.find("#tabItem1").trigger("setDisabled", dis);
}</code></pre>
<h4 id=".wui-subobj-8 示例5：显示为树表(treegrid)">8 示例5：显示为树表(treegrid)</h4>
<ul>
<li>opt.datagrid: 设置easyui-datagrid的选项</li>
<li>opt.treegrid: 如果指定，则以树表方式展示子表，设置easyui-treegrid的选项</li>
</ul>
<p>默认使用以下配置：</p>
<pre><code>{
    idField: "id",  // 不建议修改
    fatherField: "fatherId", // 指向父结点的字段，不建议修改
    treeField: "id", // 显示树结点的字段名，可根据情况修改
}</code></pre>
<p>子表以树表显示时，不支持分页（查询时自动设置参数pagesz=-1）。</p>
<p class="see"><strong>@see <a href="#treegrid">treegrid</a></strong> </p>
<h4 id=".wui-subobj-9 示例6：offline模式时显示虚拟字段以及提交时排除虚拟字段">9 示例6：offline模式时显示虚拟字段以及提交时排除虚拟字段</h4>
<p>在添加主对象时，对子对象的添加、更新、删除操作不会立即操作数据库，而是将最终子对象列表与主对象一起提交（接口是主对象.add）。<br />
我们称这时的子对象对话框为offline模式，它会带来一个问题，即子对象对话框上点确定后，子表列表中无法显示虚拟字段。</p>
<p>解决方案是：1. 在对话框中用jd_vField选项指定虚拟字段名，2. 在subobj选项中以vFields选项指定这些字段只显示而不最终提交到add接口中。</p>
<ul>
<li>opt.vFields: (v5.5) 指定虚拟字段(virtual field)，多个字段以逗号分隔。这些字段只用于显示，不提交到后端。</li>
</ul>
<p>示例：InvRecord对象包含子表InvRecord1，字段定义为：</p>
<pre><code>@InvRecord1: id, invId, whId, whId2, itemId
vcol: itemName, whName, whName2</code></pre>
<p>打开对话框dlgInvRecord添加对象，再打开子表明细对话框dlgInvRecord1添加子表项。<br />
在subobj组件中，通过选项vFields排除只用于显示而不向后端提交的虚拟字段，dlgInvRecord.html中：</p>
<pre><code>    &lt;div class="wui-subobj" data-options="obj:'InvRecord1', relatedKey:'invId', valueField:'inv1', vFields:'itemName,whName,whName2', dlg:'dlgInvRecord1'" title="物料明细"&gt;
        ...子表与字段列表...
    &lt;/div&gt;</code></pre>
<p>子表明细对话框中，为了在点击确定后将虚拟字段拷贝回subobj子表列表中，应通过data-options中指定jd_vField选项来指定虚拟字段名，如 dlgInvRecord1.html:</p>
<pre><code>仓库   &lt;select name="whId" class="my-combobox" required data-options="ListOptions.Warehouse()"&gt;&lt;/select&gt;  (Warehouse函数中已定义{jd_vField: 'whName'})
到仓库 &lt;select name="whId2" class="my-combobox" required data-options="ListOptions.Warehouse({jd_vField:'whName2'})"&gt;&lt;/select&gt; (覆盖Warehouse函数定义中的jd_vField选项)
物料   &lt;input name="itemId" class="wui-combogrid" required data-options="ListOptions.ItemGrid()"&gt;  (ItemGrid函数中已定义{jd_vField: 'itemName'})</code></pre>
<p>ListOptions中对下拉列表参数的设置示例：(store.js)</p>
<pre><code>var ListOptions = {
    ...
    Warehouse: function (opt) {
        return $.extend({
            jd_vField: "whName", // 指定它在明细对话框中对应的虚拟字段名
            textField: "name", // 注意区别于jd_vField，textField是指定显示内容是url返回表中的哪一列
            url: ...
        }, opt);
    },
    ItemGrid: function () {
        return {
            jd_vField: "itemName",
            textField: "name",
            url: ...
        }
    },
}</code></pre>
<p>注意带Grid结尾的选项用于wui-combogrid组件; 否则应用于my-combobox组件；<br />
两者选项接近，wui-combogrid选项中应包含columns定义以指定下拉列表中显示哪些列，而my-combobox往往包含formatter选项来控制显示（默认是显示textField选项指定的列，设置formatter后textField选项无效）</p>
<p>上例中, 通过为组件指定jd_vField选项，实现在offline模式的子表对话框上点确定时，会自动调用WUI.getFormData_vf将虚拟字段和值字段拼到一起，返回并显示到表格中。</p>
<p class="see"><strong>@see <a href="#getFormData_vf">getFormData_vf</a></strong> </p></div>
<div class="block">
<h2 id="easyui-tabs">@key easyui-tabs</h2>
<p>扩展: 若未指定onSelect回调, 默认行为: 点Tab发出tabSelect事件, 由Tab自行处理</p></div>
<div class="block">
<h2 id="WUI.toggleTab">@fn WUI.toggleTab(jtabs, which, show, noEvent?)</h2>
<p>禁用或启用easyui-tabs组件的某个Tab页.<br />
which可以是Tab页的索引数或标题.<br />
示例:</p>
<pre><code>var jtabs = jdlg.find(".easyui-tabs");
WUI.toggleTab(jtabs, "组合物料", formData.type == "P");</code></pre></div>
<div class="block">
<h2 id=".wui-picker">@key .wui-picker 字段后的工具按钮</h2>
<p>示例：输入框后添加一个编辑按钮，默认不可编辑，点按钮编辑：</p>
<pre><code>&lt;input name="value" class="wui-picker-edit"&gt;</code></pre>
<p>示例：输入框后添加一个帮助按钮：</p>
<pre><code>&lt;input name="value" class="wui-picker-help" data-helpKey="取消工单"&gt;</code></pre>
<p>点击帮助按钮，跳往WUI.options.helpUrl指定的地址。如果指定data-helpKey，则跳到该锚点处。</p>
<p>可以多个picker一起使用。</p>
<p>帮助链接：(加wui-help类则点击可跳转，同时也支持用data-helpKey属性指定主题)</p>
<pre><code>&lt;a class="wui-help"&gt;&lt;span&gt;&lt;i class="fa fa-question-circle"&gt;&lt;/i&gt;帮助&lt;/span&gt;&lt;/a&gt;</code></pre></div>
<div class="block">
<h2 id=".wui-more">@key .wui-more</h2>
<p>显示一个按钮，用于隐藏（默认）或显示后面的内容。基于easyui-linkbutton创建，兼容该组件的options比如图标.</p>
<pre><code>示例: 列对应: title=code,-,amount 
&lt;span class="wui-more" data-options="iconCls: 'icon-tip'"&gt;更多示例&lt;/span&gt;
&lt;pre&gt;
映射方式对应: title=编码-&gt;code, Total Sum-&gt;amount&amp;amp;useColMap=1
根据code, 存在则更新: title=code,amount&amp;amp;uniKey=code
根据code, 批量更新: title=code,amount&amp;amp;uniKey=code!
带子表: title=code,amount,@order1.itemCode,@order1.qty&amp;amp;uniKey=code
&lt;/pre&gt;</code></pre></div>
<div class="block">
<h2 id="WUI.showByType">@fn WUI.showByType(jo, type)</h2>
<p>(v6) 该函数已不建议使用。本来用于显示多组mycombobox/wui-combogrid组件，现成推荐直接用组件的setOption事件动态修改组件选项。</p>
<p>对话框上form内的一组控件中，根据type决定当前显示/启用哪一个控件。</p>
<p>需求：ItemStatusList定义了Item的状态，但当Item类型为“报修”时，其状态使用<code>ItemStatusList_报修</code>，当类型为“公告”时，状态使用ItemStatusList_公告，其它类型的状态使用ItemStatusList</p>
<p>HTML: 在对话框中，将这几种情况都定义出来：</p>
<pre><code>&lt;select name="status" class="my-combobox" data-options="jdEnumList:ItemStatusList"&gt;&lt;/select&gt;
&lt;select name="status" class="my-combobox type-报修" style="display:none" data-options="jdEnumList:ItemStatusList_报修"&gt;&lt;/select&gt;
&lt;select name="status" class="my-combobox type-公告" style="display:none" data-options="jdEnumList:ItemStatusList_公告"&gt;&lt;/select&gt;</code></pre>
<p>注意：当type与“报修”时，它按class为&quot;type-报修&quot;来匹配，显示匹配到的控件（并添加active类），隐藏并禁用其它控件。<br />
如果都不匹配，这时看第一条，如果它不带<code>type-xxx</code>类，则使用第一条来显示，否则所有都不启用（隐藏、禁用）。</p>
<p>JS: 根据type设置合适的status下拉列表，当type变化时更新列表：</p>
<pre><code>function initDlgXXX()
{
    ...
    jdlg.on("beforeshow", onBeforeShow);
    // 1. 根据type动态显示status
    $(frm.type).on("change", function () {
        var type = $(this).val();
        WUI.showByType(jfrm.find("[name=status]"), type);
    });
    function onBeforeShow(ev, formMode, opt) 
    {
        ...
        setTimeout(onShow);
        function onShow() {
            ...
            // 2. 打开对话框时根据type动态显示status
            $(frm.type).trigger("change");
        }
    }
}</code></pre>
<p>支持combogrid组件，注意combogrid组件用&quot;[comboname]&quot;而非&quot;[name]&quot;来找jQuery组件：</p>
<pre><code>WUI.showByType(jdlg.find("[comboname=orderId]"), type);</code></pre>
<p>HTML示例：</p>
<pre><code>&lt;tr&gt;
    &lt;td class="orderIdTd"&gt;关联单据&lt;/td&gt;
    &lt;td&gt;
        &lt;input name="orderId" class="wui-combogrid type-生产领料 type-生产调拨 type-生产入库 type-生产退料" data-options="ListOptions.OrderGrid({type:'生产工单'})"&gt;
        &lt;input name="orderId" class="wui-combogrid type-销售" data-options="ListOptions.OrderGrid({type:'销售计划'})"&gt;
        ...
    &lt;/td&gt;
&lt;/tr&gt;</code></pre>
<p>支持组件状态被动态修改，比如添加模式时打开对话框就禁用该组件：</p>
<pre><code>jdlg.find("[comboname=orderId]").combogrid({disabled: forAdd});</code></pre>
<p>这时调用showByType后，active组件仍会保持disabled状态。类似的，如果调用者先隐藏了组件，则调用showByType后active组件也是隐藏的。</p>
<p>注意：对tr等包含输入框的块组件也可使用，但要求内部只有一个带name的输入组件，且各块的内部输入组件的name都相同。</p>
<pre><code>    &lt;tr class="optional type-出库"&gt;...&lt;input name="orderId"&gt;...&lt;/tr&gt;
    &lt;tr class="optional type-入库"&gt;...&lt;input name="orderId"&gt;...&lt;/tr&gt;</code></pre>
<p>JS控制：</p>
<pre><code>WUI.showByType(jdlg.find("tr.optional"), type);</code></pre>
<p>当一个块不显示时，其内部的带name的输入组件被设置disabled，提交时不会带该字段。<br />
如果块内部包含多个输入框，或各块内的输入框的name不同，如果各块内所有输入框都默认显示、未禁用（也不会动态修改显示、禁用），这时也可以使用showByType，否则会有问题。</p></div>
<div class="block">
<h2 id="diffObj">@fn diffObj(obj, obj1)</h2>
<p>返回null-无差异，如果是对象与对象比较，返回差异对象，否则返回true表示有差异</p>
<pre><code>var rv = diffObj({a:1, b:99}, {a:1, b:98, c:100});
// rv: {b:98, c:100}

var rv = diffObj([{a:1, b:99}], [{a:1, b:99}]);
// rv: null (无差异)

var rv = diffObj([{a:1, b:99}], [{a:1, b:99}, {a:2}]);
// rv: true

var rv = diffObj("hello", "hello");
// rv: null (无差异)

var rv = diffObj("hello", 99);
// rv: true</code></pre></div>
<div class="block">
<h2 id="showDataReport">@fn showDataReport(opt={ac, @gres, @gres2?, res?, cond?, title?="统计报表", detailPageName?, detailPageParamArr?, resFields?, cond2?, tmField?, showChart?})</h2>
<p>选项说明：</p>
<ul>
<li>res: 汇总字段，默认为<code>COUNT(*) 数量</code></li>
<li>gres: 行统计字段。须为数组，示例：<code>["userPhone", "userName 用户", null, "status 状态=CR:新创建;RE:已完成"]</code>。<br />
数组每个元素符合后端query接口res参数要求，可以是1个字段也可以是逗号分隔的多个字段；如果为空则跳过。<br />
注意：月报用 <a href="配合tmUnit:" title="y,m">&quot;y 年, m 月&quot;</a>，日报用 [&quot;y 年, m 月, d 日&quot;] (配合tmUnit: &quot;y,m,d&quot;)</li>
<li>gres2: 列统计字段。格式与gres相同。</li>
<li>cond: 查询条件，字符串，示例：WUI.getQueryCond({id: &quot;&gt;1&quot;, status: &quot;CR,RE&quot;, createTm: &quot;&gt;=2020-1-1 and &lt;2021-1-1&quot;}), 用getQueryCond可使用查询框支持的条件格式。</li>
<li>orderby: 排序方式</li>
<li>title: 统计页面标题</li>
<li>detailPageName: 在统计表中点击数值，可以显示明细页面。这里指定用哪个页面来显示明细项；如果未指定则以pageSimple来显示。</li>
<li>detailPageParamArr: 如果指定了detailPageName，可以用此参数来定制showPage的第三参数(paramArr)。</li>
<li>
<p>tmField: 如果用到y,m,d等时间统计字段，应指定使用哪个时间字段进行运算。后端可能已经定义了时间字段(tmCols)，指定该选项可覆盖后端的定义。</p>
</li>
<li>
<p>resFields: 用户可选择的字段列表（如res, cond中出现的字段）。如果指定（或指定了gres或gres2），则工具栏多出“统计”按钮，可供用户进一步设置。<br />
注意gres,gres2,tmField中的字段会被自动加入，在resFields中指定或不指定都可以。</p>
</li>
<li>showChart: 是否显示统计图表对话框。</li>
<li>
<p>tmUnit: 用于统计图，特别用于月报、日报等，会自动补齐缺少的时间。常用有：&quot;y,m&quot;-年月,&quot;y,m,d&quot;-年月日。注意一旦指定tmUnit则orderby选项自动与tmUnit相同。</p>
</li>
<li>showSum: 自动添加统计行或列</li>
</ul>
<p class="see"><strong>@see <a href="#JdcloudStat.tmUnit">JdcloudStat.tmUnit</a></strong>  </p>
<ul>
<li>cond2: 内部使用，在cond基础上再加一层过滤，由报表对话框上用户设置的条件生成。<br />
在cond基础上再加一层过滤，条件由统计对话框上设置。参考WUI.getQueryCond。示例: </li>
</ul>
<p>示例：</p>
<pre><code>WUI.showDataReport({
    ac: "Employee.query",
    gres: ["depName 部门", "性别"],
    gres2: ["职称", "学历"],
    cond: WUI.getQueryCond({status: '在职'}),
    detailPageName: "pageEmployee1",
    title: "师资报表"
});</code></pre>
<p>示例：订单月报</p>
<pre><code>WUI.showDataReport({
    ac: "Ordr.query",
    res: "SUM(amount) 总和", // 不指定则默认为`COUNT(1) 总数`
    tmField: "createTm 创建时间",
    gres: ["y 年,m 月", "status 状态=CR:新创建;RE:已完成;CA:已取消"],
    gres2: ["dscr 订单类别"],
    cond: WUI.getQueryCond({createTm: "&gt;=2020-1-1 and &lt;2021-1-1", status: "CR,RE,CA"}), // 生成条件字符串
    detailPageName: "pageOrder",
    title: "订单月报",

    // 定义用户可选的字段，定义它或gres/gres2会在工具栏显示“统计”按钮。注意不需要定义y,m等时间字段，它们由tmField自动生成。
    resFields: "amount 金额, status 状态=CR:新创建;RE:已完成;CA:已取消, dscr 订单类别, userName 用户, userPhone 用户手机号, createTm 创建时间",

    // showChart: true, // 显示统计图
    // gres: ["y 年,m 月"],
    // tmUnit: "y,m",
});</code></pre>
<p>示例：订单状态占比, 显示饼图（当只有gres没有gres2，且没有tmUnit时，可自动显示饼图）</p>
<pre><code>WUI.showDataReport({
    ac: "Ordr.query",
    res: "COUNT(1) 总数", // 不指定则默认为`COUNT(1) 总数`
    gres: ["status 状态=CR:新创建;RE:已完成;CA:已取消"],
    detailPageName: "pageOrder",
    title: "订单状态占比",

    // 定义用户可选的字段，定义它或gres/gres2会在工具栏显示“统计”按钮。注意不需要定义y,m等时间字段，它们由tmField自动生成。
    resFields: "amount 金额, status 状态=CR:新创建;RE:已完成;CA:已取消, dscr 订单类别, userName 用户, userPhone 用户手机号, createTm 创建时间",

    showChart: true, // 显示统计图
    orderby: "总数 DESC"
});</code></pre>
<p>示例：多个统计项：订单状态报表，同时统计数量和金额：</p>
<pre><code>WUI.showDataReport({
    ac: "Ordr.query",
    res: "COUNT(1) 总数, SUM(amount) 总金额",
    gres: ["status 状态=CR:新创建;RE:已完成;CA:已取消"],
    // gres2: ["dscr 订单类别"], // 试试加上列统计项有何样式区别
    detailPageName: "pageOrder",
    title: "订单状态占比",
    // showSum: true, // 自动添加行列统计

    // 定义用户可选的字段，定义它会在工具栏显示“统计”按钮。注意不需要定义y,m等时间字段，它们由tmField自动生成。
    resFields: "amount 金额, status 状态=CR:新创建;RE:已完成;CA:已取消, dscr 订单类别, userName 用户, userPhone 用户手机号, createTm 创建时间",
});</code></pre>
<p>注意：统计图(showChart:true)目前只支持第一个统计项。</p></div>
<div class="block">
<h2 id="showDlgChart">@fn showDlgChart(data, rs2StatOpt, seriesOpt, chartOpt)</h2>
<ul>
<li>data: 可以是数据，也可以是deferred对象（比如callSvr返回）</li>
<li>rs2StatOpt: 数据转换选项，参考rs2Stat</li>
<li>seriesOpt, chartOpt: 参考echarts全局参数以及series参数: <a href="https://echarts.apache.org/zh/option.html#series">https://echarts.apache.org/zh/option.html#series</a><br />
echarts示例：<a href="https://echarts.apache.org/examples/zh/index.html">https://echarts.apache.org/examples/zh/index.html</a></li>
</ul>
<p class="see"><strong>@see <a href="#WUI.rs2Stat">WUI.rs2Stat</a></strong>  图表数据转换</p>
<p class="see"><strong>@see <a href="#WUI.initChart　显示图表">WUI.initChart　显示图表</a></strong> </p>
<p>示例：</p>
<pre><code class="language-javascript">// 各状态订单数: 柱图
WUI.showDlgChart(callSvr("Ordr.query", {
    gres: "status =CR:新创建;RE:已完成;CA:已取消",
    res: "count(*) 总数",
}));

// 各状态订单数: 饼图，习惯上应占比排序
WUI.showDlgChart(callSvr("Ordr.query", {
    gres: "status =CR:新创建;RE:已完成;CA:已取消",
    res: "count(*) 总数",
    orderby: "总数 DESC"
}), null, {
    type: "pie"
});

// 订单年报
WUI.showDlgChart(callSvr("Ordr.query", {
    gres: "y",
    res: "count(*) 总数",
}));

// 订单月报，横坐标为年月（两列）
WUI.showDlgChart(callSvr("Ordr.query", {
    gres: "y,m",
    res: "count(*) 总数",
}), {  // rs2StatOpt
    xcol:[0,1]
});

// 订单月报，指定tmUnit，注意加orderby让时间排序，支持自动补齐缺少的时间
WUI.showDlgChart(callSvr("Ordr.query", {
    gres: "y,m",
    res: "count(*) 总数",
    orderby: "y,m"
}), {  // rs2StatOpt
    tmUnit: "y,m"
});

// 订单各月占比，显示为饼图，哪个月订单多则排在前
WUI.showDlgChart(callSvr("Ordr.query", {
    gres: "y,m",
    res: "count(*) 总数",
    orderby: "总数 DESC"
}), {  // rs2StatOpt
    xcol:[0,1]
}, { // seriesOpt
    type: "pie"
}, { // chartOpt
    title: { text: "订单各月分布" }
});

// 分状态订单月报
WUI.showDlgChart(callSvr("Ordr.query", {
    gres: "y,m,status =CR:新创建;RE:已完成;CA:已取消",
    res: "count(*) 总数",
    orderby: "y,m"
}), {  // rs2StatOpt
    tmUnit: "y,m"
});

// 同上，配置堆积柱状图，配置stack
WUI.showDlgChart(callSvr("Ordr.query", {
    gres: "y,m,status =CR:新创建;RE:已完成;CA:已取消",
    res: "count(*) 总数",
    orderby: "y,m"
}), {  // rs2StatOpt
    tmUnit: "y,m"
}, { // seriesOpt
    type: "bar",
    stack: "X"
}, { // chartOpt
    // swapXY: true // 横向柱状图
});

// 分用户订单月报
WUI.showDlgChart(callSvr("Ordr.query", {
    cond: {createTm: "&gt;=2010-1-1 and &lt;2030-1-1"},
    gres: "userId",
    res: "userName,count(*) 总数",
    orderby: "总数 DESC"
}), {  // rs2StatOpt
    xcol: 1
},{ // seriesOpt
    type: 'pie', // 饼图
});

// 分用户订单月报
WUI.showDlgChart(callSvr("Ordr.query", {
    cond: {createTm: "&gt;=2020-1-1 and &lt;2021-1-1"},
    gres: "y,m,userId",
    res: "userName,count(*) 总数",
    orderby: "y,m"
}), {  // rs2StatOpt
    tmUnit: "y,m"
}, { // seriesOpt
    type: 'bar',
});</code></pre></div>
<div class="block">
<h2 id="ObjLog">@module ObjLog 操作日志</h2>
<p>系统默认会记录操作日志ObjLog，可在管理端展示：</p>
<ul>
<li>
<p>菜单：系统设置-操作日志，结合查询框查找</p>
<pre><code>&lt;a href="#pageObjLog"&gt;操作日志&lt;/a&gt;</code></pre>
</li>
<li>表中选中任一记录，在表头右键菜单中，可查看该记录关联的操作日志。</li>
<li>
<p>可添加“日志”菜单到工具栏，按钮名为&quot;objLog&quot;：</p>
<pre><code>jtbl.datagrid({
    ...
    toolbar: WUI.dg_toolbar(jtbl, jdlg, ..., 'objLog');
});</code></pre>
</li>
</ul></div>
<div class="block">
<h2 id="JdcloudStat">@module JdcloudStat</h2>
<p>按日期进行数据分析统计</p>
<p class="see"><strong>@see <a href="#initPageStat">initPageStat</a></strong> </p></div>
<div class="block">
<h2 id="WUI.options.statFormatter">@var WUI.options.statFormatter</h2></div>
<div class="block">
<h2 id="JdcloudStat.tmUnit">@key JdcloudStat.tmUnit 按时间维度分析</h2>
<p>tmUnit指定时间维度分析的类型，目前支持以下维度：</p>
<pre><code>"y,m"     年月
"y,m,d"   年月日
"y,m,d,h" 年月日时
"y,w"     年周
"y,q"     年季度</code></pre></div>
<div class="block">
<h2 id="WUI.pivot">@fn WUI.pivot(rs, opt)</h2>
<p class="param"><strong>@param opt</strong>  {gcol, xcol, ycol?, gtext?, maxSeriesCnt?, formatter?}</p>
<p>gcol/gtext, xcol, ycol可以是数字, 表示第几列; 也可以是数字数组, 表示若干列.<br />
gtext也是列号或列号数组，与gcol合用，表示按gcol分组，最终“组名”结果按gtext列显示。<br />
如果指定formatter，则“组名”再经formatter处理后显示。formatter(val): val是一个值或一个数组，由gcol/gtext决定。</p>
<p>如果指定opt.maxSeriesCnt，则分组最多maxSeriesCnt列，其它组则都归并到“其它”组。</p>
<p>示例: 按年-月统计各产品类别(cateId)的订单金额, 可以调用接口:</p>
<pre><code>callSvr("Ordr.query", {gres: "y,m,cateId", res: "cateName,SUM(amount) sum"}, orderby: "y,m")</code></pre>
<p>得到rs表格:</p>
<pre><code>var rs = {
    h: ["y","m","cateId","cateName","sum"],
    d: [
        [2019, 11, 1, "衣服", 20000],
        [2019, 11, 2, "食品", 12000],
        [2019, 12, 2, "食品", 15000],
        [2020, 02, 1, "衣服", 19000]
    ]
}</code></pre>
<p>即:</p>
<pre><code>y   m   cateId  cateName    sum
------------
2019    11  1   衣服  20000
2019    11  2   食品  12000
2019    12  2   食品  15000
2020    02  1   衣服  19000</code></pre>
<ol>
<li>
<p>将分类cateId转到列上(但按cateName来显示):</p>
<p>var rs1 = pivot(rs, {<br />
xcol: [0, 1], // 0,1列<br />
gcol: 2, // 按该列转置<br />
gtext: 3, // 表示第3列是第2列的显示内容, 也可以用函数<code>function (row) { return row[3] }</code><br />
ycol: 4, // 值列, 可以不指定, 缺省为最后一列.<br />
})</p>
</li>
</ol>
<p>得到结果:</p>
<pre><code>rs1 = {
    h: ["y","m","衣服","食品"],
    d: [
        [2019, 11, 20000, 12000],
        [2019, 12, null, 15000],
        [2020, 02, 19000, null]
    ]
}</code></pre>
<p>即:</p>
<pre><code>y   m 衣服    食品
------------
2019    11  20000   12000
2019    12  null    15000
2020    02  19000   null</code></pre>
<ol>
<li>
<p>若xcol中只保留年:</p>
<p>var rs1 = pivot(rs, {<br />
xcol: 0,<br />
gcol: 2,<br />
gtext: 3,<br />
ycol:4<br />
})</p>
</li>
</ol>
<p>得到结果将变成这样:</p>
<pre><code>rs1 = {
    h: ["y","衣服","食品"],
    d: [
        [2019, 20000, 27000],
        [2020, 19000, null]
    ]
}</code></pre>
<ol>
<li>
<p>若在xcol中保留分类, 将年-月转到列上:</p>
<p>var rs1 = pivot(rs, {<br />
xcol: [2, 3], // 或只留3也可以<br />
gcol: [0, 1],<br />
ycol:4<br />
})</p>
</li>
</ol>
<p>得到结果:</p>
<pre><code>rs1 = {
    h: ["cateId","cateName","2019-11","2019-12","2020-2"],
    d: [
        [1, "衣服", 20000, null, 19000],
        [2, "食品", 12000, 15000, null]
    ]
}</code></pre>
<p>即:</p>
<pre><code>cateId cateName 2019-11 2019-12 2020-02
------------
1   衣服  20000   0   19000
2   食品  12000   15000   0</code></pre>
<ol>
<li>
<p>ycol也可以指定多列, 用的比较少.</p>
<p>var rs1 = pivot(rs, {<br />
xcol: [0, 1],<br />
gcol: 3,<br />
ycol: [4,4], // 为演示结果, 故意重复sum列. 实际可能为&quot;订单总额&quot;,&quot;订单数&quot;两列.<br />
})</p>
</li>
</ol>
<p>得到结果:</p>
<pre><code>rs1 = {
    h: ["y","m","衣服","食品"],
    d: [
        [2019, 11, [20000,20000], [12000,12000]],
        [2019, 12, null, [15000,15000]],
        [2020, 02, [19000,19000], null]
    ]
}</code></pre></div>
<div class="block">
<h2 id="WUI.rs2Stat">@fn WUI.rs2Stat(rs, opt?) -> statData</h2><div class="toc"><p style="margin-left:0em"><a href="#WUI.rs2Stat-1 常用统计图示例">1 常用统计图示例</a></p>
<p style="margin-left:0em"><a href="#WUI.rs2Stat-2 tmUnit使用举例">2 tmUnit使用举例</a></p>
</div>
<p>将query接口返回的数据，转成统计图需要的数据格式。</p>
<p class="param"><strong>@param opt</strong>  {xcol, ycol, gcol, gtext, maxSeriesCnt, tmUnit, formatter, formatterX}</p>
<p class="param"><strong>@param opt.xcol</strong>  指定X轴数据，可以是一列或多列，如0表示第0列, 值[0,1]表示前2列。可以没有x列，用空数组`[]`表示。</p>
<p class="param"><strong>@param opt.ycol</strong>  指定值数据，可以是一列或多列。</p>
<p class="param"><strong>@param opt.gcol</strong>  指定分组列。</p>
<p class="param"><strong>@param opt.gtext</strong>  指定分组值对应的显示文本列。比如表中既有商品编号，又有商品名称，商品编号列设置为gcol用于分组，而商品名称列设置为gtext用于显示。</p>
<p>xcol,ycol,gcol,gtext,maxSeriesCnt参数可参考函数 WUI.pivot</p>
<p class="param"><strong>@param opt.tmUnit</strong>  如果非空，表示按指定时间维度分析。参考[JdcloudStat.tmUnit]().</p>
<p>未指定tmUnit时，缺省xcol=0列（或1列，当有3列及以上且未指定ycol时，当成是<code>xcol,xcoltext,ycol</code>三列格式），ycol=最后一列，gcol如需要则应手工指定</p>
<p>tmUnit用于指定时间字段: &quot;y,m&quot;-年,月; &quot;y,m,d&quot;-年,月,日; &quot;y,w&quot;-年,周; &quot;y,m,d,h&quot;-年,月,日,时; &quot;y,q&quot;-年,季度<br />
若指定了tmUnit，则可以不指定xcol,gcol,ycol，而是由字段排列自动得到，详见&quot;tmUnit使用举例&quot;章节。</p>
<p class="param"><strong>@param opt.formatter</strong>  对汇总数据列进行格式化，缺省取WUI.options.statFormatter[ycolNames]。Function(value).</p>
<p class="param"><strong>@param opt.formatterX</strong>  对X轴数据进行格式化，缺省取WUI.options.statFormatter[xcolNames]。Function(value)。若opt.xcol是数组，则value也是数组。</p>
<p class="return"><strong>@return statData</strong>  { @xData, @yData=[{name=seriesName, data=@seriesData}]  }</p>
<p>与echart结合使用示例可参考 initChart. 原理如下：</p>
<pre><code>var option = {
    ...
    legend: {
        data: statData.yData
    },
    xAxis:  {
        type: 'category',
        boundaryGap: false,
        data: statData.xData
    },
    yAxis: {
        type: 'value',
        axisLabel: {
            formatter: '{value}'
        }
    },
    series: statData.yData
};
myChart.setOption(option);</code></pre>
<h4 id="WUI.rs2Stat-1 常用统计图示例">1 常用统计图示例</h4>
<p>例1：统计每个用户的订单金额, 由高到低显示前10名, 显示为饼图或柱状图.</p>
<pre><code>callSvr("Ordr.query", {gres: "userId 用户编号", res: "userName 用户, SUM(amount) 金额", orderby: "sum DESC", pagesz: 10})
// 一般用userId而不是userName来分组, 因为不仅userName可能会重名, 而且userName一般是从外部表join过来的, 没有索引性能较差不适合做分组字段.</code></pre>
<p>得到结果示例:</p>
<pre><code>var rs = {
    h: ["用户编号", "用户", "金额"],
    d: [
        [1001,"用户1",12000],
        [1002,"用户2",10000]
    ]
}</code></pre>
<p>即:</p>
<pre><code>用户编号    用户  金额
-------------
1001    用户1 12000
1002    用户2 10000
...</code></pre>
<p>通过rs2Stat转换:</p>
<pre><code>var statData = rs2Stat(rs, {xcol:1}); // xcol指定横轴数据列, 缺省为第0列, 这里指定为第1列，用名字替代编号。ycol选项可指定统计值列, 这里没有指定，缺省为最后一列，
// 结果：
statData = {
    xData: [
        '用户1', '用户2'
    ],
    yData: [
        {name: '金额', data: [12000, 10000]}
    ]
}</code></pre>
<p>例2：按年-月统计订单金额, 显示为柱状图或折线图.</p>
<pre><code>callSvr("Ordr.query", {gres: "y,m", res: "SUM(amount) sum", orderby: "y,m"})</code></pre>
<p>得到表:</p>
<pre><code>y   m   sum
-----------
2019    11  30000
2019    12  34000
2020    2   25000</code></pre>
<p>转换示例:</p>
<pre><code>var rs = {
    h: ["y", "m", "sum"],
    d: [
        [2019,11,30000],
        [2019,12,34000],
        [2020,2,25000],
    ]
}
var statData = rs2Stat(rs, {xcol:[0,1]});
// 结果：
statData = {
    xData: [
        '2019-11', '2019-12', '2020-2'
    ],
    yData: [
        {name: '累计', data: [30000, 34000, 25000]}
    ]
}</code></pre>
<p>上面年月中缺少了2020-1, 如果要补上缺少的月份, 可以使用tmUnit参数指定日期类型, 注意这时原始数据中年月须已排好序:</p>
<pre><code>var statData = rs2Stat(rs, {xcol:[0,1], ycol:2, tmUnit:"y,m"} );
// 指定tmUnit后, xcol缺省为前N列即tmUnit这几列, 如"y,m,d"(年月日)表示前3列即`xcol: [0,1,2]`. 上面参数可简写为:
var statData = rs2Stat(rs, {tmUnit:"y,m"} );
// 结果：
statData = {
    xData: [
        '2019-11', '2019-12', '2020-1', '2020-2'
    ],
    yData: [
        {name: '累计', data: [30000, 34000, 0, 25000]}
    ]
}</code></pre>
<p>例3：按年-月统计各产品类别(cateId)的订单金额, 产品类别在列上显示(即显示为系列, 列为&quot;年,月,类别1,类别2,...&quot;):</p>
<pre><code>callSvr("Ordr.query", {gres: "y,m,cateId", res: "cateName,SUM(amount) sum"}, orderby: "y,m")

y   m   cateId  cateName    sum
------------
2019    11  1   衣服  20000
2019    11  2   食品  12000
2019    12  2   食品  15000
2020    02  1   衣服  19000</code></pre>
<p>结果需要将分类cateName转到列上, 即:</p>
<pre><code>y   m 衣服    食品
------------
2019    11  20000   12000
2019    12  0   15000
2020    02  19000   0</code></pre>
<p>可以添加gcol参数指定转置列(pivot column):</p>
<pre><code>var rs = {
    h: ["y","m","cateId","cateName","sum"],
    d: [
        [2019, 11, 1, "衣服", 20000],
        [2019, 11, 2, "食品", 12000],
        [2019, 12, 2, "食品", 15000],
        [2020, 02, 1, "衣服", 19000]
    ]
}
var statData = rs2Stat(rs, {
    xcol: [0, 1], // 0,1列
    gcol: 2,
    gtext: 3 // gtext表示gcol如何显示, 数字3表示按第3列显示, 即"1","2"显示成"衣服", "食品"; gtext也可以用函数, 如 `function (val, row, i) { return row[3] }`
})
// 结果：
statData = {
    xData: [
        '2019-11', '2019-12', '2020-2'
    ],
    yData: [
        {name: '衣服', data: [20000, 0, 19000]},
        {name: '食品', data: [12000, 15000, 0]}
    ]
}</code></pre>
<p>如果还需要补上缺少的年月, 可以加tmUnit参数, 要求原始数据中年月须已排好序:</p>
<pre><code>var statData = rs2Stat(rs, {
    // xcol: [0, 1], // 有tmUnit参数时, 且刚好前N列表示时间, 则xcol可缺省
    gcol: 2,
    gtext: 3,
    tmUnit: "y,m"
})
// 结果：
statData = {
    xData: [
        '2019-11', '2019-12', '2020-1', '2020-2' // '2020-1'是自动补上的
    ],
    yData: [
        {name: '衣服', data: [20000, 0, 0, 19000]},
        {name: '食品', data: [12000, 15000, 0, 0]}
    ]
}</code></pre>
<p>注意: 上面将分类cateName转到列上再转成统计数据, 也可以分步来做, 先用pivot函数:</p>
<pre><code>var rs1 = pivot(rs, {
    xcol: [0, 1],
    gcol: 2,
    gtext: 3
})</code></pre>
<p>得到结果rs1:</p>
<pre><code>y   m 衣服    食品
------------
2019    11  20000   12000
2019    12  0   15000
2020    02  19000   0</code></pre>
<p>再将rs1转成统计数据:</p>
<pre><code>var statData = rs2Stat(rs1, {
    xcol: [0, 1],
    ycol: [2, 3], // 注意这时ycol是多列, 显式指定.
    tmUnit: "y,m"
})</code></pre>
<h4 id="WUI.rs2Stat-2 tmUnit使用举例">2 tmUnit使用举例</h4>
<p>当有tmUnit时, 列按如下规则分布, 可以省去指定xcol, gcol等参数:</p>
<pre><code>与tmUnit匹配的时间列   值统计列
与tmUnit匹配的时间列   分组列 值统计列
与tmUnit匹配的时间列   分组列 组名列 值统计列</code></pre>
<p>例如以下列, 均可以只用参数 <code>{tmUnit: "y,m,d"}</code>:</p>
<pre><code>y,m,d,sum  完整参数为: { tmUnit: "y,m,d", xcol:[0,1,2], ycol: 3 }
y,m,d,cateName,sum  完整参数为: { tmUnit: "y,m,d", xcol:[0,1,2], gcol:3, ycol: 4 }
y,m,d,cateId,cateName,sum  完整参数为:   { tmUnit: "y,m,d", xcol:[0,1,2], gcol:3, gtext:4, ycol: 5 }</code></pre>
<p>示例一：</p>
<pre><code>var rs = {
    h: ["y", "m", "d", "sum"], // 时间维度为 y,m,d; sum为统计值
    d: [
        [2016, 6, 29, 13],
        [2016, 7, 1, 2],
        [2016, 7, 2, 9],
    ]
}
var statData = rs2Stat(rs, {tmUnit: "y,m,d"});

// 结果：
statData = {
    xData: [
        '2016-6-29', '2016-6-30', '2016-7-1', '2016-7-2' // 2016-6-30为自动补上的日期
    ],
    yData: [
        {name: 'sum', data: [13, 0, 2, 9]} // 分别对应xData中每个日期，其中'2016-6-30'没有数据自动补0
    ]
}</code></pre>
<p>示例二： 有汇总字段</p>
<pre><code>var rs = {
    h: ["y", "m", "d", "sex", "sum"], // 时间维度为 y,m,d; sex为汇总字段, sum为累计值
    d: [
        [2016, 6, 29, '男', 10],
        [2016, 6, 29, '女', 3],
        [2016, 7, 1, '男', 2],
        [2016, 7, 2, '男', 8],
        [2016, 7, 2, '女', 1],
    ]
}
var statData = rs2Stat(rs, {tmUnit: "y,m,d"});

// 结果：
statData = {
    xData: [
        '2016-6-29', '2016-6-30', '2016-7-1', '2016-7-2' // 2016-6-30为自动补上的日期
    ],
    yData: [
        {name: '男', data: [10, 0, 2, 8]}, // 分别对应xData中每个日期，其中'2016-6-30'没有数据自动补0
        {name: '女', data: [3, 0, 0, 1]} // '2016-6-30'与'2016-7-1'没有数据自动补0.
    ]
}</code></pre>
<p>默认yData中的系列名(seriesName)直接使用汇总字段，但如果汇总字段后还有一列，则以该列作为显示名称。</p>
<p>示例三： 汇总字段&quot;sex&quot;后面还有一列&quot;sexName&quot;, 因而使用sexName作为图表系列名用于显示. 而&quot;sex&quot;以&quot;M&quot;,&quot;F&quot;分别表示男女，仅做内部使用：</p>
<pre><code>var rs = {
    h: ["y", "m", "d", "sex", "sexName", "sum"], // 时间维度为 y,m,d; sex为汇总字段, sexName为汇总显示字段, sum为累计值
    d: [
        [2016, 6, 29, 'M', '男', 10],
        [2016, 6, 29, 'F', '女', 3],
        [2016, 7, 1, 'M', '男', 2],
        [2016, 7, 2, 'M', '男', 8],
        [2016, 7, 2, 'F', '女', 1],
    ]
}
var statData = rs2Stat(rs, {tmUnit: "y,m,d"});
// 结果：与示例二相同。它等价于调用:
var statData = rs2Stat(rs, {tmUnit: "y,m,d",
    xcol: [0,1,2],
    gcol: 3,
    gtext: 4,
    ycol: 5
});</code></pre>
<p>示例四： 汇总字段支持格式化，假设性别字段以'M','F'分别表示'男', '女':</p>
<pre><code>var rs = {
    h: ["y", "m", "d", "sex", "sum"], // 时间维度为 y,m,d; sex为汇总字段, sum为累计值
    d: [
        [2016, 6, 29, 'M', 10],
        [2016, 6, 29, 'F', 3],
        [2016, 7, 1, 'M', 2],
        [2016, 7, 2, 'M', 8],
        [2016, 7, 2, 'F', 1],
    ]
}
var opt = {
    tmUnit: "y,m,d",
    // arr为当前行数组, i为统计字段在数组中的index, 即 arr[i] = value.
    formatter: function (value, arr, i) {
        return value=='M'?'男':'女';
    }
};
var statData = rs2Stat(rs, opt);
// 结果：与示例二相同。</code></pre>
<p>可以使用变量WUI.options.statFormatter指定全局formatter，如示例四也可以写：</p>
<pre><code>WUI.options.statFormatter = {
    sex: function (value, arr, i) {
        return value=='M'?'男':'女';
    }
}
var statData = rs2Stat(rs, {tmUnit: "y,m,d"});</code></pre>
<p>在无汇总时，列&quot;sum&quot;会自动被改为&quot;累计&quot;，这时默认在statFormatter中设置的：</p>
<pre><code>WUI.options.statFormatter = {
    sum: function (value) {
        return '累计';
    }
}</code></pre>
<p>X轴数据也支持定制，通过设置formaterX回调函数，如tm=&quot;y,m,d&quot;时，默认显示如&quot;2020-10-1&quot;，现在想只显示&quot;10-1&quot;，可以用：</p>
<pre><code>var statData = WUI.rs2Stat(rs, {tmUnit:"y,m,d", formatterX:function (value) {
    return value[1] + "-" + value[2]
}})</code></pre></div>
<div class="block">
<h2 id="WUI.initChart">@fn WUI.initChart(chartTable, statData, seriesOpt, chartOpt)</h2>
<p>初始化echarts报表组件.</p>
<ul>
<li>chartTable: 图表DOM对象</li>
<li>statData: 符合echarts规范的数据，格式为 {@xData, @yData=[{name, @data}]}.</li>
<li>seriesOpt, chartOpt: 参考echarts全局参数以及series参数: <a href="https://echarts.apache.org/zh/option.html#series">https://echarts.apache.org/zh/option.html#series</a><br />
echarts示例：<a href="https://echarts.apache.org/examples/zh/index.html">https://echarts.apache.org/examples/zh/index.html</a></li>
</ul>
<p>statData示例：</p>
<pre><code>statData = {
    xData: [
        '2016-6-29', '2016-6-30', '2016-7-1', '2016-7-2'
    ],
    yData: [
        {name: 'sum', data: [13, 0, 2, 9]} // 分别对应xData中每个日期，其中'2016-6-30'没有数据自动补0
    ]
}</code></pre>
<p>特别地，设置 chartOpt.swapXY = true，表示横向柱状图。</p>
<p class="see"><strong>@see <a href="#WUI.rs2Stat">WUI.rs2Stat</a> <a href="#"></a></strong>  WUI.initPageStat</p></div>
<div class="block">
<h2 id="WUI.initPageStat">@fn WUI.initPageStat(jpage, setStatOpt) -> statItf</h2>
<p>通用统计页模式</p>
<ul>
<li>查询条件区，如起止时间</li>
<li>生成统计图按钮</li>
<li>一个或多个图表，每个图表可设置不同的查询条件、时间维度等。</li>
</ul>
<p>示例可参考超级管理端API日志统计(web/adm/pageApiLogStat)</p>
<p>html示例:</p>
<pre><code>&lt;div wui-script="pageUserRegStat.js" title="用户注册统计" my-initfn="initPageUserRegStat"&gt;
    开始时间 
    &lt;input type="text" name="createTm" data-op="&gt;=" data-options="showSeconds:false" class="easyui-datetimebox txtTm1"&gt;
    结束时间
    &lt;input type="text" name="createTm" data-op="&lt;" data-options="showSeconds:false" class="easyui-datetimebox txtTm2"&gt;
    快捷时间选择
    &lt;select class="txtTmRange"&gt;
        &lt;option value ="近8周"&gt;近8周&lt;/option&gt;
        &lt;option value ="近6月"&gt;近6月&lt;/option&gt;
    &lt;/select&gt;

    各种过滤条件：
    性别:
    &lt;select name="sex"&gt;
        &lt;option value =""&gt;全部&lt;/option&gt;
        &lt;option value ="男"&gt;男&lt;/option&gt;
        &lt;option value ="女"&gt;女&lt;/option&gt;
    &lt;/select&gt;
    地域:
    &lt;select name="region" class="my-combobox" data-options="valueField:'id',textField:'name',url:WUI.makeUrl(...)"&gt;&lt;/select&gt;

    统计项
    &lt;select id="cboRes"&gt;
        &lt;option value ="COUNT(*) 总数"&gt;数量&lt;/option&gt;
        &lt;option value="SUM(t) sum"&gt;调用时间(毫秒)&lt;/option&gt;
        &lt;!-- 可以指定多个字段，逗号分隔，表示显示多个系列（这时下面的“分类汇总”是无效的），示例：
        &lt;option value ="totalMh 理论工时,totalMh1 实际工时,totalMh2 出勤工时"&gt;工时&lt;/option&gt;
        --&gt;
    &lt;/select&gt;

    汇总字段:
    &lt;select id="g"&gt;
        &lt;option value =""&gt;无&lt;/option&gt;
        &lt;option value ="sex"&gt;性别&lt;/option&gt;
        &lt;option value="region"&gt;地域&lt;/option&gt;

        &lt;!-- 可以指定两个字段，逗号分隔，格式"分组字段,分组显示字段"
        &lt;option value="userId,userName"&gt;用户&lt;/option&gt;
        &lt;option value="itemId,itemName"&gt;物料&lt;/option&gt;
        --&gt;
    &lt;/select&gt;

    &lt;input type="button" value="生成" class="btnStat"/&gt;

    时间维度类型：
    &lt;select id="tmUnit"&gt;
        &lt;option value="y,w"&gt;周报表&lt;/option&gt;
        &lt;option value="y,m"&gt;月报表&lt;/option&gt;
    &lt;/select&gt;

    统计图：
    &lt;div class="divChart" data-ac="User.query"&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
<p>遍历jpage中带name属性的各组件，生成统计请求的参数，调用接口获取统计数据并显示统计图表.</p>
<ul>
<li>报表组件.divChart上，可以用data-ac属性指定调用名，用data-res属性指定调用的res参数(默认为&quot;COUNT(*) sum&quot;)，更多参数可通过setStatOpt(...opt)回调函数动态设置opt.queryParam参数。<br />
可以用 jpage.find(&quot;.divChart&quot;)[0].echart 来取 echart对象.</li>
<li>生成图表的按钮组件 .btnStat</li>
<li>带name属性（且没有disabled属性）的组件，会自动生成查询条件(根据name, data-op, value生成表达式)</li>
<li>组件.txtTm1, .txtTm2识别为起止时间，可以用过 statItf.setTmRange()去重设置它们，或放置.txtTmRange下拉框组件自动设置</li>
</ul>
<p>初始化示例：</p>
<pre><code>var statItf_ = WUI.initPageStat(jpage, setStatOpt);

function setStatOpt(chartIdx, opt) 
{
    // this是当前chart的jquery对象，chartIdx为序号，依此可针对每个chart分别设置参数

    // 设置查询参数param.ac/param.res/param.cond等
    var param = opt.queryParam;
    param.cond += ...;
    param.res = jpage.find("#cboRes").val();

    // 设置时间维度，汇总字段
    opt.tmUnit = jpage.find("#tmUnit").val();
    opt.g = jpage.find("#g").val();

    // 设置echarts参数
    var chartOpt, seriesOpt;
    if (chartIdx == 0) {
        chartOpt = { ... };
        seriesOpt = { ... };
    }
    else if (chartIdx == 1) {
        chartOpt = { ... };
        seriesOpt = { ... };
    }

    $.extend(true, opt, {
        chartOpt: chartOpt,
        seriesOpt: seriesOpt,
    });
}</code></pre>
<p class="param"><strong>@param setStatOpt</strong> (chartIdx, opt) 回调设置每个chart. this为当前chart组件，chartIdx为当前chart的序号，从0开始。</p>
<p class="param"><strong>@param opt=</strong> {tmUnit?, g?, queryParam, chartOpt, seriesOpt, onLoadData?, maxSeriesCnt?, formatter?, x?, useResOnly?}</p>
<p><strong>统计模型</strong></p>
<p>x表示横坐标字段，y表示纵坐标字段，g表示要转置到列上的字段（pivot字段）</p>
<ul>
<li>xy/xyy模式: 查询参数{res:&quot;x,y,y2?&quot;} 显示柱状图/折线图，若多个y则显示多系列。</li>
<li>gy模式: 查询参数{gres:g, res:y} 显示饼图或柱状图，显示时数据可看作xy模式。</li>
<li>xgy模式：查询参数{res:&quot;x,g,gname?,y&quot;} 或 {gres:&quot;x,g&quot;,res:&quot;gname?,y&quot;} 显示多系列柱状图。</li>
</ul>
<p>参数运用：</p>
<ul>
<li>opt.x定义x字段，注意时间字段tmUnit比如&quot;y,m,d&quot;是特殊的x量。x自身是一个或多个字段。</li>
<li>opt.g定义g字段，用于图表系列字段（pivot字段）。用于区分xyy与xgy模型: 设置了opt.g就是xgy, 否则就是xyy.<br />
g是一个字段，也可以是逗号分隔的两个字段，这时表示<code>g,gname</code>，g用于转置, gname用于显示。</li>
<li>查询参数opt.queryParam.res定义了y字段。当有opt.g时，y应只有一个字段，g作为图表系列；否则可以有多个y字段，形成多个图表系列。</li>
<li>默认会将tmUnit/x和g参数拼接到gres和res参数中用于查询。若定义 opt.useResOnly=1 时，则只使用res参数。</li>
</ul>
<p class="param"><strong>@param opt.tmUnit</strong>  Enum. 时间维度</p>
<p>如果非空，则按时间维度分析，即按指定时间类型组织横轴数据，会补全时间。参考[JdcloudStat.tmUnit]()<br />
如果设置，它会自动设置 opt.queryParam 中的gres/orderby参数。</p>
<p class="param"><strong>@param opt.g</strong>  分组字段名</p>
<p>会影响opt.queryParam中的gres选项。</p>
<p>有时分组字段使用xxxId字段，但希望显示时用xxxName字段，这时可在g中包含两个字段。</p>
<p>示例，按场景分组显示日报表：</p>
<pre><code>opt.tmUnit = "y,m,d"; // 日报表
opt.g = "sceneId,sceneName";</code></pre>
<p>这样生成的opt.queryParam中: </p>
<pre><code>gres="y,m,d,sceneId";
orderby="y,m,d";
res="sceneName,COUNT(*) sum";</code></pre>
<p class="param"><strong>@param opt.queryParam</strong>  接口查询参数</p>
<p>可以设置ac, res, gres, cond, orderby, pagesz等筋斗云框架通用查询参数，或依照接口文档设置。<br />
设置opt.tmUnit/opt.g会自动设置其中部分参数。</p>
<p>此外 ac, res参数也可通过在.divChart组件上设置data-ac, data-res属性，如</p>
<pre><code>&lt;div class="divChart" data-ac="Ordr.query" data-res="SUM(amount) sum"&gt;&lt;/div&gt;</code></pre>
<p>关于接口返回数据到图表数据转换，参考rs2Stat函数：</p>
<p class="see"><strong>@see <a href="#WUI.rs2Stat">WUI.rs2Stat</a></strong>  </p>
<p class="param"><strong>@param opt.chartOpt,</strong>  opt.seriesOpt </p>
<p>参考百度echarts全局参数以及series参数: <a href="http://echarts.baidu.com/echarts2/doc/doc.html">http://echarts.baidu.com/echarts2/doc/doc.html</a></p>
<p class="param"><strong>@param opt.onLoadData</strong> (statData, opt) 处理统计数据后、显示图表前回调。</p>
<p>this为当前图表组件(jchart对象)。常用于根据统计数据调整图表显示，修改opt中的chartOpt, seriesOpt选项即可。</p>
<p class="param"><strong>@param opt.maxSeriesCnt</strong> ?=10 </p>
<p>最多显示多少图表系列（其它系列自动归并到“其它”中）。参考rs2Stat函数同名选项。</p>
<p class="param"><strong>@param opt.formatter</strong>  </p>
<p>对汇总数据进行格式化显示。参考 rs2Stat函数同名选项。</p>
<p class="see"><strong>@see <a href="#WUI.rs2Stat">WUI.rs2Stat</a></strong> </p>
<p class="return"><strong>@return statItf=</strong> {refreshStat(), setTmRange(desc)} 统计页接口</p>
<p>refreshStat()用于显示或刷新统计图。当调用initPageStat(jpage)且jpage中有.btnStat组件时，会自动点击该按钮以显示统计图。<br />
setTmRange(desc)用于设置jpage中的.txtTm1, .txtTm2两个文本框，作为起止时间。</p>
<p class="see"><strong>@see <a href="#WUI.getTmRange">WUI.getTmRange</a></strong> </p>
<p class="see"><strong>@see <a href="#WUI.initChart　显示图表">WUI.initChart　显示图表</a></strong> </p>
<p>也可以调用WUI.initChart及WUI.rs2Stat自行设置报表，示例如下：</p>
<pre><code>var jchart = jpage.find(".divChart");
var tmUnit = "y,m"; // 按时间维度分析，按“年月”展开数据
var cond = "tm&gt;='2016-1-1' and tm&lt;'2017-1-1'";
// WUI.useBatchCall(); // 如果有多个报表，可以批量调用后端接口
// 会话访问量
callSvr("ApiLog.query", function (data) {
    var opt = { tmUnit: tmUnit };
    var statData = WUI.rs2Stat(data, opt);
    var seriesOpt = {};
    var chartOpt = {
        title: {
            text: "访问量（会话数）"
        },
        legend: null
    };

    WUI.initChart(jchart[0], statData, seriesOpt, chartOpt);
}, {res: "COUNT(distinct ses) sum", gres: tmUnit, orderby: tmUnit, cond: cond });</code></pre>
<p>此外，也支持直接显示无汇总的数据。</p>
<p>示例：有以下接口：</p>
<pre><code>RecM.query() -&gt; tbl(who, tm, cpu)</code></pre>
<p>返回 服务器(who)在每一分钟(tm)的最低cpu使用率。数据示例：</p>
<pre><code>{ h: ["who", "tm", "cpu"],
  d: [ 
    ["app", "2018-10-1 10:10:00", 89],
    ["app", "2018-10-1 10:11:00", 91],
    ["db", "2018-10-1 10:10:00", 68],
    ["db", "2018-10-1 10:11:00", 72]
  ]
}</code></pre>
<p>由于tm已经汇总到分钟，现在希望直接显示tm对应的值，且按服务器不同(&quot;app&quot;表示&quot;应用服务器&quot;，&quot;db&quot;表示&quot;数据库服务器&quot;)分系列显示。查询：</p>
<pre><code>RecM.query(res="tm,who,cpu", cond="...")</code></pre>
<p>JS示例：</p>
<pre><code>function initPageRecMStat()
{
    ...
    var statItf_ = WUI.initPageStat(jpage, setStatOpt);
    function setStatOpt(chartIdx, opt) 
    {
        var param = opt.queryParam;
        param.res = "cpu"; // y字段
        opt.x = "tm"; // x字段
        opt.g = "who", // g字段即图表系列(pivot字段)
        opt.useResOnly = true; // 直接显示原始数据，无须用gres分组，所以设置useResOnly.

        opt.formatter = function (value, arr, i) {
            var map = {
                "app": "应用服务器",
                "db": "数据库服务器"
            };
            return map[value] || value;
        };
    }
}</code></pre></div>
<div class="block">
<h2 id="pageSimple">@module pageSimple</h2><div class="toc"><p style="margin-left:0em"><a href="#pageSimple-1 示例1：列表页上加查看报表按钮">1 示例1：列表页上加查看报表按钮</a></p>
<p style="margin-left:0em"><a href="#pageSimple-2 示例2：先弹出查询条件对话框，设置后再显示报表">2 示例2：先弹出查询条件对话框，设置后再显示报表</a></p>
<p style="margin-left:0em"><a href="#pageSimple-3 示例3：菜单上增加报表，且定制报表列实现交互">3 示例3：菜单上增加报表，且定制报表列实现交互</a></p>
<p style="margin-left:0em"><a href="#pageSimple-4 辅助列">4 辅助列</a></p>
</div>
<p>用于快捷展示报表。</p>
<h4 id="pageSimple-1 示例1：列表页上加查看报表按钮">1 示例1：列表页上加查看报表按钮</h4>
<p>在订单列表上添加“月报表”按钮，点击显示订单月统计报表，并可以导出到Excel。</p>
<pre><code>// function initPageCusOrder()
var btnStat1 = {text: "月报表", "wui-perm": "导出", iconCls:'icon-ok', handler: function () {
    var queryParams = jtbl.datagrid("options").queryParams;
    var url = WUI.makeUrl("Ordr.query", {
        gres:"y 年,m 月, userId",
        res:"userName 客户, COUNT(*) 订单数, SUM(amount) 总金额",
        hiddenFields: "userId",
        orderby: "总金额 DESC"
    });
    WUI.showPage("pageSimple", "订单月报表!", [url, queryParams]);
}};
jtbl.datagrid({
    toolbar: WUI.dg_toolbar(jtbl, jdlg, ..., btnStat1),
    ...
});</code></pre>
<p>注意：调用WUI.showPage时，标题以&quot;!&quot;结尾表示每次调用都刷新该页面。而默认行为是如果页面已打开，就直接显示而不会刷新。</p>
<h4 id="pageSimple-2 示例2：先弹出查询条件对话框，设置后再显示报表">2 示例2：先弹出查询条件对话框，设置后再显示报表</h4>
<p>常常与报表查询条件对话DlgReportCond一起使用, 先设置查询时间段，然后出报表，示例:</p>
<pre><code>var btnStat1 = {text: "月统计", iconCls:'icon-ok', handler: function () {
    DlgReportCond.show(function (data) {
        var queryParams = WUI.getQueryParam({dt: [data.tm1, data.tm2]});
        var url = WUI.makeUrl("Capacity.query", { gres: 'y 年,m 月, name 员工', res: 'SUM(mh) 总工时, SUM(mhA) 总加班', pagesz: -1 });
        WUI.showPage("pageSimple", "出勤月统计!", [url, queryParams]);
    });
}};
jtbl.datagrid({
    toolbar: WUI.dg_toolbar(jtbl, jdlg, ..., btnStat1),
    ...
});</code></pre>
<p>回调函数参数data是对话框中设置了name的输入字段，默认有tm1, tm2。</p>
<p>允许定制查询条件对话框，如添加查询字段，详见dlgReportCond对话框文档。</p>
<p class="see"><strong>@see <a href="#dlgReportCond">dlgReportCond</a></strong> </p>
<h4 id="pageSimple-3 示例3：菜单上增加报表，且定制报表列实现交互">3 示例3：菜单上增加报表，且定制报表列实现交互</h4>
<p>允许定制表格显示参数，如</p>
<pre><code>WUI.showPage("pageSimple", "订单月报表!", [url, queryParams, onInitGrid]);

function onInitGrid(jpage, jtbl, dgOpt, columns, data)
{
    // dgOpt: datagrid的选项，如设置 dgOpt.onClickCell等属性
    // columns: 列数组，可设置列的formatter等属性
    // data: ajax得到的原始数据
}</code></pre>
<p>注意：关于分页：如果url中有pagesz=-1参数，则不分页。也可直接设置dgOpt.pagination指定。</p>
<p>示例：菜单上增加“工单工时统计”报表，在“数量”列上可以点击，点击后在新页面中显示该工单下的所有工件明细。</p>
<p>菜单上增加一项：</p>
<pre><code>            &lt;a href="javascript:WUI.loadScript('page/mod_工单工时统计.js')"&gt;工单工时统计&lt;/a&gt;</code></pre>
<p>用WUI.loadScript可以动态加载JS文件，web和page目录下的JS文件默认都是禁止缓存的，因此修改文件后再点菜单可立即生效无须刷新。<br />
在文件<code>page/mod_工单工时统计.js</code>中写报表逻辑，并对“数量”列进行定制：</p>
<pre><code>function show工单工时统计()
{
    DlgReportCond.show(function (data) {
        var queryParams = WUI.getQueryParam({createTm: [data.tm1, data.tm2]});
        var url = WUI.makeUrl("Ordr.query", { res: 'id 工单号, createTm 生产日期, itemCode 产品编码, itemName 产品名称, cate2Name 产品系列, itemCate 产品型号, qty 数量, mh 理论工时, mh1 实际工时', pagesz: -1 });
        WUI.showPage("pageSimple", "工单工时统计!", [url, queryParams, onInitGrid]);
    });

    function onInitGrid(jpage, jtbl, dgOpt, columns, data)
    {
        // dgOpt: datagrid的选项，如设置 dgOpt.onClickCell等属性
        // columns: 列数组，可设置列的formatter等属性
        // data: ajax得到的原始数据
        $.each(columns, function (i, col) {
            if (col.field == "数量")
                col.formatter = formatter_数量;
        });
        // console.log(columns);

        // var btn = { text: "XX", iconCts: "icon-search", handler: ... };
        // 替换工具栏按钮
        // dgOpt.toolbar = WUI.dg_toolbar(jtbl, null, btn1);
        // 或是：追加工具栏按钮
        // dgOpt.toolbar.push.apply(dgOpt.toolbar, WUI.dg_toolbar(jtbl, null, btn1));
    }

    function formatter_数量(value, row) {
        if (!value)
            return;
        return WUI.makeLink(value, function () {
            var orderId = row.工单号;
            var objParam = {orderId: orderId };
            WUI.showPage("pageSn", "工件-工单" + orderId, [ objParam ]);
        });
    }
}</code></pre>
<h4 id="pageSimple-4 辅助列">4 辅助列</h4>
<p>以下划线结尾的列不显示，也不导出。</p>
<p>示例：显示工艺并可点击打开工艺对话框。</p>
<pre><code>var url = WUI.makeUrl("Ordr.query", { res: 'id 工单号, flowId flowId_, flowName 工艺' });
WUI.showPage("pageSimple", "工单工时统计!", [url, null, onInitGrid]);

function onInitGrid(jpage, jtbl, dgOpt, columns, data)
{
    $.each(columns, function (i, col) {
        if (col.field == "工艺")
            col.formatter = Formatter.linkTo("flowId_", "#dlgFlow");
    });
}</code></pre>
<p>上面flowId字段只用于链接，不显示，也不会导出。</p></div>
<div class="block">
<h2 id="dlgReportCond">@module dlgReportCond</h2>
<pre><code>DlgReportCond.show(onOk, meta?, inst?);</code></pre>
<ul>
<li>onOk(data): 回调函数</li>
<li>meta: 用于追加动态字段, 参考WUI.showByMeta</li>
<li>inst: 实例名，与meta配合使用，不同场景配不同meta.</li>
</ul>
<p>用于显示查询对话框，默认包含startDt, endDt字段。</p>
<pre><code>DlgReportCond.show(function (data) {
    console.log(data);
})</code></pre>
<p>也可以增加自定义字段：</p>
<pre><code>var meta = [
    // title, dom, hint?
    {title: "状态", dom: '&lt;select name="status" class="my-combobox" data-options="jdEnumMap:OrderStatusMap"&gt;&lt;/select&gt;'},
    {title: "订单号", dom: "&lt;textarea name='param' rows=5&gt;&lt;/textarea&gt;", hint: '每行一个订单号'}
];
DlgReportCond.show(function (data) {
    console.log(data);
}, meta)</code></pre>
<p>如果有多个不同的使用场景，对应的自定义字段不同，可以指定实例名来实现，如订单和工单的查询条件有些不同，可分开写：</p>
<pre><code>DlgReportCond.show(function (data) {
    console.log(data);
}, meta1, "订单");

DlgReportCond.show(function (data) {
    console.log(data);
}, meta2, "工单");</code></pre></div>
<div style="text-align:center">Generated by jdcloud-gendoc</div>
</body>

</html>

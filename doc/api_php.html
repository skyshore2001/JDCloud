<html>
<head>
<meta charset="utf-8">
<title>API参考 - 筋斗云服务端</title>
<style>
h3,h4,h5,h6 {
	font-size: 1em;
}

pre {
	border-left: 1px solid #ccc;
	margin: 0 1em;
	padding: 0 0.5em;
	tab-size:4;
}

code {
	font-family: "Courier New";
    padding: 0px 3px;
    display: inline-block;
}

.toc {
	margin: 2em;
}

.toc p {
	margin: 0.3em 0;
}

.block {
	border-bottom: 1px solid #ccc;
}

</style>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="doc.css" />
<script src="refdoc.js"></script>
</head>

<body>
<h1>API参考 - 筋斗云服务端</h1>
<div>最后更新：2024-06-26</div>
<div id="menu">
<h2>Modules</h2>
<div class="toc">
<p><a href="#app_fw">app_fw (module)</a></p>
<p><a href="#ext">ext (module)</a></p>
<p><a href="#JDEnv">JDEnv (module)</a></p>
<p><a href="#AccessControl">AccessControl (module)</a></p>
</div><hr>
<h2>Keywords</h2>
<div class="toc">
<p><a href="#$BASE_DIR">$BASE_DIR (var)</a></p>
<p><a href="#$X_APP">$X_APP (var)</a></p>
<p><a href="#$X_RET_FN">$X_RET_FN (var)</a></p>
<p><a href="#AC0_">AC0_ (key)</a></p>
<p><a href="#AC1_">AC1_ (key)</a></p>
<p><a href="#AC2_">AC2_ (key)</a></p>
<p><a href="#AC_">AC_ (key)</a></p>
<p><a href="#AccessControl">AccessControl (module)</a></p>
<p><a href="#AccessControl.delField">AccessControl.delField (var)</a></p>
<p><a href="#AccessControl.qsearch">AccessControl.qsearch (fn)</a></p>
<p><a href="#AccessControl.queryRet">AccessControl.queryRet (fn)</a></p>
<p><a href="#AccessControl::$allowedAc">AccessControl::$allowedAc (var)</a></p>
<p><a href="#AccessControl::$defaultRes">AccessControl::$defaultRes (var)</a></p>
<p><a href="#AccessControl::$defaultSort">AccessControl::$defaultSort (var)</a></p>
<p><a href="#AccessControl::$enableObjLog">AccessControl::$enableObjLog (var)</a></p>
<p><a href="#AccessControl::$enumFields">AccessControl::$enumFields (var)</a></p>
<p><a href="#AccessControl::$hiddenFields">AccessControl::$hiddenFields (var)</a></p>
<p><a href="#AccessControl::$id">AccessControl::$id (var)</a></p>
<p><a href="#AccessControl::$maxPageSz">AccessControl::$maxPageSz (var)</a></p>
<p><a href="#AccessControl::$obj">AccessControl::$obj (var)</a></p>
<p><a href="#AccessControl::$onAfterActions">AccessControl::$onAfterActions (var)</a></p>
<p><a href="#AccessControl::$readonlyFields">AccessControl::$readonlyFields (var)</a></p>
<p><a href="#AccessControl::$readonlyFields2">AccessControl::$readonlyFields2 (var)</a></p>
<p><a href="#AccessControl::$requiredFields">AccessControl::$requiredFields (var)</a></p>
<p><a href="#AccessControl::$requiredFields2">AccessControl::$requiredFields2 (var)</a></p>
<p><a href="#AccessControl::$subobj">AccessControl::$subobj (var)</a></p>
<p><a href="#AccessControl::$table">AccessControl::$table (var)</a></p>
<p><a href="#AccessControl::$uuid">AccessControl::$uuid (var)</a></p>
<p><a href="#AccessControl::$vcolDefs">AccessControl::$vcolDefs (var)</a></p>
<p><a href="#AccessControl::addCond">AccessControl::addCond (fn)</a></p>
<p><a href="#AccessControl::addJoin">AccessControl::addJoin (fn)</a></p>
<p><a href="#AccessControl::addRequireCol">AccessControl::addRequireCol (fn)</a></p>
<p><a href="#AccessControl::addRes">AccessControl::addRes (fn)</a></p>
<p><a href="#AccessControl::addVCol">AccessControl::addVCol (fn)</a></p>
<p><a href="#AccessControl::api_add">AccessControl::api_add (fn)</a></p>
<p><a href="#AccessControl::api_batchAdd">AccessControl::api_batchAdd (fn)</a></p>
<p><a href="#AccessControl::api_del">AccessControl::api_del (fn)</a></p>
<p><a href="#AccessControl::api_delIf">AccessControl::api_delIf (fn)</a></p>
<p><a href="#AccessControl::api_get">AccessControl::api_get (fn)</a></p>
<p><a href="#AccessControl::api_query">AccessControl::api_query (fn)</a></p>
<p><a href="#AccessControl::api_set">AccessControl::api_set (fn)</a></p>
<p><a href="#AccessControl::api_setIf">AccessControl::api_setIf (fn)</a></p>
<p><a href="#AccessControl::callSvc">AccessControl::callSvc (fn)</a></p>
<p><a href="#AccessControl::checkSetFields">AccessControl::checkSetFields (fn)</a></p>
<p><a href="#AccessControl::checkUniKey">AccessControl::checkUniKey (fn)</a></p>
<p><a href="#AccessControl::getMaxPageSz">AccessControl::getMaxPageSz (fn)</a></p>
<p><a href="#AccessControl::isFileExport">AccessControl::isFileExport (fn)</a></p>
<p><a href="#AccessControl::onAfter">AccessControl::onAfter (fn)</a></p>
<p><a href="#AccessControl::onGenId">AccessControl::onGenId (fn)</a></p>
<p><a href="#AccessControl::onHandleRow">AccessControl::onHandleRow (fn)</a></p>
<p><a href="#AccessControl::onQuery">AccessControl::onQuery (fn)</a></p>
<p><a href="#AccessControl::onValidate">AccessControl::onValidate (fn)</a></p>
<p><a href="#AccessControl::onValidateId">AccessControl::onValidateId (fn)</a></p>
<p><a href="#ApiLog::$instance">ApiLog::$instance (var)</a></p>
<p><a href="#ApiLog::$lastId">ApiLog::$lastId (var)</a></p>
<p><a href="#ApiLog::addObjLog">ApiLog::addObjLog (fn)</a></p>
<p><a href="#BatchAddLogic">BatchAddLogic (class)</a></p>
<p><a href="#BatchInsert">BatchInsert (class)</a></p>
<p><a href="#Conf">Conf (key)</a></p>
<p><a href="#Conf::$authKeys=[]">Conf::$authKeys=[] (var)</a></p>
<p><a href="#ConfBase">ConfBase (class)</a></p>
<p><a href="#ConfBase::$authHandlers">ConfBase::$authHandlers (var)</a></p>
<p><a href="#ConfBase::$enableApiLog">ConfBase::$enableApiLog (var)</a></p>
<p><a href="#ConfBase::$enableAutoSession">ConfBase::$enableAutoSession (var)</a></p>
<p><a href="#ConfBase::$enableObjLog">ConfBase::$enableObjLog (var)</a></p>
<p><a href="#ConfBase::checkSecure">ConfBase::checkSecure (fn)</a></p>
<p><a href="#ConfBase::enableSecure">ConfBase::enableSecure (var)</a></p>
<p><a href="#ConfBase::onApiInit">ConfBase::onApiInit (fn)</a></p>
<p><a href="#ConfBase::onInitClient">ConfBase::onInitClient (fn)</a></p>
<p><a href="#DirectReturn">DirectReturn (class)</a></p>
<p><a href="#ENC_KEY">ENC_KEY (var)</a></p>
<p><a href="#ExtFactory::getInstance">ExtFactory::getInstance (fn)</a></p>
<p><a href="#ExtFactory::getObj">ExtFactory::getObj (fn)</a></p>
<p><a href="#FileCache">FileCache (class)</a></p>
<p><a href="#Guard">Guard (class)</a></p>
<p><a href="#JDApiBase::callSvc">JDApiBase::callSvc (alias)</a></p>
<p><a href="#JDEnv">JDEnv (module)</a></p>
<p><a href="#JDEnv::$MAX_DEBUG_LOG_CNT=2000">JDEnv::$MAX_DEBUG_LOG_CNT=2000 (var)</a></p>
<p><a href="#JDEvent">JDEvent (class)</a></p>
<p><a href="#JDEvent.on">JDEvent.on (fn)</a></p>
<p><a href="#JDEvent.trigger">JDEvent.trigger (fn)</a></p>
<p><a href="#JDPDO">JDPDO (class)</a></p>
<p><a href="#JDSingleton">JDSingleton (class)</a></p>
<p><a href="#JDSingletonImp">JDSingletonImp (class)</a></p>
<p><a href="#JDStatusFile">JDStatusFile (class)</a></p>
<p><a href="#MapCol.$colMap">MapCol.$colMap (var)</a></p>
<p><a href="#MapCol.mapCol">MapCol.mapCol (key)</a></p>
<p><a href="#MapCol.mapSql">MapCol.mapSql (key)</a></p>
<p><a href="#MyException">MyException (class)</a></p>
<p><a href="#PAGE_SZ_LIMIT">PAGE_SZ_LIMIT (var)</a></p>
<p><a href="#P_DB">P_DB (key)</a></p>
<p><a href="#P_DBCRED">P_DBCRED (key)</a></p>
<p><a href="#P_DEBUG">P_DEBUG (key)</a></p>
<p><a href="#P_DEBUG_LOG">P_DEBUG_LOG (key)</a></p>
<p><a href="#P_MOCK_MODE">P_MOCK_MODE (key)</a></p>
<p><a href="#P_SESSION_DIR">P_SESSION_DIR (key)</a></p>
<p><a href="#P_TEST_MODE">P_TEST_MODE (key)</a></p>
<p><a href="#P_URL_PATH">P_URL_PATH (key)</a></p>
<p><a href="#Plugins">Plugins (class)</a></p>
<p><a href="#Plugins::$map">Plugins::$map (var)</a></p>
<p><a href="#Plugins::add">Plugins::add (fn)</a></p>
<p><a href="#Plugins::exists">Plugins::exists (fn)</a></p>
<p><a href="#Q">Q (fn)</a></p>
<p><a href="#SimpleCache">SimpleCache (class)</a></p>
<p><a href="#_debug">_debug (key)</a></p>
<p><a href="#_jsonp">_jsonp (var)</a></p>
<p><a href="#_raw">_raw (var)</a></p>
<p><a href="#addLog">addLog (fn)</a></p>
<p><a href="#addToStr">addToStr (fn)</a></p>
<p><a href="#api_async">api_async (fn)</a></p>
<p><a href="#api_batchDel">api_batchDel (fn)</a></p>
<p><a href="#api_batchSet">api_batchSet (fn)</a></p>
<p><a href="#api_checkIp">api_checkIp (fn)</a></p>
<p><a href="#api_dup">api_dup (fn)</a></p>
<p><a href="#api_fw">api_fw (alias)</a></p>
<p><a href="#app_fw">app_fw (module)</a></p>
<p><a href="#arrCopy">arrCopy (fn)</a></p>
<p><a href="#arrFind">arrFind (fn)</a></p>
<p><a href="#arrGrep">arrGrep (fn)</a></p>
<p><a href="#arrMap">arrMap (fn)</a></p>
<p><a href="#arrayCmp">arrayCmp (fn)</a></p>
<p><a href="#autoload">autoload (key)</a></p>
<p><a href="#callAsync">callAsync (fn)</a></p>
<p><a href="#callJdserver">callJdserver (fn)</a></p>
<p><a href="#callSvc">callSvc (fn)</a></p>
<p><a href="#callSvcAsync">callSvcAsync (fn)</a></p>
<p><a href="#callSvcInt">callSvcInt (fn)</a></p>
<p><a href="#checkAuth">checkAuth (fn)</a></p>
<p><a href="#checkObjArrParams">checkObjArrParams (fn)</a></p>
<p><a href="#checkParams">checkParams (fn)</a></p>
<p><a href="#conf.php">conf.php (key)</a></p>
<p><a href="#conf_batchAddMaxErrors">conf_batchAddMaxErrors (var)</a></p>
<p><a href="#conf_bigTables">conf_bigTables (var)</a></p>
<p><a href="#conf_classDir">conf_classDir (key)</a></p>
<p><a href="#conf_dataDir">conf_dataDir (var)</a></p>
<p><a href="#conf_dbinst">conf_dbinst (var)</a></p>
<p><a href="#conf_jdserverBackUrl">conf_jdserverBackUrl (key)</a></p>
<p><a href="#conf_jdserverUrl">conf_jdserverUrl (key)</a></p>
<p><a href="#conf_maxLogFileSize">conf_maxLogFileSize (var)</a></p>
<p><a href="#conf_mssql_translateMysql">conf_mssql_translateMysql (var)</a></p>
<p><a href="#conf_mssql_useOdbc">conf_mssql_useOdbc (var)</a></p>
<p><a href="#conf_poweredBy">conf_poweredBy (key)</a></p>
<p><a href="#conf_returnExecTime">conf_returnExecTime (var)</a></p>
<p><a href="#conf_slowApiTime">conf_slowApiTime (var)</a></p>
<p><a href="#conf_slowHttpCallTime">conf_slowHttpCallTime (var)</a></p>
<p><a href="#conf_slowSqlTime">conf_slowSqlTime (var)</a></p>
<p><a href="#conf_sqlite_translateMysql">conf_sqlite_translateMysql (var)</a></p>
<p><a href="#conf_swoole_env">conf_swoole_env (var)</a></p>
<p><a href="#conf_tableAlias">conf_tableAlias (key)</a></p>
<p><a href="#containsWord">containsWord (fn)</a></p>
<p><a href="#dbCommit">dbCommit (fn)</a></p>
<p><a href="#dbConfirmFn">dbConfirmFn (key)</a></p>
<p><a href="#dbExpr">dbExpr (fn)</a></p>
<p><a href="#dbInsert">dbInsert (fn)</a></p>
<p><a href="#dbUpdate">dbUpdate (fn)</a></p>
<p><a href="#dbconn">dbconn (fn)</a></p>
<p><a href="#delSession">delSession (fn)</a></p>
<p><a href="#delSessionById">delSessionById (fn)</a></p>
<p><a href="#doValidateOnly">doValidateOnly (key)</a></p>
<p><a href="#endWith">endWith (fn)</a></p>
<p><a href="#env->tmpEnv">env->tmpEnv (fn)</a></p>
<p><a href="#env.appName">env.appName (var)</a></p>
<p><a href="#env.appType">env.appType (var)</a></p>
<p><a href="#env.createAC">env.createAC (fn)</a></p>
<p><a href="#env.getAc">env.getAc (fn)</a></p>
<p><a href="#errQuit">errQuit (fn)</a></p>
<p><a href="#evalExpr">evalExpr (fn)</a></p>
<p><a href="#execOne">execOne (fn)</a></p>
<p><a href="#ext">ext (module)</a></p>
<p><a href="#fromMh">fromMh (fn)</a></p>
<p><a href="#genQuery">genQuery (fn)</a></p>
<p><a href="#getBaseUrl">getBaseUrl (fn)</a></p>
<p><a href="#getConf">getConf (fn)</a></p>
<p><a href="#getCred">getCred (fn)</a></p>
<p><a href="#getExt">getExt (fn)</a></p>
<p><a href="#getHttpInput">getHttpInput (fn)</a></p>
<p><a href="#getJDEnv">getJDEnv (fn)</a></p>
<p><a href="#getQueryCond">getQueryCond (fn)</a></p>
<p><a href="#getRealIp">getRealIp (fn)</a></p>
<p><a href="#getReqIp">getReqIp (fn)</a></p>
<p><a href="#getRsAsTable">getRsAsTable (alias)</a></p>
<p><a href="#getSignContent">getSignContent (fn)</a></p>
<p><a href="#getVarsFromExpr">getVarsFromExpr (fn)</a></p>
<p><a href="#handleExportFormat">handleExportFormat (fn)</a></p>
<p><a href="#hasPerm">hasPerm (fn)</a></p>
<p><a href="#hasSignFile">hasSignFile (fn)</a></p>
<p><a href="#hiddenFields">hiddenFields (key)</a></p>
<p><a href="#htmlEscape">htmlEscape (fn)</a></p>
<p><a href="#httpCall">httpCall (fn)</a></p>
<p><a href="#httpCallAsync">httpCallAsync (fn)</a></p>
<p><a href="#inSet">inSet (fn)</a></p>
<p><a href="#injectSession">injectSession (fn)</a></p>
<p><a href="#injectSessionById">injectSessionById (fn)</a></p>
<p><a href="#isArray012">isArray012 (fn)</a></p>
<p><a href="#isArrayAssoc">isArrayAssoc (fn)</a></p>
<p><a href="#isCLI">isCLI (fn)</a></p>
<p><a href="#isCLIServer">isCLIServer (fn)</a></p>
<p><a href="#isEqualCollection">isEqualCollection (fn)</a></p>
<p><a href="#isMockMode">isMockMode (fn)</a></p>
<p><a href="#isSwoole">isSwoole (fn)</a></p>
<p><a href="#issetval">issetval (fn)</a></p>
<p><a href="#jdEncrypt">jdEncrypt (fn)</a></p>
<p><a href="#jdEncryptI">jdEncryptI (fn)</a></p>
<p><a href="#jdPush">jdPush (fn)</a></p>
<p><a href="#jdRet">jdRet (fn)</a></p>
<p><a href="#jsonDecode">jsonDecode (fn)</a></p>
<p><a href="#jsonEncode">jsonEncode (fn)</a></p>
<p><a href="#limitApiCall">limitApiCall (fn)</a></p>
<p><a href="#list2varr">list2varr (fn)</a></p>
<p><a href="#logext">logext (fn)</a></p>
<p><a href="#logit">logit (alias)</a></p>
<p><a href="#logit">logit (fn)</a></p>
<p><a href="#makeTree">makeTree (fn)</a></p>
<p><a href="#makeUrl">makeUrl (fn)</a></p>
<p><a href="#mh">mh (fn)</a></p>
<p><a href="#mparam">mparam (fn)</a></p>
<p><a href="#myexec">myexec (fn)</a></p>
<p><a href="#mypack">mypack (fn)</a></p>
<p><a href="#myround">myround (fn)</a></p>
<p><a href="#myunpack">myunpack (fn)</a></p>
<p><a href="#name2id">name2id (fn)</a></p>
<p><a href="#objarr2table">objarr2table (fn)</a></p>
<p><a href="#onCreateAC">onCreateAC (fn)</a></p>
<p><a href="#onGetPerms">onGetPerms (fn)</a></p>
<p><a href="#param">param (fn)</a></p>
<p><a href="#param_varr">param_varr (fn)</a></p>
<p><a href="#parseKvList">parseKvList (fn)</a></p>
<p><a href="#pivot">pivot (fn)</a></p>
<p><a href="#plugin">plugin (key)</a></p>
<p><a href="#plugin/index.php">plugin/index.php (key)</a></p>
<p><a href="#qsearch">qsearch (key)</a></p>
<p><a href="#qstr">qstr (fn)</a></p>
<p><a href="#queryAll">queryAll (fn)</a></p>
<p><a href="#queryAllWithHeader">queryAllWithHeader (fn)</a></p>
<p><a href="#queryOne">queryOne (fn)</a></p>
<p><a href="#randChr">randChr (fn)</a></p>
<p><a href="#rc4">rc4 (fn)</a></p>
<p><a href="#readBlock">readBlock (fn)</a></p>
<p><a href="#readBlock2">readBlock2 (fn)</a></p>
<p><a href="#redirectOut">redirectOut (fn)</a></p>
<p><a href="#retfn">retfn (var)</a></p>
<p><a href="#setParam">setParam (fn)</a></p>
<p><a href="#slow.log">slow.log (key)</a></p>
<p><a href="#sortBySeq">sortBySeq (fn)</a></p>
<p><a href="#sqlCaseWhen">sqlCaseWhen (fn)</a></p>
<p><a href="#startsWith">startsWith (fn)</a></p>
<p><a href="#table2objarr">table2objarr (fn)</a></p>
<p><a href="#tableCRUD">tableCRUD (fn)</a></p>
<p><a href="#text2html">text2html (fn)</a></p>
<p><a href="#tmCols">tmCols (fn)</a></p>
<p><a href="#tobool">tobool (fn)</a></p>
<p><a href="#tryParseBool">tryParseBool (fn)</a></p>
<p><a href="#uniKey">uniKey (key)</a></p>
<p><a href="#urlEncodeArr">urlEncodeArr (fn)</a></p>
<p><a href="#varr2objarr">varr2objarr (fn)</a></p>
<p><a href="#whiteIpList">whiteIpList (key)</a></p>
<p><a href="#单点登录">单点登录 (key)</a></p>
<p><a href="#第三方认证">第三方认证 (alias)</a></p>
</div><hr>
</div>
<div class="block">
<h2 id="MyException">@class MyException($code, $internalMsg?, $outMsg?)</h2>
<p class="param"><strong>@param $internalMsg</strong>  String. 内部错误信息，前端不应处理。</p>
<p class="param"><strong>@param $outMsg</strong>  String. 错误信息。如果为空，则会自动根据$code填上相应的错误信息。</p>
<p>(v6) 内部使用，外部调用应使用jdRet。</p>
<p>抛出错误，中断执行:</p>
<pre><code>jdRet(E_PARAM, "Bad Request - numeric param `$name`=`$ret`.", "需要数值型参数");
或
throw new MyException(E_PARAM, "Bad Request - numeric param `$name`=`$ret`.", "需要数值型参数");</code></pre>
<p>注意：在API中抛出MyException异常后，将回滚对数据库的操作，即所有之前数据库操作都将失效。<br />
如果不想回滚，可在抛错前手工提交(dbCommit)。</p>
<pre><code>$this-&gt;cancelOrder($id); // 数据库操作
dbCommit();
jdRet(E_FORBIDDEN, "付款码已失效", "fail to pay order $id: overdue");</code></pre>
<p class="see"><strong>@see <a href="#jdRet">jdRet</a></strong> </p></div>
<div class="block">
<h2 id="DirectReturn">@class DirectReturn($data=null, $isUserFmt=false)</h2>
<p>(v6) 内部使用，外部调用应使用jdRet。</p>
<p>中断执行，当作调用成功立即返回。</p>
<pre><code>jdRet();
或
throw new DirectReturn();
// 返回 [0, null]</code></pre>
<p>例：返回指定数据：</p>
<pre><code>jdRet(0, ["id"=&gt;1]);
或
throw new DirectReturn(["id"=&gt;1]);
// 返回[0, {"id":1}]</code></pre>
<p>例：直接返回非标数据（非筋斗云格式）：</p>
<pre><code>$str = '{"id":1}'; // 比如自定义的JSON
// $str = '&lt;id&gt;1&lt;/id&gt;'; // 比如XML
jdRet(null, $str);
或
throw new DirectReturn($str, true);
// 返回 {"id":1}</code></pre>
<p class="see"><strong>@see <a href="#jdRet">jdRet</a></strong> </p></div>
<div class="block">
<h2 id="jdRet">@fn jdRet($code?, $internalMsg?, $msg?)</h2>
<p>直接返回（可用echo/readfile等自行输出返回内容，否则系统不自动输出）：</p>
<pre><code>readfile(f1);
jdRet();</code></pre>
<p>成功返回：</p>
<pre><code>jdRet(0);
// 返回 [0, null]

jdRet(0, ["id" =&gt; 100]);
// 返回 [0, {"id": 100}]

// 直接返回已有的JSON串:
$str = '{"id": 100}';
jdRet(0, dbExpr($str));
// 返回`[0, {"id":100}]`</code></pre>
<p>出错返回：</p>
<pre><code>jdRet(E_PARAM);
jdRet(E_PARAM, "bad param"); // 第2参数是用于调试的错误信息，一般用英文
jdRet(E_PARAM, "bad param", "参数错"); // 第3参数是给用户看的错误信息，一般用中文
// 返回 [1, "参数错", "bad param"] 注意最终输出JSON数组中第2、3参数顺序对调了，以符合筋斗云[code, data, debuginfo...]的格式。</code></pre>
<p>(v6) 自定义返回：(code传null)</p>
<pre><code>jdRet(null, ["code" =&gt; 0, "msg" =&gt; "hello"]);
或
jdRet(null, '{"code": 0, "msg": "hello"}');
// 返回`{"code": 0, "msg": "hello"}`，注意不是标准筋斗云返回格式。</code></pre>
<p>更规范地，对于接口自定义格式输出，应使用 $X_RET_FN 定义转换函数。</p>
<p class="see"><strong>@see <a href="#$X_RET_FN">$X_RET_FN</a></strong> </p></div>
<div class="block">
<h2 id="tobool">@fn tobool($s)</h2></div>
<div class="block">
<h2 id="tryParseBool">@fn tryParseBool($s, &$val)</h2>
<p>字符串转bool，支持&quot;0/1&quot;, &quot;true/false&quot;, &quot;yes/no&quot;, &quot;on/off&quot;.</p></div>
<div class="block">
<h2 id="startsWith">@fn startsWith($s, $pat)</h2></div>
<div class="block">
<h2 id="endWith">@fn endWith($s, $pat)</h2></div>
<div class="block">
<h2 id="isCLI">@fn isCLI() </h2>
<p>command-line interface. e.g. run &quot;php x.php&quot;</p></div>
<div class="block">
<h2 id="isCLIServer">@fn isCLIServer() </h2>
<p>php built-in web server e.g. run &quot;php -S 0.0.0.0:8080&quot;</p></div>
<div class="block">
<h2 id="isSwoole">@fn isSwoole()</h2>
<p class="var"><strong>@var <a id="conf_swoole_env">conf_swoole_env</a></strong>  设置为1表示在swoole服务环境下运行</p>
<p>swoole服务环境下，getJDEnv()将返回各协程中的JDEnv.</p></div>
<div class="block">
<h2 id="isEqualCollection">@fn isEqualCollection($col1, $col2)</h2></div>
<div class="block">
<h2 id="urlEncodeArr">@fn urlEncodeArr($params)</h2>
<p>e.g.</p>
<pre><code>urlEncodeArr(["a"=&gt;1, "b"=&gt;"hello"]) -&gt; a=1&amp;b=hello
urlEncodeArr(["a"=&gt;1, "b"=&gt;null]) -&gt; a=1</code></pre>
<p>NOTE: use http_build_query instead.</p>
<pre><code>$rv = http_build_query(["a"=&gt;1, "b"=&gt;[20,30], "c"=&gt;null, "d"=&gt;"", "e"=&gt;["e1"=&gt;3] ]);
// $rv = "a=1&amp;b%5B0%5D=20&amp;b%5B1%5D=30&amp;d=&amp;e%5Be1%5D=3" 不包含c; 包含d; 

$rv1 = urldecode($rv);
// 解码后为 a=1&amp;b[0]=20&amp;b[1]=30&amp;d=&amp;e[e1]=3

parse_str($rv1, $rv2);
// $rv2是输出，值应与原始的$rv相同</code></pre></div>
<div class="block">
<h2 id="makeUrl">@fn makeUrl($ac, $params, $hash, $wantHost=false)</h2>
<p>生成被调用的URL。示例：</p>
<pre><code>// 生成相对路径，如 /jdcloud/api.php/hello?id=100#test，一般用于调用自身，如callAsync("hello")。
$url = makeUrl("hello", ["id"=&gt;100], "#test");

// 生成绝对路径(指定参数wantHost=true)，如 http://127.0.0.1/jdcloud/api.php/hello?id=100#test，URL可供外部调用。
$url = makeUrl("hello", ["id"=&gt;100], "#test", true);

// $ac也可直接指定绝对路径
$url = makeUrl("http://oliveche.com/jdcloud/api.php", ["p1"=&gt;"abc", "p2"=&gt;"333"])</code></pre></div>
<div class="block">
<h2 id="httpCall">@fn httpCall($url, $postParams =null, $opt={timeout?=5, @headers, %curlOpt={optName=>val}, useJson )</h2>
<p>请求URL，返回内容。<br />
默认使用GET请求，如果给定postParams，则使用POST请求。<br />
postParams可以是一个kv数组或字符串，也可以是一个文件名(以&quot;@&quot;开头，如&quot;@1.jpg&quot;)</p>
<p>如果请求失败，抛出E_SERVER异常。<br />
不检查http返回码。</p>
<p>示例：指定postParams, 默认以application/x-www-form-urlencoded格式提交。</p>
<pre><code>$data = [
    "name" =&gt; "xiaoming",
    "classId" =&gt; 100
];
// 注意headers的格式
$headers = [
    "Authorization: Basic dGVzdDp0ZXN0MTIz",
    "Cookie: extid=" . session_id()
];
$url = makeUrl("$baseUrl/$ac", $param);
$rv = httpCall($url, $data, ["headers" =&gt; $headers]);</code></pre>
<p>上例中在headers中用Authorization指定了登录信息，适合服务器需要登录的场景；<br />
同时主动指定了Cookie（Cookie名称需按服务端要求设置），以便与通过Session保持信息的服务器持续交互。<br />
（有的服务器不使用Cookie，而是在登录后通过返回token来标识，需要额外处理）</p>
<p>示例：调用第三方服务，登录并调用筋斗云后端</p>
<pre><code>function jdcloudCall($ac, $param=null, $postParam=null)
{
    $baseUrl = "http://localhost/jdcloud/api.php";
    $url = makeUrl("$baseUrl/$ac", $param);
    $rv = httpCall($url, $postParam, ["headers" =&gt; [
        // 模拟筋斗云用户端cookie
        "Cookie: userid=" . session_id()
    ]]);
    // 筋斗云协议格式：成功为[0, obj] 或 失败为[errCode, userMessage, internalMessage?]
    $ret = json_decode($rv, true);
    if ( $ret[0] !== 0 ) {
        throw new MyException(E_PARAM, $ret[2], $ret[1]);
    }
    return $ret[1];
}
// 如果是首次则登录
jdcloudCall("login", ["uname"=&gt;"12345678901", "pwd"=&gt;"1234"]);
// 保持会话，获取订单列表
$orders = jdcloudCall("Ordr.query");</code></pre>
<p>示例：提交application/json格式的内容</p>
<p>(v6.1) 如果POST内容指定为对象，应指定选项useJson=1，否则默认会使用urlencoded格式：</p>
<pre><code>$data = [
    "name" =&gt; "xiaoming",
    "classId" =&gt; 100
];
$rv = httpCall($url, $data, ["useJson"=&gt;1]);
// 筋斗云：设置全局变量X_RET_STR可直接设置返回内容，避免再次被json编码。</code></pre>
<p>或直接先转成JSON再提交，这时要么使用<code>useJson:1</code>，要么在headers中指定Content-Type：</p>
<pre><code>$data = json_encode([
    "name" =&gt; "xiaoming",
    "classId" =&gt; 100
]);
$headers = [
    "Content-type: application/json",
    "Authorization: Basic dGVzdDp0ZXN0MTIz"
];
$rv = httpCall($url, $data, ["headers" =&gt; $headers]);</code></pre>
<p>函数通过CURL实现，若需扩展功能，可以直接设置curlOpt选项（具体选项可查阅curl_setopt文档），如：</p>
<pre><code>$curlOpt = [
    // 设置代理
    CURLOPT_PROXY =&gt; '8.8.8.8',
    CURLOPT_PROXYPORT =&gt; 8080,

    // 通过UserAgent伪装其它浏览器
    CURLOPT_USERAGENT =&gt; 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36',

    // 返回结果包含HTTP HEADER部分。TODO: 提供简单的解析，如HTTP返回码、Response HTTP Header等。
    CURLOPT_HEADER =&gt; true
];
$rv = httpCall($url, $data, ["curlOpt" =&gt; $curlOpt]);</code></pre>
<p>如果CURL返回错误，可在此查阅错误码：<br />
<a href="http://curl.haxx.se/libcurl/c/libcurl-errors.html">http://curl.haxx.se/libcurl/c/libcurl-errors.html</a></p>
<p>出错记到trace日志，慢调用会记录到slow日志中(可配置慢调用时间阀值，默认1秒：conf_slowHttpCallTime=1.0)</p>
<p>e.g.</p>
<pre><code>$url = makeUrl("http://oliveche.com/echo.php", ["a"=&gt;1, "b"=&gt;@$GLOBALS["b"]]);
echo(httpCall($url, ["c"=&gt;1, "d"=&gt;0] ));</code></pre>
<p class="see"><strong>@see <a href="#makeUrl">makeUrl</a></strong> </p>
<p>如果是HTTP Basic认证，除了前述直接指定头&quot;Authorization: Basic {base64(user:pwd)}&quot;外，也可以：</p>
<pre><code>$rv = httpCall($url, $data, [
    "curlOpt" =&gt; [CURLOPT_USERPWD =&gt; "demo:demo123"]
]);</code></pre>
<p>或是在url中直接包含，如: </p>
<pre><code>$rv = httpCall("demo:demo123@" . $url, $data);</code></pre>
<p>使用PUT操作示例，同时指定用户密码：<br />
取HTTP返回码，可在$opt中加&quot;httpCode&quot;字段，将会回写这个字段中：</p>
<pre><code>$out = [];
$rv = httpCall($f, getHttpInput(), [
    "curlOpt" =&gt; [CURLOPT_CUSTOMREQUEST =&gt; "PUT", CURLOPT_USERPWD =&gt; "yibo:yibo123"],
    "httpCode" =&gt; null
], $out);
if ($out["httpCode"] != 204)
    jdRet(E_SERVER, "fail to put file: $rv", "保存文件失败");</code></pre></div>
<div class="block">
<h2 id="parseKvList">@fn parseKvList($kvListStr, $sep, $sep2)</h2>
<p>解析key-value列表字符串。如果出错抛出异常。<br />
示例：</p>
<pre><code>$map = parseKvList("CR:新创建;PA:已付款", ";", ":");
// map: {"CR": "新创建", "PA":"已付款"}</code></pre></div>
<div class="block">
<h2 id="arrayCmp">@fn arrayCmp($arr1, $arr2, $fnEq, $callback)</h2>
<p>比较两个数组的差异，常用于数据同步。<br />
两个数组中的数据应一一对应。<br />
比较的结果会回调 <code>$callback($e1, $e2)</code>，如果数据在两边都有，则e1, e2均非空，否则其中一个为空。</p>
<p>下面是一个示例，metaFields是设计字段列表，dbFields是实际数据库中的字段列表，现在要对比差异，</p>
<ul>
<li>如果字段在设计和实际表中都有，不做处理（或更新字段）</li>
<li>如果字段在设计中有，在实际表中没有，则添加字段</li>
<li>如果字段在设计中没有，而在实际表中有，则删除字段</li>
</ul>
<p>数据示例如下：</p>
<pre><code>$metaFields = [
    ["name"=&gt;"id", "type"=&gt;"int"],
    ["name"=&gt;"amount", "type"=&gt;"decimal"],
    ["name"=&gt;"dscr", "type"=&gt;"nvarchar"]
];
$dbFields = [
    ["Field"=&gt;"id", "Type"=&gt;"int(11)"],
    ["Field"=&gt;"total", "Type"=&gt;"decimal(19,2)"],
    ["Field"=&gt;"dscr", "Type"=&gt;"varchar(255)"]
];</code></pre>
<p>两边字段名相同可通过 <code>$meta["name"] === $dbField["Field"];</code>来判断。</p>
<pre><code>arrayCmp($metaFields, $dbFields, function ($meta, $dbField) {
    // 定义两边对应关系
    return $meta["name"] === $dbField["Field"];
}, function ($meta, $dbField) { // meta: {type, len, ...} 参考 FIELD_META_TYPE
    if ($meta === null) { // 在meta中没有，在dbField中有，则删除字段
        echo "DROP " . $dbField["Field"] . "\n";
    }
    else if ($dbField === null) { // 在meta中有，在dbField中没有，则添加字段
        echo "ADD " . $meta["name"] . "\n";
    }
    else {
        // 字段在两边都有
    }
});</code></pre></div>
<div class="block">
<h2 id="addToStr">@fn addToStr(&$str, $str1, $sep=',')</h2>
<p>添加字符串到str. str开始必须为null。</p>
<pre><code>$atts = null;
addToStr($atts, "100");
addToStr($atts, "200");
// $atts = "100,200"</code></pre></div>
<div class="block">
<h2 id="arrCopy">@fn arrCopy(&$dst, $arr, $fields=null)</h2>
<p>将关联数组$arr中指定字段复制（覆盖）到$dst中。如果$arr是普通数组(键为数值)，则简单地追加到$dst中。<br />
数组$fields指定字段列表，如果未指定，则全部字段复制过去；如果字段复制后需要改名，可以以[$dstName, $srcName]这样的数组来表示。</p>
<p>示例：将workItem提取指定字段后插入数据库中：</p>
<pre><code>$workItem = ["repairWiId"=&gt;$id, "wiName"=&gt;$name, ...];
$wiData = ["orderId" =&gt; $orderId];
arrCopy($wiData, $workItem, [
    ["code", "repairWiId"], // 复制后改名，即 $wiData["code"] = $workItem["repairWiId"]
    "name",
    "saleWorkQty",
    ["addFlag", "isAdd"]
]);
dbInsert("WorkItem", $wiData);</code></pre>
<p>示例：</p>
<pre><code>arrCopy($wiData, $workItem); // 复制全部字段过去</code></pre>
<p>如果不想覆盖已有字段(即使值为null也不覆盖)，可以用：</p>
<pre><code>$wiData += $workItem;</code></pre></div>
<div class="block">
<h2 id="arrFind">@fn arrFind($arr, $fn)</h2>
<p>示例：</p>
<pre><code>$personArr = [ ["id"=&gt;1, "name"=&gt;"name1"], ["id"=&gt;2, "name"=&gt;"name2"] ];
$person = arrFind($personArr, function ($e) {
    return $e["id"] === 1;
});
if ($person === false) {
    // 未找到
}</code></pre>
<p>支持检查和返回数组index(也支持非数字key)，如：</p>
<pre><code>$person = arrFind($personArr, function ($e, $idx) {
    return $idx != 0 &amp;&amp; $e["id"] &gt;= 1;
}, $idx);
// $idx=1, $person=["id"=&gt;2, "name"=&gt;"name2"]
if ($person === false) {
    // 未找到
}</code></pre>
<p>注意：无法通过返回的元素(person)修改原数组元素；<br />
如果要修改数组中元素须使用返回的$idx: <code>$personArr[$idx]['name'] = 'new name'</code></p></div>
<div class="block">
<h2 id="arrMap">@fn arrMap($arr, $fn, $doFilter=false)</h2>
<p>示例：</p>
<pre><code>$personArr = [ ["id"=&gt;1, "name"=&gt;"name1"], ["id"=&gt;2, "name"=&gt;"name2"] ];
$personIdList = arrMap($arr, function ($e) {
    return $e["id"];
});
// [1, 2]</code></pre>
<p>如果doFilter为true，则return null或直接return时，该元素被过滤掉。</p></div>
<div class="block">
<h2 id="arrGrep">@fn arrGrep($arr, $fn, $mapFn=null)</h2>
<p>示例：</p>
<pre><code>$personArr = [ ["id"=&gt;1, "name"=&gt;"name1"], ["id"=&gt;2, "name"=&gt;"name2"] ];
$personArr1 = arrGrep($arr, function ($e) {
    return $e["id"] &gt; 1;
}); // [ ["id"=&gt;2, "name"=&gt;"name2"] ]

$personNameArr1 = arrGrep($arr, function ($e) {
    return $e["id"] &gt; 1;
}, function ($e) {
    return $e["name"];
}); // [ "name2" ]</code></pre></div>
<div class="block">
<h2 id="getReqIp">@fn getReqIp</h2>
<p>请求的IP。与<code>$_SERVER['REMOTE_ADDR']</code>不同的是，如果有代理，则返回所有IP列表。</p></div>
<div class="block">
<h2 id="getRealIp">@fn getRealIp()</h2>
<p>取实际IP地址，支持透过代理服务器。</p></div>
<div class="block">
<h2 id="logit">@fn logit($s, $addHeader=true, $type="trace")</h2>
<p class="alias"><strong>@alias <a id="logit">logit</a></strong> ($s, $type)</p>
<p>记录日志。</p>
<p>默认到日志文件 $conf_dataDir/trace.log. 如果指定type如type=secure, 则写到 $conf_dataDir/secure.log.</p>
<p>$s可以是字符串、数值或数组。</p>
<p>可通过在线日志工具 tool/log.php 来查看日志。也可直接打开日志文件查看。</p></div>
<div class="block">
<h2 id="jsonEncode">@fn jsonEncode($data, $doPretty=false)</h2>
<pre><code>$str = jsonEncode($data);
$data = jsonDecode($str);</code></pre></div>
<div class="block">
<h2 id="jsonDecode">@fn jsonDecode($str)</h2>
<p>等价于<code>json_decoe($str, true)</code>. 返回数组（而非对象）。</p></div>
<div class="block">
<h2 id="getSignContent">@fn getSignContent($params, $paramFilter?)</h2>
<p>取URL签名内容。一般都是将参数先排序，然后拼成<code>k1=v1&amp;k2=v2</code>这种形式。<br />
之后用md5, sha1, rsa等算法签名。</p>
<p>默认&quot;_&quot;开头的参数以及&quot;sign&quot;参数不参与签名，规则可定制，示例：&quot;sign&quot;与&quot;sign_type&quot;参数不参与验签：</p>
<pre><code>$s = getSignContent($_POST, function ($k) {
    if ($k == "sign" || $k == "sign_type")
        return false;
});</code></pre></div>
<div class="block">
<h2 id="inSet">@fn inSet($str, $strList)</h2>
<p>e.g.<br />
$rv = inSet(&quot;管理员&quot;, &quot;财务,销售,管理员&quot;); // true<br />
$rv = inSet(&quot;管理员&quot;, &quot;财务,销售,仓库管理员&quot;); // false<br />
$rv = inSet(&quot;管理员&quot;, [&quot;财务&quot;,&quot;销售&quot;,&quot;管理员&quot;]); // true</p>
<p>str可以是中英文字符，不可以带空格或符号。<br />
strList可以是数组或字符串。如果为字符串，则多个词以分隔符相隔，分隔符可以是各种符号或空格，支持中文符号或空格（必须utf-8编码）。常用英文逗号，与MySQL的find_in_set函数类似。</p></div>
<div class="block">
<h2 id="text2html">@fn text2html($s)</h2>
<p>简单的文本转html处理。支持标题、段落、列表。示例：</p>
<pre><code># 标题1
这是段落1
## 标题2
这是段落2
- 列表1
- 列表2</code></pre>
<p>示例：商品详情可在管理端编辑多行文本，在客户端显示html内容：<br />
数据库定义：</p>
<pre><code>@Item: id, ... content</code></pre>
<p>客户端访问接口Item.query/Item.get时，content返回html内容：</p>
<pre><code>class AC_Item extends AC0_Item
{
    protected function onQuery() {
        parent::onQuery();
        $this-&gt;enumFields["content"] = function ($val) {
            return text2html($val);
        };
    }
}</code></pre></div>
<div class="block">
<h2 id="pivot">@fn pivot($objArr, $gcols, $ycolCnt=1, $pivotSumField=null, $gres=null)</h2>
<p>将行转置到列。一般用于统计分析数据处理。</p>
<ul>
<li>$gcols为转置字段，可以是一个或多个字段。可以是个字符串(&quot;f1&quot; 或 &quot;f1,f2&quot;)，也可以是个数组（如[&quot;f1&quot;,&quot;f2&quot;]）</li>
<li>$objArr是对象数组，默认最后一列是统计列，如果想要最后两列作为统计列，可以指定参数ycolCnt=2。注意此时最终统计值将是一个数组。</li>
<li>以objArr[0]这个对象为基准，除去最后ycolCnt个字段做为统计列(ycols)，再除去gcols指定的要转置到列的字段，剩下的列就是xcols：相同的xcols会归并到一行中。</li>
</ul>
<p>objArr的列中包括三类：</p>
<pre><code>分组列(含转置列) 普通列 统计列</code></pre>
<ul>
<li>统计列必须在最后面，由ycolCnt指定有几列，必须为数值列</li>
<li>gres指定分组列（多个列以逗号分隔），gcols指定转置列，gres应包含gcols。如果未指定gres，则表示除了统计列都是分组列（即没有普通列）</li>
</ul>
<p>示例：</p>
<pre><code>$arr = [
    ["y"=&gt;2019, "m"=&gt;11, "cateId"=&gt;1, "cateName"=&gt;"衣服", "sum" =&gt; 20000],
    ["y"=&gt;2019, "m"=&gt;11, "cateId"=&gt;2, "cateName"=&gt;"食品", "sum" =&gt; 12000],
    ["y"=&gt;2019, "m"=&gt;12, "cateId"=&gt;2, "cateName"=&gt;"食品", "sum" =&gt; 15000],
    ["y"=&gt;2020, "m"=&gt;2, "cateId"=&gt;1, "cateName"=&gt;"衣服", "sum" =&gt; 19000],
    ["y"=&gt;2020, "m"=&gt;2, "cateId"=&gt;3, "cateName"=&gt;"电器", "sum" =&gt; 28000]
];

// 将类别转到列
$arr1 = pivot($arr, "cateId,cateName");</code></pre>
<p>得到：</p>
<pre><code>$arr1 = [
    ["y"=&gt;2019, "m"=&gt;11, "1-衣服"=&gt;20000, "2-食品"=&gt;12000, "3-电器" =&gt; null],
    ["y"=&gt;2019, "m"=&gt;12, "2-食品"=&gt;15000],
    ["y"=&gt;2020, "m"=&gt;2, "1-衣服"=&gt;19000, "3-电器"=&gt;28000]
];</code></pre>
<p>注意：结果的第一行中，会包含所有可能出现的列，没有值的列填null。</p>
<p>如果需要行列统计，可指定pivotSumField=&quot;合计&quot;，这样就会添加一列叫&quot;合计&quot;，且添加一行统计行</p>
<pre><code>$arr1 = pivot($arr, "cateId,cateName", 1, "合计");</code></pre>
<p>结果为:</p>
<pre><code>$arr1 = [
    ["y"=&gt;2019, "m"=&gt;11, "1-衣服"=&gt;20000, "2-食品"=&gt;12000, "3-电器"=&gt;null, "合计"=&gt;32000],
    ["y"=&gt;2019, "m"=&gt;12, "2-食品"=&gt;15000, "合计"=&gt;15000],
    ["y"=&gt;2020, "m"=&gt;2, "1-衣服"=&gt;19000, "3-电器"=&gt;28000, "合计"=&gt;47000],
    ["1-衣服"=&gt;39000, "2-食品"=&gt;27000, "3-电器"=&gt;28000, "合计"=&gt;94000]
];</code></pre>
<p>特别地，如果只有1行，则不添加统计行，如果只有1列数据列，不添加统计列。</p>
<p>在后端查询时, 往往用id字段分组但显示为名字, 可以用hiddenFields参数指定不要返回的字段:<br />
例如上例中cateId若只需要参与查询, 不需要返回在最终结果中：</p>
<pre><code>callSvr("Ordr.query", {gres: "y,m,cateId", res: "cateName,SUM(amount) sum", pivot: "cateName", hiddenFields:"cateId"})</code></pre>
<p>结果为：</p>
<pre><code>$arr1 = [
    ["y"=&gt;2019, "m"=&gt;11, "衣服"=&gt;20000, "食品"=&gt;12000, "电器"=&gt;null],
    ["y"=&gt;2019, "m"=&gt;12, "食品"=&gt;15000],
    ["y"=&gt;2020, "m"=&gt;2, "衣服"=&gt;19000, "电器"=&gt;28000]
];</code></pre>
<p>其它示例: 显示用户单数统计表</p>
<pre><code>var url = WUI.makeUrl("Ordr.query", {gres:"userId", res:"userName 客户, COUNT(*) 订单数, SUM(amount) 总金额", hiddenFields:"userId", pivot:'订单数'});
WUI.showPage("pageSimple", "用户单数统计!", [url]);</code></pre>
<p>示例：多个统计列（ycolCnt&gt;1）的情况</p>
<pre><code>$arr = [
    ["y"=&gt;2019, "m"=&gt;11, "cateName"=&gt;"衣服", "sum" =&gt; 20000, "cnt" =&gt; 100],
    ["y"=&gt;2019, "m"=&gt;11, "cateName"=&gt;"衣服", "sum" =&gt; 12000, "cnt" =&gt; 150], // 故意与第一行重复，这时将与第一行最后两列分别累加
    ["y"=&gt;2019, "m"=&gt;12, "cateName"=&gt;"食品", "sum" =&gt; 15000, "cnt" =&gt; 80],
    ["y"=&gt;2020, "m"=&gt;2, "cateName"=&gt;"衣服", "sum" =&gt; 19000, "cnt" =&gt; 90],
    ["y"=&gt;2020, "m"=&gt;2, "cateName"=&gt;"电器", "sum" =&gt; 28000, "cnt" =&gt; 30]
];

// 将类别转到列, 最后两列为统计列
$arr1 = pivot($arr, "cateName", 2);</code></pre>
<p>得到：</p>
<pre><code>$arr1 = [
    ["y"=&gt;2019, "m"=&gt;11, "衣服"=&gt;[32000, 250], "食品"=&gt;null, "电器" =&gt; null],
    ["y"=&gt;2019, "m"=&gt;12, "食品"=&gt;[15000, 80] ],
    ["y"=&gt;2020, "m"=&gt;2, "衣服"=&gt;[19000,90], "电器"=&gt;[28000, 30] ]
];</code></pre></div>
<div class="block">
<h2 id="myround">@fn myround($val, $n=0)</h2>
<p>如果$val是数值，按指定小数位数进行四舍五入，返回数值。<br />
如果$val是个数组，则对数组中每项分别处理后返回新数组。<br />
否则原样返回。</p>
<p>注意：php的round返回的浮点数不精确。比如0.53会返回0.53000000000000003<br />
而number_format函数尾部可能会有多余的0, 且是字符串</p></div>
<div class="block">
<h2 id="mh">@fn mh($val)</h2>
<p>显示工时。以&quot;30s&quot;（秒）, &quot;5m&quot;（分）, &quot;1.2h&quot;（小时）, &quot;3d&quot;（天）这种样式显示。</p></div>
<div class="block">
<h2 id="fromMh">@fn fromMh($val)</h2>
<p>将工时字符串转为小时。示例：</p>
<ul>
<li>&quot;30s&quot;（秒） =&gt; 30/3600.0</li>
<li>&quot;5m&quot;（分）=&gt; 5/60.0</li>
<li>&quot;1.2h&quot;（小时）=&gt; 1.2</li>
<li>&quot;3d&quot;（天）=&gt; 3*24.0</li>
</ul></div>
<div class="block">
<h2 id="isArray012">@fn isArray012($var)</h2>
<p>判断是否为数值键的数组</p></div>
<div class="block">
<h2 id="isArrayAssoc">@fn isArrayAssoc($var)</h2>
<p>判断是否为关联数组</p></div>
<div class="block">
<h2 id="makeTree">@fn makeTree($arr, $idField="id", $fatherIdField="fatherId", $childrenField="children"</h2>
<p>将array转成tree.</p>
<pre><code>$ret = makeTree([
    ["id"=&gt;1],
    ["id"=&gt;2, "fatherId"=&gt;1],
    ["id"=&gt;3, "fatherId"=&gt;2],
    ["id"=&gt;4, "fatherId"=&gt;1]
]);</code></pre>
<p>结果：</p>
<pre><code>$ret = [
    ["id"=&gt;1, "children"=&gt; [
        ["id"=&gt;2, "fatherId"=&gt;1, "children"=&gt; [
            ["id"=&gt;3, "fatherId"=&gt;2],
        ],
        ["id"=&gt;4, "fatherId"=&gt;1]
    ]
]</code></pre></div>
<div class="block">
<h2 id="readBlock">@fn readBlock($getLine, $makeBlock, $isNewBlock, $handleBlock, $opt)</h2><div class="toc"><p style="margin-left:0em"><a href="#readBlock-1 参考原型程序">1 参考原型程序</a></p>
<p style="margin-left:0em"><a href="#readBlock-2 协程(php5.5后支持)">2 协程(php5.5后支持)</a></p>
</div>
<p>readBlock编程模式</p>
<p>原型问题：读一个文件，其中以&quot;#&quot;开头的行(curLine)表示一个块(block)开始，这个块一直到下一个块开始处才结束。如：</p>
<pre><code># block1
paragraph 1
paragraph 2
# block 2
paragraph 3
# block 3</code></pre>
<p>提供以下回调函数，将解析出每个块，并最终交给handleBlock回调处理：</p>
<pre><code>$block = null;
$curLine = getLine() // 读一行，返回null或false表示结束
makeBlock(&amp;$block, $curLine) // 读一行时，添加到block
isNewBlock($curLine); // 判断一个新的block开始
handleBlock($block) // 处理block，返回false表示立即结束循环</code></pre>
<ul>
<li>opt: {skipStart=false} 可设置忽略开头行</li>
</ul>
<p>使用模型后示例如下：</p>
<pre><code>$fp = fopen("1.txt","r");
readBlock(function () use ($fp) { // getLine
    return fgets($fp);
}, function (&amp;$block, $curLine) { // makeBlock
    $block .= $curLine;
}, function ($curLine) { // isNewBlock
    return $curLine[0] == "#";
}, function ($block) { // handleBlock
    echo("&gt;&gt;&gt;$block&lt;&lt;&lt;\n");
});
fclose($fp);</code></pre>
<p>假如以数组方式处理，示例如下（注意除了getLine不同，其余部分相同）：</p>
<pre><code>$arr = file("1.txt");
$i = 0;
readBlock(function () use ($arr, &amp;$i) { // getLine
    if ($i == count($arr))
        return false;
    return $arr[$i++];
}, function (&amp;$block, $curLine) { // makeBlock
    $block .= $curLine;
}, function ($curLine) { // isNewBlock
    return $curLine[0] == "#";
}, function ($block) { // handleBlock
    echo("$block\n");
});</code></pre>
<h4 id="readBlock-1 参考原型程序">1 参考原型程序</h4>
<pre><code>$fp = fopen("1.txt","r");
$block = null;
while (true) {
    $curLine = fgets($fp);
    if ($curLine === false || ($block != null &amp;&amp; $curLine[0] == "#")) {
        handleBlock($block);
        if ($curLine === false)
            break;
        $block = $curLine;
        continue;
    }
    $block .= $curLine;
}
fclose($fp);</code></pre>
<h4 id="readBlock-2 协程(php5.5后支持)">2 协程(php5.5后支持)</h4>
<p>将<code>$handleBlock($block)</code>调用改为<code>yield $block</code>可提供协程式编程风格，可把循环控制交给主程序，调用示例：</p>
<pre><code>$fp = fopen("1.txt","r");
$g = readBlockG(...);
while($g-&gt;valid()) {
    $block = $g-&gt;current();
    handleBlock($block);
    $g-&gt;next();
}
fclose($fp);</code></pre></div>
<div class="block">
<h2 id="readBlock2">@fn readBlock2($getLine, $makeBlock, $isBlockStart, $isBlockEnd, $handleBlock, $opt=[])</h2>
<p>readBlock2编程模式</p>
<p>原型问题：读一个文件，其中以&quot;#&quot;开头的行(curLine)表示一个块(block)开始，以&quot;.&quot;开头的行表示一个块结束，如：</p>
<pre><code># block1
paragraph 1
paragraph 2
.
others -- out of block
# block 2
paragraph 3
.
other2 -- out of block
# block 3</code></pre>
<p>提供以下回调函数，将解析出每个块，并最终交给handleBlock回调处理：</p>
<pre><code>$block = null;
$curLine = getLine() // 读一行，返回null或false表示结束
makeBlock(&amp;$block, $curLine) // 读一行时，添加到block
isBlockStart($curLine); // 判断一个block开始
isBlockEnd($curLine); // 判断一个block结束
handleBlock($block) // 处理block</code></pre>
<ul>
<li>opt: {skipStart=false, skipEnd=true} 可设置忽略开头行，以及包含结束行</li>
</ul>
<p>使用模型后的代码：</p>
<pre><code>$fp = fopen("1.txt","r");
readBlock2(function () use ($fp) { // getLine
    return fgets($fp);
}, function (&amp;$block, $curLine) { // makeBlock
    $block .= $curLine;
}, function ($curLine) { // isBlockStart
    return $curLine[0] == "#";
}, function ($curLine) { // isBlockEnd
    return $curLine[0] == ".";
}, function ($block) { // handleBlock
    echo("&gt;&gt;&gt;$block&lt;&lt;&lt;\n");
});
fclose($fp);</code></pre>
<p>设置选项示例：</p>
<pre><code>readBlock2(...
, ["skipStart"=&gt;true]);</code></pre>
<p>原型代码：</p>
<pre><code>$fp = fopen("1.txt","r");
$block = null;
$blockFlag = false;
while (true) {
    $curLine = fgets($fp);
    if ($curLine === false)
        break;
    if (! $blockFlag) {
        if ($curLine[0] == "#")
            $blockFlag = true;
    }
    else if ($curLine[0] == '.') {
        $blockFlag = false;
        handleBlock($block);
        $block = null;
        continue;
    }
    if ($blockFlag)
        $block .= $curLine;
}
fclose($fp);

function handleBlock($s)
{
    echo("&gt;&gt;&gt;$s&lt;&lt;&lt;\n");
}</code></pre></div>
<div class="block">
<h2 id="containsWord">@fn containsWord($str, $word)</h2>
<p>检查是否包含一个词，与stripos等函数不同，它会检查词边界，如：</p>
<pre><code>$rv = containsWord("hello, world", "hello"); // true
$rv = containsWord("hello, world", "llo"); // false</code></pre></div>
<div class="block">
<h2 id="qstr">@fn qstr($s, $q="'")</h2>
<p>将字符串变成引用串，默认用双引号，如：</p>
<pre><code>$str1 = qstr($str);</code></pre>
<p>效果：</p>
<pre><code>hello =&gt; "hello"
"i'm ok", he said. =&gt; "\"i'm ok'\", he said."</code></pre>
<p>也可用单引号：</p>
<pre><code>$str1 = qstr($str, "'"); </code></pre>
<p>效果：</p>
<pre><code>hello =&gt; 'hello'
i'm ok =&gt; 'i\'m ok'</code></pre></div>
<div class="block">
<h2 id="myexec">@fn myexec($cmd, $errMsg = "操作失败", &$out = null)</h2>
<p>执行Shell命令。如果出错则jdRet并记录日志。</p>
<p>由于php exec函数限制，为了能够输出错误信息，一般建议加错误重定向，让出错信息显示在日志或接口返回中，如：</p>
<pre><code>myexec("magick 1.jpg -resize '1200x1200&gt;' 2.jpg 2&gt;&amp;1");
myexec("magick 1.jpg -resize '1200x1200&gt;' 2.jpg 2&gt;&amp;1", "图片处理失败"); // 可定制出错消息
myexec("php create_file.php 2&gt;&amp;1 &gt;file1"); // 注意如果'2&gt;&amp;1'放在最后，则错误会输出到file1中。</code></pre>
<p>注意：为保证兼容性，在Windows下会使用sh命令, 自动在命令中加&quot;sh -c&quot;。</p>
<p>$out参数可输出返回结果，注意是数组，一个元素表示一行。</p>
<ul>
<li>
<p>在Windows环境下，sh是安装git-bash后自带的（路径示例：C:\Program Files\Git\usr\bin）<br />
如果使用Apache系统服务的方式（默认是SYSTEM用户执行），应确保上述命令行在系统PATH（而不只是当前用户的PATH）中。</p>
</li>
<li>
<p>Win10环境中Apache+php调用shell可能会卡死，应修改git-bash下的文件：/etc/nsswitch.conf （路径示例：C:\Program Files\Git\etc\nsswitch.conf）</p>
<pre><code>db_home: env 
#db_home: env windows cygwin desc</code></pre>
</li>
<li>Win11环境中在Win10修改的基础上，在windwows的服务里，打开Apache服务，选择[登录]标签页，勾选上[本地系统账户]和[允许服务与桌面交互], 选好后重启apache服务, 注意是在[服务]里重启apache服务，不是在apache里重启</li>
</ul></div>
<div class="block">
<h2 id="redirectOut">@fn redirectOut($fn)</h2>
<p>将$fn函数执行中的输出重定向，返回通过echo等方式输出的字符串。示例：</p>
<pre><code>$str1 = redirectOut(function () {
    echo("redirect 1");
});
// $str1="redirect 1"</code></pre>
<p>支持嵌套，示例：</p>
<pre><code>$str1 = redirectOut(function () {
    echo("redirect 1");
    global $str2;
    $str2 = redirectOut(function () {
        echo("redirect 2");
    });
});
echo($str1 . ',' . $str2);</code></pre></div>
<div class="block">
<h2 id="mypack">@fn mypack($data, $format=null)</h2>
<p>结构体封包。解包使用myunpack.</p>
<p>数据格式代码参考: <a href="https://www.php.net/manual/en/function.pack.php">https://www.php.net/manual/en/function.pack.php</a><br />
常用格式：</p>
<pre><code>C - 8位整数
n - 16位整数(网络序)
N - 32位整数(网络序)
a{数字} - 定长字符串(长度不足补0)
f - float
d - double</code></pre>
<p>示例：</p>
<pre><code>$format = [
    "a4", "type", // 定长字符串（不足补0）
    "N", "deviceId", // 设备id,
    "C", "y", // 年
    "C", "m", // 月
    "C", "d", // 日
    "C", "h", // 时
    "C", "n", // 分
    "C", "s", // 秒
];
$tm = localtime(strtotime("2022-4-1 09:10:11"), true);
$data = [
    "deviceId" =&gt; 20501, // 设备id,
    "type" =&gt; "WM",
    "y" =&gt; $tm["tm_year"]-100, // 年
    "m" =&gt; $tm["tm_mon"]+1, // 月
    "d" =&gt; $tm["tm_mday"], // 日
    "h" =&gt; $tm["tm_hour"], // 时
    "n" =&gt; $tm["tm_min"], // 分
    "s" =&gt; $tm["tm_sec"], // 秒
];
$packData = mypack($data, $format);
print("enc=" . bin2hex($packData) . ", len=" . strlen($packData). "\n");

$data1 = myunpack($packData, $format);
var_dump($data1);</code></pre>
<p>也可以不用format，直接封包：</p>
<pre><code>$packData = mypack([
    'C', 0x10,
    'C', 0x02,
    "n", $item['dbNumber'],
    'N', (0x84000000 | ($item['startAddr'] * 8))
]);</code></pre>
<p>TODO: 支持结构体、数组等：</p>
<pre><code>$format_st = [
    "N", "a"
    "a4", "b"
];
$format = [
    ["f", 4], "arr", // 定长数组, 不足补0
    ["f", "*"], "arr1", // 不定长数组(内置长度)
    $format_st, "st", // 结构体
    [$format_st, 4], "stList" // 结构体定长数组
    [$format_st, "*"], "stList2" // 结构体不定长数组(内置长度)
];
$data = [
    "arr" =&gt; [1.1, 2.2],
    "arr1" =&gt; [3.3, 4.4, 5.5],
    "st" =&gt; [ "a" =&gt; 100, "b" =&gt; "BB" ],
    "stList" =&gt; [
        [ "a" =&gt; 101, "b" =&gt; "b1"],
        [ "a" =&gt; 102, "b" =&gt; "b2"]
    ],
    "stList2" =&gt; [
        [ "a" =&gt; 101, "b" =&gt; "b1"],
        [ "a" =&gt; 102, "b" =&gt; "b2"]
    ]
];</code></pre></div>
<div class="block">
<h2 id="myunpack">@fn myunpack($packData, $format)</h2>
<p>结构体解包。</p>
<p class="see"><strong>@see <a href="#mypack">mypack</a></strong> </p></div>
<div class="block">
<h2 id="randChr">@fn randChr($cnt, $type='c')</h2>
<p>生成指定长度的随机字符串。</p>
<pre><code>$rv = randChr(10); // 10个字符, [0-9A-Z]
$rv = randChr(10, 'x'); // 同上但去除易混淆的01和OI
$rv = randChr(10, 'd'); // 10个纯数字, [0-9]
$rv = randChr(10, 'w'); // 10个纯字母, [A-Z]</code></pre></div>
<div class="block">
<h2 id="evalExpr">@fn evalExpr($expr, $arr)</h2>
<p>表达式计算引擎/规则引擎。<br />
变量必须出现在关联数组$arr中，表达式类似SQL，支持有限的几个函数但允许扩展，其它语法参考PHP（比如三目运算）。</p>
<p>调用示例：</p>
<pre><code>$rv = evalExpr("a&gt;10 and b='AA'", ["a"=&gt;98, "b"=&gt;"AA"]);
var_dump($rv); // 如果有运行错将抛出；如果有语法错，php7以上可捕获并抛出，php5直接中止，可查看trace日志或PHP日志。</code></pre>
<p>表达式示例：基本比较运算和逻辑运算，支持括号嵌套，支持null常量：</p>
<pre><code>a&gt;1 and b='aa' and (c&lt;=0 or c&gt;=100) or (d=null or e!=null)</code></pre>
<ul>
<li>and/or/not可分别写作<code>&amp;&amp; || !</code>, 注意全部小写</li>
<li><code>=</code>与<code>==</code>相同。</li>
<li>单引号与双引号含义相同</li>
<li>不允许出现'$'（PHP变量）或';'（多语句）</li>
</ul>
<p>示例：支持in/not in集合运算：</p>
<pre><code>a in (3,4) or b not in ('CR', 'PA')</code></pre>
<p>示例：三目运算</p>
<pre><code>a&gt;1? b: c</code></pre>
<p>内置函数：</p>
<ul>
<li>fnmatch(pattern, str), 用于模糊匹配，示例：<code>fnmatch("a*", b)</code>; <code>fnmatch('8*', 888)</code>值为true</li>
</ul>
<p>扩展函数：若调用了非内置函数如<code>f1()</code>或<code>f2(a, b)</code>，则会查询并调用函数<code>evalExpr_f1()</code>或<code>evalExpr_f2($a, $b)</code>。<br />
显然若函数不存在将报错。支持以下扩展函数：</p>
<ul>
<li>timediff(tm1, tm2), 用于日期比较，计算日期tm1-tm2且以秒数返回，如<code>timediff(tm1, '2023-1-1 10:00') &gt;= 60</code>; <code>timediff('2022-1-1 1:00', '2022-1-1')=3600</code>值为true</li>
</ul>
<p class="see"><strong>@see <a href="#getVarsFromExpr">getVarsFromExpr</a></strong> </p></div>
<div class="block">
<h2 id="getVarsFromExpr">@fn getVarsFromExpr($expr)</h2>
<p>取表达式中的变量集合：</p>
<pre><code>$rv = getVarsFromExpr("a in (98,99) and b=null and timediff(c1, '2022-1-1')&gt;3600"); 
// $rv=["a","b","c1"]</code></pre>
<p class="see"><strong>@see <a href="#evalExpr">evalExpr</a></strong>  表达式引擎</p></div>
<div class="block">
<h2 id="JDStatusFile">@class JDStatusFile</h2>
<p>状态自动加载和保存.<br />
示例：从cleanData.json文件中加载状态到关联数组$stat，并在修改$stat后自动保存。</p>
<pre><code>{
    // $stat = ["id"=&gt;1000]; // 可以给初始值
    $sf = new JDStatusFile("cleanData.json", $stat);
    ...
    // $sf-&gt;save(); // 立即保存
    // unset($sf); // 手工调用，立即保存。一般无须调用。
} // 当$sf变量出作用域后，就会自动保存，即使中途有异常，也会自动保存。</code></pre>
<p>上面无论是否出异常都会保存，如果只想在正常时才保存，可在异常时调用rollback：</p>
<pre><code>$sf = new JDStatusFile("cleanData.json", $stat);
try {
    ...
    $sf-&gt;save();
}
catch (Exception $ex) {
    $sf-&gt;rollback();
}</code></pre>
<p>注意：</p>
<ul>
<li>保存前会检查$stat数据是否有变化，无变化时不保存。</li>
<li>若存在并发访问时，以最后一次写入为准。</li>
<li>变量$sf即使没有用到也要定义，它的作用域决定了何时写入状态文件。如果直接用<code>new JDStatusFile()</code>则对象立即释放无法保存状态。</li>
</ul></div>
<div class="block">
<h2 id="Guard">@class Guard</h2>
<p>利用对象析构做清理工作，确保清理工作一定会完成。</p>
<p>示例:</p>
<pre><code>$g = new Guard(function () {
    // do clean task
});</code></pre>
<p>注意变量$g即使没有用到也要定义，它的作用域决定了何时清理。</p></div>
<div class="block">
<h2 id="app_fw">@module app_fw</h2><div class="toc"><p style="margin-left:0em"><a href="#app_fw-1 通用函数">1 通用函数</a></p>
<p style="margin-left:0em"><a href="#app_fw-2 初始化配置">2 初始化配置</a></p>
<p style="margin-left:2em"><a href="#app_fw-2.1 数据库配置">2.1 数据库配置</a></p>
<p style="margin-left:0em"><a href="#app_fw-3 测试模式与调试等级">3 测试模式与调试等级</a></p>
<p style="margin-left:0em"><a href="#app_fw-4 模拟模式">4 模拟模式</a></p>
<p style="margin-left:0em"><a href="#app_fw-5 session会话管理">5 session会话管理</a></p>
<p style="margin-left:0em"><a href="#app_fw-6 动态修改环境配置项">6 动态修改环境配置项</a></p>
</div>
<p>筋斗云服务端通用应用框架。</p>
<h4 id="app_fw-1 通用函数">1 通用函数</h4>
<ul>
<li>
<p>获得指定类型参数</p>
<p class="see"><strong>@see <a href="#param">param</a> <a href="#mparam">mparam</a></strong> </p>
</li>
<li>
<p>数据库连接及操作</p>
<p class="see"><strong>@see <a href="#dbconn">dbconn</a> <a href="#execOne">execOne</a> <a href="#queryOne">queryOne</a> <a href="#queryAll">queryAll</a> <a href="#dbInsert">dbInsert</a> <a href="#dbUpdate">dbUpdate</a></strong> </p>
</li>
<li>错误处理设施
<p class="see"><strong>@see <a href="#MyException">MyException</a> <a href="#errQuit">errQuit</a></strong> </p></li>
</ul>
<h4 id="app_fw-2 初始化配置">2 初始化配置</h4>
<p>app_fw框架自动包含 $BASE_DIR/php/conf.user.php。</p>
<p>项目部署时的配置，一般用于定义环境变量、全局变量等，通常不添加入版本库，在项目实施时手工配置。</p>
<p>对于不变的全局配置，应在app.php中定义。</p>
<h5 id="app_fw-2.1 数据库配置">2.1 数据库配置</h5>
<p class="key"><strong>@key <a id="P_DB">P_DB</a></strong>  环境变量，指定DB类型与地址。</p>
<p class="key"><strong>@key <a id="P_DBCRED">P_DBCRED</a></strong>  环境变量，指定DB登录帐号</p>
<p>P_DB格式为：</p>
<pre><code>P_DB={主机名}/{数据库名}
或
P_DB={主机名}:{端口号}/{数据库名}</code></pre>
<p>例如：</p>
<pre><code>P_DB=localhost/myorder
P_DB=www.myserver.com:3306/myorder</code></pre>
<p>P_DBCRED格式为<code>{用户名}:{密码}</code>，或其base64编码后的值，如</p>
<pre><code>P_DBCRED=ganlan:1234
或
P_DBCRED=Z2FubGFuOjEyMzQ=</code></pre>
<p>连接mysql示例(注意在php.ini中打开php_pdo_mysql扩展)，设置以下环境变量：</p>
<pre><code>putenv("P_DBTYPE=mysql");
putenv("P_DB=172.12.77.221/jdcloud");
putenv("P_DBCRED=demo:demo123");</code></pre>
<p>P_DBTYPE参数可以不设置，它默认值就是mysql。</p>
<p>连接mssql可以通过php_pdo_sqlsrv扩展+odbc驱动，也可以通过php_pdo_odbc扩展+odbc驱动, 建议前者。</p>
<p>连接mssql示例(通过php_pdo_sqlsrv和php_sqlsrv扩展, 微软官网下载)<br />
<a href="https://learn.microsoft.com/en-us/sql/connect/php/installation-tutorial-linux-mac?view=sql-server-ver16">https://learn.microsoft.com/en-us/sql/connect/php/installation-tutorial-linux-mac?view=sql-server-ver16</a></p>
<pre><code>putenv("P_DBTYPE=mssql");
putenv("P_DB=sqlsrv:DATABASE=FNWMS; SERVER=myserver.delta.corp; Encrypt=no");
putenv("P_DBCRED=wms:1234");</code></pre>
<p>连接mssql示例(通过php_pdo_odbc扩展), linux平台:<br />
<a href="https://learn.microsoft.com/en-us/sql/connect/odbc/linux-mac/installing-the-microsoft-odbc-driver-for-sql-server?view=sql-server-ver16">https://learn.microsoft.com/en-us/sql/connect/odbc/linux-mac/installing-the-microsoft-odbc-driver-for-sql-server?view=sql-server-ver16</a></p>
<pre><code>setlocale(LC_ALL, "en_US.UTF-8"); // 如果写入中文乱码，试试指定locale
$GLOBALS["conf_mssql_useOdbc"] = true;
putenv("P_DBTYPE=mssql");
// driver名字在/etc/odbcinst.ini中查看
putenv("P_DB=odbc:DRIVER={ODBC Driver 18 for SQL Server}; LANGUAGE=us_english; DATABASE=FNWMS; SERVER=myserver.delta.corp; Encrypt=no");
putenv("P_DBCRED=wms:1234");

// windows平台odbc示例:
// putenv("P_DB=odbc:DRIVER=SQL Server Native Client 10.0; DATABASE=jdcloud; Trusted_Connection=Yes; SERVER=.\MSSQL2008;");

// 使用odbc的文件DSN示例（可通过系统自带的odbcad32工具创建），如：
// putenv("P_DB=odbc:FILEDSN=d:\db\jdcloud-mssql.dsn");</code></pre>
<p>对oracle数据库为最基本的DBEnv级别支持, 不支持接口框架, 示例: (需要php扩展oci8.so和pdo_oci.so)</p>
<pre><code>putenv("P_DBTYPE=oracle");
putenv("P_DB=oci:dbname=10.30.250.131:1525/mesdzprd;charset=AL32UTF8");</code></pre>
<p>此外，P_DB还试验性地支持SQLite数据库，直接指定以&quot;.db&quot;为扩展名的文件，以及P_DBTYPE即可，不需要P_DBCRED。例如：<br />
连接sqlite示例(注意打开php_pdo_sqlite扩展)：</p>
<pre><code>putenv("P_DBTYPE=sqlite");
putenv("P_DB=../myorder.db");</code></pre>
<p>连接SQLite数据库未做严格测试，不建议使用。</p>
<p>做性能对比测试时还支持不连数据库(当然也不会写ApiLog)，可指定：</p>
<pre><code>putenv("P_DB=null");</code></pre>
<p>也可以直接创建DBEnv来用(调用queryOne/execOne等)，示例：</p>
<pre><code># mysql
$db = "mysql:host=localhost;port=3306;dbname=jt_wms";
$env = new DBEnv("mysql", $db, "demo", "demo123");

$rows = $env-&gt;queryAll("SELECT * FROM Employee");
$rowCnt = $env-&gt;queryOne("SELECT COUNT(*) FROM Employee");
$newId = $env-&gt;dbInsert("Employee", ["name"=&gt;"name1"]);
$cnt = $env-&gt;dbUpdate("Task", ["vendorId" =&gt; $id], ["vendorId" =&gt; $id1]);
$cnt = $env-&gt;execOne("UPDATE Task SET vendorId=venderId+1");

# sqlite
$db = "sqlite:jdcloud.db";
$env = new DBEnv("sqlite", $db);

# mssql over PDO
$db = "sqlsrv:DATABASE=FNWMS; SERVER=myserver.test.com; Encrypt=no";
# mssql over odbc
# $db = "odbc:DRIVER={SQL Server Native Client 11.0}; LANGUAGE=us_english; DATABASE=jdcloud; SERVER=."; // "UID=demo; PWD=demo123"
$env = new DBEnv("mssql", $db, "demo", "demo123");

# oracle
$db = "oci:dbname=10.30.250.131:1525/mesdzprd;charset=AL32UTF8";
$env = new DBEnv("oracle", $db, "demo", "demo123");</code></pre>
<p>如果配置了P_DEBUG_LOG=1且P_DEBUG=9，则记录SQL调用日志到debug.log</p>
<p class="var"><strong>@var <a id="conf_dbinst">conf_dbinst</a></strong>  DB浏览器-数据库实例配置</p>
<p>使用SQL语句<code>show databases</code>或<code>show tables</code>可查看数据库或数据表的列表。<br />
除了当前数据库实例，也支持连接到其它数据库实例。配置示例：</p>
<pre><code>$mssql_db = "odbc:DRIVER={SQL Server Native Client 11.0}; LANGUAGE=us_english; DATABASE=jdcloud; SERVER=."; // "UID=sa; PWD=ibdibd"
# $mssql_db = "sqlsrv:DATABASE=FNWMS; SERVER=myserver.test.com; Encrypt=no"; // mssql over PDO
$oracle_db = "oci:dbname=10.30.250.131:1525/mesdzprd;charset=AL32UTF8";
$GLOBALS["conf_dbinst"] = [
    // 实例名称 =&gt; [数据库类型，PDO连接字符串，用户，密码]
    "本地测试mysql" =&gt; ["mysql", "mysql:host=localhost;port=3306;dbname=wms", "demo", "demo123"],
    "mssql实例" =&gt; ["mssql", $mssql_db, "demo", "demo123"],
    "sqlite实例" =&gt; ["sqlite", "sqlite:jdcloud.db"],
    "oracle实例" =&gt; ["oracle", $oracle_db, "demo", "demo123"],
];</code></pre>
<h4 id="app_fw-3 测试模式与调试等级">3 测试模式与调试等级</h4>
<p class="key"><strong>@key <a id="P_TEST_MODE">P_TEST_MODE</a></strong>  Integer。环境变量，允许测试模式。0-生产模式；1-测试模式；2-自动化回归测试模式(RTEST_MODE)</p>
<p class="key"><strong>@key <a id="P_DEBUG">P_DEBUG</a></strong>  Integer。环境变量，设置调试等级，值范围0-9。</p>
<p class="key"><strong>@key <a id="P_DEBUG_LOG">P_DEBUG_LOG</a></strong>  Integer。(v5.4) 环境变量，是否打印接口明细日志到debug.log。0-不打印，1-全部打印，2-只打印出错的调用</p>
<p>测试模式特点：</p>
<ul>
<li>输出的HTTP头中包含：<code>X-Daca-Test-Mode: 1</code></li>
<li>输出的JSON格式经过美化更易读，且可以显示更多调试信息。前端可通过在接口中添加<code>_debug</code>参数设置调试等级。<br />
如果想要查看本次调用涉及的SQL语句，可以用<code>_debug=9</code>。</li>
<li>某些用于测试的接口可以调用，例如execSql。因而十分危险，生产模式下一定不可误设置为测试模式。</li>
<li>可以使用模拟模式</li>
</ul>
<p>注意：v5.4起可设置P_DEBUG_LOG，在测试模式或生产模式都可用，可记录日志到后台debug.log文件中。一般用于在生产环境下，临时开放查看后台日志。</p>
<p>注意：v3.4版本起不允许客户端设置_test参数，且用环境变量P_TEST_MODE替代符号文件CFG_TEST_MODE。</p>
<p>在过去测试模式用于：可直接对生产环境进行测试且不影响生产环境，即部署后，在前端指定以测试模式连接，在后端为测试模式连接专用的测试数据库，且使用专用的cookie，实现与生产模式共用代码但互不影响。<br />
现已废弃这种用法，应搭建专用的测试环境用于测试开发。</p>
<p class="key"><strong>@key <a id="_debug">_debug</a></strong>  前端URL参数</p>
<p>(v6.1) 前端指定调试等级（相当于指定P_DEBUG），会同时记录debug日志（相当于后端设置P_DEBUG_LOG=1）；<br />
在测试模式下，调试信息会以指定等级输出到前端。</p>
<p class="see"><strong>@see <a href="#addLog">addLog</a></strong> </p>
<h4 id="app_fw-4 模拟模式">4 模拟模式</h4>
<p class="key"><strong>@key <a id="P_MOCK_MODE">P_MOCK_MODE</a></strong>  Integer. 模拟模式. 值：0/1，或部分模拟，值为模块列表，如"wx,sms"，外部模块名称定义见ext.php.</p>
<p>对第三方系统依赖（如微信认证、支付宝支付、发送短信等），可通过设计Mock接口来模拟。</p>
<p>注意：v3.4版本起用环境变量P_MOCK_MODE替代符号文件CFG_MOCK_MODE/CFG_MOCK_T_MODE，且模拟模式只允许在测试模式激活时才能使用。</p>
<p class="see"><strong>@see <a href="#ExtMock">ExtMock</a></strong> </p>
<h4 id="app_fw-5 session会话管理">5 session会话管理</h4>
<ul>
<li>应用的session名称为 &quot;{app}id&quot;, 如应用名为 &quot;user&quot;, 则session名为&quot;userid&quot;. 因而不同的应用同时调用服务端也不会冲突。</li>
<li>保存session文件的目录为 $conf_dataDir/session, 可使用环境变量P_SESSION_DIR重定义(推荐配置$conf_dataDir而不是P_SESSION_DIR)。</li>
<li>同一主机，不同URL下的session即使APP名相同，也不会相互冲突，因为框架会根据当前URL，设置cookie的有效路径。</li>
</ul>
<p class="key"><strong>@key <a id="P_SESSION_DIR">P_SESSION_DIR</a></strong>  ?= $conf_dataDir/session 环境变量，定义session文件存放路径。</p>
<p class="key"><strong>@key <a id="P_URL_PATH">P_URL_PATH</a></strong>  环境变量。项目的URL路径，如"/jdcloud", 用于定义cookie生效的作用域，也用于拼接相对URL路径。</p>
<p class="see"><strong>@see <a href="#getBaseUrl">getBaseUrl</a></strong> </p>
<p>PHP默认的session过期时间为1440s(24分钟)，每次在使用session时，以1/1000的概率检查过期(session.gc_divisor=1000, session.gc_probability=1)。<br />
查看PHP默认配置可以用：<code>php -r 'phpinfo();' |grep -i session.gc</code><br />
注意：在centos7/8中默认配置是1/1000，在ubuntu20+中默认配置为0/1000即禁用了概率回收机制，但在/etc/cron.d/php中以定时任务方式配置了每30分钟清理一次。</p>
<p>要配置它，可以应用程序的conf.user.php中设置，如：</p>
<pre><code>ini_set("session.gc_maxlifetime", "2592000"); // 30天过期</code></pre>
<p>测试时，想要到时间立即清除session，可以设置：</p>
<pre><code>ini_set("session.gc_probability", "1000"); // 1000/1000概率做回收。每次访问都回收，性能差，仅用于测试。</code></pre>
<p>在浏览器中默认cookie的有效时间是'session'即浏览器关闭时生效，因而每次打开浏览器须重新登录。<br />
若想保留指定时长，可以设置：</p>
<pre><code>session_set_cookie_params(3600*24*7); // 保留7天</code></pre>
<p>注意：前端会记住cookie过期时间，假如后端再次改成保留10天，由于前端已记录的是7天过期，无法立即更新，只能清除cookie后再请求才能生效。</p>
<p class="class"><strong>@class SessionInDb</strong> </p>
<p>支持将会话存在数据库表Session中。在多机部署应用服务时，有时不方便用文件保存会话，这时可以切换为用数据库保存。<br />
先在DESIGN.md中声明表并使用upgrade工具创建表:</p>
<pre><code>@Session: id, name, value(t), tm</code></pre>
<p>然后在conf.php或conf.user.php中添加：</p>
<pre><code>// 使用数据库保存会话
session_set_save_handler(new SessionInDb(), true);
// ini_set("session.gc_maxlifetime", "1440"); // 配置会话超时时间，默认24分钟</code></pre>
<h4 id="app_fw-6 动态修改环境配置项">6 动态修改环境配置项</h4>
<p>在程序中可动态设置部分参数，比如一般建议debug日志只记错误（环境变量P_DEBUG_LOG设置为2），若想对于对外开发的某些接口调用记录所有日志，可以改为1，如：</p>
<pre><code>function api_fn1($env) {
    $env-&gt;DEBUG_LOG = 1; // 强制记录debug日志，也可设置0强制不记录；
    // 注意$env即全局JDEnv/DBEnv对象，在函数接口中是参数传入的，在AC类中可用$this-&gt;env来取。
    // $env-&gt;DBG_LEVEL = 9; // 对应环境配置项P_DEBUG

    // 以下不建议程序中修改
    // $env-&gt;TEST_MODE = 0; // 对应环境配置项P_TEST_MODE
    // $env-&gt;MOCK_MODE = 0; // 对应环境配置项P_MOCK_MODE
}</code></pre></div>
<div class="block">
<h2 id="$BASE_DIR">@var $BASE_DIR</h2>
<p>Web主目录实际路径，即包含api.php的目录，即server目录。<br />
为绝对路径，最后不带&quot;/&quot;.</p>
<p class="var"><strong>@var <a id="conf_dataDir">conf_dataDir</a></strong> </p>
<p>数据目录，默认值与$BASE_DIR相同，可在conf.user.php中改写，用于同一套程序部署多套环境(称为&quot;多实例&quot;)。<br />
程序输出的文件都应存放于此目录下，如session目录, 日志文件(trace.log/debug.log等), 上传目录(upload目录), JDStatusFile状态文件。<br />
注意如果要设置，应设置为绝对路径。</p>
<p>示例：(php/conf.user.php中配置)</p>
<pre><code>if (strpos($_SERVER["SCRIPT_NAME"], "/jdcloud-a1/") === 0) {
    putenv("P_DB=localhost/jdcloud_a1");
    $GLOBALS["conf_dataDir"] = __DIR__ . "/../data-jdcloud-a1";
    // $GLOBALS["conf_dataDir"] = "/var/www/src/jdcloud/server/data-jdcloud-a1";
}
else if (strpos($_SERVER["SCRIPT_NAME"], "/jdcloud-a2/") === 0) {
    putenv("P_DB=localhost/jdcloud_a2");
    $GLOBALS["conf_dataDir"] = __DIR__ . "/../data-jdcloud-a2";
}</code></pre>
<p>注意：二次开发后端的自动生成代码不受conf_dataDir控制，若多实例中某实例修改了二开后端配置，会立即在其它实例上也生效！<br />
可以通过配置<code>$GLOBALS["conf_classDir"][1]</code>来实现多实例后端的隔离。</p>
<p class="see"><strong>@see <a href="#conf_classDir">conf_classDir</a></strong> </p></div>
<div class="block">
<h2 id="conf_poweredBy">@key conf_poweredBy ?= "jdcloud"</h2>
<p>设置HTTP头x-powered-by，用于与x-daca-server-rev一起共同决定系统版本。<br />
同时可隐藏默认的php标识及版本。</p>
<p>当前端调用多个jdcloud应用接口（或有些后端接口配置了代理到其它服务）时，<br />
由于各jdcloud应用的版本不同， 会导致前端误判为版本已升级，从而引起前端自动刷新。<br />
这时可在conf.user.php中配置conf_poweredBy，用于与其它应用区分。示例： </p>
<pre><code>$GLOBALS["conf_poweredBy"] = "wms";
或
$GLOBALS["conf_poweredBy"] = "wms@server-pc";</code></pre>
<p>jdcloud前端检查当x-powered-by未变化但x-daca-server-rev变化时，才会自动刷新实现实时热更新。</p></div>
<div class="block">
<h2 id="conf_mssql_translateMysql">@var conf_mssql_translateMysql = true</h2>
<p>默认为true，即应用层可以使用部分mysql语法（常用于虚拟字段定义），框架自动转换为mssql/sqlserver数据库的T-SQL语法。<br />
支持：</p>
<ul>
<li>LIMIT分页: 使用TOP或OFFSET/FETCH替代. 支持&quot;LIMIT 20&quot; / &quot;LIMIT 100,20&quot;两种语法.</li>
<li>group_concat函数: 使用string_agg替代(须sqlserver 2017以上版本). 支持order by / separator子句.</li>
<li>if/ifnull函数: 使用iis/isnull替代等</li>
</ul>
<p class="var"><strong>@var <a id="conf_mssql_useOdbc">conf_mssql_useOdbc</a></strong>  = false</p>
<p>默认通过pdo_sqlsrv驱动连接mssql，若通过pdo_odbc连接，应设置为true</p></div>
<div class="block">
<h2 id="conf_sqlite_translateMysql">@var conf_sqlite_translateMysql = true</h2>
<p>默认为true，即应用层可以使用部分mysql语法（常用于虚拟字段定义），框架自动转换为sqlite语法:</p>
<ul>
<li>转换 if(cond, t, f) =&gt; case when cond then t else f end </li>
<li>转换 concat(a, b) =&gt; (a || b)</li>
</ul></div>
<div class="block">
<h2 id="conf_slowSqlTime">@var conf_slowSqlTime SQL慢查询阈值时间，默认值为1.0(秒).</h2>
<p class="var"><strong>@var <a id="conf_slowApiTime">conf_slowApiTime</a></strong>  慢接口阈值时间，默认值为1.0(秒).</p>
<p class="var"><strong>@var <a id="conf_slowHttpCallTime">conf_slowHttpCallTime</a></strong>  Web调用慢的阈值时间，默认值为1.0(秒).</p>
<p class="key"><strong>@key <a id="slow.log">slow.log</a></strong>  慢查询日志</p>
<p>当操作时间超过阈值时间时，会记录到慢查询日志slow.log。<br />
注意日志时间为SQL完成时的时间，日志时间减去操作时间才是开始时间。因此日志顺序与执行顺序不一定相同。</p></div>
<div class="block">
<h2 id="conf_batchAddMaxErrors">@var conf_batchAddMaxErrors ?=20</h2>
<p>导入时，最多允许报错的条目数。</p></div>
<div class="block">
<h2 id="conf_maxLogFileSize">@var conf_maxLogFileSize ?=100000000</h2>
<p>写日志文件的最大字节数，默认为100MB，例如写trace.log文件，当超过100MB后会自动转存为trace.log.1。<br />
这样的话写trace日志最多消耗约200MB空间。</p></div>
<div class="block">
<h2 id="conf_bigTables">@var conf_bigTables</h2>
<p>在管理端列表页显示大表（如超过1000万行）时，虽然有分页，但因为page参数会自动查询总数量而特别慢。将表加到该配置可跳过取数量，使得大表得以立即显示。示例：</p>
<pre><code>$GLOBALS["conf_bigTables"] = ["Sn", "SnLog"];</code></pre>
<p>注意：只要数组中包含有AC类的对象名($ac-&gt;obj)或表名($ac-&gt;table)，就会生效。<br />
比如AC_Data类的对象名是Data，而底层表名可能被改为了一个视图如&quot;select ...&quot;，此时若conf_bigTables中有&quot;Data&quot;就可以匹配该对象。</p></div>
<div class="block">
<h2 id="param_varr">@fn param_varr($str, $type, $name)</h2>
<p>type的格式如&quot;i:n:b?:dt:tm?&quot;.</p>
<pre><code>$ordr1 = param_varr("10:1.5,11:2.0", "i:n", "ordr1"); // [ [10, 1.5], [11, 2.0] ] 注意类型已转换
$ordr1 = varr2objarr($ordr1, ["itemId", "qty"]); // [ ["itemId"=&gt;10, "qty"=&gt;1.5], ["itemId"=&gt;11, "qty"=&gt;2.0] ]

// 一般通过param调用来取值：
$ordr1 = param("ordr1/i:n", null, "P"); // 从$_POST中取ordr1参数。
$ordr1 = varr2objarr($ordr1, ["itemId", "qty"]); 

// 只有单个列的特殊写法
$snLog1 = param_varr("10,11,12", "i:", "snLog1"); // [ [10], [11], [12] ]
$snLog1 = varr2objarr($snLog1, ["snId"]); // [ ["snId"=&gt;10], ["snId"=&gt;11], ["snId"=&gt;12] ]</code></pre>
<ul>
<li>每个词表示一个字段类型<br />
类型标识：i-Integer; n-Number/Double; b-Boolean(0/1); dt/tm-DateTime</li>
<li>后置&quot;?&quot;表示该参数可缺省。</li>
</ul>
<p class="see"><strong>@see <a href="#param">param</a></strong> </p>
<p class="see"><strong>@see <a href="#list2varr">list2varr</a></strong> </p>
<p class="see"><strong>@see <a href="#varr2objarr">varr2objarr</a></strong> </p></div>
<div class="block">
<h2 id="param">@fn param($name, $defVal?, $col?, $doHtmlEscape=true, $env = null)</h2>
<p class="param"><strong>@param $col:</strong>  默认先取$_GET再取$_POST，"G" - 从$_GET中取; "P" - 从$_POST中取</p>
<p>$col也可以直接指定一个集合，如</p>
<pre><code>param($name, $defVal, $param)</code></pre>
<p>获取名为$name的参数。<br />
$name中可以指定类型，返回值根据类型确定。如果该参数未定义或是空串，直接返回缺省值$defVal。</p>
<p>$name中指定类型的方式如下：</p>
<ul>
<li>名为&quot;id&quot;, 或以&quot;Id&quot;或&quot;/i&quot;结尾: int</li>
<li>以&quot;/b&quot;结尾: bool. 可接受的字符串值为: &quot;1&quot;/&quot;true&quot;/&quot;on&quot;/&quot;yes&quot;=&gt;true, &quot;0&quot;/&quot;false&quot;/&quot;off&quot;/&quot;no&quot; =&gt; false</li>
<li>以&quot;/dt&quot;: datetime, 仅有日期部分</li>
<li>以&quot;/tm&quot;结尾: datetime</li>
<li>以&quot;/n&quot;结尾: numeric/double</li>
<li>以&quot;/s&quot;结尾（缺省）: string. 缺省为防止XSS攻击会做html编码，如&quot;a&amp;b&quot;处理成&quot;a&amp;b&quot;，设置参数doHtmlEscape可禁用这个功能。</li>
<li>复杂类型(数组)：以&quot;/i+&quot;结尾: int array</li>
<li>复杂类型：以&quot;/js&quot;结尾: json object</li>
<li>复杂类型(二维数组)：List类型（以&quot;,&quot;分隔行，以&quot;:&quot;分隔列），类型定义如&quot;/i:n:b:dt:tm&quot; （列只支持简单类型，不可为复杂类型）</li>
</ul>
<p>示例：</p>
<pre><code>$id = param("id");
$svcId = param("svcId/i", 99);
$wantArray = param("wantArray/b", false);
$startTm = param("startTm/dt", time());</code></pre>
<p>List类型示例。参数&quot;items&quot;类型在文档中定义为list(id/Integer, qty/Double, dscr/String)，可用param(&quot;items/i:n:s&quot;)获取, 值如</p>
<pre><code>items=100:1:洗车,101:1:打蜡</code></pre>
<p>返回</p>
<pre><code>[ [ 100, 1.0, "洗车"], [101, 1.0, "打蜡"] ]</code></pre>
<p>如果某列可缺省，用&quot;?&quot;表示，如param(&quot;items/i:n?:s?&quot;)可获取值：</p>
<pre><code>items=100:1,101::打蜡</code></pre>
<p>返回</p>
<pre><code>[ [ 100, 1.0, null], [101, null, "打蜡"] ]</code></pre>
<p>要转换成objarr，可以用：</p>
<pre><code>$varr = param("items/i:n?:s?");
$objarr = varr2objarr($var, ["id", "qty", "dscr"]);</code></pre>
<p>$objarr值为：</p>
<pre><code>[
    [ "id"=&gt;100, "qty"=&gt;1.0, dscr=&gt;null],
    [ "id"=&gt;101, "qty"=&gt;null, dscr=&gt;"打蜡"]
]</code></pre>
<p>(v6) 对cond参数或cond类型是特别处理的，会自动从GET/POST中取值，并且支持字符串、数组、键值对多种形式，参考getQueryCond：</p>
<pre><code>$cond = mparam("cond");
$gcond = param("gcond/cond");</code></pre></div>
<div class="block">
<h2 id="mparam">@fn mparam($name, $col = null, $doHtmlEscape = true, $env = null)</h2>
<p class="brief"><strong>@brief mandatory</strong>  param</p>
<p class="param"><strong>@param col</strong>  'G'-从URL参数即$_GET获取，'P'-从POST参数即$_POST获取。参见param函数同名参数。</p>
<p>$name可以是一个数组，表示至少有一个参数有值，这时返回每个参数的值。<br />
参考param函数，查看$name如何支持各种类型。</p>
<p>注意：即使传入值是空串，也会当作未传值而报错！</p>
<p>示例：</p>
<pre><code>$svcId = mparam("svcId");
$svcId = mparam("svcId/i");
$itts = mparam("itts/i+")
list($svcId, $itts) = mparam(["svcId", "itts/i+"]); # require one of the 2 params</code></pre></div>
<div class="block">
<h2 id="getConf">@fn getConf($confName, $arr=$GLOBALS)</h2>
<p>取配置项，如果未配置则报错。</p>
<pre><code>$url = getConf("conf_jdserverUrl");</code></pre>
<p>若不想报错则直接取：</p>
<pre><code>if (isset($GLOBALS["conf_xxx"])) ...</code></pre>
<p>如果希望用户未配置时返回缺省值，可直接先配置其缺省值（应确保在conf.user.php中可被覆盖）：</p>
<pre><code>$GLOBALS["conf_jdserverUrl"] = "http://...";</code></pre></div>
<div class="block">
<h2 id="checkParams">@fn checkParams($obj, $names, $errPrefix?)</h2>
<p>检查$obj对象中指定的必填参数（通过names指定）。<br />
检查失败直接抛出异常，不再向下执行。</p>
<p>示例：obj中必须有&quot;brand&quot;, &quot;vendorName&quot;字段，否则应报错：</p>
<pre><code>checkParams($order, [
    "brand", "vendorName"
]);
// 报错示例: "缺少参数`vendorName`"</code></pre>
<p>或如果希望报错时明确一些，可以翻译一下参数，这样来指定：</p>
<pre><code>checkParams($order, [
    "brand" =&gt; "品牌",
    "vendorName" =&gt; "供应商",
    "phone" // 也允许不指定名字
], "传入订单对象"); // 可选的第三参数errPrefix用于报错前缀
// 报错示例: "传入订单对象缺少参数`供应商(vendorName)`"</code></pre>
<p>注意：它只检查是否有该字段，不检查该字段是否为null或空串(&quot;&quot;)。</p>
<p>对于对象数组，可以用checkObjArrParam函数，示例</p>
<pre><code>checkObjArrParam(null, $_POST, ["MATNR"=&gt;"物料号", "MAKTX"=&gt;"物料名"]);</code></pre>
<p>它相当于</p>
<pre><code>foreach ($_POST as $i=&gt;$e) {
    checkParams($e, ["MATNR"=&gt;"物料号", "MAKTX"=&gt;"物料名"], "第".($i+1)."行"); // 设置第3参数，可让报错时前面会加上这个描述
    ...
}</code></pre>
<p class="see"><strong>@see <a href="#checkObjArrParams">checkObjArrParams</a></strong>  对象数组参数检查</p></div>
<div class="block">
<h2 id="checkObjArrParams">@fn checkObjArrParams($objArr, $fields=null, $name='数组')</h2>
<p>检查对象数组$arr中是否填写字段，$name为数组名，用于报错。<br />
检查失败直接抛出异常，不再向下执行。</p>
<pre><code>$personArr = [
    ["id" =&gt; 100, "name" =&gt; "name1"],
    ["id" =&gt; 101 ],
];
checkObjArrParams($personArr, ["id","name"]); 
// 报错: "数组第2行: 缺少参数`name`"</code></pre>
<p>或指定报错名称：</p>
<pre><code>checkObjArrParams($personArr, ['id'=&gt;'编号','name'=&gt;'姓名'], 'personArr数组');
// 报错: "personArr数组第2行: 缺少参数`姓名(name)`"</code></pre>
<p class="see"><strong>@see <a href="#checkParams">checkParams</a></strong>  对象参数检查</p></div>
<div class="block">
<h2 id="queryAllWithHeader">@fn queryAllWithHeader($sql, $wantArray=false)</h2>
<p class="alias"><strong>@alias <a id="getRsAsTable">getRsAsTable</a></strong> ($sql)</p>
<p>查询SQL，返回筋斗云table格式：{@h, @d}<br />
h是标题字段数组，d是数据行。<br />
即queryAll函数的带表格标题版本。</p>
<pre><code>$tbl = queryAllWithHeader("SELECT id, name FROM User");</code></pre>
<p>返回示例：</p>
<pre><code>[
    "h"=&gt;["id","name"],
    "d"=&gt;[ [1,"name1"], [2, "name2"]]
]</code></pre>
<p>如果查询结果为空，则返回：</p>
<pre><code>[ "h" =&gt; [], "d" =&gt; [] ];</code></pre>
<p>如果指定了参数$wantArray=true, 则返回二维数组，其中首行为标题行：</p>
<pre><code>$tbl = queryAllWithHeader("SELECT id, name FROM User", true);</code></pre>
<p>返回：</p>
<pre><code>[ ["id", "name"], [1, "name1"], [2, "name2"] ]</code></pre>
<p>如果查询结果为空，则返回:</p>
<pre><code>[ [], [] ]</code></pre>
<p class="see"><strong>@see <a href="#queryAll">queryAll</a></strong> </p></div>
<div class="block">
<h2 id="sortBySeq">@fn sortBySeq($arr, $seq)</h2>
<p>确保$arr数组中元素顺序与$seq数组中一致。<br />
示例：</p>
<pre><code>$arr = ["id","age","name","prop"]
sortBySeq($arr, ["name", "age", "score"]);
// $arr为 ["id","name","age","prop"]</code></pre>
<p>注意: $seq中未指定的元素(如上例$arr中的&quot;prop&quot;)，或是多指定的元素(如&quot;score&quot;在$arr中不存在)，都忽略不管，最终确保$arr中顺序与$seq不冲突即可。</p>
<p>算法: 重新赋值$arr中在$seq指定的元素，如上例中重新赋值两个：</p>
<pre><code>$arr[1]="name";
$arr[2]="age";</code></pre></div>
<div class="block">
<h2 id="objarr2table">@fn objarr2table ($objarr, $fixedColCnt=null, $seq=null)</h2>
<p>将objarr格式转为table格式, 如：</p>
<pre><code>objarr2table(
    [
        ["id"=&gt;100, "name"=&gt;"A"],
        ["id"=&gt;101, "name"=&gt;"B"]
    ]
) -&gt; 
    [
        "h"=&gt;["id", "name"],
        "d"=&gt;[ 
            [100,"A"], 
            [101,"B"]
        ] 
    ]</code></pre>
<p>注意：</p>
<ul>
<li>objarr每行中列的顺序可以不一样，table列按首行顺序输出。</li>
<li>
<p>每行中列数可以不一样，这时可指定最少固定列数 $fixedColCnt, 而该列以后，将自动检查所有行决定是否加到header中。例：</p>
<p>objarr2table(<br />
[<br />
[&quot;id&quot;=&gt;100, &quot;name&quot;=&gt;&quot;A&quot;],<br />
[&quot;name&quot;=&gt;&quot;B&quot;, &quot;id&quot;=&gt;101, &quot;flag_v&quot;=&gt;1],<br />
[&quot;id&quot;=&gt;102, &quot;name&quot;=&gt;&quot;C&quot;, &quot;flag_r&quot;=&gt;1]<br />
], 2  // 2列固定<br />
) -&gt;<br />
[<br />
&quot;h&quot;=&gt;[&quot;id&quot;, &quot;name&quot;, &quot;flag_v&quot;, &quot;flag_r&quot;],<br />
&quot;d&quot;=&gt;[<br />
[100,&quot;A&quot;, null,null],<br />
[101,&quot;B&quot;, 1, null],<br />
[102,&quot;C&quot;, null, 1]<br />
]<br />
]</p>
</li>
</ul>
<p>可选参数$seq是个数组，可指定列顺序，如上例中指定$seq=<code>["name", "id"]</code>，则最终的列数组将为<code>["name", "id", "flag_v", "flag_r"]</code>。</p>
<p class="see"><strong>@see <a href="#table2objarr">table2objarr</a></strong> </p>
<p class="see"><strong>@see <a href="#varr2objarr">varr2objarr</a></strong> </p></div>
<div class="block">
<h2 id="table2objarr">@fn table2objarr</h2>
<p>将table格式转为 objarr, 如：</p>
<pre><code>table2objarr(
    [
        "h"=&gt;["id", "name"],
        "d"=&gt;[ 
            [100,"A"], 
            [101,"B"]
        ] 
    ]
) -&gt; [ ["id"=&gt;100, "name"=&gt;"A"], ["id"=&gt;101, "name"=&gt;"B"] ]</code></pre></div>
<div class="block">
<h2 id="varr2objarr">@fn varr2objarr</h2>
<p>将类型 varr (仅有值的二维数组, elem=[$col1, $col2] ) 转为 objarr (对象数组, elem={col1=&gt;cell1, col2=&gt;cell2})</p>
<p>例：</p>
<pre><code>varr2objarr(
    [ [100, "A"], [101, "B"] ], 
    ["id", "name"] )
-&gt; [ ["id"=&gt;100, "name"=&gt;"A"], ["id"=&gt;101, "name"=&gt;"B"] ]</code></pre></div>
<div class="block">
<h2 id="list2varr">@fn list2varr(ls, colSep=':', rowSep=',')</h2>
<ul>
<li>ls: 代表二维表的字符串，有行列分隔符。</li>
<li>colSep, rowSep: 列分隔符，行分隔符。</li>
</ul>
<p>将字符串代表的压缩表(&quot;v1:v2:v3,...&quot;)转成值数组。</p>
<p>e.g.</p>
<pre><code>$users = "101:andy,102:beddy";
$varr = list2varr($users);
// $varr = [["101", "andy"], ["102", "beddy"]];
$objarr = $varr2objarr($varr, ["id", "name"]); // [ ["id"=&gt;"101", "name"=&gt;"andy"], ["id"=&gt;"102", "name"=&gt;"beddy"] ]

$cmts = "101\thello\n102\tgood";
$varr = list2varr($cmts, "\t", "\n");
// $varr=[["101", "hello"], ["102", "good"]]</code></pre>
<p class="see"><strong>@see <a href="#varr2objarr">varr2objarr</a></strong> </p>
<p class="see"><strong>@see <a href="#param_varr">param_varr</a></strong> </p></div>
<div class="block">
<h2 id="getCred">@fn getCred($cred) -> [user, pwd]</h2>
<p>$cred为&quot;{user}:{pwd}&quot;格式，支持使用base64编码。<br />
示例：</p>
<pre><code>list($user, $pwd) = getCred(getenv("P_ADMIN_CRED"));
if (! isset($user)) {
    // 未设置用户名密码
}</code></pre></div>
<div class="block">
<h2 id="dbconn">@fn dbconn($fnConfirm=$GLOBALS["dbConfirmFn"])</h2>
<p class="param"><strong>@param fnConfirm</strong>  fn(dbConnectionString), 如果返回false, 则程序中止退出。</p>
<p class="key"><strong>@key <a id="dbConfirmFn">dbConfirmFn</a></strong>  连接数据库前回调。</p>
<p>连接数据库</p>
<p>数据库由环境变量P_DB指定，格式可以为：</p>
<pre><code>host1/carsvc (无扩展名，表示某主机host1下的mysql数据库名；这时由 环境变量 P_DBCRED 指定用户名密码。

dir1/dir2/carsvc.db (以.db文件扩展名标识的文件路径，表示SQLITE数据库）</code></pre>
<p>环境变量 P_DBCRED 指定用户名密码，格式为 base64(dbuser:dbpwd).</p></div>
<div class="block">
<h2 id="dbCommit">@fn dbCommit($doRollback=false)</h2>
<p>中间先提交一次事务，然后进入另一个事务。</p>
<p>用于一段事务执行完后及时提交，避免下一段出问题后导致全部回滚，示例：</p>
<pre><code>// 上一批完成出库
$this-&gt;outOfBinDone(["portType" =&gt; "出库缓存架 OR 出库缓存架-大件"]);
dbCommit();
//处理当前出库单据
$this-&gt;outOfBin($_POST);</code></pre></div>
<div class="block">
<h2 id="Q">@fn Q($str, $env=null)</h2>
<p>quote string</p>
<p>一般是把字符串如&quot;abc&quot;转成加单引号的形式&quot;'abc'&quot;. 适用于根据用户输入串拼接成SQL语句时，对输入串处理，避免SQL注入。</p>
<p>示例：</p>
<pre><code>$sql = sprintf("SELECT id FROM User WHERE uname=%s AND pwd=%s", Q(param("uname")), Q(param("pwd")));</code></pre>
<p>注意不同数据库对转义处理不同，如mysql将&quot;'&quot;转义为&quot;\'&quot;，而sqlite转义为&quot;''&quot;。<br />
如果未指定$env，则取当前$env.</p></div>
<div class="block">
<h2 id="getQueryCond">@fn getQueryCond(cond)</h2>
<p>根据cond生成查询条件字符串。其中cond可以是</p>
<ul>
<li>
<p>null，忽略</p>
</li>
<li>
<p>条件字符串，参考SQL语句WHERE条件语法（不支持函数、子查询等），示例：</p>
<pre><code>"100"或100 生成 "id=100"
"id=1"
"id&gt;=1 and id&lt;100"
"status='CR'"  注意字符串要加引号
"status IN ('CR','PA')"
"tm&gt;='2020-1-1' AND tm&lt;'2020-2-1'"
"name like 'wang%' OR dscr like 'want%'"
"name IS NULL OR dscr IS NOT NULL"</code></pre>
</li>
<li>
<p>键值对，键为字段名，值为查询条件，使用更加直观（如字符串不用加引号），如：</p>
<pre><code>[
    "id"=&gt;1,
    "status"=&gt;"CR",
    "name"=&gt;"null",
    "dscr"=&gt;null,
    "f1"=&gt;"",
    "f2"=&gt;"empty"
]
生成 "id=1 AND status='CR'" AND name IS NULL AND f2=''"
注意，当值为null或空串时会忽略掉该条件，所以dscr和f1参数没有进入条件；用字符串"null"表示"IS NULL"条件，用字符串"empty"表示空串。

可以使用符号： &gt; &lt; &gt;= &lt;= !(not) ~(like匹配)
[
    "id&gt;=" =&gt; 100, 
    "id&lt;=" =&gt; 200,
    "tm&gt;=" =&gt; "2020-1-1",
    "tm&lt;"  =&gt; "2021-1-1",
    "status!"=&gt;"CR",
    "name~" =&gt; "wang%",
    "dscr~" =&gt; "aaa",
    "dscr2!~" =&gt;"aaa"
]
生成 "id&gt;=100 AND id&lt;=200 AND tm&gt;='2020-1-1" AND tm&lt;'2021-1-1' AND status&lt;&gt;'CR' AND name LIKE 'wang%' AND dscr LIKE '%aaa%' AND dscr2 NOT LIKE '%aaa%'"
同样，如果值是null或""，则它不进入条件，如 `["id&gt;=" =&gt; 100, "id&lt;" =&gt; null]`生成条件为 `id&gt;=100`

这样比较方便拼接条件，例如前端调用`callSvr("Ordr", {cond:{"createTm&gt;=":tm1, "createTm&lt;":tm2}})`，当tm1或tm2为空不产生条件;
后端也是类似，例如：

    $tm1 = param("tm1");
    $tm2 = param("tm2");
    $cond = getQueryCond(["createTm&gt;=" =&gt; $tm1, "createTm&lt;"=&gt;$tm2]); // 如果tm1或tm2为空，则不产生条件

也可以将符号放在值中（但这样则无法同一字段指定多次）：
["id"=&gt;"&lt;100", "tm"=&gt;"&gt;2020-1-1", "status"=&gt;"!CR", "name"=&gt;"~wang%", "dscr"=&gt;"~aaa", "dscr2"=&gt;"!~aaa"]
生成 "id&lt;100 AND tm&gt;'2020-1-1" AND status&lt;&gt;'CR' AND name LIKE 'wang%' AND dscr LIKE '%aaa%' AND dscr2 NOT LIKE '%aaa%'"
like用于字符串匹配，字符串中用"%"或"*"表示通配符，如果不存在通配符，则表示包含该串(即生成'%xxx%')

支持IN和NOT IN:
["id"=&gt;"IN 100,101", "status"=&gt;"NOT IN CA,XX"]
生成"id IN (1,2,3) AND status NOT IN ('CR','XX')"

["b"=&gt;"!null", "d"=&gt;"!empty"]
生成 "b IS NOT NULL" AND d&lt;&gt;''"</code></pre>
<p>可用AND或OR连接多个条件，但不可加括号嵌套：</p>
<pre><code>["tm"=&gt;"&gt;=2020-1-1 AND &lt;2020-2-1", "tm2"=&gt;"&lt;2020-1-1 OR &gt;=2020-2-1"]
生成 "(tm&gt;='2020-1-1' AND tm&lt;'2020-2-1') AND (tm2&lt;'2020-1-1' OR tm2&gt;='2020-2-1')"

["id"=&gt;"&gt;=1 AND &lt;100", "status"=&gt;"CR OR PA", "status2"=&gt;"!CR AND !PA OR null"]
生成 "(id&gt;=1 AND id&lt;100) AND (status='CR' OR status='PA') AND (status2&lt;&gt;'CR" AND status2&lt;&gt;'PA' OR status2 IS NULL)"

["a"=&gt;"null OR empty", "b"=&gt;"!null AND !empty", "_or"=&gt;1]
生成 "(a IS NULL OR a='') OR (b IS NOT NULL AND b&lt;&gt;'')", 默认为AND条件, `_or`选项用于指定OR条件</code></pre>
</li>
<li>
<p>数组，每个元素是上述条件字符串或键值对，如：</p>
<pre><code>["id&gt;=1", "id&lt;100", "name LIKE 'wang%'"] // "id&gt;=1 AND id&lt;100" AND name LIKE 'wang%'"
等价于 ["id"=&gt;"&gt;=1 AND &lt;100", "name"=&gt;"~wang%"] 或混合使用 [ ["id"=&gt;"&gt;=1 AND &lt;100"], "name LIKE 'wang%'"]
["id=1", "id=2", "_or"=&gt;true]  // 下划线开头是特别选项，"_or"表示用或条件，生成"id=1 OR id=2"</code></pre>
</li>
</ul>
<p>支持前端传入的get/post参数中同时有cond参数，且cond参数允许为数组，比如传</p>
<pre><code>URL中：cond[]=a=1&amp;cond[]=b=2
POST中：cond=c=3</code></pre>
<p>后端处理</p>
<pre><code>getQueryCond([$_GET["cond"], $_POST["cond"]]);</code></pre>
<p>最终得到cond参数为&quot;a=1 AND b=2 AND c=3&quot;。</p>
<p>前端callSvr示例: url参数或post参数均可支持数组或键值对：</p>
<pre><code>callSvr("Hub.query", {res:"id", cond: {id: "&gt;=1 AND &lt;100"}})
callSvr("Hub.query", {res:"id", cond: ["id&gt;=1", "id&lt;100"]}, $.noop, {cond: {name:"~wang%", dscr:"~111"}})</code></pre>
<p>字段名支持中文，也支持带表名如<code>t0.xxx</code>的形式：</p>
<pre><code>$cond = getQueryCond([
    "t0.createTm&gt;=" =&gt; $tm1,
    "t0.createTm&lt;"  =&gt; $tm2
]);</code></pre></div>
<div class="block">
<h2 id="genQuery">@fn genQuery($sql, $cond)</h2>
<p>连接SELECT主语句(不带WHERE条件)和查询条件。<br />
示例：</p>
<pre><code>genQuery("SELECT id FROM Vendor", [name=&gt;$name, "phone"=&gt;$phone]);</code></pre>
<p>注意：当传入$name为null而$phone非null时，只生成phone的条件；而若$name和$phone都是null时，则生成没有WHERE条件的SQL，返回所有数据。</p>
<p>其它示例：</p>
<pre><code>genQuery("SELECT id FROM Vendor", [name=&gt;$name, "phone IS NOT NULL"]);
genQuery("SELECT id FROM Vendor", [name=&gt;$name, "phone"=&gt;$phone, "_or"=&gt;true]); // "name='eric' OR phone='13700000001'"</code></pre>
<p class="see"><strong>@see <a href="#getQueryCond">getQueryCond</a></strong> </p></div>
<div class="block">
<h2 id="execOne">@fn execOne($sql, $getInsertId?=false)</h2>
<p class="param"><strong>@param $getInsertId</strong> ?=false 取INSERT语句执行后得到的id. 仅用于INSERT语句。</p>
<p>执行SQL语句，如INSERT, UPDATE等。执行SELECT语句请使用queryOne/queryAll.</p>
<pre><code>$token = mparam("token");
execOne("UPDATE Cinf SET appleDeviceToken=" . Q($token));</code></pre>
<p>注意：在拼接SQL语句时，对于传入的string类型参数，应使用Q函数进行转义，避免SQL注入攻击。</p>
<p>对于INSERT语句，设置参数$getInsertId=true, 可取新加入数据行的id. 例：</p>
<pre><code>$sql = sprintf("INSERT INTO Hongbao (userId, createTm, src, expireTm, vdays) VALUES ({$uid}, '%s', '{$src}', '%s', {$vdays})", date('c', $createTm), date('c', $expireTm));
$hongbaoId = execOne($sql, true);</code></pre>
<p>(v5.1) 简单的单表添加和更新记录建议优先使用dbInsert和dbUpdate函数，更易使用。<br />
上面两个例子，用dbInsert/dbUpdate函数，无须使用Q函数防注入，也无须考虑字段值是否要加引号：</p>
<pre><code>// 更新操作示例
$cnt = dbUpdate("Cinf", ["appleDeviceToken" =&gt; $token], "ALL");

// 插入操作示例
$hongbaoId = dbInsert("Hongbao", [
    "userId"=&gt;$uid,
    "createTm"=&gt;date(FMT_DT, $createTm),
    "src" =&gt; $src, ...
]);</code></pre>
<p class="see"><strong>@see <a href="#dbInsert">dbInsert</a> <a href="#dbUpdate">dbUpdate</a> <a href="#queryOne">queryOne</a></strong> </p></div>
<div class="block">
<h2 id="queryOne">@fn queryOne($sql, $assoc = false)</h2>
<p>执行查询语句，只返回一行数据，如果行中只有一列，则直接返回该列数值。<br />
如果查询不到，返回false.</p>
<p>示例：查询用户姓名与电话，默认返回值数组：</p>
<pre><code>$row = queryOne("SELECT name,phone FROM User WHERE id={$id}");
if ($row === false)
    jdRet(E_PARAM, "bad user id");
// $row = ["John", "13712345678"]</code></pre>
<p>也可返回关联数组:</p>
<pre><code>$row = queryOne("SELECT name,phone FROM User WHERE id={$id}", true);
if ($row === false)
    jdRet(E_PARAM, "bad user id");
// $row = ["name"=&gt;"John", "phone"=&gt;"13712345678"]</code></pre>
<p>当查询结果只有一列且assoc=false时，直接返回该数值。</p>
<pre><code>$phone = queryOne("SELECT phone FROM User WHERE id={$id}");
if ($phone === false)
    jdRet(E_PARAM, "bad user id");
// $phone = "13712345678"</code></pre>
<p>(v5.3)<br />
可将WHERE条件单独指定：$cond参数形式该函数getQueryCond</p>
<pre><code>$id = queryOne("SELECT id FROM Vendor", false, ["phone"=&gt;$phone]);</code></pre>
<p>注意：如果传入的$phone为null时，此时没有WHERE条件，返回第1条数据！</p>
<p class="see"><strong>@see <a href="#queryAll">queryAll</a></strong> </p>
<p class="see"><strong>@see <a href="#getQueryCond">getQueryCond</a></strong> </p></div>
<div class="block">
<h2 id="queryAll">@fn queryAll($sql, $assoc = false)</h2>
<p>执行查询语句，返回数组。<br />
如果查询失败，返回空数组。</p>
<p>默认返回值数组(varr):</p>
<pre><code>$rows = queryAll("SELECT name, phone FROM User");
if (count($rows) &gt; 0) {
    ...
}
// 值为：
$rows = [
    ["John", "13712345678"],
    ["Lucy", "13712345679"]
    ...
]
// 可转成table格式返回
return ["h"=&gt;["name", "phone"], "d"=&gt;$rows];</code></pre>
<p>也可以返回关联数组(objarr)，如：</p>
<pre><code>$rows = queryAll("SELECT name, phone FROM User", true);
if (count($rows) &gt; 0) {
    ...
}
// 值为：
$rows = [
    ["name"=&gt;"John", "phone"=&gt;"13712345678"],
    ["name"=&gt;"Lucy", "phone"=&gt;"13712345679"]
    ...
]
// 可转成table格式返回
return objarr2table($rows);</code></pre>
<p>queryAll支持执行返回多结果集的存储过程，这时返回的不是单一结果集，而是结果集的数组：</p>
<pre><code>$allRows = queryAll("call syncAll()");</code></pre>
<p>(v5.3)<br />
可将WHERE条件单独指定：$cond参数形式该函数getQueryCond</p>
<pre><code>$rows = queryAll("SELECT id FROM Vendor", false, ["phone"=&gt;$phone]);</code></pre>
<p>注意：如果传入的$phone为null时，此时没有WHERE条件，返回所有数据！</p>
<p class="see"><strong>@see <a href="#objarr2table">objarr2table</a></strong> </p>
<p class="see"><strong>@see <a href="#getQueryCond">getQueryCond</a></strong> </p></div>
<div class="block">
<h2 id="dbInsert">@fn dbInsert(table, kv, noEscape=false) -> newId</h2>
<p>e.g. </p>
<pre><code>$orderId = dbInsert("Ordr", [
    "tm" =&gt; date(FMT_DT),
    "tm1" =&gt; dbExpr("now()"), // 使用dbExpr直接提供SQL表达式
    "amount" =&gt; 100,
    "raw" =&gt; ["id"=&gt;100, "name"=&gt;"jack"], // (v5.5) 数组转JSON保存
    "dscr" =&gt; null // null字段会被忽略
]);</code></pre>
<p>为防止XSS攻击，默认会处理字段值，将&quot;&gt;&quot;, &quot;&lt;&quot;转义为&quot;&gt;&quot;和&quot;&lt;&quot;。如果想保持原始值，可以用：</p>
<pre><code>$id = dbInsert("Ordr", [
    "cond" =&gt; dbExpr(Q("amount &gt; 100"))
]);</code></pre>
<p>或</p>
<pre><code>$id = dbInsert("Ordr", [
    "cond" =&gt; "amount &gt; 100"
], true); // noEscape=true</code></pre>
<p>如需高性能大批量插入数据，可以用BatchInsert</p>
<p class="see"><strong>@see <a href="#BatchInsert">BatchInsert</a></strong> </p></div>
<div class="block">
<h2 id="BatchInsert">@class BatchInsert</h2>
<p>大批量为某表添加记录，一次性提交。</p>
<pre><code>$bi = new BatchInsert($table, $headers, $opt=null);</code></pre>
<ul>
<li>headers: 列名数组(如[&quot;name&quot;,&quot;dscr&quot;])，或逗号分隔的字符串(如&quot;name,dscr&quot;)</li>
<li>opt.batchSize/i?=0: 指定批大小。0表示不限大小。</li>
<li>opt.useReplace/b?=false: 默认用&quot;INSERT INTO&quot;语句，设置为true则用&quot;REPLACE INFO&quot;语句。一般用于根据某unique index列添加或更新行。</li>
<li>
<p>opt.debug/b?=false: 如果设置为true, 只输出SQL语句，不插入数据库。</p>
<p>$bi-&gt;add($row);</p>
</li>
<li>row: 可以是值数组或关联数组。如果是值数组，必须与headers一一对应，比如[&quot;name1&quot;, &quot;dscr1&quot;]；<br />
如果是关联数组，按headers中字段自动取出值数组，这样关联数组中即使多一些字段也无影响，比如[&quot;name&quot;=&gt;&quot;name1&quot;, &quot;dscr&quot;=&gt;&quot;dscr1&quot;, &quot;notUsedCol&quot;=100]。</li>
</ul>
<p>示例：</p>
<pre><code>$bi = new BatchInsert("Syslog", "module,tm,content");
for ($i=0; $i&lt;10000; ++$i)
    $bi-&gt;add([$m, $tm, $content]);
$n = $bi-&gt;exec();</code></pre>
<p>如果担心一次请求数量过多，也可以指定批大小，如1000行提交一次：</p>
<pre><code>$opt = [
    "batchSize" =&gt;1000
]
$bi = new BatchInsert("Syslog", "module,tm,content", $opt);</code></pre>
<ul>
<li>opt: {batchSize/i, useReplace/b}</li>
</ul></div>
<div class="block">
<h2 id="dbExpr">@fn dbExpr($val)</h2><div class="toc"><p style="margin-left:0em"><a href="#dbExpr-1 用于在dbInsert/dbUpdate(插入或更新数据库)时，使用表达式：">1 用于在dbInsert/dbUpdate(插入或更新数据库)时，使用表达式：</a></p>
<p style="margin-left:0em"><a href="#dbExpr-2 也用于直接返回字符串数据，不经JSON编码处理，示例：">2 也用于直接返回字符串数据，不经JSON编码处理，示例：</a></p>
</div>
<h4 id="dbExpr-1 用于在dbInsert/dbUpdate(插入或更新数据库)时，使用表达式：">1 用于在dbInsert/dbUpdate(插入或更新数据库)时，使用表达式：</h4>
<pre><code>$id = dbInsert("Ordr", [
    "tm" =&gt; dbExpr("now()") // 使用dbExpr直接提供SQL表达式
]);</code></pre>
<p>另外，写数据库时，为防止XSS跨域攻击，param/mparam/dbInsert/dbUpdate对值会自动做htmlentity转义(本项目用htmlEscape函数)，如&quot;&gt;7&quot;转成&quot;&gt;7&quot;。<br />
为防止转义，使用原始字串值，可以用：</p>
<pre><code>// 防止param/mparam转义，设置doHtmlEscape参数=false; 或直接从$_GET/$_POST中取值
$value = mparam("value", null, false); // 第3参数是doHtmlEscape
$value1 = $_POST["value1"]; // 不用param函数

// 防止dbInsert/dbUpdate转义，用dbExpr和Q函数。
$id = dbUpdate("Ordr", [
    "cond" =&gt; dbExpr(Q("f&gt;3 &amp;&amp; r&lt;60")); // 注意用Q函数对字符串加引号
]);</code></pre>
<p>示例：对象set/add接口中，防止某字段被转义：</p>
<pre><code>protected function onValidate()
{
    if (issetval("cond")) {
        $_POST["cond"] = dbExpr(Q($_POST["cond"]));
    }
}</code></pre>
<h4 id="dbExpr-2 也用于直接返回字符串数据，不经JSON编码处理，示例：">2 也用于直接返回字符串数据，不经JSON编码处理，示例：</h4>
<pre><code>function api_test2()
{
    $ret = '{"a":100, "b":[3,4]}';
    return dbExpr($ret);
    // 接口输出 [0, {"a":100, "b":[3,4]}]
    // 也可以用 jdRet(0, dbExpr($ret));
}</code></pre>
<p class="see"><strong>@see <a href="#dbInsert">dbInsert</a></strong> </p>
<p class="see"><strong>@see <a href="#dbUpdate">dbUpdate</a></strong> </p></div>
<div class="block">
<h2 id="dbUpdate">@fn dbUpdate(table, kv, id_or_cond?, noEscape=false) -> cnt</h2>
<p class="param"><strong>@param id_or_cond</strong>  查询条件，如果是数值比如100或"100"，则当作条件"id=100"处理；否则直接作为查询表达式，比如"qty<0"；</p>
<p>为了安全，cond必须指定值，不可为空（避免因第三参数为空导致误更新全表!）。如果要对全表更新，可传递特殊值&quot;ALL&quot;，或用&quot;1=1&quot;之类条件。</p>
<p>e.g.</p>
<pre><code>// UPDATE Ordr SET ... WHERE id=100
$cnt = dbUpdate("Ordr", [
    "amount" =&gt; 30,
    "dscr" =&gt; "test dscr",
    "raw" =&gt; ["id"=&gt;100, "name"=&gt;"jack"], // (v5.5) 数组转JSON保存
    "tm" =&gt; "null", // 用""或"null"对字段置空；用"empty"对字段置空串。
    "tm1" =&gt; null // null会被忽略
], 100);

// UPDATE Ordr SET tm=now() WHERE tm IS NULL
$cnt = dbUpdate("Ordr", [
    "tm" =&gt; dbExpr("now()")  // 使用dbExpr，表示是SQL表达式
], "tm IS NULL);

// 全表更新，没有条件。UPDATE Cinf SET appleDeviceToken={token}
$cnt = dbUpdate("Cinf", ["appleDeviceToken" =&gt; $token], "ALL");</code></pre>
<p>cond条件可以用key-value指定(cond写法参考getQueryCond)，如：</p>
<pre><code>dbUpdate("Task", ["vendorId" =&gt; $id], ["vendorId" =&gt; $id1]);
基本等价于 (当id1为null时稍有不同, 上面生成"IS NULL"，而下面的SQL为"=null"非标准)
dbUpdate("Task", ["vendorId" =&gt; $id], "vendorId=$id1"]);</code></pre>
<p>为防止XSS攻击，默认会处理字段值，将&quot;&gt;&quot;, &quot;&lt;&quot;转义为&quot;&gt;&quot;和&quot;&lt;&quot;。如果想保持原始值，可以用：</p>
<pre><code>$cnt = dbUpdate("Ordr", [
    "cond" =&gt; dbExpr(Q("amount &gt; 100"))
]);</code></pre>
<p>或</p>
<pre><code>$cnt = dbUpdate("Ordr", [
    "cond" =&gt; "amount &gt; 100"
], null, true); // noEscape=true</code></pre></div>
<div class="block">
<h2 id="SimpleCache">@class SimpleCache</h2>
<p>缓存在数组中。适合在循环中缓存key-value数据。</p>
<pre><code>$cache = new SimpleCache(); // id=&gt;name
for ($idList as $id) {
    $name = $cache-&gt;get($id, function () use ($id) {
        return queryOne("SELECT name FROM Vendor WHERE id=$id");
    });
}</code></pre>
<p>更简单地，也可以直接使用全局的cache (这时注意确保key在全局唯一）：</p>
<pre><code>for ($idList as $id) {
    $name = SimpleCache::getInstance()-&gt;get("VendorIdToName-{$id}", function () use ($id) {
        return queryOne("SELECT name FROM Vendor WHERE id=$id");
    })
}</code></pre>
<p>示例2：</p>
<pre><code>$key = join('-', [$name, $phone]);
$id = $cache-&gt;get($key);
if ($id === false) {
    $val = getVal();
    $cache-&gt;set($key, $val);
}</code></pre></div>
<div class="block">
<h2 id="FileCache">@class FileCache</h2>
<p>简单的文件cache方案, 单机时可替代redis.</p>
<pre><code>$myval = FileCache::get("myval.cache.json", function () {
    return queryAll("SELECT ...", true);
}, ["timeout" =&gt; T_HOUR*4]);</code></pre>
<ul>
<li>文件名建议为&quot;{变量名}.cache.json&quot;</li>
<li>timeout选项指定超时时间(秒), 默认不超时.</li>
</ul></div>
<div class="block">
<h2 id="getBaseUrl">@fn getBaseUrl($wantHost = true)</h2>
<p>返回 $BASE_DIR 对应的网络路径（最后以&quot;/&quot;结尾），一般指api.php所在路径。<br />
如果指定了环境变量 P_BASE_URL(可在conf.user.php中设置), 则使用该变量。<br />
否则自动判断（如果有代理转发则可能不准）</p>
<p>例：</p>
<pre><code>getBaseUrl() -&gt; "http://myserver.com/myapp/"
getBaseUrl(false) -&gt; "/myapp/"</code></pre>
<p>注意：如果使用了反向代理等机制，该函数往往无法返回正确的值，<br />
例如 <a href="http://myserver.com/8081/myapp/api.php">http://myserver.com/8081/myapp/api.php</a> 被代理到 <a href="http://localhost:8081/myapp/api.php">http://localhost:8081/myapp/api.php</a><br />
getBaseUrl()默认返回 &quot;<a href="http://localhost:8081/myapp/">http://localhost:8081/myapp/</a>&quot; 是错误的，可以设置P_BASE_URL解决：</p>
<pre><code>putenv("P_BASE_URL=http://myserver.com/8081/myapp/");</code></pre>
<p class="see"><strong>@see <a href="#$BASE_DIR">$BASE_DIR</a></strong> </p></div>
<div class="block">
<h2 id="ENC_KEY">@var ENC_KEY = 'jdcloud'</h2>
<p>默认加密key。可在api.php等处修改覆盖。</p></div>
<div class="block">
<h2 id="rc4">@fn rc4($data, $pwd)</h2>
<p>返回密文串（未编码的二进制，可用base64或hex编码）。<br />
RC4加密算法。基于异或的算法。<br />
<a href="https://www.cnblogs.com/haoxuanchen2014/p/7783782.html">https://www.cnblogs.com/haoxuanchen2014/p/7783782.html</a></p>
<p>更完善的短字符串编码，可以使用</p>
<p class="see"><strong>@see <a href="#jdEncrypt">jdEncrypt</a></strong>  基于rc4的文本加密</p>
<p class="see"><strong>@see <a href="#jdEncryptI">jdEncryptI</a></strong>  基于rc4的32位整数加密</p></div>
<div class="block">
<h2 id="jdEncrypt">@fn jdEncrypt($string, $enc=E|D, $fmt=b64|hex, $key=$ENC_KEY, $vcnt=4)</h2>
<p>基于rc4算法的文本加密，缺省密码为全局变量 $ENC_KEY。<br />
enc=E表示加密，enc=D表示解密。</p>
<pre><code>$cipher = jdEncrypt("hello");
$text = jdEncrypt($cipher, "D");
if ($text === false)
    throw "bad cipher";</code></pre>
<p>缺省返回base64编码的密文串，可设置参数$fmt=&quot;hex&quot;输出16进制编码的密文串。<br />
算法包含了校验机制，解密时如果校验失败则返回false.</p>
<p class="param"><strong>@param vcnt</strong>  校验字节数，默认为4. validation bytes cnt</p>
<p class="see"><strong>@see <a href="#rc4">rc4</a></strong>  基础rc4算法</p>
<p class="see"><strong>@see <a href="#jdEncryptI">jdEncryptI</a></strong>  基于rc4的32位整数加密</p></div>
<div class="block">
<h2 id="jdEncryptI">@fn jdEncryptI($data, $enc=E|D, $fmt=hex|b64, $key=$ENC_KEY)</h2>
<p>基于rc4算法的32位整数加解密，缺省密码为全局变量$ENC_KEY.</p>
<pre><code>$cipher = jdEncryptI(12345678, "E"); // dfa27c4c208489ca (4字节校验+4字节整数=8字节，用16进制文本表示为16个字节)
$n = jdEncryptI($cipher, "D");
if ($n === false)
    throw "bad cipher";</code></pre>
<p>可用于将整型id伪装成8字节的uuid.</p>
<p class="see"><strong>@see <a href="#rc4">rc4</a></strong>  基础rc4算法</p>
<p class="see"><strong>@see <a href="#jdEncrypt">jdEncrypt</a></strong>  基于rc4的文本加密</p></div>
<div class="block">
<h2 id="errQuit">@fn errQuit($code, $msg, $msg2 =null)</h2>
<p>生成html格式的错误信息并中止执行。<br />
默认地，只显示中文错误，双击可显示详细信息。<br />
例：</p>
<pre><code>errQuit(E_PARAM, "接口错误", "Unknown ac=`$ac`");</code></pre></div>
<div class="block">
<h2 id="addLog">@fn addLog($data, $logLevel=0)</h2>
<p>输出调试信息到前端。调试信息将出现在最终的JSON返回串中。<br />
如果只想输出调试信息到文件，不想让前端看到，应使用logit.</p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p></div>
<div class="block">
<h2 id="hasSignFile">@fn hasSignFile($f)</h2>
<p>检查应用根目录下($BASE_DIR)下是否存在标志文件。标志文件一般命名为&quot;CFG_XXX&quot;, 如&quot;CFG_MOCK_MODE&quot;等。</p></div>
<div class="block">
<h2 id="htmlEscape">@fn htmlEscape($s)</h2>
<p>用于防止XSS攻击。只转义字符&quot;&lt;&quot;, &quot;&gt;&quot;，示例：<br />
当用户保存<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>时，实际保存的是<code>&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;</code><br />
这样，当前端以<code>$div.html($val)</code>来显示时，不会产生跨域攻击泄漏Cookie。</p>
<p>如果前端就是需要带&quot;<>&quot;的字符串（如显示在input中），则应自行转义。</p>
<p>后端转义可以用html_entity_decode:</p>
<pre><code>$s = "a&amp;gt;1 and a&amp;lt;100";
$s1 = html_entity_decode($s);</code></pre></div>
<div class="block">
<h2 id="name2id">@fn name2id($refNameFields, $refIdField, $refTable, $nameFields, $opt=[])</h2>
<p>常用于导入，或数据同步，把code/name等唯一字段替换成内部id.</p>
<ul>
<li>支持缓存数据，以优化循环效率</li>
<li>
<p>支持查不到时报错或自动添加两种模式</p>
</li>
<li>opt={arr, doAutoAdd, onAdd}</li>
</ul>
<p>实例：如果给定数组（默认$_POST）含有cateName字段，则通过查询表ItemCategory中的name字段，得到相应的id字段，用cateId字段替代原cateName字段：</p>
<pre><code>name2id("cateName", "cateId", "ItemCategory", "name");
(即 cateId = SELECT id FROM ItemCategory WHERE name={cateName} )
或
name2id("cateName", "cateId", "ItemCategory", "name", ["arr" =&gt; &amp;$_POST]);</code></pre>
<p>如果查不到则会报错。<br />
也可指定不报错(doAutoAdd)，直接插入ItemCategory表中，用新插入的id值作为cateId字段，替代原cateName字段：</p>
<pre><code>name2id("cateName", "cateId", "ItemCategory", "name", ["doAutoAdd"=&gt;true]);</code></pre>
<p>如果添加时还要指定其它字段，指定onAdd：</p>
<pre><code>name2id("cateName", "cateId", "ItemCategory", "name", [
    "doAutoAdd"=&gt;true, 
    "onAdd" =&gt; function (&amp;$data) {
        $data["contactName"] = $_POST["cateContactName"];
        $data["tm"] = date(FMT_DT);
    },
    // "arr" =&gt; &amp;$myarr, // 修改$myarr数组，而不是默认的$_POST，注意加'&amp;'
]);</code></pre>
<p>TODO: 支持多字段联合查询:</p>
<pre><code>name2id("city,storeName", "storeId", "Store", "city,name");</code></pre></div>
<div class="block">
<h2 id="JDPDO">@class JDPDO</h2>
<p>数据库类PDO增强。getJDEnv()-&gt;DBH为默认数据库连接，dbconn,queryAll,execOne等数据库函数都使用它。</p>
<ul>
<li>在调试等级P_DEBUG=9时，将SQL日志输出到前端，即<code>addLog(sqlStr, DEBUG=9)</code>。</li>
<li>如果有符号文件CFG_CONN_POOL，则使用连接池（缺省不用）</li>
</ul>
<p>如果想忽略输出一条SQL日志，可以在调用SQL查询前设置skipLogCnt，如：</p>
<pre><code>$env = getJDEnv();
++ $env-&gt;DBH-&gt;skipLogCnt;  // 若要忽略两条就用 $env-&gt;DBH-&gt;skipLogCnt+=2
$env-&gt;DBH-&gt;exec('set names utf8mb4'); // 也可以是queryOne/execOne等函数。</code></pre>
<p>设置<code>$GLOBALS["conf_disableSkipLog"]=1</code>可忽略skipLogCnt机制，常用于数据库底层调试。</p>
<p class="see"><strong>@see <a href="#queryAll">queryAll</a> <a href="#execOne">execOne</a> <a href="#dbconn">dbconn</a></strong> </p></div>
<div class="block">
<h2 id="conf_tableAlias">@key conf_tableAlias 配置数据库表的别名</h2>
<p>常用于跨库调用和jdcloud微服务配置。<br />
例如主系统saic需要集成erp子系统用于库存管理，在erp子系统中应配置直接使用主系统saic中的用户、权限等表，可在conf.user.php中配置：</p>
<pre><code>$GLOBALS["conf_tableAlias"] = [
    "Employee" =&gt; "saic.Employee",
    "Role" =&gt; "saic.Role",
    "Cinf" =&gt; "saic.Cinf",
    "ApiLog" =&gt; "saic.ApiLog",
    "ObjLog" =&gt; "saic.ObjLog",
    "Syslog" =&gt; "saic.Syslog"
];</code></pre></div>
<div class="block">
<h2 id="JDSingleton">@class JDSingleton (trait)</h2>
<p>用于单件类，提供getInstance方法，例：</p>
<pre><code>class PluginCore
{
    use JDSingleton;
}</code></pre>
<p>则可以调用</p>
<pre><code>$pluginCore = PluginCore::getInstance();</code></pre></div>
<div class="block">
<h2 id="JDSingletonImp">@class JDSingletonImp (trait)</h2>
<p>用于单件基类，提供getInstance方法。<br />
使用时类名应以Base结尾，使用者可以重写该类，一般用于接口实现。例：</p>
<pre><code>class PayImpBase
{
    use JDSingletonImp;
}

// 使用者重写Base类的某些方法
class PayImp extends PayImpBase
{
}</code></pre>
<p>则可以调用</p>
<pre><code>$pay = PayImpBase::getInstance();
// 创建的是PayImp类。如果未定义PayImp类，则创建PayImpBase类，或是当Base类是abstract类时将抛出错误。</code></pre></div>
<div class="block">
<h2 id="JDEvent">@class JDEvent (trait)</h2>
<p>提供事件监听(on)与触发(trigger)方法，例：</p>
<pre><code>class PluginCore
{
    use JDEvent;

    // 提供事件"event1", 注释如下：
    /// @event PluginCore.event.event1($arg1, $arg2)
}</code></pre>
<p>则可以调用</p>
<pre><code>$pluginCore-&gt;on('event1', 'onEvent1');
$pluginCore-&gt;trigger('event1', [$arg1, $arg2]);

function onEvent1($arg1, $arg2)
{
}</code></pre></div>
<div class="block">
<h2 id="JDEvent.on">@fn JDEvent.on($ev, $fn)</h2></div>
<div class="block">
<h2 id="JDEvent.trigger">@fn JDEvent.trigger($ev, $args)</h2>
<p>返回最后次调用的返回值，false表示中止之后事件调用 </p>
<p>如果想在事件处理函数中返回值，可使用引用传递:</p>
<pre><code>$obj-&gt;on('getResult', 'onGetResult');
$a = []; $b = null;
$obj-&gt;trigger('getResult', [&amp;$a, &amp;$b]);

function onGetResult(&amp;$a, &amp;$b)
{
    $a[] = 100;
    $b = 'hello';
}</code></pre>
<p>也可使用值传递, 通过一个对象来操作:</p>
<pre><code>$obj-&gt;on('getResult', 'onGetResult');
$out = new stdclass();
$out-&gt;result = [];
$obj-&gt;trigger('getResult', [$out]);

function onGetResult($out)
{
    $out-&gt;result[] = 100;
}</code></pre></div>
<div class="block">
<h2 id="ext">@module ext 集成外部系统</h2>
<p>调用外部系统（如短信集成、微信集成等）将引入依赖，给开发和测试带来复杂性。<br />
筋斗云框架通过使用“模拟模式”(MOCK_MODE)，模拟这些外部功能，从而简化开发和测试。</p>
<p>对于一个简单的外部依赖，可以用函数isMockMode来分支。例如添加对象存储服务(OSS)支持，接口定义为：</p>
<pre><code>getOssParam() -&gt; {url, expire, dir, param={policy, OSSAccessKeyId, signature} }
模拟模式返回：
getOssParam() -&gt; {url="mock"}</code></pre>
<p>在实现时，先在ext.php中定义外部依赖类型，如Ext_Oss，然后实现函数：</p>
<pre><code>function api_getOssParam()
{
    if (isMockMode(Ext_Oss)) {
        return ["url"=&gt;"mock"];
    }
    // 实际实现代码 ...
}</code></pre>
<p>添加一个复杂的（如支持多个函数调用的）支持模拟的外部依赖，也则可以定义接口，步骤如下，以添加短信支持(SmsSupport)为例：</p>
<ul>
<li>定义一个新的类型，如Ext_SmsSupport.</li>
<li>定义接口，如 ISmsSupport.</li>
<li>在ExtMock类中模拟实现接口ISmsSupport中所有函数, 一般是调用logext()写日志到ext.log, 可以在tool/log.php中查看最近的ext日志。</li>
<li>定义一个类SmsSupport实现接口ISmsSupport，一般放在其它文件中实现(如sms.php)。</li>
<li>在onCreateExt中处理新类型Ext_SmsSupport, 创建实际接口对象。</li>
</ul>
<p>使用举例：</p>
<pre><code>$sms = getExt(Ext_SmsSupport);
$sms-&gt;sendSms(...);</code></pre>
<p>要激活模拟模式，应在conf.user.php中设置：</p>
<pre><code>putenv("P_TEST_MODE=1");
putenv("P_MOCK_MODE=1");

// 或者只开启部分模块的模拟：
// putenv("P_MOCK_MODE=sms,wx");</code></pre>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p></div>
<div class="block">
<h2 id="isMockMode">@fn isMockMode($extType)</h2>
<p>判断是否模拟某外部扩展模块。如果$extType为null，则只要处于MOCK_MODE就返回true.</p></div>
<div class="block">
<h2 id="ExtFactory::getInstance">@fn ExtFactory::getInstance()</h2>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p></div>
<div class="block">
<h2 id="ExtFactory::getObj">@fn ExtFactory::getObj($extType, $allowMock?=true)</h2>
<p>获取外部依赖对象。一般用getExt替代更简单。</p>
<p>示例：</p>
<pre><code>$sms = ExtFactory::getInstance()-&gt;getObj(Ext_SmsSupport);</code></pre>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p></div>
<div class="block">
<h2 id="getExt">@fn getExt($extType, $allowMock = true)</h2>
<p>用于取外部接口对象，如：</p>
<pre><code>$sms = getExt(Ext_SmsSupport);</code></pre></div>
<div class="block">
<h2 id="logext">@fn logext($s, $addHeader?=true)</h2>
<p>写日志到ext.log中，可在线打开tool/init.php查看。<br />
(logit默认写日志到trace.log中)</p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p></div>
<div class="block">
<h2 id="limitApiCall">@fn limitApiCall($name, $sec)</h2>
<p>对接口printSheet限制10秒内只能调用1次（按session限制，即限制用户登录后的连续调用）：</p>
<pre><code>// $_SESSION["printSheetTm"]将记录上次调用时间
limitApiCall("printSheet", 10); // 10s内不允许重复调用</code></pre>
<p>TODO: 全局限定</p>
<pre><code>limitApiCall("printSheet", 10, ["useSession"=&gt;false]);</code></pre>
<p>TODO: 限制10s秒内对同一订单只能调用1次：</p>
<pre><code>// $_SESSION["printSheetTm"]将记录一个时间数组
limitApiCall("printSheet", 10, [
    "key" =&gt; orderId
]);</code></pre></div>
<div class="block">
<h2 id="JDEnv">@module JDEnv</h2><div class="toc"><p style="margin-left:0em"><a href="#JDEnv-1 函数型接口">1 函数型接口</a></p>
<p style="margin-left:0em"><a href="#JDEnv-2 对象型接口">2 对象型接口</a></p>
<p style="margin-left:2em"><a href="#JDEnv-2.1 标准对象接口">2.1 标准对象接口</a></p>
<p style="margin-left:2em"><a href="#JDEnv-2.2 非标准对象接口">2.2 非标准对象接口</a></p>
<p style="margin-left:2em"><a href="#JDEnv-2.3 RESTful风格接口">2.3 RESTful风格接口</a></p>
<p style="margin-left:0em"><a href="#JDEnv-3 接口复用">3 接口复用</a></p>
<p style="margin-left:0em"><a href="#JDEnv-4 常用操作">4 常用操作</a></p>
<p style="margin-left:0em"><a href="#JDEnv-5 插件机制">5 插件机制</a></p>
</div>
<p class="alias"><strong>@alias <a id="api_fw">api_fw</a></strong> </p>
<p>服务接口实现框架。</p>
<p>服务接口包含：</p>
<ul>
<li>函数型接口，如 &quot;login&quot;, &quot;getToken&quot;等, 一般实现在 api_functions.php中。</li>
<li>对象型接口，如 &quot;Ordr.query&quot;, &quot;User.get&quot; 等，一般实现在 api_objects.php中。</li>
</ul>
<p>关于参数传递，除add/set等接口有特殊要求外（添加或修改的字段必须用POST传递），<br />
一般用GET或POST传递参数均可。使用POST传参时，Content-Type支持 application/x-www-form-urlencoded , application/form-data , application/json。</p>
<p>示例：接口定义<code>fn(a, b) -&gt; {id}</code>，可以这样调用：</p>
<pre><code>GET /api.php/fn?a=1&amp;b=2</code></pre>
<p>返回示例：<code>[0, {"id":1}]</code></p>
<p>或用POST传参：</p>
<pre><code>POST /api.php/fn
Content-Type: application/x-www-form-urlencoded

a=1&amp;b=2</code></pre>
<p>或</p>
<pre><code>POST /api.php/fn
Content-Type: application/json

{"a":1,"b":2}</code></pre>
<p>甚至混用GET/POST传参：</p>
<pre><code>POST /api.php/fn?a=1
Content-Type: application/x-www-form-urlencoded

b=2</code></pre>
<p>如果使用筋斗云前端JS，可以调用：</p>
<pre><code>callSvr("fn", {a:1, b:2}); // 用GET传参

callSvr("fn", $.noop, {a:1, b:2}); // 用POST传参. $.noop是jQuery定义的空函数，这里只用于占位，表示空的回调函数。

callSvr("fn", $.noop, JSON.stringify({a:1, b:2}), {
    contentType: "application/json"
}); // 用POST传参, json格式

callSvr("fn", {a:1}, $.noop, {b:2}); // 用GET,POST混合传参</code></pre>
<p>GET或POST传参时，编码默认使用UTF-8。<br />
POST传参时支持其它编码，应在Content-Type中显示指定，如下面指定编码为<code>charset=gbk</code>：</p>
<pre><code>POST /api.php/fn
Content-Type: application/x-www-form-urlencoded; charset=gbk

a=参数1&amp;b=参数2</code></pre>
<h4 id="JDEnv-1 函数型接口">1 函数型接口</h4>
<p>假设在文档有定义以下接口</p>
<pre><code>用户修改密码
chpwd(oldpwd, pwd) -&gt; {_token, _expire}

权限：AUTH_USER</code></pre>
<p>则在 api_functions.php 中创建该接口的实现：</p>
<pre><code>function api_chpwd()
{
    checkAuth(AUTH_USER);
    $oldPwd = mparam("oldpwd");
    $pwd = mparam("pwd");
    ...
    $ret = [
        "_token" =&gt; $token,
        "_expire" =&gt; $expire,
    ];
    return $ret;
}</code></pre>
<p>说明：</p>
<ul>
<li>函数名称一定要符合 &quot;api_{接口名}&quot; 的规范。接口名以小写字母开头。</li>
<li>使用checkAuth进行权限检查</li>
<li>返回符合接口定义的对象。最终后端框架将其转为JSON串，再由前端框架解析后传递给应用程序。</li>
</ul>
<p class="see"><strong>@see <a href="#checkAuth">checkAuth</a></strong> </p>
<p class="see"><strong>@see <a href="#mparam">mparam</a></strong>  取必选参数，如果缺少该参数则报错。</p>
<p class="see"><strong>@see <a href="#param">param</a></strong>  取可选参数，可指定缺省值。</p>
<h4 id="JDEnv-2 对象型接口">2 对象型接口</h4>
<p class="see"><strong>@see <a href="#AccessControl">AccessControl</a></strong>  对象型接口框架。</p>
<h5 id="JDEnv-2.1 标准对象接口">2.1 标准对象接口</h5>
<p>5个标准对象操作为：add, set, query, get, del。<br />
这些操作提供对象的基本增删改查(CRUD)以及列表查询、统计分析、导出等服务，称为通用对象接口。<br />
详细可参考BQP协议文档中的 <strong><a href="BQP.html#通用对象操作接口">通用对象操作接口</a></strong> 部分。</p>
<p>以下代码即为Ordr对象创建所有这些接口:</p>
<pre><code>class AC_Ordr extends AccessControl
{
}</code></pre>
<p><strong>[添加操作]</strong></p>
<pre><code>Obj.add()(POST fields...) -&gt; id
Obj.add(res)(POST fields...) -&gt; {fields...} (返回的字段由res参数指定)</code></pre>
<p>对象的属性通过POST请求内容给出，为一个个键值对。<br />
添加完成后，默认返回新对象的id, 如果想多返回其它字段，可设置res参数，如 </p>
<pre><code>Ordr.add()(status="CR", total=100) -&gt; 809
Ordr.add(res="id,status,total")(status="CR", total=100) -&gt; {id: 810, status:"CR", total: 100}</code></pre>
<p><strong>[更新操作]</strong></p>
<pre><code>Obj.set(id)(POST fields...)</code></pre>
<p>与add操作类似，对象属性的修改通过POST请求传递，而在URL参数中需要有id标识哪个对象。</p>
<p>示例：</p>
<pre><code>Obj.set(809)(status="PA", empId=10)</code></pre>
<p>如果要将某字段置空, 可以用空串或&quot;null&quot; (小写)。例如：</p>
<pre><code>Obj.set(809)(picId="", empId=null)
（实际传递参数的形式为 "picId=&amp;empId=null"）</code></pre>
<p>这两种方式都是将字段置NULL。<br />
如果要将字符串置空串(一般不建议使用)，可以用&quot;empty&quot;, 例如：</p>
<pre><code>Obj.set(809)(sn=empty)</code></pre>
<p>假如sn是数值类型，会导致其值为0或0.0。</p>
<p><strong>[获取对象操作]</strong></p>
<p>接口原型：</p>
<pre><code>Obj.get(id, res?) -&gt; {fields...}</code></pre>
<p>默认返回所有暴露的属性，通过res参数可以指定需要返回的字段。</p>
<p><strong>[删除操作]</strong></p>
<pre><code>Obj.del(id)</code></pre>
<p>根据id删除一个对象。</p>
<p><strong>[查询操作]</strong></p>
<pre><code>查询列表(默认压缩表格式)：
Obj.query(res?, cond?, distinct?=0) -&gt; tbl(fields...) = {nextkey?, total?, @h, @d}

查询列表 - 对象列表格式：
Obj.query(fmt=list, ...) -&gt; {nextkey?, total?, @list=[obj1, obj2...]}</code></pre>
<ul>
<li>
<p>res: String. 指定返回字段, 多个字段以逗号分隔，例如, res=&quot;field1,field2&quot;。<br />
在res中允许使用部分统计函数&quot;sum&quot;与&quot;count&quot;, 这时必须指定字段别名, 如&quot;count(id) cnt&quot;, &quot;sum(qty*price) total&quot;, &quot;count(distinct addr) addrCnt&quot;.</p>
</li>
<li>
<p>cond: String. 指定查询条件，语法可参照SQL语句的&quot;WHERE&quot;子句。例如：cond=&quot;field1&gt;100 AND field2='hello'&quot;, 注意使用UTF8+URL编码, 字符串值应加上单引号.<br />
(v5.1) 支持在GET/POST中同时传cond参数，且允许cond参数为数组。比如URL中：<code>cond[]=a=1&amp;cond[]=b=2</code>，在POST中：<code>cond=c=3</code>，则后端识别为 cond=&quot;a=1 AND b=2 AND c=3&quot;. 参数gcond也是一样。</p>
</li>
<li>
<p>orderby: String. 指定排序条件，语法可参照SQL语句的&quot;ORDER BY&quot;子句，例如：orderby=&quot;id desc&quot;，也可以多个排序：&quot;tm desc,status&quot; (按时间倒排，再按状态正排)</p>
</li>
<li>distinct: Boolean. 如果为1, 生成&quot;SELECT DISTINCT ...&quot;查询.</li>
</ul>
<p>返回字段:</p>
<ul>
<li>h/d: 两个数组。实际数据表的头信息(header)和数据行(data)，符合压缩表对象的格式。</li>
</ul>
<p>压缩表格式示例:</p>
<pre><code>{
    h: ["id", "name"],
    d: [[100, "myname1"], [200, "myname2"]]
}</code></pre>
<p>如果使用参数fmt=list, 则返回格式示例如下: </p>
<pre><code>{
    list: [{id: 100, name: "name1"}, {id: 101, name: "name2"}]
    nextkey: ...
}</code></pre>
<p><strong>[分页查询]</strong></p>
<pre><code>Obj.query(pagesz?=20, pagekey?) -&gt; {nextkey?, total?, @h, @d}
或
Obj.query(rows?=20, page?) -&gt; 同上</code></pre>
<ul>
<li>pagesz/rows: Integer. 这两个参数含义相同，均表示页大小，默认为20条数据。</li>
<li>pagekey: Integer. 一般首次查询时不填写（或填写0，表示需要返回总记录数即total字段），而下次查询时应根据上次调用时返回数据的&quot;nextkey&quot;字段来填写。</li>
<li>page: Integer. 指定页数, 从1开始. 用于兼容传统指定页数式的分页查询, 效率较低. 这时返回的nextkey一定为page+1或为空(表示没有下页), 且必返回total字段.</li>
</ul>
<p>返回字段:</p>
<ul>
<li>nextkey: Integer. 一个字符串, 供取下一页时填写参数&quot;pagekey&quot;。如果不存在该字段，则说明已经是最后一批数据。</li>
<li>total: Integer. 返回总记录数，仅当&quot;pagekey&quot;指定为0时返回; 或是使用&quot;page&quot;参数时也会返回该属性。</li>
</ul>
<p><strong>[分组统计]</strong></p>
<pre><code>Obj.query(gres, gcond?, ...) -&gt; tbl(fields...)</code></pre>
<ul>
<li>
<p>gres: String. 分组字段。如果设置了gres字段，则res参数中每项应该带统计函数，如&quot;sum(cnt) sum, count(id) userCnt&quot;.<br />
最终返回列为gres参数指定的列加上res参数指定的列; 如果res参数未指定，则只返回gres参数列。(v6.1) 如果指定参数gresHidden=1，gres则不会自动加到最终结果列中。</p>
</li>
<li>gcond: String. (jdcloud-php扩展) 分组过滤条件(对照SQL HAVING子句).</li>
</ul>
<p><strong>[导出报表]</strong></p>
<pre><code>Obj.query(fmt=csv/txt/excel, ...) -&gt; 文件内容</code></pre>
<h5 id="JDEnv-2.2 非标准对象接口">2.2 非标准对象接口</h5>
<p>v3.4支持非标准对象接口。实现Ordr.cancel接口：</p>
<pre><code>class AC2_Ordr extends AccessControl
{
    function api_cancel() {
    }
}</code></pre>
<p>非标准对象接口与与函数型接口写法类似，但AccessControl的众多回调函数对非标准对象接口无效。</p>
<h5 id="JDEnv-2.3 RESTful风格接口">2.3 RESTful风格接口</h5>
<p>对象型接口支持仿RESTful风格的调用。<br />
标准CRUD操作：</p>
<pre><code>POST /Ordr
等价于Ordr.add

GET /Ordr
等价于Ordr.query

GET /Ordr/123
等价于Ordr.get?id=123

PATCH /Ordr/123
等价于Ordr.set?id=123

DELETE /Ordr/123
等价于Ordr.del?id=123</code></pre>
<p>非标准操作：(v5.1新增) 谓词使用GET或POST都可以</p>
<pre><code>POST /Ordr/123/cancel
等价于Ordr.cancel?id=123</code></pre>
<ul>
<li>URL中id位置可在action后面，也可没有，如 <code>/Ordr/cancel/123</code>, <code>/Ordr/cancel?id=123</code>均可。</li>
<li>也允许以此方式调用标准CRUD操作，如<code>GET /Ordr/get/123</code>即<code>Ordr.get?id=123</code> , <code>POST /Ordr/123/set</code>即<code>Ordr.set?id=123</code>等.</li>
</ul>
<p>注意以下与RESTful惯例不一致：</p>
<ul>
<li>对象（或称实体，Entity）首字母应大写。</li>
<li>返回数据与对象型调用完全一样，HTTP总返回200成功，不会通过HTTP状态码表示调用返回值。</li>
</ul>
<h4 id="JDEnv-3 接口复用">3 接口复用</h4>
<p>内部调用接口：</p>
<pre><code>// 函数型接口
$rv = callSvcInt("test1");
// 对象型接口，自动根据当前权限匹配类：
$objArr = callSvcInt("MyObj.query", ["fmt"=&gt;"array", "cond"=&gt;...]);</code></pre>
<p>常用对象的add/set/query接口替代dbInsert/dbUpdate/queryOne/queryAll这些底层数据库函数，以支持对象中的定制逻辑。</p>
<p>调用指定类的接口：</p>
<pre><code>$ac = new AC2_MyObj();
$objArr = $ac-&gt;callSvc("MyObj", "query", ["fmt"=&gt;"array", "cond"=&gt;...]);</code></pre>
<p>特别地，在AC类内部调用同类接口：</p>
<pre><code>$objArr = $this-&gt;callSvc(null, "query", ["fmt"=&gt;"array", "cond"=&gt;...]);</code></pre>
<p>注意：以上所有调用失败时，将直接向上抛出异常；且不记录调用日志（ApiLog）。</p>
<p>直接调用callSvc将不会抛出异常，而且它会记录调用日志。</p>
<pre><code>$ret = callSvc("MyObj.query", ["fmt"=&gt;"array", "cond"=&gt;...]);
// 返回数组，是[code, data, ...]格式。</code></pre>
<p class="see"><strong>@see <a href="#callSvcInt">callSvcInt</a></strong> </p>
<p class="see"><strong>@see <a href="#AccessControl::callSvc">AccessControl::callSvc</a></strong> </p>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p>
<p>要复用框架，比如只调用框架函数（如数据库操作），不调用任何接口：tool/xx.php</p>
<pre><code>require_once("api_fw.php");
$rv = queryOne("...");</code></pre>
<p>定义新的接口服务：api1.php</p>
<pre><code>require_once("api_fw.php");
// 定义接口...
callSvc();</code></pre>
<p>调用已有接口：</p>
<pre><code>require_once("api.php");
...
$ret = callSvc("genVoucher");</code></pre>
<h4 id="JDEnv-4 常用操作">4 常用操作</h4>
<p>错误处理</p>
<p class="see"><strong>@see <a href="#MyException">MyException</a></strong> </p>
<p>中断执行，直接返回</p>
<p class="see"><strong>@see <a href="#DirectReturn">DirectReturn</a></strong> </p>
<p>调试日志</p>
<p>可使用addLog输出调试信息而不破坏协议输出格式。</p>
<p class="see"><strong>@see <a href="#addLog">addLog</a></strong>  </p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p>
<h4 id="JDEnv-5 插件机制">5 插件机制</h4>
<p>插件是包含数据库/接口/前端逻辑页设计、后端实现、前端逻辑页实现的模块。</p>
<p>其设计由插件目录/DESIGN.md定义，可由upgrade工具自动部署。</p>
<p class="key"><strong>@key <a id="plugin/index.php">plugin/index.php</a></strong>  插件配置</p>
<p>plugin/{pluginName}为插件目录。</p>
<p>plugin/index.php是插件配置文件，在后端应用框架中自动引入，内容示例如下：</p>
<pre><code>&lt;?php

Plugins::add("plugin1");
Plugins::add("plugin2", "plugin2/index.php"); // 指定插件主文件，如不指定，默认为"plugin2/plugin.php"</code></pre>
<p>表示当前应用使用两个插件&quot;plugin1&quot;和&quot;plugin2&quot;, 分别对应目录 plugin/plugin1和plugin/plugin2.</p>
<p class="see"><strong>@see <a href="#Plugins::add">Plugins::add</a></strong> </p>
<p class="key"><strong>@key <a id="plugin">plugin</a></strong>  插件定义</p>
<p>插件实现包括交互接口，以及插件API（后端调用接口），以优惠券插件&quot;coupon&quot;为例: (plugin/coupon/plugin.php)</p>
<pre><code>&lt;?php

// 可选：定义模块API，均使用静态变量或函数
class Coupon
{
    // use MapCol; // 如果要用mapCol/mapSql函数，则打开该trait.

    static $conf1; // 模块配置
    static function func1($arg1) // 模块公共接口
    {
        // 调用实现部分
        $imp = CouponImpBase::getInstance();
        $imp-&gt;genCoupons($src);
    }
}

// 模块实现依赖的接口。如果必须由外部实现，则使用abstract类及函数
abstract class CouponImpBase
{
    use JDSingletonImp;

    abstract function genCoupons($src);
}

// 实现函数型交互接口takeCoupon
function api_takeCoupon() {}

// 实现对象型交互接口 Coupon.query/get/set/del/add
class AC1_Coupon extends AccessControl {}

// 可选：返回前端配置
return [
    "js" =&gt; "m2/plugin.js", // 如果前端需要包含文件
];</code></pre>
<p>注意：</p>
<p>调用插件API函数：</p>
<pre><code>    Coupon::func1($arg1);</code></pre>
<p>交互接口应在插件设计文档(plugin/coupon/DESIGN.md)中定义原型。</p>
<p>插件依赖的接口应定义CouponImp类来实现，一般放在文件 php/class/CouponImp.php中自动加载。</p></div>
<div class="block">
<h2 id="$X_RET_FN">@var $X_RET_FN</h2>
<p>默认接口调用后输出筋斗云的<code>[0, data]</code>格式。<br />
若想修改返回格式，可设置该回调函数。</p>
<ul>
<li>如果返回对象，则输出json格式。</li>
<li>如果返回String类型，则直接输出字符串。</li>
<li>如果返回false，应自行用echo/readfile等输出。注意API日志中仍记录筋斗云返回数据格式。</li>
<li>(v6) 如果有参数<code>{jdcloud:1}</code>，则忽略此处设置，仍使用筋斗云格式输出。</li>
</ul>
<p>示例：返回 <code>{code, data}</code>格式：</p>
<pre><code>global $X_RET_FN;
$X_RET_FN = function ($ret, $env) {
    $ret = [
        "code" =&gt; $ret[0],
        "data" =&gt; $ret[1]
    ];
    if ($env-&gt;TEST_MODE)
        $ret["jdData"] = $ret;
    return $ret;
};</code></pre>
<p>示例：返回xml格式：</p>
<pre><code>global $X_RET_FN;
$X_RET_FN = function ($ret, $env) {
    header("Content-Type: application/xml");
    return "&lt;xml&gt;&lt;code&gt;$ret[0]&lt;/code&gt;&lt;data&gt;$ret[1]&lt;/data&gt;&lt;/xml&gt;";
};</code></pre>
<p class="var"><strong>@var <a id="retfn">retfn</a></strong>  通用URL参数，指定返回样式</p>
<p>筋斗云默认返回样式是<code>[code, data]</code>，可通过指定URL参数retfn来修改：</p>
<ul>
<li>retfn=obj: 成功返回{code:0,data,debug?}, 失败返回{code:非0,message,debug?}</li>
<li>retfn=raw: 与下面指定URL参数_raw=1或2相同</li>
<li>retfn=xml: 字段名与retfn=obj相同，以xml格式返回。</li>
</ul>
<p>如果需要扩展某种返回样式如xxx1，只需要定义下面函数，然后调用时指定参数<code>retfn=xxx1</code>：</p>
<pre><code>function retfn_xxx1($ret, $env) {}</code></pre>
<p class="var"><strong>@var <a id="_raw">_raw</a></strong>  通用URL参数，只返回内容</p>
<p>如果有URL参数<code>_raw=1</code>，则结果不封装为<code>[code, data]</code>形式，而是直接返回data. 示例：</p>
<pre><code>callSvr("Ordr.query", {cond:{id:5}, fmt:"one", _raw: 1});
或
callSvr("Ordr.get", {id:5, _raw: 1});
或
callSvr("Ordr/5", {_raw: 1});</code></pre>
<p>返回示例：</p>
<pre><code>{"id": 5, ...}</code></pre>
<p>假如不加<code>_raw: 1</code>，则返回<code>[0, {"id": 5, ...}]</code>。</p>
<p>如果指定<code>_raw: 2</code>，则进一步只返回值，如取订单数：</p>
<pre><code>callSvr("Ordr", {_raw: 1, fmt:"one", res: "count(*) cnt"});
和
callSvr("Ordr", {_raw: 2, fmt:"one", res: "count(*) cnt"});</code></pre>
<p>分别返回</p>
<pre><code>{"cnt": 275}
和
275</code></pre>
<p>如果值有多项，则以tab间隔，如：</p>
<pre><code>callSvr("Ordr/5", {_raw: 1, res: "status,amount"});
和
callSvr("Ordr/5", {_raw: 2, res: "status,amount"});</code></pre>
<p>分别返回：</p>
<pre><code>{"status": "CR", "amount": "128.00"}
和
CR  128.00</code></pre>
<p>常用于在shell脚本中集成，如：</p>
<pre><code>baseUrl=http://localhost/jdcloud-ganlan/server/api.php
amount=$(curl "$baseUrl/Ordr/5?_raw=2&amp;res=amount&amp;_app=emp-adm")</code></pre>
<p>或</p>
<pre><code>read status amount &lt;&lt;&lt; $(curl "$baseUrl/Ordr/5?_raw=2&amp;res=status+amount&amp;_app=emp-adm")</code></pre>
<p class="var"><strong>@var <a id="_jsonp">_jsonp</a></strong>  通用URL参数，返回函数调用或变量赋值格式</p>
<p>示例：</p>
<pre><code>http://localhost/p/jdcloud/api.php/Ordr/5?_jsonp=api_OrdrGet
返回

api_OrdrGet([0, {"id":5,...}]);

http://localhost/p/jdcloud/api.php/Ordr/5?_jsonp=api_order%3d
返回

api_order=[0, {"id":5,...}];</code></pre>
<p>常用于直接返回JS脚本，示例：</p>
<pre><code>&lt;script&gt;
function api_OrdrGet(order)
{
    console.log(order);
}
&lt;/script&gt;
&lt;script src="http://localhost/p/jdcloud/api.php/Ordr/5?_jsonp=api_OrdrGet"&gt;&lt;/script&gt;</code></pre>
<p>JS示例：</p>
<pre><code>&lt;script src="http://localhost/p/jdcloud/api.php/Ordr/5?_jsonp=api_order%3d"&gt;&lt;/script&gt;
&lt;script&gt;
console.log(api_order);
&lt;/script&gt;</code></pre>
<p>可以叠加通用URL参数<code>_raw</code>:</p>
<pre><code>http://localhost/p/jdcloud/api.php/Ordr/5?_jsonp=api_OrdrGet&amp;_raw=1
返回

api_OrdrGet({"id":5,...});</code></pre>
<p>但不建议使用<code>_raw</code>参数，因为如果查询出错（如id不存在）则会返回错误的格式。</p></div>
<div class="block">
<h2 id="$X_APP">@var $X_APP</h2>
<p class="fn"><strong>@fn <a id="getJDEnv">getJDEnv</a></strong> ()</p>
<p>可以在应用结束前添加逻辑，如：</p>
<pre><code>$env = getJDEnv(); // 非swoole环境下也可以直接用 $GLOBALS["X_APP"]
$env-&gt;onAfterActions[] = function () {
    httpCall("http://oliveche.com/echo.php");
};</code></pre>
<p>注意：</p>
<ul>
<li>如果接口返回错误, 该回调不执行(DirectReturn返回除外)，除非有dbExpr标识（见下面例子）。</li>
<li>此时接口输出已完成，不可再输出内容，否则将导致返回内容错乱。addLog此时也无法输出日志(可以使用logit记日志到文件)</li>
<li>此时接口的数据库事务已提交，如果再操作数据库，与之前操作不在同一事务中。</li>
<li>若出现异常，只会写日志，不会抛出错误，且所有函数仍会依次执行。</li>
</ul>
<p>示例: 当创建工单时, <strong>异步</strong>向用户发送通知消息, 且在异步操作中需要查询新创建的工单, 不应立即发送或使用AccessControl的onAfterActions;<br />
因为在异步任务查询新工单时, 可能接口还未执行完, 数据库事务尚未提交, 所以只有放在$env的onAfterActions中才可靠.</p>
<p>注意：如果是batch接口，默认每个子操作接口是独立的（除非指定使用事务即useTrans=1），这时子操作接口失败也不会执行onAfterActions。</p>
<p>如果接口失败也要强制执行，可使用dbExpr把函数包一层，来标识强制执行，示例：</p>
<pre><code>$env-&gt;onAfterActions[] = dbExpr(function () use ($ifLog) {
    logit("write ifLog");
    dbInsert("IfLog", $ifLog);
});</code></pre>
<p>注意：接口失败时，之前的数据库写操作会被rollback，如果失败时也要写数据库，可将逻辑放在onAfterActions中。</p>
<p>onAfterActions中的函数有一个<code>$ret</code>参数，可以获取接口返回数据：</p>
<pre><code>$env-&gt;onAfterActions[] = function ($ret) {
    // $ret符合筋斗云返回格式，$ret[0]是返回值，0表示成功，$ret[1]是返回数据。
    // 由于此时已完成输出，无法通过声明`&amp;$ret`来修改返回数据。
};</code></pre></div>
<div class="block">
<h2 id="hasPerm">@fn hasPerm($perms, $exPerms=null)</h2><div class="toc"><p style="margin-left:0em"><a href="#hasPerm-1 内置认证">1 内置认证</a></p>
<p style="margin-left:0em"><a href="#hasPerm-2 扩展认证方式">2 扩展认证方式</a></p>
<p style="margin-left:2em"><a href="#hasPerm-2.1 simple: 筋斗云简单认证">2.1 simple: 筋斗云简单认证</a></p>
<p style="margin-left:2em"><a href="#hasPerm-2.2 basic: HTTP基本认证">2.2 basic: HTTP基本认证</a></p>
<p style="margin-left:2em"><a href="#hasPerm-2.3 none: 不验证/模拟身份认证">2.3 none: 不验证/模拟身份认证</a></p>
</div>
<p>检查权限。perms可以是单个权限或多个权限，例：</p>
<pre><code>if (hasPerm(AUTH_USER)) ...  // 用户登录后可用
if (hasPerm(AUTH_USER | AUTH_EMP)) ... // 用户或员工登录后可用
if (hasPerm(AUTH_LOGIN)) ... // 用户、员工、管理员任意一种登录</code></pre>
<p>类似的还有checkAuth函数，不同的是如果检查不通过则直接抛出异常，不再往下执行。</p>
<pre><code>checkAuth(AUTH_USER);
checkAuth(AUTH_ADMIN | PERM_TEST_MODE); 要求必须管理员登录或测试模式才可用。
checkAuth(AUTH_LOGIN);</code></pre>
<p class="see"><strong>@see <a href="#checkAuth">checkAuth</a></strong> </p>
<p>(v5.4) exPerms用于扩展验证, 是一个认证方式名数组, 示例:</p>
<pre><code>hasPerm(AUTH_LOGIN, ["simple"]);</code></pre>
<p>它表示AUTH_LOGIN检查失败后, 再检查是否通过了simple认证。支持的认证方式见下面章节描述。</p>
<h4 id="hasPerm-1 内置认证">1 内置认证</h4>
<p>login接口支持不同类别的用户登录，登录成功后会设置相应的session变量，之后就具有相应权限。</p>
<p class="fn"><strong>@fn <a id="onGetPerms">onGetPerms</a></strong> () 权限生成逻辑</p>
<p>默认逻辑如下，开发者可自定义该逻辑。</p>
<ul>
<li>用户登录后(session中有uid变量)，具有AUTH_USER权限</li>
<li>员工登录后(session中有empId变量)，具有AUTH_EMP权限</li>
<li>超级管理员登录后(session中有adminId变量)，具有AUTH_ADMIN权限</li>
<li>测试模式具有 PERM_TEST_MODE权限，模拟模式具有PERM_MOCK_MODE权限。</li>
</ul>
<h4 id="hasPerm-2 扩展认证方式">2 扩展认证方式</h4>
<p class="var"><strong>@var <a id="Conf::$authKeys=[]">Conf::$authKeys=[]</a></strong>  认证密钥及权限设置</p>
<p>示例：如果请求中使用了basic认证，则通过认证后获得与员工登录相同的权限（即AUTH_EMP权限）</p>
<pre><code>// class Conf (在conf.php中)
static $authKeys = [
    // 当匹配以下key时，当作系统用户-9999；默认全部AUTH_EMP权限的接口都可被第三方访问
    ["authType"=&gt;"basic", "key" =&gt; "user1:1234", "SESSION" =&gt; ["empId"=&gt;-9999], "allowedAc" =&gt; ["*.query","*.get"] ]
];</code></pre>
<ul>
<li>authType指定的认证方式名是在Conf::$authHandlers注册过的，目前支持：basic, simple, none(v6)。<br />
要扩展可以参考$authHandlers用法，比如插件jdcloud-plugin-jwt可支持jwt认证。</li>
</ul>
<p class="see"><strong>@see <a href="#ConfBase::$authHandlers">ConfBase::$authHandlers</a></strong> </p>
<ul>
<li>
<p>key被相应的认证方式使用，其格式由认证方式决定，一般即直接是认证密钥。</p>
</li>
<li>
<p>keyfn(key): (v6.1) key和keyfn必须指定一个。与静态匹配key不同，keyfn是一个验证函数，常用于动态查询接口调用时提供的key是否在指定的表中，然后往往动态设置SESSION（见下面basic认证中的例子）。</p>
</li>
<li>通过SESSION的设置，从而使得通过认证的接口请求，相当于具有系统-9999号用户的权限（即具有AUTH_EMP权限），<br />
意味着它可以直接调用AC2类，或是通过<code>checkAuth(AUTH_EMP)</code>的检查。</li>
</ul>
<p>在authKeys中须用allowedAc指定可用接口列表，所有都可访问可以用&quot;*&quot;。<br />
如果未指定allowedAc，则不会自动执行该权限检查，则在函数型接口中需要显示指定认证方式，如：</p>
<pre><code>checkAuth(AUTH_EMP, ["basic", "simple"]);</code></pre>
<p>对于对象型接口，无法直接使用AC2类的接口（因为没有AUTH_EMP权限），只能使用AC类接口，在其中使用checkAuth再检查权限。</p>
<p>支持的认证方式如下。</p>
<h5 id="hasPerm-2.1 simple: 筋斗云简单认证">2.1 simple: 筋斗云简单认证</h5>
<p>在请求时，添加HTTP头：</p>
<pre><code>X-Daca-Simple: $authStr</code></pre>
<p>后端检查示例: upload接口允许simple验证.</p>
<pre><code>function api_upload() {
    checkAuth(AUTH_LOGIN, ["simple"]);
    ...
}</code></pre>
<p>其中$authStr由Conf::$authKeys中以key字段指定：</p>
<pre><code>// class Conf (在conf.php中)
static $authKeys = [
    ["authType"=&gt;"simple", "key" =&gt; "user1:1234"],
];</code></pre>
<p>用curl访问该接口示例:</p>
<pre><code>curl -s -F "file=@1.jpg" "http://localhost/jdcloud/api/upload?autoResize=0" -H "X-Daca-Simple: user1:1234"</code></pre>
<p>simple认证也可以通过环境变量simplePwd确定，比如可以在conf.user.php中配置：</p>
<pre><code>putenv("simplePwd=user1:1234");</code></pre>
<h5 id="hasPerm-2.2 basic: HTTP基本认证">2.2 basic: HTTP基本认证</h5>
<p>通过HTTP标准的Basic认证方式。<br />
HTTP Basic认证，即添加HTTP头：</p>
<pre><code>Authorization: Basic $authStr</code></pre>
<p>按HTTP协议，authStr格式为base64($user:$password)<br />
可验证的用户名、密码在Conf类中配置，后端配置示例：</p>
<pre><code>// class Conf (在conf.php中)
static $authKeys = [
    ["authType"=&gt;"basic", "key" =&gt; "wms:1234", "SESSION" =&gt; ["empId"=&gt;-9000], "allowedAc" =&gt; ["Item.*","*.query","*.get"]],
    ["authType"=&gt;"basic", "key" =&gt; "mes:1235", "SESSION" =&gt; ["empId"=&gt;-9001], "allowedAc" =&gt; ["*.query"]],  // 可以多个
];</code></pre>
<p>请求示例：</p>
<pre><code>curl -u user1:1234 http://localhost/jdcloud/api.php/xxx</code></pre>
<p>注意：若php是基于apache fcgi方式的部署，可能无法收到认证串，可在apache中配置：</p>
<pre><code>SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1</code></pre>
<p>(v6.1) 如果想动态查询数据库来验证key是否合法，可以使用<strong>keyfn选项</strong>来指定验证函数。示例：</p>
<pre><code>static $authKeys = [
    // 如果接口使用basic认证，则调用keyfn_appId(key)来检查key是否合法。通过验证后检查接口限制，只允许调用Task对象接口。
    ["authType"=&gt;"basic", "keyfn" =&gt; "keyfn_appId", "allowedAc" =&gt; ["Task.*"] ],
];

// 验证key，返回true表示验证成功。然后可动态设置SESSION。
function keyfn_appId($key) {
    list($user, $pwd) = explode(':', $key);
    $sql = "SELECT id FROM App WHERE code=" . Q($user) . " AND secret=" . Q($pwd);
    $appId = queryOne($sql);
    if ($appId) {
        // 模拟Employee身份，以便接口调用AC2系列类。为了与Employee的id区分，习惯上用负值
        $_SESSION["empId"] = -$appId;
        // 设置会话变量，以便在AC2类中处理
        $_SESSION["appId"] = $appId;
        return true;
    }
}</code></pre>
<p>simple认证也可以使用keyfn机制。</p>
<h5 id="hasPerm-2.3 none: 不验证/模拟身份认证">2.3 none: 不验证/模拟身份认证</h5>
<p>(v6) 主要用于为某些接口设置模拟身份。<br />
某些接口无须登录验证即可调用，但在实现时需要调用要求权限验证的内部接口，这时需要模拟一个管理员的身份。</p>
<p>示例：提供接口queryEmp和Wis.wis01，无须登录即可调用，其内部调用Carton.query接口：</p>
<pre><code>// 函数接口示例
function api_queryEmp()
{
    // 假设Employee.query接口在AC2_Employee中定义，必须管理端登录才能调用；所以必须在Conf::$authKeys中配置模拟身份，才能正常调用。
    return callSvcInt("Employee.query", ["fmt"=&gt;"list"]);
}

// 对象接口示例
class AC_Wis extends AccessControl
{
    function api_wis01()
    {
        // 与queryEmp接口遇到的问题相同，必须在Conf::$authKeys中配置后，才能正常调用。
        return callSvcInt("Employee.query", ["fmt"=&gt;"list"]);
    }
}
// AC2类不是必须的，只是为了在管理端控制台中测试方便，因为管理端登录后只能调用AC2类不能调用AC类
class AC2_Wis extends AC_Wis
{
}

// class Conf (在conf.php中)
static $authKeys = [
    // ["authType"=&gt;"basic", "key" =&gt; "user1:1234", "SESSION" =&gt; ["empId"=&gt;-9999], "allowedAc" =&gt; ["*.query","*.get"] ]
    ["authType"=&gt;"none", "key" =&gt; "", "SESSION" =&gt; ["empId"=&gt;-9999], "allowedAc" =&gt; ["queryEmp", "Wis.*"] ]
];</code></pre>
<p>在authKeys中通过&quot;allowedAc&quot;指定了匹配&quot;queryEmp&quot;或&quot;Wis.*&quot;的这些接口无须验证，且模拟-9999号管理员。作为对比，也可以设置HTTP Basic验证。</p></div>
<div class="block">
<h2 id="checkAuth">@fn checkAuth($perms)</h2>
<p>用法与hasPerm类似，检查权限，如果不正确，则抛出错误。</p>
<p class="see"><strong>@see <a href="#hasPerm">hasPerm</a></strong>  认证与权限</p></div>
<div class="block">
<h2 id="tmCols">@fn tmCols($fieldName = "t0.tm", $doWeekFix=true)</h2>
<p>为查询添加时间维度单位: y,q,m,w,d,wd,h (年，季度，月，周，日，周几，时)。</p>
<ul>
<li>wd: 1-7表示周一到周日</li>
<li>w: 一年中第几周，范围[0,53]。周从周一开始，新年第1周不足4天算第0周（mysql week模式5）。<br />
特别地，如果是年、周统计(gres=y,w)，范围[1,53]，新年第1周不足4天算到上年中，以便跨年时1周是完整的（mysql week模式7）。<br />
若要禁止该逻辑，可设置参数$doWeekFix=false。</li>
</ul>
<p>示例：</p>
<pre><code>    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols() ];
    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols("t0.createTm") ];
    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols("log_cr.tm"), "require" =&gt; "createTm" ];</code></pre></div>
<div class="block">
<h2 id="sqlCaseWhen">@fn sqlCaseWhen($field, $map)</h2>
<p>生成SQL的case when语句，示例：</p>
<pre><code>$CusOrderStatusMap = [
    'CR'=&gt; '待审核',
    'AP'=&gt; '已审核',
    'RE'=&gt; '已签收',
    'CL'=&gt; '已结算'
];
$rv = sqlCaseWhen("status", $CusOrderStatusMap);</code></pre>
<p>$rv的值为：</p>
<pre><code>CASE status WHEN 'CR' THEN '待审核' WHEN 'AP' THEN '已审核' WHEN 'RE' THEN '已签收' WHEN 'RE' THEN '已签收' ELSE status END</code></pre></div>
<div class="block">
<h2 id="ConfBase">@class ConfBase</h2>
<p>在conf.php中定义Conf类并继承ConfBase, 实现代码配置：</p>
<pre><code>class Conf extends ConfBase
{
}</code></pre>
<p class="key"><strong>@key <a id="Conf">Conf</a></strong>  项目易变逻辑</p>
<p class="key"><strong>@key <a id="conf.php">conf.php</a></strong>  项目易变逻辑</p>
<p>$BASE_DIR/conf.php中包含Conf类，用于定义易变的临时逻辑，例如数据库维护时报错提示，临时控制某个版本不能使用，遇到节假日休息提醒等等。</p>
<p>不变的全局配置应在app.php中定义。</p></div>
<div class="block">
<h2 id="ConfBase::$enableAutoSession">@var ConfBase::$enableAutoSession?=true</h2>
<p>默认为请求创建session，请求结束时，如果session是空则会删除掉.<br />
将enableAutoSession设置为false，则在需要读写session之前需要手工调用</p>
<pre><code>session_start();</code></pre>
<p>这样便于手工控制session的启停(与php默认处理一致)。</p>
<p>如果php选项session.auto_start=1，则此选项无效。</p></div>
<div class="block">
<h2 id="ConfBase::$enableApiLog">@var ConfBase::$enableApiLog?=1</h2>
<ul>
<li>0: 不记录</li>
<li>1: 接口进入时记录、完成时更新</li>
<li>2: 只记出错(可在运行中再修改值)</li>
<li>3或其它: 接口完成时记录(可在运行中再修改值)</li>
</ul>
<p>设置为0可关闭ApiLog. 例：</p>
<pre><code>static $enableApiLog = 0;</code></pre>
<p>设置为2表示只在出错时记录日志，而且允许在程序中动态再改为其它值。<br />
例如某轮询接口Cmd.query，默认只记录错误，但若返回结果非空，也记录日志：</p>
<pre><code>// class Conf
static function onApiInit(&amp;$ac)
{
    if ($ac == "Cmd.query") {
        self::$enableApiLog = 2;
    }
}

// 当想要记录时，直接修改：
Conf::$enableApiLog = 1;</code></pre>
<p>注意当值为1时，会在接口进入前就记录，进口完成时再更新，在接口中再动态改为0或2是无效的；<br />
其它值时，只会在接口完成时记录日志（这也意味着记录顺序与发生时间可能不一致），允许在接口中再动态修改值改为0或1。</p></div>
<div class="block">
<h2 id="ConfBase::$enableObjLog">@var ConfBase::$enableObjLog?=1</h2>
<p>设置为0可关闭ObjLog. 例：</p>
<pre><code>static $enableObjLog = 0;</code></pre></div>
<div class="block">
<h2 id="ConfBase::onApiInit">@fn ConfBase::onApiInit()</h2>
<p>所有API执行时都会先走这里。</p>
<p>例：对所有API调用检查ios版本：</p>
<pre><code>static function onApiInit(&amp;$ac)
{
    $env = $this-&gt;env;
    $ver = $env-&gt;clientVer;
    if ($ver["type"] == "ios" &amp;&amp; $ver["ver"]&lt;=15) {
        jdRet(E_FORBIDDEN, "unsupport ios client version", "您使用的版本太低，请升级后使用!");
    }
}</code></pre>
<p>例：ac换名字：</p>
<pre><code>static function onApiInit(&amp;$ac)
{
    if ($ac == "DFIS-BK_S001") {
        $ac = "DMS.workGroup";
    }
}

class AC_DMS extends AccessControl
{
    function onInit() {
        Partner::checkAuth();
    }
    // DFIS-BK_S001
    function api_workGroup() {
    }
}</code></pre>
<p>例：第三方要求回调 {BASE_URL}/notify/orderStatus 这样的URL，但框架默认不支持，可以在onApiInit中转换：</p>
<pre><code>static function onApiInit(&amp;$ac)
{
    if ($ac == "notify/orderStatus") {
        $ac = "Notify.orderStatus";
    }
}

class AC_Notify extends AccessControl
{ ... }</code></pre>
<p>注意：框架默认支持<code>Notify/orderStatus</code>这样的URL（对象名Notify必须首字母大写），它可自动转成Notify.orderStatus。</p></div>
<div class="block">
<h2 id="ConfBase::$authHandlers">@var ConfBase::$authHandlers</h2>
<p>注册认证处理函数。示例：注册jwt认证方式</p>
<pre><code>ConfBase::$authHandlers["jwt"] = "hasPerm_jwt";
function hasPerm_jwt()
{
    // 返回true表示认证成功 
}</code></pre>
<p class="see"><strong>@see <a href="#hasPerm">hasPerm</a></strong> </p></div>
<div class="block">
<h2 id="ConfBase::onInitClient">@fn ConfBase::onInitClient(&$ret)</h2>
<p>客户端初始化应用时会调用initClient接口，返回plugins等信息。若要加上其它信息，可在这里扩展。</p>
<p>例：假如定义应用初始化接口为(plugins是框架默认返回的)：</p>
<pre><code>initClient(app) -&gt; {plugins, appName}</code></pre>
<p>实现：</p>
<pre><code>static function onInitClient(&amp;$ret)
{
    $app = mparam('app');
    $ret['appName'] = 'my-app';
}</code></pre>
<p>(v5.4) 此外，在全局配置<code>P_initClient</code>数据中的量将自动设置到ret中，它用于后端控制前端配置，如：</p>
<pre><code>// 配置在conf.user.php中：
$val = preg_match('/iphone|ipad|macintosh/i', $_SERVER["HTTP_USER_AGENT"]);
// $val = preg_match('/\b17\./i', getReqIp()); // apple审核用的地址, 17开头的美国地址
$GLOBALS["P_initClient"] = [
    "enableWeixinLogin" =&gt; true, // 自动微信登录
    "enableAppReviewMode" =&gt; $val // APP审核定制; 根据条件判断来设置
];</code></pre>
<p>前端框架在入口处会调用MUI.initClient(), 之后配置将放在 g_data.initClient 下面, 前端判断示例:</p>
<pre><code>if (g_data.initClient.enableAppReviewMode) {
    // ...
}</code></pre>
<p class="key"><strong>@key <a id="单点登录">单点登录</a></strong> (SSO)</p>
<p class="alias"><strong>@alias <a id="第三方认证">第三方认证</a></strong> </p>
<p>通常设计为打开筋斗云前端应用时，通过传入url参数token，在初始化时调用接口<code>initClient{token: "xxxx"}</code>。<br />
后端Conf.onInitClient在使用token去第三方获取用户信息后，在接口返回数据中包含userInfo字段即用户信息(如userInfo字段)即可。<br />
例如内嵌应用:</p>
<pre><code>&lt;iframe id="ifr" src="https://myserver.com/jdcloud/web/store.html?token=test123" width="100%" height="80%"&gt;&lt;/iframe&gt;</code></pre>
<p>内层应用前端处理示例：</p>
<pre><code>function main()
{
    ...
    WUI.initClient({token: g_args.token}); // 添加token参数
}</code></pre>
<p>后端处理示例：</p>
<pre><code>// class Conf
static function onInitClient(&amp;$ret)
{
    $token = param("token");
    if ($token) {
        $_SESSION["empId"] = 1; // TO DO: 通过token从第三方获取用户信息并保存到Employee表
        $ret["userInfo"] = callSvcInt("Employee.get");
    }
}</code></pre>
<p>另外，通过iframe内嵌筋斗云应用时，如果内外层url不是同一个站（如y1.xx.com:8080与y2.xx.com是同站，不看端口），即跨站时，<br />
内层应用会出现登录后，仍是未登录状态的情况，这是因为受跨站限制，每次请求时cookie无法保持。<br />
解决方法只能内层应用须使用https协议，且后端server/.htaccess文件中添加SameSite配置：</p>
<pre><code>header edit Set-Cookie $ ";Secure;SameSite=None"</code></pre></div>
<div class="block">
<h2 id="ConfBase::checkSecure">@fn ConfBase::checkSecure($ac)</h2>
<p class="var"><strong>@var <a id="ConfBase::enableSecure">ConfBase::enableSecure</a></strong>  ?=false</p>
<p>安全检查。一般用于检测可疑调用并记录日志，以及管理黑白IP名单。默认值为false。</p>
<p>checkSecure函数返回false则不处理该调用，并将请求加入黑名单，且返回<code>[5, "OK"]</code>.<br />
黑名单可查看文件blackip.txt。<br />
(5为E_FORBIDDEN，返回&quot;OK&quot;是为了不让攻击者获得准确的出错信息)。</p>
<p>示例：如果不是前端H5中的ajax调用，且没有cookie信息，则记录该事件到 secure.log 中，人工分析后可添加黑名单。</p>
<pre><code>static function checkSecure($ac)
{
    if (! (isset($_SERVER["HTTP_REFERER"]) &amp;&amp; isset($_SERVER["HTTP_X_REQUESTED_WITH"]) &amp;&amp; isset($_SERVER["HTTP_COOKIE"])) ) {
        $log = @sprintf("secure check: ac=$ac, ses=%s, ApiLog.id=%s", session_id(), ApiLog::$lastId);
        logit($log, true, "secure");
        // BlackList::add(getRealIp(), "no referer");
        // return false; // false表示本次调用直接返回。
    }
}</code></pre>
<p class="see"><strong>@see <a href="#BlackList">BlackList</a></strong> </p></div>
<div class="block">
<h2 id="ApiLog::$lastId">@var ApiLog::$lastId</h2>
<p>取当前调用的ApiLog编号。</p></div>
<div class="block">
<h2 id="ApiLog::$instance">@var ApiLog::$instance</h2>
<p>e.g. 修改ApiLog要记录的ac:</p>
<pre><code>@ApiLog::$instance-&gt;batchAc = "async:$f";</code></pre>
<p>加@抑制错误, 因为当Conf::enableApiLog=0时不记录ApiLog, 此时$instance为空会出现报警或错误.</p>
<p>(v6.1) 可定制ApiLog记录，比如att接口中可指定</p>
<pre><code>@ApiLog::$instance-&gt;updateLog = ["res"=&gt;"1.jpg", "ressz" =&gt; filesize("1.jpg")];</code></pre>
<p>ApiLog中, req字段会记录url请求参数和post请求参数各2000字节;<br />
res字段会记录返回数据200字节(出错时记录2000字节).<br />
必要时可以对某个webapi记录多一些返回内容, 可以在api实现中指定:</p>
<pre><code>@ApiLog::$instance-&gt;logResLen = 2000; // res最多记录2000
(还有logReqLen和logResErrLen对应req记录和res出错记录, 默认都是2000)</code></pre></div>
<div class="block">
<h2 id="ApiLog::addObjLog">@fn ApiLog::addObjLog($obj, $objId, $dscr)</h2>
<p>添加对象日志ObjLog。默认系统会记录标准add/set/del等日志到ObjLog，非标准方法若需要手工添加日志可调用此方法。<br />
示例：在Ordr.cancel接口中记录日志</p>
<pre><code>class AC1_Ordr {
    function api_cancel() {
        ...
        ApiLog::addObjLog("Ordr", 99, "取消订单");
    }
}</code></pre></div>
<div class="block">
<h2 id="MapCol.$colMap">@var MapCol.$colMap</h2>
<p>%colMap = {tbl =&gt; [tblAlias, %cols]}<br />
cols = {col =&gt; colAlias}</p>
<p>先在插件接口文档DESIGN.md中声明本插件的数据库依赖：</p>
<pre><code>@see @Store: id, name, dscr
@see @Ordr: id</code></pre>
<p>配置定表名或列名对应（如果名称相同不必声明）</p>
<pre><code>Coupon::$colMap = [
    "Store" =&gt; ["MyStore", [
        "dscr" =&gt; "description"
    ]],
    "Ordr" =&gt; ["MyOrder"]
];</code></pre>
<p>在plugin实现时，使用mapCol/mapSql来使表名、列名可配置：</p>
<pre><code>class Coupon
{
    use MapCol;
}
$tbl = Coupon::mapCol("Store"); // $tbl="MyStore"
$tbl = Coupon::mapCol("User"); // $tbl="User" 未定义时，直接取原值
$col = Coupon::mapCol("Store.dscr"); // $col="description"
$col = Coupon::mapCol("Store.name"); // $col="name" 未定义时，直接取原值

$sql = $plugin-&gt;mapSql("SELECT s.id, s.{Store.name}, s.{Store.dscr} FROM {Store} s INNER JOIN {Ordr} o ON o.id=s.{Store.storeId}");
// $sql = "SELECT s.id, s.name, s.description FROM MyStore s INNER JOIN MyOrder o ON o.id=s.storeId"</code></pre>
<p class="key"><strong>@key <a id="MapCol.mapCol">MapCol.mapCol</a></strong> ($tbl, $col=null)</p>
<p class="key"><strong>@key <a id="MapCol.mapSql">MapCol.mapSql</a></strong> ($sql)</p></div>
<div class="block">
<h2 id="Plugins">@class Plugins</h2>
<p class="see"><strong>@see <a href="#plugin/index.php">plugin/index.php</a></strong> </p></div>
<div class="block">
<h2 id="Plugins::$map">@var Plugins::$map</h2>
<p>{ pluginName =&gt; %pluginCfg={js} }</p></div>
<div class="block">
<h2 id="Plugins::add">@fn Plugins::add($pluginName, $file?)</h2>
<p>添加模块或插件。<br />
$file为插件主文件，可返回一个插件配置。如果未指定，则自动找&quot;{pluginName}/{pluginName}.php&quot;) 或 &quot;{pluginName}/plugin.php&quot;文件。</p>
<p>以下旧的格式也兼容，现已不建议使用：</p>
<pre><code>Plugins::add($pluginNameArray)</code></pre>
<p class="see"><strong>@see <a href="#Plugins.$map">Plugins.$map</a></strong> </p></div>
<div class="block">
<h2 id="Plugins::exists">@fn Plugins::exists($pluginName)</h2></div>
<div class="block">
<h2 id="tableCRUD">@fn tableCRUD($ac, $tbl, $asAdmin?=false)</h2>
<p>(v5.4)本函数仅做兼容使用，请用<code>callSvcInt</code>或<code>AccessControl::callSvc</code>方法替代。</p>
<p class="param"><strong>@param $asAdmin</strong>  默认根据用户身份自动选择"AC_"类; 如果为true, 则以超级管理员身份调用，即使用"AC0_"类。</p>
<p>设置$asAdmin=true好处是对于超级管理员权限来说，即使未定义&quot;AC0_&quot;类，默认也可以访问所有内容。</p>
<p>假如有Rating（订单评价）对象，不想通过对象型接口来查询，而是通过函数型接口来定制输出，接口设计为：</p>
<pre><code>queryRating(storeId, cond?) -&gt; tbl(id, score, dscr, tm, orderDscr)

查询店铺storeId的订单评价。

应用逻辑：
- 按时间tm倒排序</code></pre>
<p>底层利用tableCRUD实现它，这样便于保留分页、参数cond/gres等特性:</p>
<pre><code>function api_queryRating($env)
{
    $storeId = $env-&gt;mparam("storeId");

    // 定死输出内容。
    $env-&gt;_GET["res"] = "id, score, dscr, tm, orderDscr";

    // 相当于AccessControl框架中调用 addCond，用Obj.query接口的内部参数cond2以保证用户还可以使用cond参数。
    $env-&gt;_GET["cond2"] = dbExpr("o.storeId=$storeId"); 

    // 定死排序条件
    $env-&gt;_GET["orderby"] = "tm DESC";

    $ret = tableCRUD("query", "Rating", true);
    return $ret;
}</code></pre>
<p>注意：<br />
一般应直接使用标准对象接口来实现需求，有时可能出于特别需要，不方便暴露标准接口，可以对标准接口进行了包装，定死一些参数。<br />
v5.4后建议这样实现：</p>
<pre><code>function api_queryRating($env)
{
    $storeId = $env-&gt;mparam("storeId");

    // 或用callSvcInt
    $acObj = new AccessControl(); // 或 AC2_Rating，根据需要创建指定的类
    $ret = $acObj-&gt;callSvc("Rating", "query", [
        // 定死输出内容。
        "res" =&gt; "id, score, dscr, tm, orderDscr",
        "cond2" =&gt; dbExpr("storeId=$storeId"),
        "orderby" =&gt; "tm DESC"
    ]);
    return $ret;
}</code></pre>
<p class="see"><strong>@see <a href="#callSvcInt">callSvcInt</a></strong> </p>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p></div>
<div class="block">
<h2 id="setParam">@fn setParam($k, $v=null)</h2>
<p>(v6) 已废弃。只用于兼容。用$_GET[$k]=$v替代。</p>
<pre><code>setParam("id", 100);
// 或一次设置多个
setParam(["id"=&gt;100, "name"=&gt;"name1"]);</code></pre></div>
<div class="block">
<h2 id="callSvcInt">@fn callSvcInt($ac, $param=null, $postParam=null, $useTmpEnv=true)</h2>
<p>内部调用另一接口，获得返回值。<br />
内部若有异常会抛上来，特别地，调用<code>jdRet(0)</code>会当成正常调用不会抛出异常，而<code>jdRet()</code>（用于自定义输出内容）仍会抛出异常。</p>
<p>与callSvc不同的是，它不处理事务、不写ApiLog，不输出数据，更轻量。<br />
由于不处理事务，它只应在接口实现内部使用。包含api.php后调用接口应使用callSvc.</p>
<p>示例：</p>
<pre><code>$vendorId = callSvcInt("Vendor.add", null, [
    "name" =&gt; $params["vendorName"],
    "tel" =&gt; $params["vendorPhone"]
]);</code></pre>
<p>默认useTmpEnv=true时，它在独立环境中执行，不会影响当前环境的$_GET, $_POST参数，<br />
如果指定参数useTmpEnv=false，则$param或$postParam参数将直接覆盖当前环境的$_GET, $_POST参数。</p>
<p>如果未指定$param或$postParam参数，默认值为空数组即没有参数。</p>
<p>(v5.4) 上面例子会自动根据当前用户角色来选择AC类，还可以直接指定使用哪个AC类来调用，如：</p>
<pre><code>$acObj = new AC2_Vendor();
$vendorId = $acObj-&gt;callSvc("Vendor", "add", null, [
    "name" =&gt; $params["vendorName"],
    "tel" =&gt; $params["vendorPhone"]
]);</code></pre>
<p>注意请自行确保AC类对当前角色兼容性，如用户角色调用了管理员的AC类，就可能出问题。</p>
<p>示例：直接用当前的get/post参数执行，允许内部修改当前环境：</p>
<pre><code>$vendorId = callSvcInt("Vendor.add", $_GET, $_POST, false); // 经典环境下可用
或
$vendorId = callSvcInt("Vendor.add", $env-&gt;_GET, $env-&gt;_POST, false);</code></pre>
<p class="see"><strong>@see <a href="#tmpEnv">tmpEnv</a></strong> </p>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p>
<p class="see"><strong>@see <a href="#AccessControl::callSvc">AccessControl::callSvc</a></strong> </p></div>
<div class="block">
<h2 id="getHttpInput">@fn getHttpInput(env?)</h2>
<p>取用户请求的内容。如果是urlencoded或json格式，系统会自动解码到$_POST中，其它格式须应用自行处理。</p>
<p>注意：<br />
应用应使用getHttpInput()而不是file_get_contents(&quot;php://input&quot;) 来取原始输入。<br />
因为为参数加密状态下(xparam特性)，两者是不同的，getHttpInput()返回才是正确的。</p></div>
<div class="block">
<h2 id="api_checkIp">@fn api_checkIp()</h2>
<p class="key"><strong>@key <a id="whiteIpList">whiteIpList</a></strong>  白名单配置.</p>
<p>可在conf.user.php中设置whiteIpList，如</p>
<pre><code>putenv("whiteIpList=115.238.59.110");</code></pre>
<p>要验证调用者是否在IP白名单中，不是白名单调用将直接抛错，可以调用</p>
<pre><code>api_checkIp();</code></pre>
<p>外部可直接调用接口checkIp测试，例如用JS：</p>
<pre><code>callSvr("checkIp");</code></pre>
<p class="see"><strong>@see <a href="#BlackList">BlackList</a></strong> </p></div>
<div class="block">
<h2 id="injectSession">@fn injectSession($userId, $appType, $fn, $days=3)</h2>
<p>对别人的session进行操作，比如删除，修改参数等。<br />
$fn为对session的操作，当设置为false时，表示删除session.</p>
<p>基于ApiLog查找指定用户的session, 默认找3天(参数days)内该用户的最近一次session（且该session此后未被别的用户使用）.<br />
操作将记录在日志trace.log中。</p>
<p>示例：当管理员的权限字段(perms)被修改后，直接修改该用户的session令其立刻生效。<br />
(注意：此机制仅优化常见场景，但并不可靠）</p>
<pre><code>class AC0_Employee {
    protected function onValidate() {
        if ($this-&gt;ac == "set" &amp;&amp; issetval("perms?")) {  // "perms?"以问号结尾表示传入空串也算设置了，这时set接口将置空该字段。
            $params = $_POST; // 注意：闭包不可直接use $_POST，否则得到null值
            injectSession($this-&gt;id, "emp", function () use ($params) {
                $_SESSION["perms"] = $params["perms"];
                // $_SESSION["adminFlag"] = $env-&gt;param("adminFlag/i", 0, $params); // 注意字段类型要正确，可用param函数。
            });
        }
    }
}</code></pre>
<p class="see"><strong>@see <a href="#delSession">delSession</a></strong> </p>
<p class="see"><strong>@see <a href="#injectSessionById">injectSessionById</a></strong> </p></div>
<div class="block">
<h2 id="injectSessionById">@fn injectSessionById($sessionId/$sessionIdArray, $fn)</h2>
<p>对别人的session进行操作，比如删除，修改参数等。<br />
$fn为对session的操作，当设置为false时，表示删除session.</p>
<p class="see"><strong>@see <a href="#delSessionById">delSessionById</a></strong> </p></div>
<div class="block">
<h2 id="delSession">@fn delSession($userId, $appType, $days=3)</h2>
<p>删除指定用户的session. 例如：踢掉在线用户等。</p>
<p>示例：当用户的“管理员标志”(adminFlag)被修改后，踢掉该用户让其重新登录。</p>
<pre><code>class AC0_User {
    protected function onValidate() {
        if ($this-&gt;ac == "set" &amp;&amp; issetval("adminFlag")) {
            delSession($this-&gt;id, "user");
        }
    }
}</code></pre>
<p class="see"><strong>@see <a href="#injectSession">injectSession</a></strong> </p></div>
<div class="block">
<h2 id="delSessionById">@fn delSessionById($sessionId/$sessionIdArray)</h2>
<p>删除指定sessionId. 例如：踢掉在线用户等。</p>
<p class="see"><strong>@see <a href="#injectSessionById">injectSessionById</a></strong> </p></div>
<div class="block">
<h2 id="httpCallAsync">@fn httpCallAsync($url, $postParams=null)</h2>
<p>发起调用后立即返回，即用于发起异步调用。<br />
默认发起GET调用，如果postParams非空(可以为字符串、数值或数组)，则发起POST调用。</p>
<p>示例：调用自身服务，可使用相对路径：</p>
<pre><code>httpCallAsync("/jdcloud/api.php?ac=async&amp;f=sendSms", [
    "phone" =&gt; "13712345678",
    "msg" =&gt; "验证码为1234"
]);</code></pre>
<p>未指定主机时，固定连接127.0.0.1:80，若其它端口可在conf.user.php中配置:</p>
<pre><code>$GLOBALS["conf_httpCallAsyncPort"] = 8080;</code></pre>
<p>目前内部callAsync/callSvcAsync会用到它。</p>
<p>调用其它系统可指定完整URL，支持http或https：</p>
<pre><code>httpCallAsync("http://127.0.0.1:8081/setTimeout", [
    "url" =&gt; "http://127.0.0.1/jdcloud/api.php/hello",
]);</code></pre>
<p>TODO: 如果给定postParams，目前content-type固定使用application/json. 且不支持指定headers.</p></div>
<div class="block">
<h2 id="callAsync">@fn callAsync($ac, $params, $opt={wait, cron, code})</h2>
<p>异步调用某个内部函数。</p>
<p>异步调用的原理是通过调用callSvcAsync函数，在当前接口执行完成后，发起一个async接口调用并立即返回。<br />
然后在async接口中正常同步调用指定的内部函数。</p>
<p>与直接调用callSvcAsync相比，使用callAsync更简单，不必将函数封装为外部接口，只需要在<code>$allowedAsyncCalls</code>中注册即可被外部调用。</p>
<p>示例：让一个同步调用变成支持异步调用，以sendSms为例</p>
<pre><code>// 1. 设置已注册的异步调用函数。建议在api.php中设置。
$allowedAsyncCalls = ["sendSms"];

function sendSms($phone, $msg) {
    // 同步调用
    return httpCall("...");
}

// 2. 异步调用
return callAsync('sendSms', [$phone, $msg]); // 参数</code></pre>
<p>注意：</p>
<ul>
<li>由于要被外部调用，须生成完整URL地址；如果部署时使用反向代理等机制，可能URL不正确，这时应设置P_BASE_URL，详见[getBaseUrl]。</li>
<li>如果指定了等待时间opt.wait(毫秒)，表示在opt.wait豪秒后执行。此时必须连接jdserver做任务调度，须配置conf_jdserverUrl和conf_jdserverBackUrl，详见[callSvcAsync]。<br />
opt.cron和opt.code参数用于设置周期性任务。详见[jdserver]的setTimeout接口。</li>
<li>安全性：调用async接口的服务器IP，如果不是本机，须配置加入白名单(whiteIpList)，详见[api_async]。</li>
</ul>
<p class="see"><strong>@see <a href="#callSvcAsync">callSvcAsync</a></strong> </p>
<p class="see"><strong>@see <a href="#api_async">api_async</a></strong> </p>
<p class="see"><strong>@see <a href="#jdserver">jdserver</a></strong> </p></div>
<div class="block">
<h2 id="callSvcAsync">@fn callSvcAsync($ac, $urlParam, $postParams=null, $opt={wait, cron, code, disabled})</h2><div class="toc"><p style="margin-left:0em"><a href="#callSvcAsync-1 延迟执行任务">1 延迟执行任务</a></p>
<p style="margin-left:0em"><a href="#callSvcAsync-2 周期性任务">2 周期性任务</a></p>
</div>
<p>在当前事务执行完后，调用指定接口并立即返回（不等服务器输出数据）。一般用于各种异步通知。<br />
示例：</p>
<pre><code>// 支持调用自己
callSvcAsync("sendMail", ["type"=&gt;"Issue", "id"=&gt;100]);
// 自动以getBaseUrl来补全url

// 支持调用外部http或https, 将ac直接当成url
callSvcAsync("http://localhost:8080/pdi/api/sendMail", ["type"=&gt;"Issue", "id"=&gt;100]);
callSvcAsync("https://oliveche.com/pdi/api/sendMail", ["type"=&gt;"Issue", "id"=&gt;100]);</code></pre>
<p>通过opt可以设置延迟执行或周期性循环执行的任务，它须通过jdserver中间件实现。<br />
须设置[conf_jdserverUrl]和[conf_jdserverBackUrl]。</p>
<h4 id="callSvcAsync-1 延迟执行任务">1 延迟执行任务</h4>
<p>如果指定了等待时间opt.wait，表示在opt.wait毫秒后执行。示例：30秒后发送邮件：</p>
<pre><code>$wait = 30000;
callSvcAsync("sendMail", ["type"=&gt;"Issue", "id"=&gt;100], null, ['wait'=&gt;$wait]);</code></pre>
<p>此时必须连接jdserver做任务调度。</p>
<h4 id="callSvcAsync-2 周期性任务">2 周期性任务</h4>
<p>cron和code参数用于添加周期性执行的任务，可以与wait合用。详见[jdserver]的setTimeout接口。</p>
<p>示例：添加每30秒执行一次的周期任务：</p>
<pre><code>$wait = 30000;
callSvcAsync("sendMail", ["type"=&gt;"Issue", "id"=&gt;100], null, ['wait'=&gt;$wait, 'cron'=&gt;1, 'code'=&gt;'app1-task-1']);</code></pre>
<p>callSvcAsync使用异步调用，只管连通，不管对方是非处理成功。如果是同步调用，可使用callJdserver:</p>
<pre><code>callJdserver("setTimeout", null, [
    'url' =&gt; makeUrl('sendMail', ["type"=&gt;"Issue", "id"=&gt;100], null, true) // 默认为内部接口生成相对路径，此处是供外部调用，加第4参数true表示生成完整路径
    'wait' =&gt; $wait,
    'cron' =&gt; 1,
    'code' =&gt; 'app1-task-1'
]);</code></pre>
<p>示例：添加周一到周五9:00-18:00间每30秒执行一次的周期任务：</p>
<pre><code>$wait = 30000;
callSvcAsync("sendMail", ["type"=&gt;"Issue", "id"=&gt;100], null, ['wait'=&gt;$wait, 'cron'=&gt;'0 9-18 * * 1-5', 'code'=&gt;'app1-task-2']);</code></pre>
<p>每晚1:00执行：</p>
<pre><code>callSvcAsync("sendMail", ["type"=&gt;"Issue", "id"=&gt;100], null, ['cron'=&gt;'0 1 * * *', 'code'=&gt;'app1-task-2']);</code></pre>
<p>上面指定opt.code参数用于后期修改或删除任务，必须为<code>{应用}-{对象}-{标识}</code>结构，删除周期任务示例：</p>
<pre><code>callJdserver('Timer.del', ['code'=&gt;'app1-task-1']);</code></pre>
<p class="see"><strong>@see <a href="#callJdserver">callJdserver</a></strong> </p>
<p class="key"><strong>@key <a id="conf_jdserverUrl">conf_jdserverUrl</a></strong>  jdserver地址</p>
<p class="key"><strong>@key <a id="conf_jdserverBackUrl">conf_jdserverBackUrl</a></strong>  jdserver回调地址，本系统被jdserver调用的地址</p>
<p>jdserver用于消息推送和任务调度, 是独立运行的守护进程, 提供websocket和http调用接口。<br />
jdcloud后端会用到jdserver的http接口，比如<code>http://127.0.0.1:8081/setTimeout</code>。</p>
<p>习惯上会在Apache上配置代理路径'/jdserver'，<br />
即通过访问<code>http://{server}/jdserver/setTimeout</code>达到相同效果，并可以支持https/wss协议连接。</p>
<p>jdserver默认路径配置为<code>http://127.0.0.1/jdserver</code>，通过本机Apache服务代理，端口80。<br />
如连其它服务器请修改配置，在conf.user.php中，示例：</p>
<pre><code>$conf_jdserverUrl = "https://oliveche.com/jdserver";  // 路径带jdserver的是经代理的; 经公网最好走https
// $conf_jdserverUrl = "http://192.168.1.14:8081"; // 这种是直接连原始服务器</code></pre>
<p>jdserver回调地址指的是jdserver调用本系统接口的地址，比如和jdserver在同一台机器，可以设置：</p>
<pre><code>$conf_jdserverBackUrl = "http://127.0.0.1/jdcloud/api.php";</code></pre>
<p>又如在开发环境内网中，通过ssh隧道将web服务以8081端口代理到jdserver所在服务器线上，则可设置回调</p>
<pre><code>$conf_jdserverBackUrl = "http://localhost:8081/asyncTask/server/api.php";</code></pre>
<p>注意，由于是代理到了jdserver所在服务器，所以此处localhost其实指的是jdserver所在服务器。</p>
<p>注意：如果是调用了callAsync函数实现回调内部函数，它内部是通过jdserver回调async接口实现的，<br />
而async接口要求调用方（非本机调用）在IP白名单内，所以非本机调用情况下，还应设置IP白名单才可以回调成功。</p></div>
<div class="block">
<h2 id="api_async">@fn api_async</h2>
<p>提供async接口，用于内部发起异步调用:</p>
<pre><code>async(f)(params...)
params为JSON格式。</code></pre>
<p>注意：要求调用者在IP白名单中，配置示例：</p>
<pre><code>putenv("whiteIpList=115.238.59.110 127.0.0.1 ::1");</code></pre>
<p>调用实际函数前会设置环境变量：enableAsync=0。</p>
<p class="see"><strong>@see <a href="#whiteIpList">whiteIpList</a></strong> </p></div>
<div class="block">
<h2 id="jdPush">@fn jdPush($app, $msg, $user='*')</h2>
<p>借助jdserver实时推送消息到websocket。须配置conf_jdserverUrl。</p>
<p>前端可直接通过jdserver调用push接口，给其它客户端发消息，示例：</p>
<pre><code>callSvr("/jdserver/push", $.noop, {
    app: "app1",
    // user: "*", // 不指定user默认使用群发
    msg: {
        ac: "msg1",
        data: "hello"
    }
});</code></pre>
<p>详见前端文档[jdPush].</p>
<p class="see"><strong>@see <a href="#$conf_jdserverUrl">$conf_jdserverUrl</a></strong> </p></div>
<div class="block">
<h2 id="callJdserver">@fn callJdserver($ac, $param=null, $postParam=null, $async=false)</h2>
<p>调用jdserver的接口。示例：</p>
<pre><code>callJdserver('Timer.set', ['code'=&gt;'asynctask-task-1'], [
    'cron' =&gt; '0 1 * * *'
]);</code></pre>
<p>如果指定参数async=true，则在当前接口程序完成后，发起异步调用，若出错将只记日志不报错。</p>
<p class="see"><strong>@see <a href="#$conf_jdserverUrl">$conf_jdserverUrl</a></strong> </p></div>
<div class="block">
<h2 id="env.appName">@var env.appName?=user</h2>
<p>客户端应用标识，默认为&quot;user&quot;.<br />
根据URL参数&quot;_app&quot;确定值。</p>
<p class="var"><strong>@var <a id="env.appType">env.appType</a></strong> </p>
<p>根据应用标识($env-&gt;appName)获取应用类型(AppType)。注意：应用标识一般由前端应用通过URL参数&quot;_app&quot;传递给后端。<br />
不同的应用标识可以对应相同的应用类型，如应用标识&quot;emp&quot;, &quot;emp2&quot;, &quot;emp-adm&quot; 都表示应用类型&quot;emp&quot;，即 应用类型=应用标识自动去除尾部的数字或&quot;-xx&quot;部分。</p>
<p>不同的应用标识会使用不同的cookie名，因而即使用户同时操作多个应用，其session不会相互干扰。<br />
同样的应用类型将以相同的方式登录系统。</p></div>
<div class="block">
<h2 id="env.getAc">@fn env.getAc($wantBatch=false)</h2>
<p>取当前调用名。<br />
如果是batch调用，则返回当前子调用名。</p>
<p>如果指定参数wantBatch=true, 则batch调用直接返回&quot;batch&quot;，此时可以用env.getAc1()返回子调用名。</p></div>
<div class="block">
<h2 id="conf_returnExecTime">@var conf_returnExecTime</h2>
<p>如果值为1, 将通过HTTP头返回接口执行时间, 示例:<br />
X-Exec-Time: 13ms</p></div>
<div class="block">
<h2 id="JDEnv::$MAX_DEBUG_LOG_CNT=2000">@var JDEnv::$MAX_DEBUG_LOG_CNT=2000</h2>
<p>调试日志最大条目数，默认2000条。<br />
达到极限时会清除掉前一半后继续记录，以避免内存耗尽。</p></div>
<div class="block">
<h2 id="env->tmpEnv">@fn env->tmpEnv($param, $postParam, $fn, $useTmpEnv=true)</h2>
<p>(v5.4) 在指定的GET/POST参数下执行fn函数，执行完后恢复初始环境。<br />
$param或$postParam为null时，与空数组<code>[]</code>等价。</p>
<p>示例：</p>
<pre><code>$param = ["cond" =&gt; "createTm&gt;'2019-1-1'];
$ret = $env-&gt;tmpEnv($param, null, function () {
    return callSvcInt("User.query");
});</code></pre>
<p>示例：用当前参数环境执行：</p>
<pre><code>$ret = $env-&gt;tmpEnv($_GET, $_POST, function () {
    return callSvcInt("User.query");
});</code></pre>
<p>默认对当前环境的修改(如修改$_GET等)会被恢复，除非指定参数$useTmpEnv=false。</p></div>
<div class="block">
<h2 id="env.createAC">@fn env.createAC($tbl, $ac = null, $cls = null) </h2>
<p>如果$cls非空，则按指定AC类创建AC对象。<br />
否则按当前登录类型自动创建AC类（回调onCreateAC）。</p>
<p>特别地，为兼容旧版本，当$cls为true时，按超级管理员权限创建AC类（即检查&quot;AC0_XX&quot;或&quot;AccessControl&quot;类）。</p>
<p>示例：</p>
<pre><code>$env-&gt;createAC("Ordr", "add");
$env-&gt;createAC("Ordr", "add", true);
$env-&gt;createAC("Ordr", null, "AC0_Ordr");</code></pre></div>
<div class="block">
<h2 id="callSvc">@fn callSvc($ac=null, $useTrans=true, $apiFn=null)</h2>
<p>外部调用接口。返回符合筋斗云格式的数组，至少2元素，即<code>[0, 成功数据, 调试信息...]</code>或<code>[非0, 失败信息, 内部失败原因, 调试信息...]</code></p>
<ul>
<li>如果不指定ac, 则自动从请求中解析，设置响应header并输出内容。</li>
<li>自动开启数据库事务，除非指定useTrans=false</li>
<li>自动记录调用日志、操作日志等。</li>
</ul>
<p>示例：接口应用api.php的最后</p>
<pre><code>callSvc();</code></pre>
<p>示例：server/tool/task.php是命令行程序(通过php task.php执行)，用于定时任务，如果它想调用已有接口：</p>
<pre><code>// 模拟AC2权限调用接口
$_SESSION = ["empId" =&gt; -1];
// 设置参数；当然也可以设置$_POST参数
$_GET = ["for" =&gt; "task", "fmt" =&gt; "one"];
$rv = callSvc("Employee.query");</code></pre>
<p>如果指定apiFn，则直接以接口环境执行该函数，包括记录ApiLog、开启数据库事务、开启并保存session等（注意接口执行会设置cookie路径和名称等）、使用jdRet报错等。<br />
示例：在server/weixin/auth.php中，实现微信登录，因为需要记录$_SESSION[&quot;uid&quot;]，它必须在接口环境下执行，否则后续执行将会认为未登录：</p>
<pre><code>$rv = callSvc("weixinLogin", true, function () use ($isMock) {
    $userInfo = ...;
    $imp = LoginImpBase::getInstance();
    return $imp-&gt;onWeixinLogin($userInfo, $rawData);
});
if ($rv[0]) {
    logit("weixin/auth.php fails: " . jsonEncode($rv));
    echo("fail: " . $rv[1]);
    exit();
}</code></pre>
<p class="see"><strong>@see <a href="#callSvcInt">callSvcInt</a></strong> </p></div>
<div class="block">
<h2 id="AccessControl">@module AccessControl</h2><div class="toc"><p style="margin-left:0em"><a href="#AccessControl-1 基本权限控制">1 基本权限控制</a></p>
<p style="margin-left:0em"><a href="#AccessControl-2 虚拟字段(VCol)">2 虚拟字段(VCol)</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.1 关联字段">2.1 关联字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.2 关联字段依赖">2.2 关联字段依赖</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.3 计算字段">2.3 计算字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.4 子表压缩字段">2.4 子表压缩字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.5 自定义字段">2.5 自定义字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.6 flags和props字段">2.6 flags和props字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.7 外部虚拟字段(ExtVCol)">2.7 外部虚拟字段(ExtVCol)</a></p>
<p style="margin-left:4em"><a href="#AccessControl-2.7.1 嵌套查询">2.7.1 嵌套查询</a></p>
<p style="margin-left:4em"><a href="#AccessControl-2.7.2 关联子查询优化">2.7.2 关联子查询优化</a></p>
<p style="margin-left:0em"><a href="#AccessControl-3 子表">3 子表</a></p>
<p style="margin-left:2em"><a href="#AccessControl-3.1 子表的增删改查操作">3.1 子表的增删改查操作</a></p>
<p style="margin-left:4em"><a href="#AccessControl-3.1.1 子表添加">3.1.1 子表添加</a></p>
<p style="margin-left:4em"><a href="#AccessControl-3.1.2 子表查询">3.1.2 子表查询</a></p>
<p style="margin-left:4em"><a href="#AccessControl-3.1.3 子表更新与删除">3.1.3 子表更新与删除</a></p>
<p style="margin-left:2em"><a href="#AccessControl-3.2 关联子表对象">3.2 关联子表对象</a></p>
<p style="margin-left:2em"><a href="#AccessControl-3.3 子表查询参数">3.3 子表查询参数</a></p>
<p style="margin-left:0em"><a href="#AccessControl-4 操作完成回调">4 操作完成回调</a></p>
<p style="margin-left:0em"><a href="#AccessControl-5 其它">5 其它</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.1 编号自定义生成">5.1 编号自定义生成</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.2 缺省排序">5.2 缺省排序</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.3 缺省输出字段列表">5.3 缺省输出字段列表</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.4 最大每页数据条数">5.4 最大每页数据条数</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.5 虚拟表和视图">5.5 虚拟表和视图</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.6 query接口输出格式">5.6 query接口输出格式</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.7 distinct查询">5.7 distinct查询</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.8 枚举支持及自定义字段处理">5.8 枚举支持及自定义字段处理</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.9 动态设置虚拟字段及属性">5.9 动态设置虚拟字段及属性</a></p>
<p style="margin-left:0em"><a href="#AccessControl-6 批量更新(setIf/batchSet)和批量删除(delIf/batchDel)">6 批量更新(setIf/batchSet)和批量删除(delIf/batchDel)</a></p>
<p style="margin-left:0em"><a href="#AccessControl-7 连接第三方数据库">7 连接第三方数据库</a></p>
</div>
<p>对象型接口框架。<br />
AccessControl简写为AC，同时AC也表示自动补全(AutoComplete).</p>
<p>在设计文档中完成数据库设计后，通过添加AccessControl的继承类，可以很方便的提供诸如 {Obj}.query/add/get/set/del 这些对象型接口。</p>
<p>每个对象提供字段，包括 表字段（或称主表字段）、虚拟字段（称为vcol，包括关联字段，计算字段等）、子表字段（称为subobj）三种类别。</p>
<p>例如，设计文档中已定义订单对象(Ordr)的主表(Ordr)和订单日志子表(OrderLog)：</p>
<pre><code>@Ordr: id, userId, status, amount
@OrderLog: id, orderId, tm, dscr</code></pre>
<p>注意：之所以用对象和主表名用Ordr而不是Order词是避免与SQL关键字冲突。</p>
<p>有了表设计，订单的标准接口就已经自动生成好了：</p>
<pre><code>// 查询订单
Ordr.query() -&gt; tbl(id, userId, ...)
// 添加订单
Ordr.add()(userId=1, status='CR', amount=100) -&gt; id
// 查看订单
Ordr.get(id=1)
// 修改订单状态
Ordr.set(id=1)(status='PA')
// 删除订单
Ordr.del(id=1)</code></pre>
<p>但是，只有超级管理员登录后（例如从示例应用中的超级管理端登录后，web/adm.html），才有权限使用这些接口。</p>
<p>如果希望用户登录后，也可以使用这些接口，只要添加一个继承AccessControl的类，且命名为&quot;AC1_Ordr&quot;即可：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
}</code></pre>
<p>有了以上定义，在用户登录系统后，就可以使用上述和超级管理员一样的标准订单接口了。</p>
<p>说明：</p>
<p>类的命名规则为AC前缀加对象名（或主表名，因为对象名与主表名一致）。框架默认提供的前缀如下：</p>
<p class="key"><strong>@key <a id="AC_">AC_</a></strong>   游客权限(AUTH_GUEST)，如未定义则调用时报“无权操作”错误。</p>
<p class="key"><strong>@key <a id="AC0_">AC0_</a></strong>  超级管理员权限(AUTH_ADMIN)，如未定义，默认拥有所有权限。</p>
<p class="key"><strong>@key <a id="AC1_">AC1_</a></strong>   用户权限(AUTH_USER)，如未定义，则降级使用游客权限接口(AC_)。</p>
<p class="key"><strong>@key <a id="AC2_">AC2_</a></strong>   员工权限(AUTH_EMP/PERM_MGR), 如未定义，报权限不足错误。</p>
<p>因而上例中命名为 &quot;AC1_Ordr&quot; 就表示用户登录后调用Ordr对象接口，将受该类控制。而这是个空的类，所以拥有一切操作权限。</p>
<p>框架为AUTH_ADMIN权限自动选择AC0_类，其它类可以通过函数 onCreateAC 进行自定义，仍未定义的框架使用AC_类。</p>
<p>(v5.4) 当调用对象接口时，将自动尝试加载 php/class/AC_{obj}.php 文件。所以可将该obj相关的AC类放到该文件中。</p>
<p class="fn"><strong>@fn <a id="onCreateAC">onCreateAC</a></strong> ($obj)</p>
<p>需开发者在api.php中定义。<br />
根据对象名，返回权限控制类名，如 AC1<em>{$obj}。<br />
如果返回null, 则默认为 AC</em>{obj}</p>
<h4 id="AccessControl-1 基本权限控制">1 基本权限控制</h4>
<p class="var"><strong>@var <a id="AccessControl::$allowedAc">AccessControl::$allowedAc</a></strong>  设定允许的操作，如不指定，则允许所有操作。示例: ["add", "get", "set", "del", "query"] </p>
<p class="var"><strong>@var <a id="AccessControl::$readonlyFields">AccessControl::$readonlyFields</a></strong>  ?=[]  (影响add/set) 字段列表，添加/更新时为这些字段填值无效。</p>
<p class="var"><strong>@var <a id="AccessControl::$readonlyFields2">AccessControl::$readonlyFields2</a></strong>  ?=[]  (影响set操作) 字段列表，更新时对这些字段填值无效。</p>
<p>注意：v5.4以下设置只读字段，只记录日志但不报错。<br />
v5.4起将报错，设置该类的useStrictReadonly=false可以兼容旧行为不报错，(v5.5)或者设置URL参数useStrictReadonly=0。</p>
<p class="var"><strong>@var <a id="AccessControl::$hiddenFields">AccessControl::$hiddenFields</a></strong>  ?= []  (for get/query) 隐藏字段列表。默认表中所有字段都可返回。一些敏感字段不希望返回的可在此设置。</p>
<p class="key"><strong>@key <a id="hiddenFields">hiddenFields</a></strong> </p>
<p>客户端请求可以加参数hiddenFields指定要隐藏的字段.<br />
示例：按客户编号(cusId)分组，但返回客户名(cusName)字段，不要返回cusId这个字段:</p>
<pre><code>callSvr("CusOrder.query", {gres:"cusId", res:"cusName 客户, COUNT(*) 订单数, SUM(amount) 总金额", hiddenFields:"cusId"})</code></pre>
<p>特别地，如果指定为参数hiddenFields为0，则显示所有辅助字段（如虚拟字段依赖引入的字段），一般用于调试。</p>
<p class="var"><strong>@var <a id="AccessControl::$requiredFields">AccessControl::$requiredFields</a></strong>  ?=[] (for add/set) 字段列表。添加时必须填值；更新时不允许置空。</p>
<p class="var"><strong>@var <a id="AccessControl::$requiredFields2">AccessControl::$requiredFields2</a></strong>  ?=[] (for set) 字段列表。更新时不允许设置空。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onQuery">AccessControl::onQuery</a></strong> () (for get/query)  用于对查询条件进行设定。实际上，set/del/setIf/delIf等操作也会调用它验证数据是否可操作。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onValidate">AccessControl::onValidate</a></strong> ()  (for add/set). 验证添加和更新时的字段，或做自动补全(AutoComplete)工作。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onValidateId">AccessControl::onValidateId</a></strong> () (for get/set/del) 用于对id字段进行检查。比如在del时检查用户是否有权操作该记录。可在其中设置$this->id。</p>
<p>上节例子中，用户可以操作系统的所有订单。</p>
<p>现在我们到设计文档中，将接口API设计如下：</p>
<pre><code>== 订单接口 ==

添加订单：
Ordr.add()(amount) -&gt; id

查看订单：
Ordr.query() -&gt; tbl(id, userId, status, amount)
Ordr.get(id)

权限：AUTH_GUEST

应用逻辑
- 用户只能添加(add)、查看(get/query)订单，不可修改(set)、删除(del)订单
- 用户只能查看(get/query)属于自己的订单。
- 用户在添加订单时，必须设置amount字段，不必（也不允许）设置id, userId, status这些字段。
  服务器应将userId字段自动设置为该用户编号，status字段自动设置为"CR"（已创建）</code></pre>
<p>为实现以下逻辑，上面例子中代码可修改为：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $allowedAc = ["get", "query", "add"];
    protected $requiredFields = ["amount"];
    protected $readonlyFields = ["status", "userId"];

    protected function onQuery()
    {
        $userId = $_SESSION["uid"];
        $this-&gt;addCond("userId={$userId}");
    }

    protected function onValidate()
    {
        if ($this-&gt;ac == "add") {
            $userId = $_SESSION["uid"];
            $_POST["userId"] = $userId;
            $_POST["status"] = "CR";
        }
    }
}</code></pre>
<p>说明：</p>
<ul>
<li>使用$allowedAc设定了该对象接口允许的操作。</li>
<li>使用$requiredFields与$readonlyFields设定了添加时必须指定或不可指定的字段。由于&quot;id&quot;字段默认就是不可添加/更新的，所以不必在这里指定。</li>
<li>在onQuery中，对用户可查看的订单做了限制：只允许访问自己的订单。这里通过添加了条件实现。<br />
$_SESSION[&quot;uid&quot;]是在用户登录后设置的，可参考login接口定义(api_login).</li>
<li>在onValidate中，对添加操作时的字段做自动补全。由于添加和更新都会走这个接口，所以用 $this-&gt;ac 判断只对添加操作时补全。<br />
由于添加和更新操作的具体字段都通过 $_POST 来传递，故直接设置 $_POST中的相应字段即可。</li>
</ul>
<h4 id="AccessControl-2 虚拟字段(VCol)">2 虚拟字段(VCol)</h4>
<p class="var"><strong>@var <a id="AccessControl::$vcolDefs">AccessControl::$vcolDefs</a></strong>  (for get/query) 定义虚拟字段</p>
<p>常用于展示关联表字段、统计字段等。<br />
在query,get操作中可以通过res参数指定需要返回的每个字段，这些字段可能是普通列名(col)/虚拟列名(vcol)/子对象(subobj)名。</p>
<h5 id="AccessControl-2.1 关联字段">2.1 关联字段</h5>
<p>例如，在订单列表中需要展示用户名字段。设计文档中定义接口：</p>
<pre><code>Ordr.query() -&gt; tbl(id, dscr, ..., userName?, userPhone?, createTm?)</code></pre>
<p>query接口的&quot;...&quot;之后就是虚拟字段。后缀&quot;?&quot;表示是非缺省字段，即必须在&quot;res&quot;参数中指定才会返回，如：</p>
<pre><code>Ordr.query(res="*,userName")</code></pre>
<p>在cond中可以直接使用虚拟字段，不管它是否在res中指定，如</p>
<pre><code>Ordr.query(cond="userName LIKE 'jian%'", res="id,dscr")</code></pre>
<p>通过设置$vcolDefs实现这些关联字段：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["u.name AS userName", "u.phone AS userPhone"],
            "join" =&gt; "INNER JOIN User u ON u.id=t0.userId",
            // "default" =&gt; false, // 指定true表示Ordr.query在不指定res时或res中以"*"开头时将默认会返回该字段。
        ],
        [
            "res" =&gt; ["log_cr.tm AS createTm"],
            "join" =&gt; "LEFT JOIN OrderLog log_cr ON log_cr.action='CR' AND log_cr.orderId=t0.id",
        ]
    ]
}</code></pre>
<ul>
<li>default: 默认虚拟字段，示例：&quot;<em>,picCnt&quot;表示返回t0表所有字段加默认虚拟字段，再加指定的picCnt字段；而&quot;t0.</em>,picCnt&quot;返回t0表的所有字段以及picCnt字段，不含默认虚拟字段；<br />
对移动端应用接口，尽量不使用default=true，让前端自由控制。对管理平台接口，列表页和详情对话框上均显示的虚拟字段设置为default=true比较方便，因为链接方式打开详情对话框时，只能直接调用&quot;Obj.query&quot;接口，不方便指定res参数。</li>
</ul>
<p>注意：如果需要在程序中引入某个关联表定义，可以调用addVCol显式指定，例如：</p>
<pre><code>$this-&gt;addVcol("userName"); // 在SQL语句中添加SELECT userName ... JOIN User
// 如果不想影响SELECT字段:
$this-&gt;addVcol("userName", false, "-"); // 只在SQL语句中添加 JOIN User</code></pre>
<h5 id="AccessControl-2.2 关联字段依赖">2.2 关联字段依赖</h5>
<p>假设设计有“订单评价”对象，它会与“订单对象”相关联：</p>
<pre><code>@Rating: id, orderId, content</code></pre>
<p>表间的关系为：</p>
<pre><code>订单评价Rating(orderId) &lt;-&gt; 订单Ordr(userId) &lt;-&gt; 用户User</code></pre>
<p>现在要为Rating表增加关联字段 &quot;Ordr.dscr AS orderDscr&quot;, 以及&quot;User.name AS userName&quot;, 设计接口为：</p>
<pre><code>Rating.query() -&gt; tbl(id, orderId, content, ..., orderDscr?, userName?)
注意：userName字段不直接与Rating表关联，而是通过Ordr表桥接。</code></pre>
<p>实现时，只需在vcolDefs中使用require指定依赖字段：</p>
<pre><code>class AC1_Rating extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["o.dscr AS orderDscr", "o.userId"],
            "join" =&gt; "INNER JOIN Ordr o ON o.id=t0.orderId",
        ],
        [
            "res" =&gt; ["u.name AS userName"],
            "join" =&gt; "INNER JOIN User u ON o.userId=u.id",
            "require" =&gt; "userId", // *** 定义依赖，如果要用到res中的字段如userName，则自动添加userId字段引入的表关联。
            // 这里指向orderDscr也可以，一般习惯上指向关联的字段。
        ],
    ];
}</code></pre>
<p>使用require, 框架可自动将Ordr表作为中间表关联进来。<br />
如果没有require定义，以下调用</p>
<pre><code>Rating.query(res="*,orderDscr,userName")</code></pre>
<p>也不会出问题，因为在userName前指定了orderDscr，框架可自动引入相关表。而以下查询就会出问题：</p>
<pre><code>Rating.query(res="*,userName")
或
Rating.query(res="*,userName,orderDscr")</code></pre>
<p>(v5.5) 如果要依赖多个字段，&quot;require&quot;可以用逗号分隔多个字段，如：</p>
<pre><code>"require" =&gt; "userId,procId"</code></pre>
<p>可以依赖任何字段，包括虚拟字段(vcolDefs中定义的), 主表字段, 子表字段(subobj中定义的)。</p>
<h5 id="AccessControl-2.3 计算字段">2.3 计算字段</h5>
<p>示例：管理端应用在查询订单时，需要订单对象上有一个原价字段：</p>
<pre><code>Ordr.query() -&gt; tbl(..., amount2)
amount2:: 原价，通过OrderItem中每个项目重新计算累加得到，不考虑打折优惠。</code></pre>
<p>可实现为：</p>
<pre><code>class AC0_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["(SELECT SUM(qty*ifnull(price2,0)) FROM OrderItem WHERE orderId=t0.id) AS amount2"],
        ]
    ];
}</code></pre>
<h5 id="AccessControl-2.4 子表压缩字段">2.4 子表压缩字段</h5>
<p>除了使用<a href="#AccessControl::$subobj">子表</a>, 对于简单的情况，也可以设计为将子表压缩成一个虚拟字段，在Query操作时直接返回。</p>
<p>示例：OrderItem是Ordr对象的一个子表，现在想在查询Ordr对象列表时，返回OrderItem的相关信息。<br />
这就要把一张子表压缩成一个字段。我们使用List来描述这种压缩字段的格式：表中每行以&quot;,&quot;分隔，行中每个字段以&quot;:&quot;分隔。<br />
利用List，可将接口设计为：</p>
<pre><code>Ordr.query() -&gt; tbl(..., itemsInfo)
itemsInfo:: List(name, price, qty). 例如"洗车:25:1,换轮胎:380:2", 表示两行记录，每行3个字段。注意字段内容中不可出现":", ","这些分隔符。</code></pre>
<p>子表压缩是一种特殊的计算字段，可实现如下：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["(SELECT group_concat(concat(oi.name, ':', oi.price, ':', oi.qty)) FROM OrderItem oi WHERE oi.orderId=t0.id) itemsInfo"] 
        ],
        ...
    ]
}</code></pre>
<p>注意：计算字段，包括子表压缩字段都是很消耗性能的。</p>
<h5 id="AccessControl-2.5 自定义字段">2.5 自定义字段</h5>
<p>假设有张虚拟表Task, 它没有存储在数据库中, 另一张表UserTaskLog关联到它。在设计文档中定义如下:</p>
<pre><code>@UserTaskLog: id, userId, taskId
@Conf::$taskTable: id, type, name
(关联： UserTaskLog(taskId) &lt;-&gt; Conf::$taskTable )

提供查询接口：
UserTaskLog.query() -&gt; tbl(id, taskId, ..., taskName)
taskName:: 由关联表的taskTable.name字段得到。</code></pre>
<p>实现中，在代码中直接定义Task表：</p>
<pre><code>class Conf
{
    static $taskTable = [
        ["id" =&gt; 1, "type"=&gt;"invite", "name" =&gt; "邀请5个用户注册"],
        ["id" =&gt; 2, "type"=&gt;"invite", "name" =&gt; "邀请10个用户注册"],
    ];
}</code></pre>
<p>通过在vcolDefs的join属性指定一个函数，可以实现返回taskName字段：</p>
<pre><code>function getTaskName(&amp;$row)
{
    foreach (Conf::$taskTable as $task) {
        if ($row["taskId"] == $task["id"]) {
            $row["taskName"] = $task["name"];
        }
    }
}

class AC1_UserTaskLog extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["taskName"],
            "join" =&gt; getTaskName
        ]
    ];
}</code></pre>
<p>注意:</p>
<ul>
<li>自定义字段只限于对query/get的最终结果集进行操作</li>
<li>自定义字段不能用于设置cond条件.</li>
</ul>
<h5 id="AccessControl-2.6 flags和props字段">2.6 flags和props字段</h5>
<p>（试验功能）<br />
框架支持两个特别的数据库字段flags和props，并可将它们拆解为flag_xxx或prop_xxx格式。<br />
例如，在订单表上定义：</p>
<pre><code>@Ordr: id, flags

- flags: EnumList(g-go-员工已出发, v-visited-已回访, r-reviewed-已人工校验过, i-imported-是自动导入的订单)。例如, 值"gv"表示有"g"标志和"v"标志。</code></pre>
<p>要查询已回访或未回访的订单，可以用：</p>
<pre><code>Ordr.query(cond="flag_v=1/0", res="id,flags") -&gt; tbl(id, flags, ..., flag_g?, flag_v?, ...)</code></pre>
<p>注意：返回字段将自动根据flags的值增加诸如flag_g这样的字段，值为0或1；但res参数中不可指定flag_v这样的虚拟字段。</p>
<p>要设置或清除已回访标志&quot;g&quot;，可以用：</p>
<pre><code>Ordr.set(id=1)(flag_g=1/0)</code></pre>
<p>注意：不可一次设置多个flag。如果需要这样，则应直接设置flags字段。</p>
<p>props字段与之类似，flags字段中一个标志是一个字母，而props字段的标志以一个词，因而多个标志以空格隔开。<br />
假设Ordr表中定义了props字段，且某条记录的值为&quot;go visited&quot;，则该记录返回字段会有 <code>{ prop_go:1, prop_visited:1 }</code></p>
<p>也可以进行设置和清除，并可与flags一起用，如：</p>
<pre><code>Ordr.set(id=1)(prop_go=1/0, flag_v=1/0)</code></pre>
<h5 id="AccessControl-2.7 外部虚拟字段(ExtVCol)">2.7 外部虚拟字段(ExtVCol)</h5>
<p>(v5.2) 增加“外部虚拟字段”用于创建嵌套查询。</p>
<h6 id="AccessControl-2.7.1 嵌套查询">2.7.1 嵌套查询</h6>
<p>示例：下面已定义y, m两个虚拟字段，现在基于y和m再创建新的虚拟字段ym，可以这样：</p>
<pre><code>$vcolDefs = [
    [
        "res" =&gt; ["year(tm) y", "month(tm) m"],
    ],
    [
        "res" =&gt; ["concat(y, '-', m) ym"],
        // 用isExt指定这是外部虚拟字段
        "isExt" =&gt; true,
        // 用require指定所有依赖的内层字段
        "require" =&gt; 'y,m'
    ]
]</code></pre>
<p>query/get接口生成的查询语句大致为：</p>
<pre><code>SELECT t0.*, concat(y, '-', m) ym
FROM (
    SELECT t0.id,year(tm) y,month(tm) m FROM ApiLog t0
    WHERE ...
) t0</code></pre>
<p>如果不使用isExt=true, 则生成的语句为像下面这样，是不正确的语句，将报“数据库错误”：</p>
<pre><code>SELECT t0.id,year(tm) y,month(tm) m, concat(y, '-', m) ym FROM ApiLog t0
WHERE ...</code></pre>
<p>用require标识依赖的内层查询的字段，上例中若未指定requrie，查询<code>query(res="id,y,m,ym")</code>没有问题，但查询<code>query(res="id,ym")</code>将出错，因为y,m字段未引入，不可识别。</p>
<p>注意：外部虚拟字段依赖的内部字段将自动添加到查询中，但不会返回到最终结果集中，除非用户指定了要这些字段或指定参数<code>hiddenFields:0</code>。<br />
比如query(res=&quot;id,ym&quot;)会在查询时引入y,m字段，但最终并不返回. (内部使用了hiddenFields机制)</p>
<p>注意：目前外部虚拟字段不支持使用join, cond条件。</p>
<p>注意：关于时间统计相关的虚拟字段，一般通过tmCols函数来指定：</p>
<pre><code>protected function onInit() {
    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols() ];
}</code></pre>
<p>外部虚拟字段主要用于性能优化。对于上例中的计算字段，即使没有外部虚拟字段机制，也还可以利用MySQL变量做这样实现：</p>
<pre><code>$vcolDefs = [
    [
        "res" =&gt; ["@y:=year(tm) y", "@m:=month(tm) m"],
    ],
    [
        "res" =&gt; ["concat(@y, '-', @m) ym"],
        "require" =&gt; 'y,m'
    ]
]</code></pre>
<h6 id="AccessControl-2.7.2 关联子查询优化">2.7.2 关联子查询优化</h6>
<p><strong>外部虚拟字段还常常用于优化SELECT语句中关联子查询性能。框架将自动识别关联子查询，并使用嵌套查询机制来优化性能。</strong></p>
<p>如果一个虚拟字段，它的res中定义有关联子查询，在query操作时可能性能很差，当：<br />
排序字段(orderby)不是主表字段；<br />
或orderby虽然是主表字段（甚至是索引），但查询引擎的查询计划不佳，也会导致特别慢。（这种情况下，测试时可强制指定索引，比如在from t0后加上force index(primary)，可以大幅优化。）</p>
<p>示例：对ApiLog表有虚拟字段sesCnt，它使用关联子查询，定义如下：</p>
<pre><code>$vcolDefs = [
    [
        // 可作为“外部虚拟字段”来优化
        "res" =&gt; ["(select count(*) from ApiLog t1 where t1.ses=t0.ses) sesCnt"]
    ],
    [
        // 普通虚拟字段，将在示例中用于orderby
        "res" =&gt; ["u.name AS userName", "u.phone AS userPhone"],
        "join" =&gt; "INNER JOIN User u ON u.id=t0.userId"
    ]
]</code></pre>
<p>未做优化时，query(orderby=userName)查询语句如下：</p>
<pre><code>SELECT t0.*, (select count(*) from ApiLog t1 where t1.ses=t0.ses) sesCnt
FROM ApiLog t0
JOIN User ...
ORDER BY u.name
LIMIT 0,20</code></pre>
<p>当ORDER-BY不是主表ApiLog的字段时，或虽然是主表字段但数据库的查询引擎判断失误（此处不可预料），<br />
都可能导致查询计划中将会把虚拟字段全部计算出来后再排序，导致巨慢。（实测2万行数据，查询20行数据需要16秒）</p>
<p>优化策略是使用嵌套查询，将sesCnt字段放到外层查询：</p>
<pre><code>SELECT t0.*, (select count(*) from ApiLog t1 where t1.ses=t0.ses) sesCnt
FROM (
    SELECT t0.*
    FROM ApiLog t0
    JOIN User ...
    ORDER BY u.name
    LIMIT 0,20
) t0</code></pre>
<p>这样只需要对最终结果20条数据计算虚拟字段。<br />
由于出现了外层和内层两层SQL，我们将外层的虚拟字段称为外部虚拟字段。</p>
<p>效果：ApiLog仅20000行数据，优化前查询一次16秒，优化后降低到0.2s。</p>
<p>注意：框架对于未指定isExt也未指定join条件的vcol定义，将自动生成isExt及require属性。<br />
对于含有嵌套子查询的res定义，例如<code>(SELECT... WHERE t0.xxx...)</code>，当作是外部字段，并分析其依赖于t0表的字段。例如：</p>
<pre><code>[
    "res" =&gt; ["(select count(*) from ApiLog t1 where t1.ses=t0.ses and t0.userId is not null) sesCnt"],
]</code></pre>
<p>将自动计算和添加属性：</p>
<pre><code>    "isExt" =&gt; true,
    "require" =&gt; "ses,userId"</code></pre>
<p>上面require属性指定内层查询应暴露给外层的字段，可以是主表字段、虚拟字段或子表字段，不可加任何前缀（如<code>t0.ses</code>不允许），如果有多个可用逗号分隔。<br />
注意res中的t0指的是内层查询的结果表，名称固定为t0; 而require中的表指的是内层查询内部的表。<br />
如果自动处理或识别有误，可手工设置isExt和require属性。</p>
<p>注意：使用外部虚拟字段时，将导致require中的字段被添加到查询结果集，例如上面例子中的&quot;ses,userId&quot;字段，会出现在SQL语句中，但会在最终结果集中删除（除非请求指定了要该字段）。</p>
<p>注意：如果想禁止优化，可手工设置vcolDef的isExt属性为false：</p>
<pre><code>[
    "res" =&gt; ["(select count(*) from ApiLog t1 where t1.ses=t0.ses) sesCnt"],
    "isExt" =&gt; false
]</code></pre>
<p>注意：一组res定义将共享相同的isExt和require属性，因而不可将外部字段与普通字段定义在一起，且依赖t0字段不同的的外部字段也不应放在一组中。<br />
下面示例在处理时将报错：</p>
<pre><code>[
    "res" =&gt; [
        "(SELECT COUNT(id) FROM PdiRecord WHERE type='EQ' AND orderId=t0.id) AS eqCnt",
        "t0.DMSOrderNo dmsOrder",
    ]
]</code></pre>
<p>应将res分成几组：</p>
<pre><code>[
    "res" =&gt; [
        "(SELECT COUNT(id) FROM PdiRecord WHERE type='EQ' AND orderId=t0.id) AS eqCnt",
    ]
],
[
    "res" =&gt; [
        "t0.DMSOrderNo dmsOrder",
    ]
]</code></pre>
<p>注意: 在做分组查询时(query接口有gres参数), 不会自动优化为外部查询, 以免语句错误.<br />
示例: <code>Hub.query</code>为列车查询接口, exFlag为虚拟字段, 表示是否有异常, 则 查看正常/异常列车数接口为:</p>
<pre><code>Hub.query(gres: "exFlag", res: "count(*) cnt") -&gt; tbl(exFlag, cnt)</code></pre>
<p>实现虚拟字段:</p>
<pre><code>[ "res" =&gt; ["EXISTS (SELECT id FROM Exception WHERE hubId=t0.id AND doneFlag=0) exFlag"] ]</code></pre>
<p>在普通查询时, exFlag为外部字段, 而在分组查询时为普通字段.</p>
<h4 id="AccessControl-3 子表">3 子表</h4>
<p class="var"><strong>@var <a id="AccessControl::$subobj">AccessControl::$subobj</a></strong>  (for get/query) 定义子表</p>
<p>subobj: { name =&gt; {obj, cond, AC?, res?, default?=false, forceUpdate(v5.5) } } （v5.4）指定子表对象obj，全面支持子表的增删改查。</p>
<p>或</p>
<p>subobj: { name =&gt; {sql, default?=false, wantOne?=0} } 指定SQL语句，查询结果作为子表对象（旧写法，不建议使用。只允许查询，不支持对子表修改）</p>
<p>设计接口：</p>
<pre><code>Ordr.get() -&gt; {id, ..., @orderLog}
- orderLog: {id, tm, dscr, ..., empName} 订单日志子表。</code></pre>
<p>实现：复用已有的子表对象。</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $subobj = [
        "orderLog" =&gt; ["obj"=&gt;"OrderLog", "cond"=&gt;"orderId=%d", "AC"=&gt;"AC1_OrderLog", "res"=&gt;"*,empName,empPhone"],
    ];
}

class OrderLog extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["e.name AS empName", "e.phone AS empPhone"],
            "join" =&gt; "LEFT JOIN Employee e ON e.id=t0.empId"
        ]
    ];
}</code></pre>
<p>选项说明：</p>
<ul>
<li>obj: 指定调用哪个对象</li>
<li>AC: 指定使用哪个类来实现接口，常常是<code>AC1</code>, <code>AC2</code>这些类，其实只要是AccessControl的子表均可以，可以不是AC前缀的类。<br />
也可以不指定，这时根据用户权限自动寻找合适的类。<br />
也可以指定使用基类<code>"AC"=&gt;"AccessControl"</code>，用在没有专门为该对象定义过类的情况下。</li>
<li>cond: cond条件是可选的，常常在其中包含&quot;field=%d&quot;，表示子表的field关联主表的id字段。(v5.5)也可用<code>field={id}</code>这种格式来表示关联主表的子段。</li>
<li>还可以使用res, cond, gres, orderby等子表query接口的标准参数，或子表类支持的特定参数。</li>
</ul>
<p>子表对象也可以直接用SQL语句来定义：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $subobj = [
        "orderLog" =&gt; ["sql"=&gt;"SELECT ol.*, e.name empName, e.phone empPhone FROM OrderLog ol LEFT JOIN Employee e ON ol.empId=e.id WHERE orderId=%d"],
        // 替代了obj, AC, cond, res等子表设置。一般建议还是用obj来定义子表较好。
    ];
}</code></pre>
<p>子表和虚拟字段类似，支持get/query操作，执行指定的SQL语句作为结果。结果以一个数组返回[{id, tm, ...}]。</p>
<ul>
<li>sql选项定义子表查询语句，其中常常用&quot;field=%d&quot;这样语句来定义与主表id字段的关系。(v5.5) 也可以用&quot;field={id}&quot;的格式，花括号里定义主表关联字段。<br />
(v5.1)为了优化query接口，避免每一行分别查一次子表，查询语句会被改为&quot;field IN (...)&quot;的形式。</li>
</ul>
<p>其它选项：</p>
<ul>
<li>default: 与虚拟字段(vcolDefs)上的&quot;default&quot;选项一样，表示当&quot;res&quot;参数以&quot;<em>&quot;开头(比如`res=&quot;</em>,picCnt&quot;`)或未指定时，是否默认返回该字段。</li>
<li>wantOne: 如果为1, 则结果以一个对象返回即 {id, tm, ...}, 适用于主表与子表一对一的情况。(v6.1)如果值为2，则所有字段将直接合并到主表（如果有同名字段将覆盖）。</li>
</ul>
<h5 id="AccessControl-3.1 子表的增删改查操作">3.1 子表的增删改查操作</h5>
<p>假设主对象为Obj，子对象为Obj1，设计如下：</p>
<pre><code>@Obj: id, name
vcol: @obj1 (说明：vcol表示虚拟字段，@obj1表示字段obj1是个数组，一般就是子对象)

@Obj1: id, objId, name （通过objId关联主对象)</code></pre>
<h6 id="AccessControl-3.1.1 子表添加">3.1.1 子表添加</h6>
<p>在添加主对象时，同时添加子对象:</p>
<pre><code>Obj.add()(name, @obj1...) -&gt; id</code></pre>
<p>示例：</p>
<pre><code>callSvr("Obj.add", $.noop, {
    name: "name1",
    obj1: [
        { name: "obj1-name1" },
        { name: "obj1-name2" }
    ]
});</code></pre>
<h6 id="AccessControl-3.1.2 子表查询">3.1.2 子表查询</h6>
<p>主对象添加后，可以通过get接口获取主对象及子对象：</p>
<pre><code>callSvr("Obj.get", {id: 1001, res:"id,name,obj1"}) -&gt; {
    id: 1001,
    name: "name1",
    obj1: [
        { id: 10001, name: "obj1-name1" },
        { id: 10002, name: "obj1-name2" }
    ]
});</code></pre>
<p>要控制子对象的查询结果字段，可以加<code>res_{子对象名}</code>参数；要控制子对象的查询参数，可以加<code>param_{子对象名}</code>参数，示例：</p>
<pre><code>callSvr("Obj.get", {id: 1001, res:"id,name,obj1", res_obj1:"id,name"})
或
callSvr("Obj.get", {id: 1001, res:"id,name,obj1", param_obj1: { res: "id,name"} })
callSvr("Obj.get", {id: 1001, res:"id,name,obj1", param_obj1: { res: "id,name", cond: "id&gt;=10002"} })</code></pre>
<p>注意：如果使用了别名，则指定res,param时也要用别名：</p>
<pre><code>callSvr("Obj.get", {id: 1001, res:"id,name,obj1 objList", res_objList:"id,name"})
// 甚至可以多别名分别指定:
callSvr("Obj.get", {id: 1001, res:"id,name,obj1 objList,obj1 objList2", res_objList:"id,name", res_objList2:"id,code"})</code></pre>
<p>当然，也可以直接查询子对象，如：</p>
<pre><code>callSvr("Obj1.query", {cond: "objId=1001", res:"id,name,obj1", fmt:"array"}) -&gt; [
    { id: 10001, name: "obj1-name1" },
    { id: 10002, name: "obj1-name2" }
]</code></pre>
<p>这里用fmt参数指定返回array格式，因为默认返回的是<code>h/d</code>格式.</p>
<h6 id="AccessControl-3.1.3 子表更新与删除">3.1.3 子表更新与删除</h6>
<p>主对象添加后，可以通过set接口添加/更新/删除子对象。假定后端提供如下更新接口（可更新主表字段name等，子表名为obj1）：</p>
<pre><code>Obj.set(id)(name?, @obj1...)</code></pre>
<p>示例：</p>
<pre><code>callSvr("Obj.set", {id: 1001}, $.noop, {
    name: "name1",
    obj1: [
        { id: 10001, name: "obj1-name1-changed" }, // set接口中指定子表id的，表示更新该子表行
        { name: "obj1-name3" },  // set接口中未指定子表id的，表示新增子表行
        { id: 10002, _delete: 1}  // set接口中指定子表id且设置了`_delete: 1`，表示删除该子表行
    ]
});</code></pre>
<p>注意：主对象删除时（del/delIf接口），子对象不会自动删除。后端应根据情况自行处理。</p>
<p>(v6) 对子表的更新有patch/put两种模式，通过submode参数指定，该参数只对主表set接口有效：</p>
<ul>
<li>patch: 默认模式，见上面示例。须用<code>_delete</code>指定要删除的原来子表项。</li>
<li>put: 覆盖更新模式。与patch的区别是无须指定<code>_delete</code>来删除原来子表项，新子表直接覆盖原子表。</li>
</ul>
<p>与上述示例中效果相同的操作示例：</p>
<pre><code>// submode=put模式
callSvr("Obj.set", {id: 1001, submode: "put"}, $.noop, {
    name: "name1",
    obj1: [
        { id: 10001, name: "obj1-name1-changed" }, // set接口中指定子表id的，表示更新该子表行; 也可以不指定id，则原来记录被删除，这条会被重新添加。
        { name: "obj1-name3" },  // set接口中未指定子表id的，表示新增子表行
        // 原表中的10002项未指定，则自动被删除。
    ]
});</code></pre>
<p>注意：add接口在指定uniKey参数时，可检查数据存在则更新(即调用set接口)。因此add/batchAdd接口也可以指定submode参数。<br />
在批量导入(batchAdd接口+uniKey参数)时，默认使用put模式做子表更新。</p>
<p>(v5.5) subobj选项forceUpdate</p>
<p>对子表进行修改和删除时，默认会要求该项必须已关联主表。加此选项强制更新关联。<br />
在上面示例中，如果子项<code>id=10001</code>或<code>id=10002</code>的关联字段objId为空或与主表<code>id=1001</code>不同，则会报错“找不到该项”(因为数据隔离，该项确实不属于该主表，所以查不到)。<br />
加上选项<code>forceUpdate =&gt; true</code>就可以直接更新关联或删除指定子项了（但也同时引入安全隐患）：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $subobj = [
        "orderLog" =&gt; ["obj"=&gt;"OrderLog", ..., "forceUpdate" =&gt; true],
    ];
}</code></pre>
<h5 id="AccessControl-3.2 关联子表对象">3.2 关联子表对象</h5>
<p>(v5.5)<br />
典型的主子表关系是一对多的，如果将上面例子反过来，在<code>OrderLog.query</code>中想返回Ordr对象，也可使用subobj机制，如接口定义为：</p>
<pre><code>OrderLog.query() -&gt; tbl(id, ..., @ordr)</code></pre>
<p>可实现为：</p>
<pre><code>class AC2_OrderLog extends AccessControl
{
    protected $subobj = [
        "ordr" =&gt; [
            "obj"=&gt;"Ordr", "AC"=&gt;"AC2_Ordr", "cond"=&gt;"t0.id={orderId}", // 用`{主表字段名}`设置关联外键。注意它等价于定义 `"cond"=&gt;"t0.id=%d", "%d"=&gt;"orderId"`
            //"sql"=&gt;"SELECT * FROM Ordr t1 WHERE t1.id={orderId}", // 也可以用 "sql" 来替代obj/AC/res/cond等子表选项
            "res" =&gt; "t0.*",
            "wantOne"=&gt;1,
            "default"=&gt;true
        ]
    ];
}</code></pre>
<p>多对一的关联表往往设置<code>wantOne=1</code>，这样ordr属性就是个对象而非数组。</p>
<p>注意：在主表add接口中支持同时添加关联表, 但不可在set接口中添加/更新关联表.</p>
<p>(v6.1) 设置<code>wantOne=2</code>，可以将子表合并到主表中。<br />
有一种统计型子表也比较常见，比如Task(任务)-Task1(子任务)的关联模型中，定义统计子表<code>%task1stat={successCnt/成功数, failCnt/失败数, lastTm/最后时间}</code></p>
<pre><code>class AC2_Task extends AccessControl
{
    protected $subobj = [
        "task1stat" =&gt; [
            "obj" =&gt; 'Task1',
            "cond" =&gt; 'task1Id={id}',
            "res" =&gt; "COUNTIF(result='S') successCnt, COUNTIF(result='F') failCnt, MAX(tm) lastTm",
            "wantOne" =&gt; 2
        ]
    ];
}</code></pre>
<p>注意：COUNTIF与SUMIF是筋斗云扩展的统计函数，允许在res中指定。</p>
<pre><code>callSvr("Task.get", {id: 1, res:"id,name,task1stat"});</code></pre>
<p>出来的结果示例：<code>{id: 1, name: "task1", successCnt: 3, failCnt: 0, lastTm: "2020-1-1 10:10:10"}</code>。<br />
而如果<code>wantOne=1</code>，则结果为：<code>{id: 1, name: "task1", task1stat: {successCnt: 3, failCnt: 0, lastTm: "2020-1-1 10:10:10"}}</code>。</p>
<p>一般在定义subobj时指定<code>wantOne=1</code>，而在调用时可通过<code>param_{subobj名}</code>参数中指定wantOne来灵活调整，如：</p>
<pre><code>callSvr("Task.get", {id: 1, res:"id,name,task1stat", param_task1stat:{wantOne:2} });</code></pre>
<h5 id="AccessControl-3.3 子表查询参数">3.3 子表查询参数</h5>
<p>(v5.4)<br />
可以通过 <code>res_{子对象名}</code> 或 <code>param_{子对象名}</code> 为子对象指定查询条件，param可指定子对象可接受的一切参数。<br />
示例：实现接口 <code>Hub.query(id, ..., lastData)</code>, 查询主机时，可通过lastData字段返回最近一次的主机数据.</p>
<pre><code>class AC2_Hub extends AccessControl
{
    protected $subobj = [
        "lastData" =&gt; ["obj"=&gt;"HubData", "cond"=&gt;"hubId=%d", "AC"=&gt;"AC2_HubData", "res"=&gt;"tm,pos,speed,alt", "wantOne"=&gt;1 ]
    ];
}</code></pre>
<p>前端调用例：</p>
<pre><code>callSvr("Hub.get", {id:5, res: "id,name,lastData", res_lastData:"pos,speed"});
或
callSvr("Hub.get", {
    id: 5,
    res: "id,name,lastData", // 指定返回子对象lastData，可在param_lastData中定义其参数
    param_lastData: {res:"pos,speed", cond:"tm&gt;'2019-1-1'"} 
    // 这个里面的res相当于直接用res_lastData参数; 若指定cond，不会覆盖$subobj定义中的cond，而是追加条件。
    // cond条件同样支持使用子对象的虚拟字段, 如子对象定义了`year(tm) y`，可以用`cond: "y&gt;=2020"`条件。
});</code></pre>
<p>参数中还可以添加orderby等标准query接口条件，或子对象query接口支持的自定义查询条件。</p>
<p>特别地，在子查询param中还可以指定<code>wantOne</code>覆盖subobj中的定义，如返回最近5条数据可以调用：</p>
<pre><code>callSvr("Hub.get", {
    id: 5,
    res: "id,name,lastData", 
    param_lastData: {pagesz: 5, wantOne: 0} 
});</code></pre>
<p>注意：子查询适合用于get接口。<br />
对于query接口，可用于一般带分页的查询，一次返回主表项几十个的情况。<br />
例如典型的主、子表场景：一次查询不超过100个订单（分页&lt;100），一个订单带有最多几十行明细，或最多几十条订单日志。<br />
不可用于总查询返回（主表项数乘以子表项数）超过千行的场景，因为会丢数据。虽可以通过调节子表的maxPageSz解决，但并不建议这样做。</p>
<p>query接口的子查询默认是不分页的，即返回所有子对象数据（实现时是设置pagesz=-1，所有主表项的子对象数加起来默认最多10000条，所以可能会造成子对象丢失问题）。<br />
即使指定wantOne也会查询出所有数据后返回首行，若指定pagesz参数则会报错。</p>
<p>这是由于query接口的子查询使用了查询优化，对所有主表项一次查询返回所有子对象。<br />
当关联表很大时（如主表每条数据关联上千条）不适用。或通过设置参数<code>disableSubobjOptimize=1</code>禁用query接口的子查询优化。<br />
这时一次query接口相当于分别执行多次get接口，效率低，但允许指定pagesz或wantOne参数只返回指定条数据。</p>
<p>query接口子查询示例：</p>
<pre><code>// subobj定义中指定了wantOne=1，但它仍会查所有子对象并取第一条（get接口没有这个问题），当子对象很多时可能丢失数据。
callSvr("Hub.query", {
    res: "id,name,lastData"
});

// 禁用了子查询优化，这时为每个主表项分别查询子对象，根据wantOne=1为每个主表项返回1个子对象。
callSvr("Hub.query", {
    disableSubobjOptimize: 1,
    res: "id,name,lastData"
});

// wantOne设置为0可覆盖掉subobj定义中的wantOne参数，返回所有子对象列表。
// 但这里设置pagesz无效，框架将报错。
callSvr("Hub.query", {
    res: "id,name,lastData", 
    param_lastData: {pagesz: 5, wantOne: 0}  // pagesz设置无效，将出错!!!
});

// 禁用了子查询优化，这时为每个主表项分别查询子对象，根据pagesz=5为每个主表项返回5个子对象。
callSvr("Hub.query", {
    disableSubobjOptimize: 1,
    res: "id,name,lastData", 
    param_lastData: {pagesz: 5, wantOne: 0}  // pagesz设置有效
});</code></pre>
<p>此处细节较为复杂，最佳实践请参考“筋斗云开发实例讲解”文档的“最先、最后关联问题”。</p>
<p>【res增强语法：指定子表查询参数】</p>
<p>(v6.1) 在res参数中支持通过子表前后缀修饰来定义子表的wantOne和res参数。称为【子表修饰】<br />
示例：</p>
<pre><code>callSvr("Task.query", {
    res: "%task, @task1, ...task2stat={successCnt,failCnt}"
});</code></pre>
<p>相当于：</p>
<pre><code>callSvr("Task.query", {
    res: "%task, @task1={*,successCnt,failCnt}, ...task2stat"
    param_task: {wantOne: 1},
    param_task1: {wantOne: 0},
    res_task1: "*,successCnt,failCnt",
    param_task2stat: {wantOne: 2},
});</code></pre>
<ul>
<li>
<p>前缀符号<code>@</code>,<code>%</code>和<code>...</code>分别表示输出形式为数组、对象(hash)和展开对象，即对应<code>param_{子表名}</code>中的wantOne参数的0，1和2值。<br />
如果不指定，那么以子表定义中的wantOne定义为准。</p>
</li>
<li>
<p>后缀<code>={子表res}</code>定义子表res，等同于指定<code>res_{子表名}</code>参数。如果未指定，则使用子表定义中的res参数。</p>
</li>
<li>支持同时指定别名，如：<code>@task1 子任务={*,successCnt}</code></li>
<li>支持嵌套定义，如：<code>@task1 子任务={*, ...task2stat={*,successCnt}}</code></li>
</ul>
<h4 id="AccessControl-4 操作完成回调">4 操作完成回调</h4>
<p class="fn"><strong>@fn <a id="AccessControl::onAfter">AccessControl::onAfter</a></strong> (&$ret)  (for all) 操作完成时的回调。可修改操作结果ret。</p>
<p>如果要对get/query结果中的每行字段进行设置，应重写回调 onHandleRow.<br />
有时使用 onAfterActions 就近添加逻辑更加方便。</p>
<p>注意：对于query接口，无论返回哪种格式（如默认的压缩表、或用fmt参数指定list/csv/txt/excel等格式），在onAfter或onAfterActions中都是对象数组的格式，如：</p>
<pre><code>[ [ "id"=&gt;100, "name"=&gt;"name1"], ["id"=&gt;101", "name"=&gt;"name2"], ... ]</code></pre>
<p class="var"><strong>@var <a id="AccessControl::$onAfterActions">AccessControl::$onAfterActions</a></strong>  =[].  onAfter的替代方案，更易使用，便于与接近的逻辑写在一起。</p>
<p class="var"><strong>@var <a id="AccessControl::$id">AccessControl::$id</a></strong>   get/set/del时指定的id, 或add后返回的id.</p>
<p>例如，添加订单时，自动添加一条日志，可以用：</p>
<pre><code>protected function onValidate()
{
    if ($this-&gt;ac == "add") {
        ... 
        // 可修改$ret
        $this-&gt;onAfterActions[] = function (&amp;$ret) use ($logAction) {
            $orderId = $this-&gt;id;
            dbInsert("OrderLog", [
                "orderId" =&gt; $orderId,
                "action" =&gt; "CR",
                "tm" =&gt; date(FMT_DT)  // 或用mysql表达式 dbExpr("now()"]
            ]);
        };
    }
}</code></pre>
<p>与onAfter类似，加到onAfterActions集合中的函数，如果要修改返回数据，只要在函数参数中声明<code>&amp;$ret</code>就可以修改它了。</p>
<p>注意：</p>
<ul>
<li>如果接口返回错误(jdRet或throw Exception，包括DirectReturn), onAfter以及onAfterActions该回调均不执行</li>
</ul>
<p>(v5.4) 如果要在应用处理完成时添加逻辑，可使用全局对象<code>$X_APP</code>的onAfterActions方法，注意这时逻辑不在同一数据库事务中。</p>
<p class="see"><strong>@see <a href="#$X_APP">$X_APP</a></strong> </p>
<p class="fn"><strong>@fn <a id="AccessControl::onHandleRow">AccessControl::onHandleRow</a></strong> (&$rowData) (for get/query) 在onAfter之前运行，用于修改行中字段。</p>
<h4 id="AccessControl-5 其它">5 其它</h4>
<h5 id="AccessControl-5.1 编号自定义生成">5.1 编号自定义生成</h5>
<p class="fn"><strong>@fn <a id="AccessControl::onGenId">AccessControl::onGenId</a></strong> () (for add) 指定添加对象时生成的id. 缺省返回0表示自动生成.</p>
<p>示例：为避免ID暴露业务数据，可跳号生成ID，比如造成单量放大5-20倍的假象:</p>
<pre><code>protected function onGenId()
{
    $id = queryOne("SELECT MAX(id) FROM Ordr");
    return $id + rand(5, 20);
}</code></pre>
<p>这个示例在超大并发时可能会有ID重复的风险且性能不高，更好的方法是向一个ID生成器服务发起请求。</p>
<h5 id="AccessControl-5.2 缺省排序">5.2 缺省排序</h5>
<p class="var"><strong>@var <a id="AccessControl::$defaultSort">AccessControl::$defaultSort</a></strong>  ?= "t0.id" (for query)指定缺省排序.</p>
<p>示例：Video对象默认按id倒序排列：</p>
<pre><code>class AC_Video extends AccessControl 
{
    protected $defaultSort = "t0.id DESC";
    ...
}</code></pre>
<p>当query接口没有指定orderby参数时，使用$defaultSort排序；例外：对分组查询未指定orderby参数时（即指定有gres参数时），是不会加默认排序的。</p>
<h5 id="AccessControl-5.3 缺省输出字段列表">5.3 缺省输出字段列表</h5>
<p class="var"><strong>@var <a id="AccessControl::$defaultRes">AccessControl::$defaultRes</a></strong>  (for query)指定缺省输出字段列表. 如果不指定，则为"*", 即 "t0.*" 加默认虚拟字段(指定default=true的字段)</p>
<h5 id="AccessControl-5.4 最大每页数据条数">5.4 最大每页数据条数</h5>
<p class="var"><strong>@var <a id="PAGE_SZ_LIMIT">PAGE_SZ_LIMIT</a></strong>  =10000 默认每页最大数据条数</p>
<p class="fn"><strong>@fn <a id="AccessControl::getMaxPageSz">AccessControl::getMaxPageSz</a></strong> ()  (for query) 取每页最大数据条数。为非负整数。</p>
<p class="var"><strong>@var <a id="AccessControl::$maxPageSz">AccessControl::$maxPageSz</a></strong>  ?= -1 (for query) 指定某对象的每页最大数据条数。默认值为-1，表示使用PAGE_SZ_LIMIT值即10000。</p>
<p>前端通过 {obj}.query(pagesz)来指定每页返回多少条数据，缺省是20条，最高不可超过$maxPageSz条。当指定为负数时，表示按$maxPageSz条返回。<br />
（旧版maxPageSz不允许超过PAGE_SZ_LIMIT，v6.1起不限制）</p>
<pre><code>class MyObj extends AccessControl
{
    protected $maxPageSz = 20000; // 最大允许返回20000条
    // protected $maxPageSz = -1; // 最大允许返回 PAGE_SZ_LIMIT 条
}</code></pre>
<h5 id="AccessControl-5.5 虚拟表和视图">5.5 虚拟表和视图</h5>
<p>假如要对ApiLog进行过滤，只查询管理端的写操作。实现以下接口：</p>
<pre><code>EmpLog.query() -&gt; tbl(id, tm, userId, ac, req, res, reqsz, ressz, empName?, empPhone?)</code></pre>
<p>一种办法可以在后台定义一个视图，如:</p>
<pre><code>CREATE VIEW EmpLog AS
SELECT t0.id, tm, userId, ac, req, res, reqsz, ressz, e.name empName, e.phone empPhone
FROM ApiLog t0
LEFT JOIN Employee e ON e.id=t0.userId
WHERE t0.app='emp-adm' AND t0.userId IS NOT NULL
ORDER BY t0.id DESC</code></pre>
<p>然后可将该视图当作表一样查询（但不可更新），如：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
}</code></pre>
<p>这样就可以实现上述接口了。</p>
<p>另一种办法是直接使用AccessControl创建虚拟表，代码如下：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
    protected $table = 'ApiLog';
    protected $defaultSort = "t0.id DESC";
    protected $defaultRes = "id, tm, userId, ac, req, res, reqsz, ressz, empName, empPhone";
    protected $vcolDefs = [
        [
            "res" =&gt; ["e.name AS empName", "e.phone AS empPhone"],
            "join" =&gt; "LEFT JOIN Employee e ON e.id=t0.userId"
        ]
    ];

    protected function onQuery() {
        $this-&gt;addCond("app='emp-adm' and userId IS NOT NULL");
    }
}</code></pre>
<p>与上例相比，它不仅无须在数据库中创建视图，还也可以进行更新。<br />
其要点是：</p>
<ul>
<li>重写 AccessControl::$table</li>
<li>重写 AccessControl::$defaultRes</li>
<li>用addCond添加缺省查询条件</li>
</ul>
<p>table也可以指定为子表(即视图)，例如上例也可以这样实现，省去onQuery中的实现：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
    // 注意：子查询要加括号括起来
    protected $table = "(SELECT * FROM ApiLog t0 WHERE t0.app='emp-adm' and t0.userId IS NOT NULL)";
    protected $defaultSort = "t0.id DESC";
    protected $defaultRes = "id, tm, userId, ac, req, res, reqsz, ressz, empName, empPhone";
    protected $vcolDefs = [
        [
            "res" =&gt; ["e.name AS empName", "e.phone AS empPhone"],
            "join" =&gt; "LEFT JOIN Employee e ON e.id=t0.userId"
        ]
    ];
}</code></pre>
<p>甚至可将整个SQL子查询封在table中：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
    protected $table = "(SELECT t0.id, tm, userId, ac, req, res, reqsz, ressz, e.name AS empName, e.phone AS empPhone </code></pre>
<p>FROM ApiLog t0<br />
LEFT JOIN Employee e ON e.id=t0.userId<br />
WHERE t0.app='user' and t0.userId IS NOT NULL<br />
ORDER BY t0.id DESC)&quot;;<br />
}</p>
<h5 id="AccessControl-5.6 query接口输出格式">5.6 query接口输出格式</h5>
<p>query接口支持fmt参数：</p>
<ul>
<li>list: 生成<code>{ @list, nextkey?, total? }</code>格式，而非缺省的 <code>{ @h, @d, nextkey?, total? }</code>格式</li>
<li>array: (v5.5) 直接返回对象数组, 没有分页信息. 若未指定pagesz参数, 则pagesz自动为-1, 尽可能返回全部数据.</li>
<li>tree: (v5.5) 将{id,fatherId}线性结构转为树型结构{id,children}.<br />
可以通过URL参数treeFields重定义各字段名，默认值为<code>id,fatherId,children</code>，设置示例：<code>{treeFields:'code,fatherCode'}</code>，<code>{treeFields:'code,fatherCode,subtree'}</code><br />
注意：和array一样不支持分页。</li>
<li>one: 类似get接口，只返回第一条数据，常用于统计等接口。若查询不到则抛错。</li>
<li>one?: (v5.5) 与&quot;one&quot;相似，但若查询不到则返回false而不抛出错误。而且若只有一个字段，则直接返回该字段内容，而非该行对象。</li>
<li>
<p>csv/txt/excel: 导出文件，注意为了避免分页，调用时可设置较大的pagesz值。</p>
<ul>
<li>csv: 逗号分隔的文件，utf8编码。</li>
<li>excel: 逗号分隔的文件，gb18030编码以便excel可直接打开不会显示中文乱码。</li>
<li>txt: 制表分隔的文件, utf8编码。</li>
</ul>
</li>
<li>hash: (v5.5) 返回key-value形式的数据. 值可以是对象, 数组还是标量, 从而有多种细分格式, 如<br />
&quot;hash&quot;, &quot;hash:keyField&quot;, &quot;hash:keyField,valueField&quot;, &quot;multihash&quot;, &quot;multihash:keyField&quot;, &quot;multihash:keyField,valueField&quot;等形式</li>
</ul>
<p>注意：hash/multihash和array, tree格式一样不支持分页。<br />
array和hash格式示例:</p>
<pre><code>callSvr("Sn.query", {gres:"status", res:"COUNT(id) cnt")
// {h: ["status","cnt"], d: [{status:"CA", cnt:2}, {status:"CR", cnt:50}, {status:"RE", cnt:2}]}

callSvr("Sn.query", {gres:"status", res:"COUNT(id) cnt", fmt:"array")
// [{status:"CA", cnt:2}, {status:"CR", cnt:50}, {status:"RE", cnt:2}]

callSvr("Sn.query", {gres:"status", res:"COUNT(id) cnt",fmt:"hash"}) 或(未指定keyField时,默认取第1个字段即status)
callSvr("Sn.query", {gres:"status", res:"COUNT(id) cnt",fmt:"hash:status"})
// {"CA":{status:"CA", cnt:2}, "CR":{status:"CR", cnt:50}, "RE":{status:"RE", cnt:2}}

callSvr("Sn.query", {gres:"status", res:"COUNT(id) cnt",fmt:"hash:status,cnt"})
// {"CA", 2, "CR":50, "RE": 2}

callSvr("Sn.query", {gres:"status", res:"COUNT(id) cnt",fmt:"multihash:cnt"})
// {2:[{status:"CA",cnt:2}, {status:"RE",cnt:2}], 50:[{status:"CR", cnt:50}]}
callSvr("Sn.query", {gres:"status", res:"COUNT(id) cnt",fmt:"multihash:cnt,status"})
// {2:["CA","RE"], 50:["CR"]}</code></pre>
<p>TODO: 可加一个系统参数<code>_enc</code>表示输出编码的格式。</p>
<h5 id="AccessControl-5.7 distinct查询">5.7 distinct查询</h5>
<p>如果想生成<code>SELECT DISTINCT t0.a, ...</code>查询，<br />
当在AccessControl外部时，可以设置</p>
<pre><code>$env-&gt;param("distinct", 1);</code></pre>
<p>如果是在AccessControl子类中，可以设置</p>
<pre><code>$this-&gt;sqlConf["distinct"] =1;</code></pre>
<h5 id="AccessControl-5.8 枚举支持及自定义字段处理">5.8 枚举支持及自定义字段处理</h5>
<p>(版本5.0)</p>
<p class="var"><strong>@var <a id="AccessControl::$enumFields">AccessControl::$enumFields</a></strong>  {field => map/fn($val, $row) }支持处理枚举字段，或自定义处理。</p>
<p>作为比onHandleRow/onAfterActions等更易用的工具，enumFields可对返回字段做修正。例如，想要对返回的status字段做修正，如&quot;CR&quot;显示为&quot;Created&quot;，可设置：</p>
<pre><code>$this-&gt;enumFields["status"] = ["CR"=&gt;"Created", "CA"=&gt;"Cancelled"];</code></pre>
<p>也可以设置为自定义函数，如：</p>
<pre><code>$map = ["CR"=&gt;"Created", "CA"=&gt;"Cancelled"];
$this-&gt;enumFields["status"] = function($v, $row) use ($map) {
    if (array_key_exists($v, $map))
        return $v . "-" . $map[$v];
    return $v;
};</code></pre>
<p>enumFields机制支持字段别名，比如若调用<code>Ordr.query(res="id 编号,status 状态")</code>，status字段使用了别名&quot;状态&quot;后，仍然可被正确处理，而用onHandleRow则不好处理。</p>
<p>(v5.5) enum字段也常用于计算字段，即根据其它字段进行处理，可在require选项中指定依赖字段，并在函数中使用getAliasVal/setAliasVal方法取值/设置值:</p>
<pre><code>protected $vcolDefs = [
    // 不良数
    [
        "res" =&gt; ["(SELECT COUNT(DISTINCT s.id) FROM Fault f JOIN Sn s ON s.id=f.snId WHERE s.orderId=t0.id) faultCnt"],
    ],
    // 根据不良数计算不良率。faultCnt是虚拟字段，qty是主表字段
    [
        "res" =&gt; ["null faultRate"], // 由于不是主表字段，须当成alias添加，不可直接指定为"faultRate"。给默认值null
        "require" =&gt; "faultCnt,qty" // 依赖字段可以是主表字段、虚拟字段或子表字段均可，若依赖多个字段，用","分隔
    ]
];

$this-&gt;enumFields["faultRate"] = function($v, $row) {
    // 不要直接用 $row["xxx"]取值, 否则若调用时指定了别名（典型的是导出文件或输出统计表场景）则取不到值了。
    $faultCnt = $this-&gt;getAliasVal($row, "faultCnt");
    $qty = $this-&gt;getAliasVal($row, "qty");
    // $this-&gt;setAliasVal($row, "qty1", $qty); // 设置值，除非特别需要，一般不建议在enumFields某计算字段里设置其它字段值。
    return $qty == 0? 0: $faultCnt/$qty;
};</code></pre>
<p>此外，枚举字段可直接由请求方通过res参数指定描述值，如：</p>
<pre><code>Ordr.query(res="id, status =CR:Created;CA:Cancelled")
或指定alias:
Ordr.query(res="id 编号, status 状态=CR:Created;CA:Cancelled")</code></pre>
<p>也可定义空值(null)或空串(&quot;&quot;)的显示，如: <code>status =CR:新创建;CA:已取消;:(null)</code>，表示将空值显示为<code>(null)</code>。</p>
<p>(版本5.1)<br />
设置enumFields也支持逗号分隔的枚举列表，比如字段值为&quot;CR,CA&quot;，实际可返回&quot;Created,Cancelled&quot;。</p>
<p>(v5.2) 导出文件时，处理字段格式</p>
<p>在导出报表时，常常需要处理字段格式，例如，虚拟子表字段inv定义为：<code>[{itemId,qty,itemName}]</code></p>
<pre><code>protected $subobj = [
    "inv" =&gt; ["sql"=&gt;"SELECT itemId,qty,i.name itemName FROM Inv LEFT JOIN Item i ON i.id=Inv.itemId WHERE couponId=%d"]
];</code></pre>
<p>默认导出文件时值会处理成 &quot;1000:1.00:商品1,1001:2.00:商品2&quot; 这种格式，现在希望导出格式如&quot;商品1,商品2(2件)&quot;，可处理该字段如下：<br />
(写在onQuery或onInit回调中均可)</p>
<pre><code>protected function onQuery() {
    if ($this-&gt;isFileExport()) {
        $this-&gt;enumFields["inv"] = function($v, $row) {
            if (is_array($v)) {
                $v = join(',', array_map(function ($e) {
                    if ($e['qty'] != 1.0)
                        return $e['itemName'] . '(' . doubleval($e['qty']) . '件)';
                    else
                        return $e['itemName'];
                }, $v));
            }
            return $v;
        };
    }
}</code></pre>
<h5 id="AccessControl-5.9 动态设置虚拟字段及属性">5.9 动态设置虚拟字段及属性</h5>
<p>添加虚拟字段或属性，vcolDefs, subobj建议在onInit函数中添加或修改，而不是onQuery中。否则用res指定返回字段将无效。<br />
onQuery中常用addCond来添加过滤条件，也可以设置enumFields。<br />
示例：AC2继承AC0类，但要增加一个虚拟字段，又不要影响AC1，故可以加在AC2的onInit中。</p>
<pre><code>protected function onInit() {
    parent::onInit();
    $this-&gt;vcolDefs[] = [
        "res" =&gt; ["(SELECT result FROM PdiItemResult WHERE pdiRecordId=t0.id AND itemId=1) 客户描述"],
    ];
}</code></pre>
<h4 id="AccessControl-6 批量更新(setIf/batchSet)和批量删除(delIf/batchDel)">6 批量更新(setIf/batchSet)和批量删除(delIf/batchDel)</h4>
<p>(v5.1) 以Ordr对象为例，要支持根据条件批量更新或删除：</p>
<pre><code>Ordr.setIf(cond)(field1=value1, field2=value2, ...)
Ordr.delIf(cond)</code></pre>
<p>在cond中，除了使用基本字段，还可以像query接口一样使用虚拟字段来查询，框架自动join相关表。</p>
<p>示例：对具有PERM_MGR权限的员工，登录后允许批量更新和批量删除：</p>
<pre><code>class AC2_Ordr extends AccessControl
{
    function api_delIf() {
        checkAuth(PERM_MGR);
        return parent::api_delIf();
    }
    function api_setIf() {
        checkAuth(PERM_MGR);
        $this-&gt;checkSetFields(["status", "cmt"]);
        return parent::api_setIf();
    }
}</code></pre>
<p>setIf接口会检测readonlyFields及readonlyFields2中定义的字段不可更新。<br />
也可以直接用checkSetFields指定哪些字段允许更新。</p>
<p>(v6) batchSet与setIf接口原型相同，但batchSet接口将根据cond参数查出所有的记录，一一进行set操作；即它会执行onValidate中的逻辑。<br />
而setIf不走onValidate，相关逻辑必须为setIf接口再定制。</p>
<p>类似地还有batchDel操作。显然，batchSet/batchDel逐条记录执行，会比setIf/delIf慢很多，但好处是可重用单条记录更新、删除的业务逻辑。</p>
<p>注意：筋斗云web管理端上，多选或按Ctrl键进行的批量操作，用的是setIf/delIf。</p>
<h4 id="AccessControl-7 连接第三方数据库">7 连接第三方数据库</h4>
<p>如果是同一个数据库服务实例中的其它数据库，是可以直接访问的，只要访问时带上数据库名前缀即可。如：</p>
<pre><code>class AC2_Data extends AccessControl
{
    protected $table = "fiss.aiobjectdata";
}</code></pre>
<p>如果是在其它数据库服务器上，则可以通过修改env来实现，示例：</p>
<pre><code>class AC2_Data extends AccessControl
{
    protected $table = "fiss.aiobjectdata";
    protected function onInit() {
        $db = "mysql:host=10.80.140.32;port=3306;dbname=fiss"; // 也可以连oracle, mssql等各种其它类型数据库，参考DBEnv
        $this-&gt;env = clone $this-&gt;env;
        $this-&gt;env-&gt;changeDb("mysql", $db, "root", "123456");
        // 这里是直接打开新连接的，如果一次接口调用中访问多次，则应全局缓存该连接
    }
}</code></pre></div>
<div class="block">
<h2 id="AccessControl.delField">@var AccessControl.delField</h2>
<p>如果设置该字段(例如设置为disableFlag字段)，则把删除动作当作是设置该字段为1，且在查询接口中跟踪此字段增加过滤。<br />
必须是flag字段（0/1值）。</p>
<p>示例：</p>
<pre><code>// class AC2_Store extends AccessControl
protected $delField = "disableFlag";</code></pre>
<p>由于数据实际上未删除，可以在管理端中手中调用接口恢复，比如</p>
<pre><code>callSvr("Store.set", {id:139}, $.noop, {disabledFlag:0})</code></pre></div>
<div class="block">
<h2 id="AccessControl::$uuid">@var AccessControl::$uuid ?=false 将id伪装为uuid</h2>
<p>为避免整数类型的id暴露内部编号，可输出仿uuid类型的id，例如：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $uuid = true;
}</code></pre>
<p>例如原先<code>Ordr.get/Ordr.query</code>返回<code>{id: 41}</code>，现在变为<code>{id: "d9a37e4c2038e8ad"}</code>.</p>
<p>其原理为在onQuery中添加：</p>
<pre><code>$this-&gt;enumFields["id"] = function($v, $row) {
    return jdEncryptI($v, "E", "hex");
};</code></pre>
<p>param函数以&quot;id&quot;类型符来支持这种伪uuid类型，如：</p>
<pre><code>$id = param("userId"); // 支持整数或伪uuid类型
$key = param("pagekey/id");  // 支持整数或伪uuid类型</code></pre></div>
<div class="block">
<h2 id="AccessControl::$enableObjLog">@var AccessControl::$enableObjLog ?=true 默认记ObjLog</h2>
<p>标准增删改方法会自动记录ObjLog。如果不要自动记录，可设置此字段为false.</p>
<p class="see"><strong>@see <a href="#ApiLog::addObjLog">ApiLog::addObjLog</a></strong>  (table, id, dscr) 手动加ObjLog</p></div>
<div class="block">
<h2 id="AccessControl::$table">@var AccessControl::$table AC表名</h2>
<p class="var"><strong>@var <a id="AccessControl::$obj">AccessControl::$obj</a></strong>  AC对象名</p>
<p>AC类AC_MyObj1默认的表名和对象名都是MyObj1，但有时会修改表名（比如底层表其它是一个查询视图，或几个对象共享一张表），<br />
比如AC_Vender/AC_Customer的对象名分别为Vendor和Customer, 而表名都是BizPartner。</p></div>
<div class="block">
<h2 id="AccessControl::callSvc">@fn AccessControl::callSvc($tbl, $ac, $param=null, $postParam=null, $useTmpEnv=true)</h2>
<p class="alias"><strong>@alias <a id="JDApiBase::callSvc">JDApiBase::callSvc</a></strong> </p>
<p>直接调用指定类的接口，如内部直接调用&quot;PdiRecord.query&quot;方法：</p>
<pre><code>// 假如当前是AC2权限，对应的AC类为AC2_PdiRecord:
$acObj = new AC2_PdiRecord();
$acObj-&gt;callSvc("PdiRecord", "query");</code></pre>
<p>这相当于调用<code>callSvcInt("PdiRecord.query")</code>。<br />
区别是，用本方法可自由指定任意AC类，无须根据当前权限自动匹配类。</p>
<p>例如，&quot;PdiRecord.query&quot;接口不对外开放，只对内开放，我们就可以只定义<code>class PdiRecord extends AccessControl</code>（无AC前缀，外界无法访问），在内部访问它的query接口：</p>
<pre><code>$acObj = new PdiRecord();
$acObj-&gt;callSvc("PdiRecord", "query");</code></pre>
<p>和callSvcInt一样，如果未指定param/postParam，则没有参数；<br />
若想使用当前环境的参数，应显式指定$_GET/$_POST环境参数，如<code>$acObj-&gt;callSvc("PdiRecord", "query", $_GET, $_POST);</code><br />
默认对当前环境的修改(如修改$_GET等)会被恢复，除非指定参数$useTmpEnv=false。</p>
<p>注意: 对比callSvc函数，它只能使用当前环境，不可指定param/postParam参数。</p>
<p>也适用于AC类内的调用，这时可不传table，例如调用当前类的add接口：</p>
<pre><code>$rv = $this-&gt;callSvc(null, "add", null, $postParam);</code></pre>
<p>示例：通过手机号发优惠券时，支持批量发量，用逗号分隔的多个手机号，接口：</p>
<pre><code>手机号userPhone只有一个时：
Coupon.add()(userPhone, ...) -&gt; id

如果userPhone包含多个手机号：（用逗号隔开，支持中文逗号，支持有空格）
Coupon.add()(userPhone, ...) -&gt; {cnt, idList}</code></pre>
<p>重载add接口，如果是批量添加则通过callSvc再调用add接口：</p>
<pre><code>function api_add() {
    if (@$_POST["userPhone"]) {
        $arr = preg_split('/[,，]/u', $_POST["userPhone"]);
        if (count($arr) &gt; 1) {
            $idList = [];
            foreach ($arr as $e) {
                $postParam = array_merge($_POST, ["userPhone"=&gt;trim($e)]);
                $idList[] = $this-&gt;callSvc(null, "add", null, $postParam);
            }
            jdRet(0, [
                "cnt"=&gt;count($idList),
                "idList"=&gt;$idList
            ]);
        }
    }
    return parent::api_add();
}</code></pre>
<p>框架自带的批量添加接口api_batch也是类似调用。</p>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p>
<p class="see"><strong>@see <a href="#callSvcInt">callSvcInt</a></strong> </p></div>
<div class="block">
<h2 id="AccessControl::addRes">@fn AccessControl::addRes($res, $analyzeCol=true)</h2>
<p>定义新的虚拟字段，并添加到get/query接口的返回字段中。<br />
如果要引入已有的虚拟字段，应调用addVCol。</p>
<p>注意: </p>
<ul>
<li>analyzeCol=true时, 注册到对象的虚拟字段中。</li>
<li>addRes(&quot;col+1 as col1&quot;, false); -- 简单地新定义一个计算列, as可省略</li>
</ul>
<p>返回true/false: 是否添加到输出列表</p>
<p class="see"><strong>@see <a href="#AccessControl::addCond">AccessControl::addCond</a></strong>  其中有示例</p>
<p class="see"><strong>@see <a href="#AccessControl::addVCol">AccessControl::addVCol</a></strong>  添加已定义的虚拟列。</p></div>
<div class="block">
<h2 id="AccessControl::addCond">@fn AccessControl::addCond($cond, $prepend=false, $fixUserQuery=true)</h2>
<p class="param"><strong>@param $prepend</strong>  为true时将条件排到前面。</p>
<p class="param"><strong>@param $fixUserQuery</strong>  值为true会自动处理虚拟字段，但这时不允许复杂查询。设置为false写cond不受规则限制。</p>
<p>addCond用于添加查询条件，可以使用表的字段或虚拟字段(无须用t0限定表名)，功能等同于前端调用对象query接口时给定的cond参数。<br />
可以调用多次addCond时，多个条件会依次用&quot;AND&quot;连接起来，如果指定参数prepand为true，则该条件加在最前面。</p>
<p>示例：假如设计有接口：</p>
<pre><code>Ordr.query(q?) -&gt; tbl(..., payTm?)
参数：
- q: 查询条件，值为"paid"时，查询10天内已付款的订单。且结果会多返回payTm/付款时间字段。</code></pre>
<p>实现时，在onQuery中检查参数&quot;q&quot;并定制查询条件，虚拟字段可以用addVCol来引入(否则要在查询的res参数中指定了)：</p>
<pre><code>protected $vcolDefs = [
    [
        "res" =&gt; ["olpay.tm payTm"],
        "join" =&gt; "LEFT JOIN OrderLog olpay ON olpay.orderId=t0.id AND olpay.action='PA'"
    ]
];
protected function onQuery()
{
    if (param("q") == "paid") {
        $validDate = date("Y-m-d", strtotime("-9 day"));
        // 注意：要添加虚拟字段用addVCol，不是addRes(常用于定义虚拟字段)
        $this-&gt;addVCol("payTm");
        $this-&gt;addCond("payTm&gt;'$validDate'");
    }
}</code></pre>
<p>如果想要查询固定返回空，习惯上可以用:</p>
<pre><code>$this-&gt;addCond("1&lt;&gt;1");</code></pre>
<p>当给定参数fixUserQuery=false时，可以突破query接口对cond的限制，比如不允许各种子查询，也不允许使用各种SQL函数（count/sum/avg等少量聚合函数除外）。<br />
但此时不再支持虚拟字段，各字段前宜加上相应的表名.</p>
<p>仍用上面示例：</p>
<pre><code>// 在cond中使用payTm虚拟字段，可自动解析和引入它的定义
$this-&gt;addCond("payTm&gt;'$validDate'");</code></pre>
<p>这相当于调用：</p>
<pre><code>$this-&gt;addVCol("payTm", false, "-"); // 需手工引入虚拟字段定义，用“-”参数表示并不加到结果字段中
$this-&gt;addCond("olpay.tm&gt;'$validDate'", false, false);</code></pre></div>
<div class="block">
<h2 id="AccessControl::addJoin">@fn AccessControl::addJoin(joinCond)</h2>
<p>添加Join条件.</p>
<p class="see"><strong>@see <a href="#AccessControl::addCond">AccessControl::addCond</a></strong>  其中有示例</p></div>
<div class="block">
<h2 id="AccessControl::addVCol">@fn AccessControl::addVCol($col, $ignoreError=false, $alias=null, $isHiddenField=false)</h2>
<p class="param"><strong>@param $col</strong>  必须是一个英文词, 不允许"col as col1"形式; 该列必须在 vcolDefs 中已定义.</p>
<p class="param"><strong>@param $alias</strong>  列的别名。可以中文. 特殊字符"-"表示只添加join/cond等定义，并不将该字段加到输出字段中。</p>
<p class="return"><strong>@return Boolean</strong>  T/F 返回false表示添加失败。</p>
<p>引入一个已有的虚拟字段及其相应关联表，例如之前在vcolDefs中定义过虚拟字段<code>createTm</code>:</p>
<pre><code>// 引入createTm定义及关联表，且在最终输出中添加createTm列
$this-&gt;addVCol("createTm"); 

// 只引入createTm字段的关联表，不影响最终输出字段
$this-&gt;addVCol("createTm", false, "-");

// 添加字段(如果不是虚拟字段则当作表字段添加)
$this-&gt;addVCol("createTm", self::VCOL_ADD_RES); // ignoreError特别用法

// 如果不是虚拟字段则当作子表字段或表字段添加
$this-&gt;addVCol("createTm", self::VCOL_ADD_RES|self::VCOL_ADD_SUBOBJ); // ignoreError特别用法</code></pre>
<p>如果isHiddenField=true, 则该字段是辅助字段，最终返回前将删除(AccessControl::hiddenFields机制)</p></div>
<div class="block">
<h2 id="AccessControl::addRequireCol">@fn AccessControl::addRequireCol($col, $isExt=false)</h2>
<p>添加依赖字段，用法与vcolDefs中的require属性相同，可以指定一个或多个字段（多个字段以逗号分隔）。<br />
字段可以是实体字段、虚拟字段或子表字段。注意实体字段无须加&quot;t0.&quot;表前缀。</p>
<p>与addRes方法类似，但不影响最终返回结果，也不可指定别名。<br />
即如果这些字段没有在res中指定，则返回前会自动删除。<br />
示例：</p>
<pre><code>$this-&gt;addRequireCol("flowId");
$this-&gt;addRequireCol("flowId,qty"); // 加多个字段</code></pre></div>
<div class="block">
<h2 id="AccessControl::api_add">@fn AccessControl::api_add()</h2>
<p>标准对象添加接口。</p>
<p class="key"><strong>@key <a id="uniKey">uniKey</a></strong>  防止重复机制/add接口支持存在则更新，不存在则添加</p>
<p>(v6) 支持在添加时根据指定字段判断记录是否存在，若存在则更新，不存在才添加，称为uniKey机制。<br />
示例：添加工单，若指定code对应的工单已存在，则更新该工单</p>
<pre><code>callSvr("Ordr.add", {uniKey: "code"}, $.noop, {code: "ordr1", itemId: 99});</code></pre>
<p>uniKey可以指定多个字段，以逗号分隔即可，常用于关联表，如操作物料类别与打印模板的关联表Cate_PrintTpl:</p>
<pre><code>callSvr("Cate_PrintTpl.add", {uniKey: "cateId,printTplId"}, $.noop, {cateId: 101, printTplId: 999});</code></pre>
<p>表示添加关联记录，若关联记录已存在则忽略。（当指定要添加的字段刚好完全就是uniKey中字段时，没必要做更新操作，会直接忽略。）</p>
<p>注意：uniKey支持使用虚拟字段（如关联字段）.</p>
<p>如果uniKey以&quot;!&quot;结尾，则表示<strong>更新模式</strong>。示例：更新工单，当记录不存在时报错：</p>
<pre><code>callSvr("Ordr.add", {uniKey: "code!"}, $.noop, {code: "ordr1", itemId: 99});</code></pre>
<p>在uniKey匹配时，默认处理是更新操作，可以通过<code>uniKeyMode</code>参数来定制行为：</p>
<ul>
<li>set: （默认）转为更新操作（如果要更新的字段刚好就是uniKey字段，则忽略更新），接口最终返回已存在记录的id。</li>
<li>error: 如果已存在记录，则报错。在更新模式下等同于set，即记录不存在时报错。</li>
<li>ignore: 忽略添加操作，接口直接返回已存在记录的id。在更新模式下，不添加，也不报错，以-1值返回记录id。</li>
</ul>
<p>示例：添加工单，如果code已存在则报错，不允许添加</p>
<pre><code>callSvr("Ordr.add", {uniKey:"code", uniKeyMode:"error"}, $.noop, {code:"4500000088", itemId: 1, qty: 100});</code></pre>
<p>示例：更新工单，当记录不存在时返回-1，不报错：</p>
<pre><code>callSvr("Ordr.add", {uniKey: "code!", uniKeyMode:"ignore"}, $.noop, {code: "ordr1", itemId: 99});</code></pre>
<p>注意：尽管add接口可通过uniKey实现更新模式，但set接口是不支持uniKey的。<br />
通过导入实现<strong>批量更新</strong>应使用batchAdd；一般地通过条件进行批量更新使用batchSet/setIf接口。</p>
<p>以上示例是将记录的控制权交给接口调用方的（如前端或后端内部接口调用callSvcInt等）；如果要在后端对象内控制重复记录行为，请参考</p>
<p class="see"><strong>@see <a href="#AccessControl::checkUniKey">AccessControl::checkUniKey</a></strong> </p>
<p class="key"><strong>@key <a id="doValidateOnly">doValidateOnly</a></strong> </p>
<p>标准add/set接口支持的URL参数，如果为1，表示只做数据验证，不做实际的添加或更新动作，示例：</p>
<pre><code>callSvr("Employee.add", {doValidateOnly: 1}, $.noop, {uname:'a'})</code></pre></div>
<div class="block">
<h2 id="AccessControl::checkUniKey">@fn AccessControl::checkUniKey($uniKey, $handler="error", $required=false)</h2>
<p>后端检查uniKey用于防止重复：</p>
<ul>
<li>添加时，如果根据uniKey匹配的记录已存在，则做更新处理（或报错不许重复设置）；</li>
<li>更新时，如果根据uniKey匹配的记录已存在，则报错不许设置（或忽略不设置）。</li>
</ul>
<p>该函数只对add/set接口有效，一般用在onValidate回调中。</p>
<p class="param"><strong>@param handler</strong>  添加时遇到重复记录的处理方式，可指定为以下字符串值</p>
<ul>
<li>set: 转为更新操作（如果要更新的字段刚好就是uniKey字段，则忽略更新），接口最终返回已存在记录的id。</li>
<li>error: 报错：已存在重复记录。</li>
<li>ignore: 忽略添加操作，接口直接返回已存在记录的id。</li>
</ul>
<p>handler参数只用于add接口; set接口遇到重复均报错处理.</p>
<p class="param"><strong>@param required</strong>  如果设置为true，则该字段添加时不可为空。只对add接口有效，set接口忽略该参数。</p>
<p>用法示例：</p>
<pre><code>function onValidate()
{
    // code字段不允许重复, 添加或更新(add/set)时若发现该记录已存在则报错("error")，但该字段可以为空。
    $this-&gt;checkUniKey("code", "error");

    // uniKey支持多字段：
    // name,phone字段组合不允许重复。在添加时若遇到重复则当作更新处理("set")，且添加时这两个字段不可为空。
    $this-&gt;checkUniKey("name,phone", "set", true);
}</code></pre>
<p>uniKey以&quot;!&quot;结尾为更新模式，即必须匹配到记录，否则报错，详见[uniKey]</p>
<p class="see"><strong>@see <a href="#uniKey">uniKey</a></strong> </p></div>
<div class="block">
<h2 id="AccessControl::api_set">@fn AccessControl::api_set()</h2>
<p>标准对象设置接口。api函数应通过callSvc调用，不应直接调用。</p></div>
<div class="block">
<h2 id="AccessControl::api_get">@fn AccessControl::api_get()</h2>
<p>标准对象获取接口。api函数应通过callSvc调用，不应直接调用。</p></div>
<div class="block">
<h2 id="AccessControl::api_query">@fn AccessControl::api_query()</h2>
<p>标准对象查询接口（列表）。api函数应通过callSvc调用，不应直接调用。</p>
<p>接口参数有：res, cond, pagesz, pagekey, orderby, gres, union, fmt等。(参见DACA架构接口文档)</p>
<p>(v6) cond字段很灵活支持类SQL查询字符串、数组或键值对，参考</p>
<p class="see"><strong>@see <a href="#getQueryCond">getQueryCond</a></strong> </p>
<p>内部调用时还支持以下参数：</p>
<ul>
<li>
<p>res2, cond2: 与res, cond含义相同，为确保只能通过后端代码调用，不可由前端参数指定，必须用dbExpr包一层，比如<br />
[<br />
&quot;res2&quot;=&gt;dbExpr(&quot;id,name,snCnt&quot;),<br />
&quot;cond2&quot;=&gt;dbExpr(&quot;tm&gt;'2020-1-1'&quot;)<br />
]<br />
用于为AccessControl类指定res/cond外的其它字段或条件，而res/cond是可以由前端来指定的。</p>
</li>
<li>join: 指定关联表。必须用dbExpr包一层。</li>
</ul>
<p>调用示例：</p>
<pre><code>// 定死res外部无法覆盖, 但外部可额外指定cond参数
$ret = callSvcInt("PdiRecord.query", [
    "res" =&gt;"id,vinCode,result,orderId,tm", // 用了res则意味着不允许前端指定字段，用res2则前端还可以用res指定其它字段
    "cond2" =&gt;dbExpr("type='EQ' AND tm&gt;='2019-1-1'") // 多个条件也可这样自动拼接： getQueryCond(["type='EQ'", "tm&gt;='2019-1-1']) 或 getQueryCond(["type"=&gt;"EQ", "tm"=&gt;"&gt;=2019-1-1"])
]);</code></pre>
<p class="see"><strong>@see <a href="#AccessControl::addCond">AccessControl::addCond</a></strong> </p>
<p class="see"><strong>@see <a href="#AccessControl::addRes">AccessControl::addRes</a></strong> </p>
<p class="see"><strong>@see <a href="#AccessControl::addJoin">AccessControl::addJoin</a></strong> </p>
<p class="see"><strong>@see <a href="#qsearch">qsearch</a></strong>  模糊查询机制</p></div>
<div class="block">
<h2 id="AccessControl.queryRet">@fn AccessControl.queryRet(objArr, nextkey?, totalCnt?, fixedColCnt?=0)</h2>
<p>处理objArr，按照fmt参数指定的格式返回，与query接口返回相同。例如，默认的<code>h-d</code>表格式, <code>list</code>格式，<code>excel</code>等。</p></div>
<div class="block">
<h2 id="AccessControl.qsearch">@fn AccessControl.qsearch($fields, $q)</h2>
<p class="key"><strong>@key <a id="qsearch">qsearch</a></strong> </p>
<p>模糊查询 (v5.4)</p>
<p>后端可定制如下示例接口：</p>
<pre><code>Obj.query(q) -&gt; 同query接口返回</code></pre>
<p>查询匹配参数q的内容（比如查询name, label等字段）。<br />
参数q是一个字符串，或多个以空格分隔的字符串。例如&quot;aa bb&quot;表示字段包含&quot;aa&quot;且包含&quot;bb&quot;。<br />
每个字符串中可以用通配符&quot;<em>&quot;，如&quot;a</em>&quot;表示以a开头，&quot;<em>a&quot;表示以a结尾，而&quot;</em>a*&quot;和&quot;a&quot;是效果相同的。</p>
<p>定制实现：可指定字段及查询参数</p>
<pre><code>protected function onQuery() {
    $this-&gt;qsearch(["name", "label", "content"], param("q"));
}</code></pre>
<p>(v6) 除了后端定制，query接口还内置支持qsearch操作，前端可直接通过qsearch参数指定查询条件，示例：</p>
<pre><code>callSvr("Ordr.query", {qsearch: "dscr,cmt:张* 退款"})</code></pre>
<p>qsearch的格式是<code>字段1,字符2,...:查询内容</code>(使用英文逗号及冒号分隔).<br />
上例表示在dscr或cmt字段中查找包含&quot;张%&quot;(匹配开头)且包含&quot;%退款%&quot;的记录. 它等价于前端调用：</p>
<pre><code>callSvr("Ordr.query", {cond: {_or: 1, dscr: "~张* and ~退款", cmt: "~张* and ~退款"}})</code></pre>
<p>(v6.1) 可以指定各字段的匹配规则，当查询短语中没有&quot;<em>&quot;时，默认表示包含（即&quot;abc&quot;等价于&quot;</em>abc<em>&quot;）；<br />
如果字段以&quot;</em>&quot;结尾，表示查询&quot;abc&quot;时等价于&quot;abc*&quot;（即该字段默认匹配开头）；<br />
如果字段以&quot;!&quot;结尾，表示必须精确匹配，即查询&quot;abc&quot;就是&quot;abc&quot;，不会模糊匹配。</p>
<pre><code>callSvr("Sn.query", {qsearch: "code!,name*:a001"})</code></pre>
<p>上例表示查询code为&quot;a001&quot;，或是name以&quot;a001&quot;开头的项，等价于调用：</p>
<pre><code>callSvr("Sn.query", {cond: {_or: 1, code: "a001", name: "~a001*"}})</code></pre>
<p class="see"><strong>@see <a href="#getQueryCond">getQueryCond</a></strong> </p></div>
<div class="block">
<h2 id="AccessControl::api_del">@fn AccessControl::api_del()</h2>
<p>标准对象删除接口。api函数应通过callSvc调用，不应直接调用。</p></div>
<div class="block">
<h2 id="AccessControl::checkSetFields">@fn AccessControl::checkSetFields($allowedFields)</h2>
<p>e.g.<br />
function onValidate()<br />
{<br />
if ($this-&gt;ac == &quot;set&quot;)<br />
$this-&gt;checkSetFields([&quot;status&quot;, &quot;cmt&quot;]);<br />
}</p></div>
<div class="block">
<h2 id="AccessControl::api_setIf">@fn AccessControl::api_setIf()</h2>
<p>批量更新。</p>
<p>setIf接口会检测readonlyFields及readonlyFields2中定义的字段不可更新。<br />
也可以直接用checkSetFields指定哪些字段允许更新。<br />
返回更新记录数。<br />
示例：</p>
<pre><code>class AC2_Ordr extends AccessControl {
    function api_setIf() {
        // 限制只有经理权限才能批量更新
        checkAuth(PERM_MGR);

        // 限制只能更新指定字段
        $this-&gt;checkSetFields(["status", "cmt"]);

        // 限制只可更新自己的订单，一般写在onQuery中，以便get/query/setIf/delIf均可通用。
        $empId = $_SESSION["empId"];
        $this-&gt;addCond("empId=$empId");
        // $this-&gt;addJoin(...);

        return parent::api_setIf();
    }
}</code></pre></div>
<div class="block">
<h2 id="api_batchSet">@fn api_batchSet()</h2>
<p>与setIf接口不同，batchSet接口将根据cond参数查出所有的记录，一一进行set操作；即它会执行onValidate中的逻辑。</p></div>
<div class="block">
<h2 id="api_batchDel">@fn api_batchDel()</h2>
<p>与delIf接口不同，batchDel接口将根据cond参数查出所有的记录，一一进行del操作；即它会执行onValidateId中的逻辑。</p></div>
<div class="block">
<h2 id="AccessControl::api_delIf">@fn AccessControl::api_delIf()</h2>
<p>批量删除。返回删除记录数。<br />
示例：</p>
<pre><code>class AC2_Ordr extends AccessControl {
    function api_delIf() {
        // 限制只有经理权限才能批量更新
        checkAuth(PERM_MGR);

        // 限制只可更新自己的订单，一般写在onQuery中，以便get/query/setIf/delIf均可通用。
        $empId = $_SESSION["empId"];
        $this-&gt;addCond("empId=$empId");
        // $this-&gt;addJoin(...);

        return parent::api_delIf();
    }
}</code></pre></div>
<div class="block">
<h2 id="api_dup">@fn api_dup($opt)</h2>
<p>实现对象复制接口，支持一次复制多个。参数id可以是一个整数，或以逗号分隔的多个整数。</p>
<pre><code>Obj.dup(id) -&gt; [newId1, ...]</code></pre>
<p>支持定制，示例：</p>
<pre><code>function api_dup() {
    $this-&gt;dupObjOpt = [
        // 在get请求前，已自动生成了get请求参数，已自动添加了子表项，这里可修改默认请求参数
        "beforeGet" =&gt; function (&amp;$param) {
        },
        // 在add请求前，可修改待添加的数据。如果不指定，默认是将code/name字段自动加随机数。注意原数据的id已删除。
        "beforeAdd" =&gt; function (&amp;$data) {
            $data["code"] .= '-' . rand(1000,10000);
            $data["name"] .= '-' . rand(1000,10000);
        },
    ];
    return parent::api_dup();
}</code></pre>
<p>特别地，如果涉及子表间引用，比如Item有子表specName和specValue，但specValue中有字段specNameId是引用SpecName表的，这种情况就需要将引用旧Id修正为新添加的Id。<br />
可以在子表的onValidateId中调用fixRefId函数来实现。</p>
<pre><code>class AC2_SpecValue 
{
    protected function onValidate()
    {
        if ($this-&gt;ac == 'add') {
            // 修正Item.dup时的错误关联键specNameId，它指向SpecName中的id。
            // 字段值可以是一个或多个（以逗号分隔）Id，如100, "100,101"均可。
            self::fixRefId($_POST["specNameId"], "SpecName");
        }
    }
}</code></pre></div>
<div class="block">
<h2 id="AccessControl::api_batchAdd">@fn AccessControl::api_batchAdd()</h2><div class="toc"><p style="margin-left:0em"><a href="#AccessControl::api_batchAdd-1 支持三种方式上传">1 支持三种方式上传</a></p>
<p style="margin-left:2em"><a href="#AccessControl::api_batchAdd-1.1 直接在HTTP POST中传输内容">1.1 直接在HTTP POST中传输内容</a></p>
<p style="margin-left:2em"><a href="#AccessControl::api_batchAdd-1.2 标准csv/txt文件上传">1.2 标准csv/txt文件上传</a></p>
<p style="margin-left:2em"><a href="#AccessControl::api_batchAdd-1.3 传入对象数组">1.3 传入对象数组</a></p>
<p style="margin-left:0em"><a href="#AccessControl::api_batchAdd-2 通过导入实现批量更新">2 通过导入实现批量更新</a></p>
<p style="margin-left:0em"><a href="#AccessControl::api_batchAdd-3 支持带子表导入">3 支持带子表导入</a></p>
<p style="margin-left:0em"><a href="#AccessControl::api_batchAdd-4 支持列名映射">4 支持列名映射</a></p>
<p style="margin-left:0em"><a href="#AccessControl::api_batchAdd-5 支持id与name转换">5 支持id与name转换</a></p>
</div>
<p>标准接口<code>Obj.batchAdd</code>用于批量导入数据（支持不存在则添加，存在则更新）。返回导入记录数cnt及编号列表idList：</p>
<pre><code>Obj.batchAdd(title?, uniKey?)(...) -&gt; {cnt, @idList}</code></pre>
<p>它在一个事务中执行，一行出错后立即失败返回，该行前面已导入的内容也会被取消（回滚）。</p>
<ul>
<li>
<p>title: List(fieldName). 指定标题行(即字段列表). 如果有该参数, 则忽略POST内容或文件中的标题行.<br />
如&quot;title=name,-,addr&quot;表示导入第一列name和第三列addr, 其中&quot;-&quot;表示忽略该列（v6:或以&quot;-&quot;开头如&quot;-empName&quot;），不导入。<br />
字段列表以逗号或空白分隔, 如&quot;title=name - addr&quot;与&quot;title=name, -, addr&quot;都可以.</p>
</li>
<li>uniKey: (v5.5) 唯一索引字段. 如果指定, 则以该字段查询记录是否存在, 存在则更新。例如&quot;code&quot;, 也支持多个字段（用于关联表），如&quot;bpId,itemId&quot;。<br />
(v6) uniKey支持&quot;!&quot;结尾称为&quot;批量更新&quot;模式，表示强制匹配，用于在批量更新时防止添加记录，如&quot;code!&quot;表示若code匹配则更新，不匹配则报错不添加。<br />
uniKey和uniKeyMode参数是由add接口来支持的，uniKeyMode参数用于定制记录存在时的行为，默认为更新，也可为报错或忽略。参考[uniKey].</li>
</ul>
<p class="see"><strong>@see <a href="#uniKey">uniKey</a></strong> </p>
<h4 id="AccessControl::api_batchAdd-1 支持三种方式上传">1 支持三种方式上传</h4>
<h5 id="AccessControl::api_batchAdd-1.1 直接在HTTP POST中传输内容">1.1 直接在HTTP POST中传输内容</h5>
<p>数据格式为：首行为标题行(即字段名列表)，之后为实际数据行。<br />
行使用&quot;\n&quot;分隔, 列使用&quot;\t&quot;或逗号分隔（后端自动判断）.<br />
接口为：</p>
<pre><code>{Obj}.batchAdd(title?)(标题行，数据行)
(Content-Type=text/plain)</code></pre>
<p>前端JS调用示例：</p>
<pre><code>var data = "name\taddr\n" + "门店1\t地址1\n门店2\t地址2\n";
callSvr("Store.batchAdd", function (ret) {
    app_alert("成功导入" + ret.cnt + "条数据！");
}, data, {contentType:"text/plain"});</code></pre>
<p>或指定title参数:</p>
<pre><code>var data = "门店名\t地址\n" + "门店1\t地址1\n门店2\t地址2\n";
callSvr("Store.batchAdd", {title: "name,addr"}, function (ret) {
    app_alert("成功导入" + ret.cnt + "条数据！");
}, data, {contentType:"text/plain"});</code></pre>
<p>示例: 在chrome console中导入数据</p>
<pre><code>callSvr("Vendor.batchAdd", {title: "-,name, tel, idCard, addr, picId"}, $.noop, `编号 姓名  手机号码    身份证号    通讯地址    身份证图
112 郭志强 15384811000 150221199211215XXX  地址1 532
111 高长平 18375991001 500226198312065XXX  地址2 534
`, {contentType:"text/plain"});</code></pre>
<h5 id="AccessControl::api_batchAdd-1.2 标准csv/txt文件上传">1.2 标准csv/txt文件上传</h5>
<p>上传的文件首行当作标题列，如果这一行不是后台要求的标题名称，可通过URL参数title重新定义。<br />
一般使用excel csv文件（编码一般为gbk），或txt文件（以&quot;\t&quot;分隔列）。<br />
接口为：</p>
<pre><code>{Obj}.batchAdd(title?)(csv/txt文件)
(Content-Type=multipart/form-data, 即html form默认传文件的格式)</code></pre>
<p>后端处理时, 将自动判断文本编码(utf-8或gbk).</p>
<p>前端HTML:</p>
<pre><code>&lt;input type="file" name="f" accept=".csv,.txt"&gt;</code></pre>
<p>前端JS示例：</p>
<pre><code>var fd = new FormData();
fd.append("file", frm.f.files[0]);
callSvr("Store.batchAdd", {title: "name,addr"}, function (ret) {
    app_alert("成功导入" + ret.cnt + "条数据！");
}, fd);</code></pre>
<p>或者使用curl等工具导入：<br />
从excel中将数据全选复制到1.txt中(包含标题行，也可另存为csv格式文件)，然后导入。<br />
下面示例用curl工具调用VendorA.batchAdd导入：</p>
<pre><code>#/bin/sh
baseUrl=http://localhost/p/anzhuang/api.php
param=title=name,phone,idCard,addr,email,legalAddr,weixin,qq,area
curl -v -F "file=@1.txt" "$baseUrl/VendorA.batchAdd?$param"</code></pre>
<p>如果要调试(php/xdebug)，可加URL参数<code>XDEBUG_SESSION_START=1</code>或Cookie中加<code>XDEBUG_SESSION=1</code></p>
<h5 id="AccessControl::api_batchAdd-1.3 传入对象数组">1.3 传入对象数组</h5>
<p>格式为 {list: [...]}</p>
<pre><code>var data = {
    list: [
        {name: "郭志强", tel: "15384811000"},
        {name: "高长平", tel: "18375991001"}
    ]
};
callSvr("Store.batchAdd", function (ret) {
    app_alert("成功导入" + ret.cnt + "条数据！");
}, data, {contentType:"application/json"});</code></pre>
<p>其中指定contentType为json不是必须的，因为新版本callSvr实现中会根据POST内容判断自动使用json。</p>
<h4 id="AccessControl::api_batchAdd-2 通过导入实现批量更新">2 通过导入实现批量更新</h4>
<p>(v5.5) batchAdd接口配合uniKey参数，可实现存在则更新，不存在则添加的逻辑。</p>
<p>示例：接上节示例，在导入时希望实现根据名称与电话(name和tel字段)匹配，则记录存在则做更新，不存在则添加，只须增加uniKey参数：</p>
<pre><code>callSvr("Store.batchAdd", {uniKey: "name,tel"}, function (ret) {
    app_alert("成功导入" + ret.cnt + "条数据！");
}, data);</code></pre>
<p class="see"><strong>@see <a href="#uniKey">uniKey</a></strong>  </p>
<p>注意: v5.5中为batchAdd接口增加了uniKey机制，在v6中为add接口增加了uniKey机制，这样batchAdd可以直接使用add接口的相应机制。</p>
<h4 id="AccessControl::api_batchAdd-3 支持带子表导入">3 支持带子表导入</h4>
<p>(v5.5) 示例：有以下主-子表对象：</p>
<pre><code>工单：@Ordr: id, code, itemId, qty
工单配料单 @BOM: id, orderId, code, name</code></pre>
<p>导入数据列及样例可定义为：（按dlgImport.html中样例定义格式，以<code>!</code>开头的首行为参数行（也可以没有），然后是标题行，后面都是数据行；列以Tab分隔）<br />
注意：拷贝到Excel中看的比较清楚；为避免Excel将长数字显示为科学计数法，在复制前先设置单元格格式为文本。</p>
<pre><code>&lt;script type="text/template" class="tplOrdr"&gt;
!title=code,itemCode,itemName,planTm,planTm1,qty,@bom.code,@bom.name,@bom.qty&amp;uniKey=code
生产订单号   物料编码    物料规格    开工日期    完工日期    生产数量    子件编码    子件规格    基本用量
SCDD210202302   30101001010484  热像仪#Fotric 615C-L47 2021-02-04  2021-02-04  1.00    20901001000052  标品#Lantern_B31-L47  1
SCDD210202302   30101001010484  热像仪#Fotric 615C-L47 2021-02-04  2021-02-04  1.00    10205001000017  标签#Lantern_40*30mm铜版纸空白标签#中性#通用 1
&lt;/script&gt;</code></pre>
<p>注意：由于子表分布在多行，必须以uniKey参数指定主表唯一字段（支持多个字段联合，以逗号分隔），将根据此字段将多行数组组合成对象后一次导入。若不指定uniKey字段，则每行分别添加，导致子表被后面数据所覆盖。<br />
为了正确将主-子表结构的数据行组合成对象，必须保证：组成一个对象的所有行必须在一起，具有相同的uniKey字段，或是对象的第二行起，不指定uniKey字段。</p>
<p>上例也可以简化定义成：(第二行起，无须主表字段，只需要最后三个子表字段) (拷贝到Excel中看)</p>
<pre><code>&lt;script type="text/template" class="tplOrdr"&gt;
!title=code,itemCode,itemName,planTm,planTm1,qty,@bom.code,@bom.name,@bom.qty&amp;uniKey=code
生产订单号   物料编码    物料规格    开工日期    完工日期    生产数量    子件编码    子件规格    基本用量
SCDD210202302   30101001010484  热像仪#Fotric 615C-L47 2021-02-04  2021-02-04  1.00    20901001000052  标品#Lantern_B31-L47  1
                        10205001000017  标签#Lantern_40*30mm铜版纸空白标签#中性#通用 1
&lt;/script&gt;</code></pre>
<p>支持导入多个子表，格式示例：(拷贝到Excel中看)</p>
<pre><code>主表字段1(假如为uniKey字段)  主表字段2   @子表A.字段1    @子表B.字段1
id1 value1  suba1   subb1
id1     suba2   
id2 value2  suba3   </code></pre>
<p>它表示：</p>
<pre><code>[
    {"主表字段1": "id1", "主表字段2": "value1", "子表A": [{ "字段1": "suba1" }, {"字段1": "suba2"}], "子表B": [{"字段1": "subb1"}]},
    {"主表字段1": "id2", "主表字段2": "value2", "子表A": [{ "字段1": "suba3" }] }
]</code></pre>
<p>它等价于：（将主表、子表分开看的更清楚）</p>
<pre><code>主表字段1(假如为uniKey字段)  主表字段2   @子表A.字段1    @子表B.字段1
id1 value1      
id1     suba1   
id1     suba2   
id1         subb1
id2 value2      
id2     suba3   </code></pre>
<h4 id="AccessControl::api_batchAdd-4 支持列名映射">4 支持列名映射</h4>
<p>(v5.5) 数据表导入时，默认是按固定列顺序来确定字段的，比如第1列必须是code，第2列必须是itemCode，如果要跳过一列，须通过&quot;-&quot;来指定；<br />
使用列名映射是另一种方式（通过指定参数useColMap=1激活），示例：</p>
<pre><code>!title=code,itemCode&amp;useColMap=1
id  name    code    itemId  itemCode
1   name1   code1   101 item-101
2   name2   code2   102 item-102</code></pre>
<p>这时只通过列名来匹配（若找不到匹配列则报错！），列的顺序对导入就没有影响。可以通过<code>-&gt;</code>来指定列的别名，示例：</p>
<pre><code>!title=编码-&gt;code,物料编码-&gt;itemCode&amp;useColMap=1
编号  物料名 编码  物料名 物料编码
1   name1   code1   101 item-101
2   name2   code2   102 item-102</code></pre>
<p>同样也可以应用在上节主子表导入的例子中，写法如下：</p>
<pre><code>&lt;script type="text/template" class="tplOrdr"&gt;
!title=生产订单号-&gt;code,物料编码-&gt;itemCode,物料规格-&gt;itemName,开工日期-&gt;planTm,完工日期-&gt;planTm1,生产数量-&gt;qty,子件编码-&gt;@bom.code,子件规格-&gt;@bom.name,基本用量-&gt;@bom.qty&amp;uniKey=code&amp;useColMap=1
生产订单号   物料编码    物料规格    开工日期    完工日期    生产数量    子件编码    子件规格    基本用量
SCDD210202302   30101001010484  热像仪#Fotric 615C-L47 2021-02-04  2021-02-04  1.00    20901001000052  标品#Lantern_B31-L47  1
SCDD210202302   30101001010484  热像仪#Fotric 615C-L47 2021-02-04  2021-02-04  1.00    10205001000017  标签#Lantern_40*30mm铜版纸空白标签#中性#通用 1
&lt;/script&gt;</code></pre>
<h4 id="AccessControl::api_batchAdd-5 支持id与name转换">5 支持id与name转换</h4>
<p>传入参数示例：</p>
<pre><code>name2id=empName,empId,Employee,name;itemName,itemId,Item,name,a</code></pre>
<p>以分号隔开一组，一组4到5个参数是定义一个转换，上面示例相当于调用：</p>
<pre><code>name2id("empName", "empId", "Employee", "name");
name2id("itemName", "itemId", "Item", "name", ["doAutoAdd"=&gt;true]);</code></pre>
<p>考虑安全性，尾部可选的a标志(表示如果引用对象不存在则自动添加)只允许最高管理员使用。</p></div>
<div class="block">
<h2 id="handleExportFormat">@fn handleExportFormat($fmt, $arr, $fname)</h2><div class="toc"><p style="margin-left:0em"><a href="#handleExportFormat-1 根据模板导出">1 根据模板导出</a></p>
</div>
<p>导出表到文件。</p>
<ul>
<li>fmt: csv-逗号分隔的文本; excel-使用gb18030编码的csv文本(excel可直接打开); txt-制表符分隔的文本。 </li>
<li>arr: 筋斗云表格格式({@h, @d}), 或二维数组表格格式。</li>
<li>fname: 导出的文件名</li>
</ul>
<p>示例：导出订单行及其明细等表，将多个查询结果拼成一个数组，导出excel-csv文件。</p>
<pre><code>class AC2_Ordr 
{
    function api_export()
    {
        $id = mparam("id");
        $tbl = queryAllWithHeader("SELECT t0.id 订单号, u.name 用户, u.phone 联系方式, t0.createTm 创建时间, t0.amount 金额
FROM Ordr t0
LEFT JOIN User u ON u.id=t0.userId
WHERE t0.id=$id", true);
        $tbl2 = queryAllWithHeader("SELECT name 商品, price 单价, qty 数量, spec 规格 FROM OrderItem WHERE orderId=$id", true);
        $tbl3 = queryAllWithHeader("SELECT name 名称, amount 金额 FROM OrderAmount WHERE orderId=$id", true);

        $arr = array_merge($tbl, [[], ["订单明细:"]], $tbl2, [[], ["金额调整:"]], $tbl3);

        $this-&gt;handleExportFormat("excel", $arr, "订单明细-$id");
    }
}</code></pre>
<p>注意：<code>[[], ["订单明细"]</code>表示插入两行，一个空行，另一个只有一列&quot;订单明细&quot;。</p>
<p>前端JS示例:</p>
<pre><code>var url = WUI.makeUrl("Ordr.export", {id: orderId});
window.open(url);</code></pre>
<p>导出示例：</p>
<pre><code>订单号 用户  联系方式    创建时间    金额
51343   王五555   "12345678901    "   2018/11/16 15:38    135

订单明细:               
商品  单价  数量  规格  
高压氧气管三胶二线   115 1   8MM 

金额调整:               
名称  金额          
运费  20          </code></pre>
<h4 id="handleExportFormat-1 根据模板导出">1 根据模板导出</h4>
<p>写onHandleExportFormat回调，示例：</p>
<pre><code>trait ExportUtil
{
    protected function onHandleExportFormat($fmt, $ret, $fname)
    {
        if ($fmt === "excel") {
            header("Content-disposition: attachment; filename=" . $fname . ".xlsx");
            header("Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
            header("Content-Transfer-Encoding: binary");
            // 模板
            $tpl = mparam("tpl");
            // TODO: 根据模板生成excel
            echo("tpl=tpl/$tpl.xlxs\n");
            echo(jsonEncode($ret));
            return true;
        }
    }
}</code></pre>
<p>在需要支持模板导出的对象类中使用它：</p>
<pre><code>class AC2_Ordr extends AccessControl
{
    use ExportUtil;
    ...
}</code></pre></div>
<div class="block">
<h2 id="AccessControl::isFileExport">@fn AccessControl::isFileExport()</h2>
<p>返回是否为导出文件请求。</p></div>
<div class="block">
<h2 id="issetval">@fn issetval($k, $arr=$_POST, &$val)</h2>
<p>一般用于add/set接口，判断是否设置了某字段。<br />
默认检查$_POST中的值。默认不允许设置空串。</p>
<p>e.g.<br />
if (issetval(&quot;perms&quot;)) ...</p>
<p>表示传入了perms字段，且非空串。注意：add接口会忽略空串字段，而set接口处理空串方式是置空该字段(null)。</p>
<pre><code>if ($this-&gt;ac == "set" &amp;&amp; issetval("perms?")) ...</code></pre>
<p>表示传入了perms字段，即使为空串也算设置，返回true，等同于isset($_POST[&quot;perms&quot;])。</p></div>
<div class="block">
<h2 id="BatchAddLogic">@class BatchAddLogic</h2>
<p>用于定制批量导入行为。<br />
示例，实现接口：</p>
<pre><code>Task.batchAdd(orderId, task1)(city, brand, vendorName, storeName)</code></pre>
<p>其中vendorName和storeName字段需要通过查阅修正为vendorId和storeId字段。</p>
<pre><code>class TaskBatchAddLogic extends BatchAddLogic
{
    protected $vendorCache = [];
    protected function onInit () {
        // 每个对象添加时都会用的字段，加在$this-&gt;params数组中
        $this-&gt;params["orderId"] = mparam("orderId", "G"); // mparam要求必须指定该字段
        $this-&gt;params["task1"] = param("task1", null, "G");
    }
    // $params为待添加数据，可在此修改，如用`$params["k1"]=val1`添加或更新字段，用unset($params["k1"])删除字段。
    function beforeAdd(&amp;$params) {
        // vendorName -&gt; vendorId
        // 如果会大量重复查询vendorName,可以将结果加入cache来优化性能
        if (! $this-&gt;vendorCache)
            $this-&gt;vendorCache = new SimpleCache(); // name=&gt;vendorId
        $vendorId = $this-&gt;vendorCache-&gt;get($params["vendorName"], function () use ($params) {
            $id = queryOne("SELECT id FROM Vendor", false, ["name" =&gt; $params["vendorName"]] );
            if (!$id) {
                // jdRet(E_PARAM, "请添加供应商", "供应商未注册: " . $params["vendorName"]);
                // 自动添加
                $id = callSvcInt("Vendor.add", null, [
                    "name" =&gt; $params["vendorName"],
                    "tel" =&gt; $params["vendorPhone"]
                ]);
            }
            return $id;
        });
        $params["vendorId"] = $vendorId;
        unset($params["vendorName"]);
        unset($params["vendorPhone"]);

        // storeName -&gt; storeId 类似处理 ...
    }
    // 处理原始标题行数据, $row1是通过title参数传入的标题数组，可能为空
    function onGetTitleRow($row, $row1) {
    }
}

class AC2_Task extends AC0_Task
{
    function api_batchAdd() {
        $this-&gt;batchAddLogic = new TaskBatchAddLogic();
        return parent::api_batchAdd();
    }
}</code></pre>
<p class="see"><strong>@see <a href="#api_batchAdd">api_batchAdd</a></strong> </p></div>
<div class="block">
<h2 id="autoload">@key autoload 类文件按需加载</h2>
<p>设置class目录为php类自动加载目录。<br />
同时将class目录设置为默认库包含路径.</p>
<p>在api.php或app.php中包含本文件，且php类放在php/class目录下，即可支持类的按需加载。</p>
<pre><code>require_once("php/autoload.php");</code></pre>
<p>特别地，对于AC类，统一按文件名&quot;AC_{对象}&quot;来查找，比如&quot;AC0_Role&quot;, &quot;AC_Role&quot;, &quot;AC2_Role&quot;都会找&quot;AC_Role.php&quot;文件。<br />
(v6) 而且，&quot;Role&quot;类也会尝试在&quot;AC_Role&quot;中查找。</p>
<p class="key"><strong>@key <a id="conf_classDir">conf_classDir</a></strong>  = ["class", "class/ext"]</p>
<p>配置php类文件的路径，可以用相对路径（相对于$BASE_DIR/php目录）或绝对路径。<br />
按惯例，数组第1元素为主类目录，第2元素为自动生成的addon类目录。</p>
<p>示例：如果服务目录不可写，或是同一份代码配置了多个实例（用$conf_dataDir区分数据目录）且各实例addon有差异，可在conf.user.php中配置: </p>
<pre><code>$GLOBALS["conf_classDir"][1] = $GLOBALS["conf_dataDir"] . "/class/ext";</code></pre>
<p>示例：添加一个类文件搜索路径：</p>
<pre><code>$GLOBALS["conf_classDir"][] = "/var/www/html/saic/php/class/erp_saic";
// $GLOBALS["conf_classDir"][] = "D:/project/saic/server/php/class/erp_saic";</code></pre></div>
<div style="text-align:center">Generated by jdcloud-gendoc</div>
</body>

</html>

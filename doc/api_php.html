<html>
<head>
<meta charset="utf-8">
<title>API参考 - 筋斗云服务端</title>
<style>
h3,h4,h5,h6 {
	font-size: 1em;
}

pre {
	border-left: 1px solid #ccc;
	margin: 0 1em;
	padding: 0 0.5em;
	tab-size:4;
}

code {
	font-family: "Courier New";
    padding: 0px 3px;
    display: inline-block;
}

.toc {
	margin: 2em;
}

.toc p {
	margin: 0.3em 0;
}

.block {
	border-bottom: 1px solid #ccc;
}

</style>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="doc.css" />
<script src="refdoc.js"></script>
</head>

<body>
<h1>API参考 - 筋斗云服务端</h1>
<div>最后更新：2018-01-04</div>
<div id="menu">
<h2>Modules</h2>
<div class="toc">
<p><a href="#app_fw">app_fw (module)</a></p>
<p><a href="#ext">ext (module)</a></p>
<p><a href="#api_fw">api_fw (module)</a></p>
<p><a href="#AccessControl">AccessControl (module)</a></p>
</div><hr>
<h2>Keywords</h2>
<div class="toc">
<p><a href="#$APP">$APP (var)</a></p>
<p><a href="#$BASE_DIR">$BASE_DIR (var)</a></p>
<p><a href="#AC0_">AC0_ (key)</a></p>
<p><a href="#AC1_">AC1_ (key)</a></p>
<p><a href="#AC2_">AC2_ (key)</a></p>
<p><a href="#AC_">AC_ (key)</a></p>
<p><a href="#AccessControl">AccessControl (module)</a></p>
<p><a href="#AccessControl::$allowedAc">AccessControl::$allowedAc (var)</a></p>
<p><a href="#AccessControl::$defaultRes">AccessControl::$defaultRes (var)</a></p>
<p><a href="#AccessControl::$defaultSort">AccessControl::$defaultSort (var)</a></p>
<p><a href="#AccessControl::$enumFields">AccessControl::$enumFields (var)</a></p>
<p><a href="#AccessControl::$hiddenFields">AccessControl::$hiddenFields (var)</a></p>
<p><a href="#AccessControl::$id">AccessControl::$id (var)</a></p>
<p><a href="#AccessControl::$maxPageSz">AccessControl::$maxPageSz (var)</a></p>
<p><a href="#AccessControl::$onAfterActions">AccessControl::$onAfterActions (var)</a></p>
<p><a href="#AccessControl::$readonlyFields">AccessControl::$readonlyFields (var)</a></p>
<p><a href="#AccessControl::$readonlyFields2">AccessControl::$readonlyFields2 (var)</a></p>
<p><a href="#AccessControl::$requiredFields">AccessControl::$requiredFields (var)</a></p>
<p><a href="#AccessControl::$requiredFields2">AccessControl::$requiredFields2 (var)</a></p>
<p><a href="#AccessControl::$subobj">AccessControl::$subobj (var)</a></p>
<p><a href="#AccessControl::$vcolDefs">AccessControl::$vcolDefs (var)</a></p>
<p><a href="#AccessControl::addCond">AccessControl::addCond (fn)</a></p>
<p><a href="#AccessControl::addJoin">AccessControl::addJoin (fn)</a></p>
<p><a href="#AccessControl::addRes">AccessControl::addRes (fn)</a></p>
<p><a href="#AccessControl::addVCol">AccessControl::addVCol (fn)</a></p>
<p><a href="#AccessControl::getMaxPageSz">AccessControl::getMaxPageSz (fn)</a></p>
<p><a href="#AccessControl::onAfter">AccessControl::onAfter (fn)</a></p>
<p><a href="#AccessControl::onGenId">AccessControl::onGenId (fn)</a></p>
<p><a href="#AccessControl::onHandleRow">AccessControl::onHandleRow (fn)</a></p>
<p><a href="#AccessControl::onQuery">AccessControl::onQuery (fn)</a></p>
<p><a href="#AccessControl::onValidate">AccessControl::onValidate (fn)</a></p>
<p><a href="#AccessControl::onValidateId">AccessControl::onValidateId (fn)</a></p>
<p><a href="#AppBase">AppBase (class)</a></p>
<p><a href="#Conf">Conf (key)</a></p>
<p><a href="#ConfBase">ConfBase (class)</a></p>
<p><a href="#ConfBase::$enableApiLog">ConfBase::$enableApiLog (var)</a></p>
<p><a href="#ConfBase::onApiInit">ConfBase::onApiInit (fn)</a></p>
<p><a href="#ConfBase::onInitClient">ConfBase::onInitClient (fn)</a></p>
<p><a href="#DirectReturn">DirectReturn (class)</a></p>
<p><a href="#ExtFactory::getInstance">ExtFactory::getInstance (fn)</a></p>
<p><a href="#ExtFactory::getObj">ExtFactory::getObj (fn)</a></p>
<p><a href="#JDEvent">JDEvent (class)</a></p>
<p><a href="#JDEvent.on">JDEvent.on (fn)</a></p>
<p><a href="#JDEvent.trigger">JDEvent.trigger (fn)</a></p>
<p><a href="#JDSingleton">JDSingleton (class)</a></p>
<p><a href="#JDSingletonImp">JDSingletonImp (class)</a></p>
<p><a href="#MapCol.$colMap">MapCol.$colMap (var)</a></p>
<p><a href="#MapCol.mapCol">MapCol.mapCol (key)</a></p>
<p><a href="#MapCol.mapSql">MapCol.mapSql (key)</a></p>
<p><a href="#MyException">MyException (class)</a></p>
<p><a href="#PAGE_SZ_LIMIT">PAGE_SZ_LIMIT (var)</a></p>
<p><a href="#P_DB">P_DB (key)</a></p>
<p><a href="#P_DBCRED">P_DBCRED (key)</a></p>
<p><a href="#P_DEBUG">P_DEBUG (key)</a></p>
<p><a href="#P_MOCK_MODE">P_MOCK_MODE (key)</a></p>
<p><a href="#P_SESSION_DIR">P_SESSION_DIR (key)</a></p>
<p><a href="#P_TEST_MODE">P_TEST_MODE (key)</a></p>
<p><a href="#P_URL_PATH">P_URL_PATH (key)</a></p>
<p><a href="#Plugins">Plugins (class)</a></p>
<p><a href="#Plugins::$map">Plugins::$map (var)</a></p>
<p><a href="#Plugins::add">Plugins::add (fn)</a></p>
<p><a href="#Plugins::exists">Plugins::exists (fn)</a></p>
<p><a href="#Q">Q (fn)</a></p>
<p><a href="#addLog">addLog (fn)</a></p>
<p><a href="#apiMain">apiMain (key)</a></p>
<p><a href="#api_fw">api_fw (module)</a></p>
<p><a href="#app_fw">app_fw (module)</a></p>
<p><a href="#callSvc">callSvc (fn)</a></p>
<p><a href="#callSvcInt">callSvcInt (fn)</a></p>
<p><a href="#checkAuth">checkAuth (fn)</a></p>
<p><a href="#conf.php">conf.php (key)</a></p>
<p><a href="#dbConfirmFn">dbConfirmFn (key)</a></p>
<p><a href="#dbconn">dbconn (fn)</a></p>
<p><a href="#errQuit">errQuit (fn)</a></p>
<p><a href="#execOne">execOne (fn)</a></p>
<p><a href="#ext">ext (module)</a></p>
<p><a href="#getAppType">getAppType (fn)</a></p>
<p><a href="#getBaseUrl">getBaseUrl (fn)</a></p>
<p><a href="#getClientVersion">getClientVersion (fn)</a></p>
<p><a href="#getCred">getCred (fn)</a></p>
<p><a href="#getExt">getExt (fn)</a></p>
<p><a href="#hasPerm">hasPerm (fn)</a></p>
<p><a href="#hasSignFile">hasSignFile (fn)</a></p>
<p><a href="#httpCall">httpCall (fn)</a></p>
<p><a href="#isCLI">isCLI (fn)</a></p>
<p><a href="#isCLIServer">isCLIServer (fn)</a></p>
<p><a href="#isEqualCollection">isEqualCollection (fn)</a></p>
<p><a href="#isMockMode">isMockMode (fn)</a></p>
<p><a href="#logext">logext (fn)</a></p>
<p><a href="#logit">logit (fn)</a></p>
<p><a href="#makeUrl">makeUrl (fn)</a></p>
<p><a href="#mparam">mparam (fn)</a></p>
<p><a href="#myEncrypt">myEncrypt (fn)</a></p>
<p><a href="#noExecApi">noExecApi (key)</a></p>
<p><a href="#objarr2table">objarr2table (fn)</a></p>
<p><a href="#onCreateAC">onCreateAC (fn)</a></p>
<p><a href="#onGetPerms">onGetPerms (fn)</a></p>
<p><a href="#param">param (fn)</a></p>
<p><a href="#param">param (fn)</a></p>
<p><a href="#param_varr">param_varr (fn)</a></p>
<p><a href="#parseKvList">parseKvList (fn)</a></p>
<p><a href="#plugin">plugin (key)</a></p>
<p><a href="#plugin/index.php">plugin/index.php (key)</a></p>
<p><a href="#queryAll">queryAll (fn)</a></p>
<p><a href="#queryOne">queryOne (fn)</a></p>
<p><a href="#setParam">setParam (fn)</a></p>
<p><a href="#setParam">setParam (fn)</a></p>
<p><a href="#setRet">setRet (fn)</a></p>
<p><a href="#setServerRev">setServerRev (fn)</a></p>
<p><a href="#startsWith">startsWith (fn)</a></p>
<p><a href="#table2objarr">table2objarr (fn)</a></p>
<p><a href="#tableCRUD">tableCRUD (fn)</a></p>
<p><a href="#tmCols">tmCols (fn)</a></p>
<p><a href="#tobool">tobool (fn)</a></p>
<p><a href="#tryParseBool">tryParseBool (fn)</a></p>
<p><a href="#urlEncodeArr">urlEncodeArr (fn)</a></p>
<p><a href="#varr2objarr">varr2objarr (fn)</a></p>
</div><hr>
</div>
<div class="block">
<h2 id="tobool">@fn tobool($s)</h2></div>
<div class="block">
<h2 id="tryParseBool">@fn tryParseBool($s, &$val)</h2>
<p>字符串转bool，支持&quot;0/1&quot;, &quot;true/false&quot;, &quot;yes/no&quot;, &quot;on/off&quot;.</p></div>
<div class="block">
<h2 id="startsWith">@fn startsWith($s, $pat)</h2></div>
<div class="block">
<h2 id="isCLI">@fn isCLI() </h2>
<p>command-line interface. e.g. run &quot;php x.php&quot;</p></div>
<div class="block">
<h2 id="isCLIServer">@fn isCLIServer() </h2>
<p>php built-in web server e.g. run &quot;php -S 0.0.0.0:8080&quot;</p></div>
<div class="block">
<h2 id="isEqualCollection">@fn isEqualCollection($col1, $col2)</h2></div>
<div class="block">
<h2 id="urlEncodeArr">@fn urlEncodeArr($params)</h2>
<p>e.g.</p>
<pre><code>urlEncodeArr(["a"=&gt;1, "b"=&gt;"hello"]) -&gt; a=1&amp;b=hello</code></pre></div>
<div class="block">
<h2 id="makeUrl">@fn makeUrl($ac, $params, $hash)</h2></div>
<div class="block">
<h2 id="httpCall">@fn httpCall($url, $postParams =null, $opt={timeout?=5, @headers} )</h2>
<p>请求URL，返回内容。<br />
默认使用GET请求，如果给定postParams，则使用POST请求。<br />
postParams可以是一个kv数组或字符串，也可以是一个文件名(以&quot;@&quot;开头，如&quot;@1.jpg&quot;)</p>
<p>如果请求失败，抛出E_SERVER异常。<br />
不检查http返回码。</p>
<p>示例：指定postParams, 默认以application/x-www-form-urlencoded格式提交。</p>
<pre><code>$data = [
    "name" =&gt; "xiaoming",
    "classId" =&gt; 100
];
// 注意headers的格式
$headers = [
    "Authorization: Basic dGVzdDp0ZXN0MTIz"
];
$rv = httpCall($url, $data, ["headers" =&gt; $headers]);</code></pre>
<p>示例：提交application/json格式的内容</p>
<pre><code>// 用json_encode将数组变成字符串。避免被httpCall转成urlencoded格式。
$data = json_encode([
    "name" =&gt; "xiaoming",
    "classId" =&gt; 100
]);
$headers = [
    "Content-type: application/json",
    "Authorization: Basic dGVzdDp0ZXN0MTIz"
];
$GLOBALS["X_RET_STR"] = httpCall($url, $data, ["headers" =&gt; $headers]);
// 筋斗云：设置全局变量X_RET_STR可直接设置返回内容，避免再次被json编码。</code></pre></div>
<div class="block">
<h2 id="parseKvList">@fn parseKvList($kvListStr, $sep, $sep2)</h2>
<p>解析key-value列表字符串。如果出错抛出异常。<br />
示例：</p>
<pre><code>$map = parseKvList("CR:新创建;PA:已付款", ";", ":");
// map: {"CR": "新创建", "PA":"已付款"}</code></pre></div>
<div class="block">
<h2 id="app_fw">@module app_fw</h2><div class="toc"><p style="margin-left:0em"><a href="#app_fw-1 通用函数">1 通用函数</a></p>
<p style="margin-left:0em"><a href="#app_fw-2 初始化配置">2 初始化配置</a></p>
<p style="margin-left:2em"><a href="#app_fw-2.1 数据库配置">2.1 数据库配置</a></p>
<p style="margin-left:0em"><a href="#app_fw-3 测试模式与调试等级">3 测试模式与调试等级</a></p>
<p style="margin-left:0em"><a href="#app_fw-4 模拟模式">4 模拟模式</a></p>
<p style="margin-left:0em"><a href="#app_fw-5 session管理">5 session管理</a></p>
<p style="margin-left:0em"><a href="#app_fw-6 应用框架">6 应用框架</a></p>
</div>
<p>筋斗云服务端通用应用框架。</p>
<h4 id="app_fw-1 通用函数">1 通用函数</h4>
<ul>
<li>
<p>获得指定类型参数</p>
<p class="see"><strong>@see <a href="#param">param</a> <a href="#mparam">mparam</a></strong> </p>
</li>
<li>
<p>数据库连接及操作</p>
<p class="see"><strong>@see <a href="#dbconn">dbconn</a> <a href="#execOne">execOne</a> <a href="#queryOne">queryOne</a> <a href="#queryAll">queryAll</a></strong> </p>
</li>
<li>错误处理设施
<p class="see"><strong>@see <a href="#MyException">MyException</a> <a href="#errQuit">errQuit</a></strong> </p></li>
</ul>
<h4 id="app_fw-2 初始化配置">2 初始化配置</h4>
<p>app_fw框架自动包含 $BASE_DIR/php/conf.user.php。</p>
<p>项目部署时的配置，一般用于定义环境变量、全局变量等，通常不添加入版本库，在项目实施时手工配置。</p>
<p>对于不变的全局配置，应在app.php中定义。</p>
<h5 id="app_fw-2.1 数据库配置">2.1 数据库配置</h5>
<p class="key"><strong>@key <a id="P_DB">P_DB</a></strong>  环境变量，指定DB类型与地址。</p>
<p class="key"><strong>@key <a id="P_DBCRED">P_DBCRED</a></strong>  环境变量，指定DB登录帐号</p>
<p>P_DB格式为：</p>
<pre><code>P_DB={主机名}/{数据库名}
或
P_DB={主机名}:{端口号}/{数据库名}</code></pre>
<p>例如：</p>
<pre><code>P_DB=localhost/myorder
P_DB=www.myserver.com:3306/myorder</code></pre>
<p>P_DBCRED格式为<code>{用户名}:{密码}</code>，或其base64编码后的值，如</p>
<pre><code>P_DBCRED=ganlan:1234
或
P_DBCRED=Z2FubGFuOjEyMzQ=</code></pre>
<p>此外，P_DB还支持SQLite数据库，直接指定以&quot;.db&quot;为扩展名的文件即可。例如：</p>
<pre><code>P_DB=../myorder.db</code></pre>
<h4 id="app_fw-3 测试模式与调试等级">3 测试模式与调试等级</h4>
<p class="key"><strong>@key <a id="P_TEST_MODE">P_TEST_MODE</a></strong>  Integer。环境变量，允许测试模式。0-生产模式；1-测试模式；2-自动化回归测试模式(RTEST_MODE)</p>
<p class="key"><strong>@key <a id="P_DEBUG">P_DEBUG</a></strong>  Integer。环境变量，设置调试等级，值范围0-9。仅在测试模式下有效。</p>
<p>测试模式特点：</p>
<ul>
<li>输出的HTTP头中包含：<code>X-Daca-Test-Mode: 1</code></li>
<li>输出的JSON格式经过美化更易读，且可以显示更多调试信息。前端可通过在接口中添加<code>_debug</code>参数设置调试等级。<br />
如果想要查看本次调用涉及的SQL语句，可以用<code>_debug=9</code>。</li>
<li>某些用于测试的接口可以调用，例如execSql。因而十分危险，生产模式下一定不可误设置为测试模式。</li>
<li>可以使用模拟模式</li>
</ul>
<p>注意：v3.4版本起不允许客户端设置_test参数，且用环境变量P_TEST_MODE替代符号文件CFG_TEST_MODE和设置全局变量TEST_MODE.</p>
<p>在过去测试模式用于：可直接对生产环境进行测试且不影响生产环境，即部署后，在前端指定以测试模式连接，在后端为测试模式连接专用的测试数据库，且使用专用的cookie，实现与生产模式共用代码但互不影响。<br />
现已废弃这种用法，应搭建专用的测试环境用于测试开发。</p>
<p class="see"><strong>@see <a href="#addLog">addLog</a></strong> </p>
<h4 id="app_fw-4 模拟模式">4 模拟模式</h4>
<p class="key"><strong>@key <a id="P_MOCK_MODE">P_MOCK_MODE</a></strong>  Integer. 模拟模式. 值：0/1，或部分模拟，值为模块列表，如"wx,sms"，外部模块名称定义见ext.php.</p>
<p>对第三方系统依赖（如微信认证、支付宝支付、发送短信等），可通过设计Mock接口来模拟。</p>
<p>注意：v3.4版本起用环境变量P_MOCK_MODE替代符号文件CFG_MOCK_MODE/CFG_MOCK_T_MODE和设置全局变量MOCK_MODE，且模拟模式只允许在测试模式激活时才能使用。</p>
<p class="see"><strong>@see <a href="#ExtMock">ExtMock</a></strong> </p>
<h4 id="app_fw-5 session管理">5 session管理</h4>
<ul>
<li>应用的session名称为 &quot;{app}id&quot;, 如应用名为 &quot;user&quot;, 则session名为&quot;userid&quot;. 因而不同的应用同时调用服务端也不会冲突。</li>
<li>保存session文件的目录为 $BASE_DIR/session, 可使用环境变量P_SESSION_DIR重定义。</li>
<li>同一主机，不同URL下的session即使APP名相同，也不会相互冲突，因为框架会根据当前URL，设置cookie的有效路径。</li>
</ul>
<p class="key"><strong>@key <a id="P_SESSION_DIR">P_SESSION_DIR</a></strong>  ?= $BASE_DIR/session 环境变量，定义session文件存放路径。</p>
<p class="key"><strong>@key <a id="P_URL_PATH">P_URL_PATH</a></strong>  环境变量。项目的URL路径，如"/jdcloud", 用于定义cookie生效的作用域，也用于拼接相对URL路径。</p>
<p class="see"><strong>@see <a href="#getBaseUrl">getBaseUrl</a></strong> </p>
<h4 id="app_fw-6 应用框架">6 应用框架</h4>
<p>继承AppBase类，可实现提供符合BQP协议接口的模块。<a href="#api_fw">api_fw</a>框架就是使用它的一个典型例子。</p>
<p class="see"><strong>@see <a href="#AppBase">AppBase</a></strong> </p></div>
<div class="block">
<h2 id="$BASE_DIR">@var $BASE_DIR</h2>
<p>包含app_fw.php的主文件（如api.php）所在目录。常用于拼接子目录名。<br />
最后不带&quot;/&quot;.</p></div>
<div class="block">
<h2 id="$APP">@var $APP?=user</h2>
<p>客户端应用标识，默认为&quot;user&quot;.<br />
根据URL参数&quot;_app&quot;确定值。</p></div>
<div class="block">
<h2 id="param_varr">@fn param_varr($str, $type, $name)</h2>
<p>type的格式如&quot;i:n:b?:dt:tm?&quot;.</p>
<ul>
<li>每个词表示一个字段类型<br />
类型标识：i-Integer; n-Number/Double; b-Boolean(0/1); dt/tm-DateTime</li>
<li>后置&quot;?&quot;表示该参数可缺省。</li>
</ul></div>
<div class="block">
<h2 id="param">@fn param($name, $defVal?, $col?, $doHtmlEscape=true)</h2>
<p class="param"><strong>@param $col:</strong>  默认先取$_GET再取$_POST，"G" - 从$_GET中取; "P" - 从$_POST中取</p>
<p>以下形式已不建议使用：</p>
<p class="fn"><strong>@fn <a id="param">param</a></strong> ($name, $defVal?, $col?=$_REQUEST, $doHtmlEscape=true)</p>
<p class="param"><strong>@param $col:</strong>  key-value collection</p>
<p>获取名为$name的参数。<br />
$name中可以指定类型，返回值根据类型确定。如果该参数未定义或是空串，直接返回缺省值$defVal。</p>
<p>$name中指定类型的方式如下：</p>
<ul>
<li>名为&quot;id&quot;, 或以&quot;Id&quot;或&quot;/i&quot;结尾: int</li>
<li>以&quot;/b&quot;结尾: bool. 可接受的字符串值为: &quot;1&quot;/&quot;true&quot;/&quot;on&quot;/&quot;yes&quot;=&gt;true, &quot;0&quot;/&quot;false&quot;/&quot;off&quot;/&quot;no&quot; =&gt; false</li>
<li>以&quot;/dt&quot;或&quot;/tm&quot;结尾: datetime</li>
<li>以&quot;/n&quot;结尾: numeric/double</li>
<li>以&quot;/s&quot;结尾（缺省）: string. 缺省为防止XSS攻击会做html编码，如&quot;a&amp;b&quot;处理成&quot;a&amp;b&quot;，设置参数doHtmlEscape可禁用这个功能。</li>
<li>复杂类型：以&quot;/i+&quot;结尾: int array</li>
<li>复杂类型：以&quot;/js&quot;结尾: json object</li>
<li>复杂类型：List类型（以&quot;,&quot;分隔行，以&quot;:&quot;分隔列），类型定义如&quot;/i:n:b:dt:tm&quot; （列只支持简单类型，不可为复杂类型）</li>
</ul>
<p>示例：</p>
<pre><code>$id = param("id");
$svcId = param("svcId/i", 99);
$wantArray = param("wantArray/b", false);
$startTm = param("startTm/dt", time());</code></pre>
<p>List类型示例。参数&quot;items&quot;类型在文档中定义为list(id/Integer, qty/Double, dscr/String)，可用param(&quot;items/i:n:s&quot;)获取, 值如</p>
<pre><code>items=100:1:洗车,101:1:打蜡</code></pre>
<p>返回</p>
<pre><code>[ [ 100, 1.0, "洗车"], [101, 1.0, "打蜡"] ]</code></pre>
<p>如果某列可缺省，用&quot;?&quot;表示，如param(&quot;items/i:n?:s?&quot;)可获取值：</p>
<pre><code>items=100:1,101::打蜡</code></pre>
<p>返回</p>
<pre><code>[ [ 100, 1.0, null], [101, null, "打蜡"] ]</code></pre>
<p>TODO: 直接支持 param(&quot;items/(id,qty?/n,dscr?)&quot;), 添加param_objarr函数，去掉parseList函数。上例将返回</p>
<pre><code>[
    [ "id"=&gt;100, "qty"=&gt;1.0, dscr=&gt;null],
    [ "id"=&gt;101, "qty"=&gt;null, dscr=&gt;"打蜡"]
]</code></pre></div>
<div class="block">
<h2 id="mparam">@fn mparam($name, $col = null)</h2>
<p class="brief"><strong>@brief mandatory</strong>  param</p>
<p>$name可以是一个数组，表示至少有一个参数有值，这时返回每个参数的值。<br />
参考param函数，查看$name如何支持各种类型。</p>
<p>示例：</p>
<pre><code>$svcId = mparam("svcId");
$svcId = mparam("svcId/i");
$itts = mparam("itts/i+")
list($svcId, $itts) = mparam(["svcId", "itts/i+"]); # require one of the 2 params</code></pre></div>
<div class="block">
<h2 id="setParam">@fn setParam($k, $v)</h2>
<p class="fn"><strong>@fn <a id="setParam">setParam</a></strong> (@kv)</p>
<p>设置参数，其实是模拟客户端传入的参数。以便供tableCRUD等函数使用。</p>
<p>示例：</p>
<pre><code>setParam("cond", "name LIKE " . Q("%$name%"));
setParam([
    "_fmt" =&gt; "list",
    "orderby" =&gt; "id DESC"
]);</code></pre>
<p class="see"><strong>@see <a href="#tableCRUD">tableCRUD</a></strong> </p></div>
<div class="block">
<h2 id="objarr2table">@fn objarr2table ($objarr, $fixedColCnt=null)</h2>
<p>将objarr格式转为table格式, 如：</p>
<pre><code>objarr2table(
    [
        ["id"=&gt;100, "name"=&gt;"A"],
        ["id"=&gt;101, "name"=&gt;"B"]
    ]
) -&gt; 
    [
        "h"=&gt;["id", "name"],
        "d"=&gt;[ 
            [100,"A"], 
            [101,"B"]
        ] 
    ]</code></pre>
<p>注意：</p>
<ul>
<li>objarr每行中列的顺序可以不一样，table列按首行顺序输出。</li>
<li>
<p>每行中列数可以不一样，这时可指定最少固定列数 $fixedColCnt, 而该列以后，将自动检查所有行决定是否加到header中。例：</p>
<p>objarr2table(<br />
[<br />
[&quot;id&quot;=&gt;100, &quot;name&quot;=&gt;&quot;A&quot;],<br />
[&quot;name&quot;=&gt;&quot;B&quot;, &quot;id&quot;=&gt;101, &quot;flag_v&quot;=&gt;1],<br />
[&quot;id&quot;=&gt;102, &quot;name&quot;=&gt;&quot;C&quot;, &quot;flag_r&quot;=&gt;1]<br />
], 2  // 2列固定<br />
) -&gt;<br />
[<br />
&quot;h&quot;=&gt;[&quot;id&quot;, &quot;name&quot;, &quot;flag_v&quot;, &quot;flag_r&quot;],<br />
&quot;d&quot;=&gt;[<br />
[100,&quot;A&quot;, null,null],<br />
[101,&quot;B&quot;, 1, null],<br />
[102,&quot;C&quot;, null, 1]<br />
]<br />
]</p>
</li>
</ul>
<p class="see"><strong>@see <a href="#table2objarr">table2objarr</a></strong> </p>
<p class="see"><strong>@see <a href="#varr2objarr">varr2objarr</a></strong> </p></div>
<div class="block">
<h2 id="table2objarr">@fn table2objarr</h2>
<p>将table格式转为 objarr, 如：</p>
<pre><code>table2objarr(
    [
        "h"=&gt;["id", "name"],
        "d"=&gt;[ 
            [100,"A"], 
            [101,"B"]
        ] 
    ]
) -&gt; [ ["id"=&gt;100, "name"=&gt;"A"], ["id"=&gt;101, "name"=&gt;"B"] ]</code></pre></div>
<div class="block">
<h2 id="varr2objarr">@fn varr2objarr</h2>
<p>将类型 varr (仅有值的二维数组, elem=[$col1, $col2] ) 转为 objarr (对象数组, elem={col1=&gt;cell1, col2=&gt;cell2})</p>
<p>例：</p>
<pre><code>varr2objarr(
    [ [100, "A"], [101, "B"] ], 
    ["id", "name"] )
-&gt; [ ["id"=&gt;100, "name"=&gt;"A"], ["id"=&gt;101, "name"=&gt;"B"] ]</code></pre></div>
<div class="block">
<h2 id="getCred">@fn getCred($cred) -> [user, pwd]</h2>
<p>$cred为&quot;{user}:{pwd}&quot;格式，支持使用base64编码。<br />
示例：</p>
<pre><code>list($user, $pwd) = getCred(getenv("P_ADMIN_CRED"));
if (! isset($user)) {
    // 未设置用户名密码
}</code></pre></div>
<div class="block">
<h2 id="dbconn">@fn dbconn($fnConfirm=$GLOBALS["dbConfirmFn"])</h2>
<p class="param"><strong>@param fnConfirm</strong>  fn(dbConnectionString), 如果返回false, 则程序中止退出。</p>
<p class="key"><strong>@key <a id="dbConfirmFn">dbConfirmFn</a></strong>  连接数据库前回调。</p>
<p>连接数据库</p>
<p>数据库由全局变量$DB(或环境变量P_DB）指定，格式可以为：</p>
<pre><code>host1/carsvc (无扩展名，表示某主机host1下的mysql数据库名；这时由 全局变量$DBCRED 或环境变量 P_DBCRED 指定用户名密码。

dir1/dir2/carsvc.db (以.db文件扩展名标识的文件路径，表示SQLITE数据库）</code></pre>
<p>环境变量 P_DBCRED 指定用户名密码，格式为 base64(dbuser:dbpwd).</p></div>
<div class="block">
<h2 id="Q">@fn Q($str, $dbh=$DBH)</h2>
<p>quote string</p>
<p>一般是把字符串如&quot;abc&quot;转成加单引号的形式&quot;'abc'&quot;. 适用于根据用户输入串拼接成SQL语句时，对输入串处理，避免SQL注入。</p>
<p>示例：</p>
<pre><code>$sql = sprintf("SELECT id FROM User WHERE uname=%s AND pwd=%s", Q(param("uname")), Q(param("pwd")));</code></pre></div>
<div class="block">
<h2 id="execOne">@fn execOne($sql, $getInsertId?=false)</h2>
<p class="param"><strong>@param $getInsertId</strong> ?=false 取INSERT语句执行后得到的id. 仅用于INSERT语句。</p>
<p>执行SQL语句，如INSERT, UPDATE等。执行SELECT语句请使用queryOne/queryAll.</p>
<pre><code>$token = mparam("token");
execOne("UPDATE cinf SET appleDeviceToken=" . Q($token));</code></pre>
<p>注意：在拼接SQL语句时，对于传入的string类型参数，应使用Q函数进行转义，避免SQL注入攻击。</p>
<p>对于INSERT语句，设置参数$getInsertId=true, 可取新加入数据行的id. 例：</p>
<pre><code>$sql = sprintf("INSERT INTO Hongbao (userId, createTm, src, expireTm, vdays) VALUES ({$uid}, '%s', '{$src}', '%s', {$vdays})", date('c', $createTm), date('c', $expireTm));
$hongbaoId = execOne($sql, true);</code></pre></div>
<div class="block">
<h2 id="queryOne">@fn queryOne($sql, $assoc = false)</h2>
<p>执行查询语句，只返回一行数据，如果行中只有一列，则直接返回该列数值。<br />
如果查询不到，返回false.</p>
<p>示例：查询用户姓名与电话，默认返回值数组：</p>
<pre><code>$row = queryOne("SELECT name,phone FROM User WHERE id={$id}");
if ($row === false)
    throw new MyException(E_PARAM, "bad user id");
// $row = ["John", "13712345678"]</code></pre>
<p>也可返回关联数组:</p>
<pre><code>$row = queryOne("SELECT name,phone FROM User WHERE id={$id}", true);
if ($row === false)
    throw new MyException(E_PARAM, "bad user id");
// $row = ["name"=&gt;"John", "phone"=&gt;"13712345678"]</code></pre>
<p>当查询结果只有一列且assoc=false时，直接返回该数值。</p>
<pre><code>$phone = queryOne("SELECT phone FROM User WHERE id={$id}");
if ($phone === false)
    throw new MyException(E_PARAM, "bad user id");
// $phone = "13712345678"</code></pre>
<p class="see"><strong>@see <a href="#queryAll">queryAll</a></strong> </p></div>
<div class="block">
<h2 id="queryAll">@fn queryAll($sql, $assoc = false)</h2>
<p>执行查询语句，返回数组。<br />
如果查询失败，返回空数组。</p>
<p>默认返回值数组(varr):</p>
<pre><code>$rows = queryAll("SELECT name, phone FROM User");
if (count($rows) &gt; 0) {
    ...
}
// 值为：
$rows = [
    ["John", "13712345678"],
    ["Lucy", "13712345679"]
    ...
]
// 可转成table格式返回
return ["h"=&gt;["name", "phone"], "d"=&gt;$rows];</code></pre>
<p>也可以返回关联数组(objarr)，如：</p>
<pre><code>$rows = queryAll("SELECT name, phone FROM User", true);
if (count($rows) &gt; 0) {
    ...
}
// 值为：
$rows = [
    ["name"=&gt;"John", "phone"=&gt;"13712345678"],
    ["name"=&gt;"Lucy", "phone"=&gt;"13712345679"]
    ...
]
// 可转成table格式返回
return objarr2table($rows);</code></pre>
<p class="see"><strong>@see <a href="#objarr2table">objarr2table</a></strong> </p></div>
<div class="block">
<h2 id="getBaseUrl">@fn getBaseUrl($wantHost = true)</h2>
<p>返回 $BASE_DIR 对应的网络路径（最后以&quot;/&quot;结尾）。<br />
如果指定了环境变量 P_URL_PATH（可在conf.user.php中设置）, 则根据该变量计算；否则自动判断（如果有符号链接可能不准）</p>
<p>例：</p>
<pre><code>P_URL_PATH = "/myapp/" 或 P_URL_PATH = "/myapp"</code></pre>
<p>则</p>
<pre><code>getBaseUrl() -&gt; "http://myserver.com/myapp/"
getBaseUrl(false) -&gt; "/myapp/"</code></pre>
<p>注意：如果使用了反向代理等机制，该函数往往无法返回正确的值。</p>
<p>例如 <a href="http://myserver.com/8081/myapp/api.php">http://myserver.com/8081/myapp/api.php</a> 被代理到 <a href="http://localhost:8081/myapp/api.php">http://localhost:8081/myapp/api.php</a><br />
getBaseUrl()默认返回 &quot;<a href="http://myserver.com/myapp/">http://myserver.com/myapp/</a>&quot; 是错误的，可以设置P_BASE_URL解决：</p>
<pre><code>putenv("P_URL_PATH=http://myserver.com/8081/myapp/");</code></pre>
<p>这样getBaseUrl()可返回该值。</p>
<p class="see"><strong>@see <a href="#$BASE_DIR">$BASE_DIR</a></strong> </p></div>
<div class="block">
<h2 id="logit">@fn logit($s, $addHeader=true, $type="trace")</h2>
<p>记录日志。</p>
<p>默认到日志文件 $BASE_DIR/trace.log. 如果指定type=secure, 则写到 $BASE_DIR/secure.log.</p>
<p>可通过在线日志工具 tool/log.php 来查看日志。也可直接打开日志文件查看。</p></div>
<div class="block">
<h2 id="myEncrypt">@fn myEncrypt($string,$operation='E',$key='carsvc')</h2>
<p class="param"><strong>@param operation</strong>  'E': encrypt; 'D': decrypt</p>
<p>加密解密字符串</p>
<p>加密:</p>
<pre><code>$cipher = myEncrypt('hello, world!');
or
$cipher = myEncrypt('hello, world!','E','nowamagic');</code></pre>
<p>解密：</p>
<pre><code>$text = myEncrypt($cipher,'D','nowamagic');</code></pre>
<p>参数说明:<br />
$string   :需要加密解密的字符串<br />
$operation:判断是加密还是解密:E:加密   D:解密<br />
$key      :加密的钥匙(密匙);</p>
<p><a href="http://www.open-open.com/lib/view/open1388916054765.html">http://www.open-open.com/lib/view/open1388916054765.html</a></p></div>
<div class="block">
<h2 id="errQuit">@fn errQuit($code, $msg, $msg2 =null)</h2>
<p>生成html格式的错误信息并中止执行。<br />
默认地，只显示中文错误，双击可显示详细信息。<br />
例：</p>
<pre><code>errQuit(E_PARAM, "接口错误", "Unknown ac=`$ac`");</code></pre></div>
<div class="block">
<h2 id="addLog">@fn addLog($str, $logLevel=0)</h2>
<p>输出调试信息到前端。调试信息将出现在最终的JSON返回串中。<br />
如果只想输出调试信息到文件，不想让前端看到，应使用logit.</p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p></div>
<div class="block">
<h2 id="getAppType">@fn getAppType()</h2>
<p>根据应用标识($APP)获取应用类型(AppType)。注意：应用标识一般由前端应用通过URL参数&quot;_app&quot;传递给后端。<br />
不同的应用标识可以对应相同的应用类型，如应用标识&quot;emp&quot;, &quot;emp2&quot;, &quot;emp-adm&quot; 都表示应用类型&quot;emp&quot;，即 应用类型=应用标识自动去除尾部的数字或&quot;-xx&quot;部分。</p>
<p>不同的应用标识会使用不同的cookie名，因而即使用户同时操作多个应用，其session不会相互干扰。<br />
同样的应用类型将以相同的方式登录系统。</p>
<p class="see"><strong>@see <a href="#$APP">$APP</a></strong> </p></div>
<div class="block">
<h2 id="hasSignFile">@fn hasSignFile($f)</h2>
<p>检查应用根目录下($BASE_DIR)下是否存在标志文件。标志文件一般命名为&quot;CFG_XXX&quot;, 如&quot;CFG_MOCK_MODE&quot;等。</p></div>
<div class="block">
<h2 id="MyException">@class MyException($code, $internalMsg?, $outMsg?)</h2>
<p class="param"><strong>@param $internalMsg</strong>  String. 内部错误信息，前端不应处理。</p>
<p class="param"><strong>@param $outMsg</strong>  String. 错误信息。如果为空，则会自动根据$code填上相应的错误信息。</p>
<p>抛出错误，中断执行:</p>
<pre><code>throw new MyException(E_PARAM, "Bad Request - numeric param `$name`=`$ret`.", "需要数值型参数");</code></pre></div>
<div class="block">
<h2 id="DirectReturn">@class DirectReturn</h2>
<p>抛出该异常，可以中断执行直接返回，不显示任何错误。</p>
<p>例：API返回非BPQ协议标准数据，可以跳出setRet而直接返回：</p>
<pre><code>echo "return data";
throw new DirectReturn();</code></pre>
<p>例：返回指定数据后立即中断处理：</p>
<pre><code>setRet(0, ["id"=&gt;1]);
throw new DirectReturn();</code></pre></div>
<div class="block">
<h2 id="AppBase">@class AppBase</h2>
<p>应用框架，用于提供符合BQP协议的接口。<br />
在onExec中返回协议数据；在onAfter中建议及时关闭DB.</p></div>
<div class="block">
<h2 id="JDSingleton">@class JDSingleton (trait)</h2>
<p>用于单件类，提供getInstance方法，例：</p>
<pre><code>class PluginCore
{
    use JDSingleton;
}</code></pre>
<p>则可以调用</p>
<pre><code>$pluginCore = PluginCore::getInstance();</code></pre></div>
<div class="block">
<h2 id="JDSingletonImp">@class JDSingletonImp (trait)</h2>
<p>用于单件基类，提供getInstance方法。<br />
使用时类名应以Base结尾，使用者可以重写该类，一般用于接口实现。例：</p>
<pre><code>class PayImpBase
{
    use JDSingletonImp;
}

// 使用者重写Base类的某些方法
class PayImp extends PayImpBase
{
}</code></pre>
<p>则可以调用</p>
<pre><code>$pay = PayImpBase::getInstance();
// 创建的是PayImp类。如果未定义PayImp类，则创建PayImpBase类，或是当Base类是abstract类时将抛出错误。</code></pre></div>
<div class="block">
<h2 id="JDEvent">@class JDEvent (trait)</h2>
<p>提供事件监听(on)与触发(trigger)方法，例：</p>
<pre><code>class PluginCore
{
    use JDEvent;

    // 提供事件"event1", 注释如下：
    /// @event PluginCore.event.event1($arg1, $arg2)
}</code></pre>
<p>则可以调用</p>
<pre><code>$pluginCore-&gt;on('event1', 'onEvent1');
$pluginCore-&gt;trigger('event1', [$arg1, $arg2]);

function onEvent1($arg1, $arg2)
{
}</code></pre></div>
<div class="block">
<h2 id="JDEvent.on">@fn JDEvent.on($ev, $fn)</h2></div>
<div class="block">
<h2 id="JDEvent.trigger">@fn JDEvent.trigger($ev, $args)</h2>
<p>返回最后次调用的返回值，false表示中止之后事件调用 </p>
<p>如果想在事件处理函数中返回复杂值，可使用$args传递，如下面返回一个数组：</p>
<pre><code>$obj-&gt;on('getResult', 'onGetResult');
$out = new stdclass();
$out-&gt;result = [];
$obj-&gt;trigger('getArray', [$out]);

function onGetResult($out)
{
    $out-&gt;result[] = 100;
}</code></pre></div>
<div class="block">
<h2 id="ext">@module ext 集成外部系统</h2>
<p>调用外部系统（如短信集成、微信集成等）将引入依赖，给开发和测试带来复杂性。<br />
筋斗云框架通过使用“模拟模式”(MOCK_MODE)，模拟这些外部功能，从而简化开发和测试。</p>
<p>对于一个简单的外部依赖，可以用函数isMockMode来分支。例如添加对象存储服务(OSS)支持，接口定义为：</p>
<pre><code>getOssParam() -&gt; {url, expire, dir, param={policy, OSSAccessKeyId, signature} }
模拟模式返回：
getOssParam() -&gt; {url="mock"}</code></pre>
<p>在实现时，先在ext.php中定义外部依赖类型，如Ext_Oss，然后实现函数：</p>
<pre><code>function api_getOssParam()
{
    if (isMockMode(Ext_Oss)) {
        return ["url"=&gt;"mock"];
    }
    // 实际实现代码 ...
}</code></pre>
<p>添加一个复杂的（如支持多个函数调用的）支持模拟的外部依赖，也则可以定义接口，步骤如下，以添加短信支持(SmsSupport)为例：</p>
<ul>
<li>定义一个新的类型，如Ext_SmsSupport.</li>
<li>定义接口，如 ISmsSupport.</li>
<li>在ExtMock类中模拟实现接口ISmsSupport中所有函数, 一般是调用logext()写日志到ext.log, 可以在tool/log.php中查看最近的ext日志。</li>
<li>定义一个类SmsSupport实现接口ISmsSupport，一般放在其它文件中实现(如sms.php)。</li>
<li>在onCreateExt中处理新类型Ext_SmsSupport, 创建实际接口对象。</li>
</ul>
<p>使用举例：</p>
<pre><code>$sms = getExt(Ext_SmsSupport);
$sms-&gt;sendSms(...);</code></pre>
<p>要激活模拟模式，应在conf.user.php中设置：</p>
<pre><code>putenv("P_TEST_MODE=1");
putenv("P_MOCK_MODE=1");

// 或者只开启部分模块的模拟：
// putenv("P_MOCK_MODE=sms,wx");</code></pre>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p></div>
<div class="block">
<h2 id="isMockMode">@fn isMockMode($extType)</h2>
<p>判断是否模拟某外部扩展模块。如果$extType为null，则只要处于MOCK_MODE就返回true.</p></div>
<div class="block">
<h2 id="ExtFactory::getInstance">@fn ExtFactory::getInstance()</h2>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p></div>
<div class="block">
<h2 id="ExtFactory::getObj">@fn ExtFactory::getObj($extType, $allowMock?=true)</h2>
<p>获取外部依赖对象。一般用getExt替代更简单。</p>
<p>示例：</p>
<pre><code>$sms = ExtFactory::getInstance()-&gt;getObj(Ext_SmsSupport);</code></pre>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p></div>
<div class="block">
<h2 id="getExt">@fn getExt($extType, $allowMock = true)</h2>
<p>用于取外部接口对象，如：</p>
<pre><code>$sms = getExt(Ext_SmsSupport);</code></pre></div>
<div class="block">
<h2 id="logext">@fn logext($s, $addHeader?=true)</h2>
<p>写日志到ext.log中，可在线打开tool/init.php查看。<br />
(logit默认写日志到trace.log中)</p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p></div>
<div class="block">
<h2 id="api_fw">@module api_fw</h2><div class="toc"><p style="margin-left:0em"><a href="#api_fw-1 函数型接口">1 函数型接口</a></p>
<p style="margin-left:0em"><a href="#api_fw-2 对象型接口">2 对象型接口</a></p>
<p style="margin-left:0em"><a href="#api_fw-3 接口复用">3 接口复用</a></p>
<p style="margin-left:0em"><a href="#api_fw-4 常用操作">4 常用操作</a></p>
<p style="margin-left:0em"><a href="#api_fw-5 插件机制">5 插件机制</a></p>
</div>
<p>服务接口实现框架。</p>
<p>服务接口包含：</p>
<ul>
<li>函数型接口，如 &quot;login&quot;, &quot;getToken&quot;等, 一般实现在 api_functions.php中。</li>
<li>对象型接口，如 &quot;Ordr.query&quot;, &quot;User.get&quot; 等，一般实现在 api_objects.php中。</li>
</ul>
<h4 id="api_fw-1 函数型接口">1 函数型接口</h4>
<p>假设在文档有定义以下接口</p>
<pre><code>用户修改密码
chpwd(oldpwd, pwd) -&gt; {_token, _expire}

权限：AUTH_USER</code></pre>
<p>则在 api_functions.php 中创建该接口的实现：</p>
<pre><code>function api_chpwd()
{
    checkAuth(AUTH_USER);
    $oldPwd = mparam("oldpwd");
    $pwd = mparam("pwd");
    ...
    $ret = [
        "_token" =&gt; $token,
        "_expire" =&gt; $expire,
    ];
    return $ret;
}</code></pre>
<p>说明：</p>
<ul>
<li>函数名称一定要符合 &quot;api_{接口名}&quot; 的规范。接口名以小写字母开头。</li>
<li>使用checkAuth进行权限检查</li>
<li>返回符合接口定义的对象。最终后端框架将其转为JSON串，再由前端框架解析后传递给应用程序。</li>
</ul>
<p class="see"><strong>@see <a href="#checkAuth">checkAuth</a></strong> </p>
<p class="see"><strong>@see <a href="#mparam">mparam</a></strong>  取必选参数，如果缺少该参数则报错。</p>
<p class="see"><strong>@see <a href="#param">param</a></strong>  取可选参数，可指定缺省值。</p>
<h4 id="api_fw-2 对象型接口">2 对象型接口</h4>
<p class="see"><strong>@see <a href="#AccessControl">AccessControl</a></strong>  对象型接口框架。</p>
<p>v3.4支持非标准对象接口。实现Ordr.cancel接口：</p>
<pre><code>class AC2_Ordr extends AccessControl
{
    function api_cancel() {
    }
}</code></pre>
<p>非标准对象接口与与函数型接口写法类似，但AccessControl的众多回调函数对非标准对象接口无效。</p>
<h4 id="api_fw-3 接口复用">3 接口复用</h4>
<p class="key"><strong>@key <a id="apiMain">apiMain</a></strong> () 服务入口函数</p>
<p class="key"><strong>@key <a id="noExecApi">noExecApi</a></strong>  全局变量，禁止apiMain执行服务</p>
<p>一般在接口服务文件api.php中定义公共变量和函数，包含所有接口，在其最后调用服务入口函数apiMain()。</p>
<p>如果某应用想包含api.php，以便使用其中的接口实现，可以用callSvc:</p>
<pre><code>// set_include_path(get_include_path() . PATH_SEPARATOR . "..");
$GLOBALS["noExecApi"] = true; // 在包含api.php前设置该变量，可禁止apiMain函数自动解析请求（CLI方式调用时默认就不解析请求，故也可以不设置该变量）。
require_once("api.php");
...
$GLOBALS["errorFn"] = function($code, $msg, $msg2=null) {...}
$ret = callSvc("genVoucher");
// 如果没有异常，返回数据；否则调用指定的errorFn函数(未指定则调用errQuit)</code></pre>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p>
<h4 id="api_fw-4 常用操作">4 常用操作</h4>
<p>错误处理</p>
<p class="see"><strong>@see <a href="#MyException">MyException</a></strong> </p>
<p>中断执行，直接返回</p>
<p class="see"><strong>@see <a href="#DirectReturn">DirectReturn</a></strong> </p>
<p>调试日志</p>
<p>可使用addLog输出调试信息而不破坏协议输出格式。</p>
<p class="see"><strong>@see <a href="#addLog">addLog</a></strong>  </p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p>
<h4 id="api_fw-5 插件机制">5 插件机制</h4>
<p>插件是包含数据库/接口/前端逻辑页设计、后端实现、前端逻辑页实现的模块。</p>
<p>其设计由插件目录/DESIGN.md定义，可由upgrade工具自动部署。</p>
<p class="key"><strong>@key <a id="plugin/index.php">plugin/index.php</a></strong>  插件配置</p>
<p>plugin/{pluginName}为插件目录。</p>
<p>plugin/index.php是插件配置文件，在后端应用框架函数apiMain中引入，内容示例如下：</p>
<pre><code>&lt;?php

Plugins::add("plugin1");
Plugins::add("plugin2", "plugin2/index.php"); // 指定插件主文件，如不指定，默认为"plugin2/plugin.php"</code></pre>
<p>表示当前应用使用两个插件&quot;plugin1&quot;和&quot;plugin2&quot;, 分别对应目录 plugin/plugin1和plugin/plugin2.</p>
<p class="see"><strong>@see <a href="#Plugins::add">Plugins::add</a></strong> </p>
<p class="key"><strong>@key <a id="plugin">plugin</a></strong>  插件定义</p>
<p>插件实现包括交互接口，以及插件API（后端调用接口），以优惠券插件&quot;coupon&quot;为例: (plugin/coupon/plugin.php)</p>
<pre><code>&lt;?php

// 可选：定义模块API，均使用静态变量或函数
class Coupon
{
    // use MapCol; // 如果要用mapCol/mapSql函数，则打开该trait.

    static $conf1; // 模块配置
    static function func1($arg1) // 模块公共接口
    {
        // 调用实现部分
        $imp = CouponImpBase::getInstance();
        $imp-&gt;genCoupons($src);
    }
}

// 模块实现依赖的接口。如果必须由外部实现，则使用abstract类及函数
abstract class CouponImpBase
{
    use JDSingletonImp;

    abstract function genCoupons($src);
}

// 实现函数型交互接口takeCoupon
function api_takeCoupon() {}

// 实现对象型交互接口 Coupon.query/get/set/del/add
class AC1_Coupon extends AccessControl {}

// 可选：返回前端配置
return [
    "js" =&gt; "m2/plugin.js", // 如果前端需要包含文件
];</code></pre>
<p>注意：</p>
<p>调用插件API函数：</p>
<pre><code>    Coupon::func1($arg1);</code></pre>
<p>交互接口应在插件设计文档(plugin/coupon/DESIGN.md)中定义原型。</p>
<p>插件依赖的接口应定义CouponImp类来实现，一般放在文件 php/class/CouponImp.php中自动加载。</p></div>
<div class="block">
<h2 id="setRet">@fn setRet($code, $data?, $internalMsg?)</h2>
<p class="param"><strong>@param $code</strong>  Integer. 返回码, 0表示成功, 否则表示操作失败。</p>
<p class="param"><strong>@param $data</strong>  返回数据。</p>
<p class="param"><strong>@param $internalMsg</strong>  当返回错误时，作为额外调试信息返回。</p>
<p>设置返回数据，最终返回JSON格式数据为 [ code, data, internalMsg, debugInfo1, ...]<br />
其中按照BQP协议，前两项为必须，后面的内容一般仅用于调试，前端应用不应处理。</p>
<p>当成功时，返回数据可以是任何类型（根据API设计返回相应数据）。<br />
当失败时，为String类型错误信息。<br />
如果参数$data未指定，则操作成功时值为null（按BQP协议返回null表示客户端应忽略处理，一般无特定返回应指定$data=&quot;OK&quot;）；操作失败时使用默认错误信息。</p>
<p>调用完后，要返回的数据存储在全局数组 $X_RET 中，以JSON字符串形式存储在全局字符串 $X_RET_STR 中。<br />
注意：也可以直接设置$X_RET_STR为要返回的字符串，从而避免setRet函数对返回对象进行JSON序列化，如</p>
<pre><code>$GLOBALS["X_RET_STR"] = '{"id":100, "name":"aaa"}';
// 如果不想继续执行后面代码，可以自行调用：
setRet(0, "OK");
throw new DirectReturn();
// 最终返回字符串为 [0, {"id":100, "name":"aaa"}]</code></pre>
<p class="see"><strong>@see <a href="#$X_RET">$X_RET</a></strong> </p>
<p class="see"><strong>@see <a href="#$X_RET_STR">$X_RET_STR</a></strong> </p>
<p class="see"><strong>@see <a href="#$errorFn">$errorFn</a></strong> </p>
<p class="see"><strong>@see <a href="#errQuit">errQuit</a></strong> ()</p></div>
<div class="block">
<h2 id="setServerRev">@fn setServerRev()</h2>
<p>根据全局变量&quot;SERVER_REV&quot;或应用根目录下的文件&quot;revision.txt&quot;， 来设置HTTP响应头&quot;X-Daca-Server-Rev&quot;表示服务端版本信息（最多6位）。</p>
<p>客户端框架可本地缓存该版本信息，一旦发现不一致，可刷新应用。</p></div>
<div class="block">
<h2 id="hasPerm">@fn hasPerm($perm)</h2>
<p>检查权限。perm可以是单个权限或多个权限，例：</p>
<pre><code>hasPerm(AUTH_USER); // 用户登录后可用
hasPerm(AUTH_USER | AUTH_EMP); // 用户或员工登录后可用</code></pre>
<p class="fn"><strong>@fn <a id="onGetPerms">onGetPerms</a></strong> ()</p>
<p>开发者需要定义该函数，用于返回所有检测到的权限。hasPerm函数依赖该函数。</p>
<p class="see"><strong>@see <a href="#checkAuth">checkAuth</a></strong> </p></div>
<div class="block">
<h2 id="checkAuth">@fn checkAuth($perm)</h2>
<p>用法与hasPerm类似，检查权限，如果不正确，则抛出错误，返回错误对象。</p>
<pre><code>checkPerm(AUTH_USER); // 必须用户登录后可用
checkPerm(AUTH_ADMIN | PERM_TEST_MODE); 要求必须管理员登录或测试模式才可用。</code></pre>
<p class="see"><strong>@see <a href="#hasPerm">hasPerm</a></strong> </p></div>
<div class="block">
<h2 id="getClientVersion">@fn getClientVersion()</h2>
<p>通过参数<code>_ver</code>或useragent字段获取客户端版本号。</p>
<p>@return: {type, ver, str}</p>
<ul>
<li>type: &quot;web&quot;-网页客户端; &quot;wx&quot;-微信客户端; &quot;a&quot;-安卓客户端; &quot;ios&quot;-苹果客户端</li>
</ul>
<p>e.g. {type: &quot;a&quot;, ver: 2, str: &quot;a/2&quot;}</p></div>
<div class="block">
<h2 id="tmCols">@fn tmCols($fieldName = "t0.tm")</h2>
<p>为查询添加时间维度单位: y,m,w,d,wd,h (年，月，周，日，周几，时)。</p>
<ul>
<li>wd: 1-7表示周一到周日</li>
<li>w: 一年中第一周，从该年第一个周一开始(mysql week函数模式7).</li>
</ul>
<p>示例：</p>
<pre><code>    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols() ];
    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols("t0.createTm") ];
    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols("log_cr.tm"), "require" =&gt; "createTm" ];</code></pre></div>
<div class="block">
<h2 id="ConfBase">@class ConfBase</h2>
<p>在conf.php中定义Conf类并继承ConfBase, 实现代码配置：</p>
<pre><code>class Conf extends ConfBase
{
}</code></pre>
<p class="key"><strong>@key <a id="Conf">Conf</a></strong>  项目易变逻辑</p>
<p class="key"><strong>@key <a id="conf.php">conf.php</a></strong>  项目易变逻辑</p>
<p>$BASE_DIR/conf.php中包含Conf类，用于定义易变的临时逻辑，例如数据库维护时报错提示，临时控制某个版本不能使用，遇到节假日休息提醒等等。</p>
<p>不变的全局配置应在app.php中定义。</p></div>
<div class="block">
<h2 id="ConfBase::$enableApiLog">@var ConfBase::$enableApiLog?=true</h2>
<p>设置为false可关闭ApiLog. 例：</p>
<pre><code>static $enableApiLog = false;</code></pre></div>
<div class="block">
<h2 id="ConfBase::onApiInit">@fn ConfBase::onApiInit()</h2>
<p>所有API执行时都会先走这里。</p>
<p>例：对所有API调用检查ios版本：</p>
<pre><code>static function onApiInit()
{
    $ver = getClientVersion();
    if ($ver["type"] == "ios" &amp;&amp; $ver["ver"]&lt;=15) {
        throw new MyException(E_FORBIDDEN, "unsupport ios client version", "您使用的版本太低，请升级后使用!");
    }
}</code></pre></div>
<div class="block">
<h2 id="ConfBase::onInitClient">@fn ConfBase::onInitClient(&$ret)</h2>
<p>客户端初始化应用时会调用initClient接口，返回plugins等信息。若要加上其它信息，可在这里扩展。</p>
<p>例：假如定义应用初始化接口为(plugins是框架默认返回的)：</p>
<pre><code>initClient(app) -&gt; {plugins, appName}</code></pre>
<p>实现：</p>
<pre><code>static function onInitClient(&amp;$ret)
{
    $app = mparam('app');
    $ret['appName'] = 'my-app';
}</code></pre></div>
<div class="block">
<h2 id="MapCol.$colMap">@var MapCol.$colMap</h2>
<p>%colMap = {tbl =&gt; [tblAlias, %cols]}<br />
cols = {col =&gt; colAlias}</p>
<p>先在插件接口文档DESIGN.md中声明本插件的数据库依赖：</p>
<pre><code>@see @Store: id, name, dscr
@see @Ordr: id</code></pre>
<p>配置定表名或列名对应（如果名称相同不必声明）</p>
<pre><code>Coupon::$colMap = [
    "Store" =&gt; ["MyStore", [
        "dscr" =&gt; "description"
    ]],
    "Ordr" =&gt; ["MyOrder"]
];</code></pre>
<p>在plugin实现时，使用mapCol/mapSql来使表名、列名可配置：</p>
<pre><code>class Coupon
{
    use MapCol;
}
$tbl = Coupon::mapCol("Store"); // $tbl="MyStore"
$tbl = Coupon::mapCol("User"); // $tbl="User" 未定义时，直接取原值
$col = Coupon::mapCol("Store.dscr"); // $col="description"
$col = Coupon::mapCol("Store.name"); // $col="name" 未定义时，直接取原值

$sql = $plugin-&gt;mapSql("SELECT s.id, s.{Store.name}, s.{Store.dscr} FROM {Store} s INNER JOIN {Ordr} o ON o.id=s.{Store.storeId}");
// $sql = "SELECT s.id, s.name, s.description FROM MyStore s INNER JOIN MyOrder o ON o.id=s.storeId"</code></pre>
<p class="key"><strong>@key <a id="MapCol.mapCol">MapCol.mapCol</a></strong> ($tbl, $col=null)</p>
<p class="key"><strong>@key <a id="MapCol.mapSql">MapCol.mapSql</a></strong> ($sql)</p></div>
<div class="block">
<h2 id="Plugins">@class Plugins</h2>
<p class="see"><strong>@see <a href="#plugin/index.php">plugin/index.php</a></strong> </p></div>
<div class="block">
<h2 id="Plugins::$map">@var Plugins::$map</h2>
<p>{ pluginName =&gt; %pluginCfg={js} }</p></div>
<div class="block">
<h2 id="Plugins::add">@fn Plugins::add($pluginName, $file?="{pluginName}/plugin.php")</h2>
<p>添加模块或插件。$file为插件主文件，可返回一个插件配置.</p>
<p>以下旧的格式也兼容，现已不建议使用：</p>
<pre><code>Plugins::add($pluginNameArray)</code></pre>
<p class="see"><strong>@see <a href="#Plugins.$map">Plugins.$map</a></strong> </p></div>
<div class="block">
<h2 id="Plugins::exists">@fn Plugins::exists($pluginName)</h2></div>
<div class="block">
<h2 id="tableCRUD">@fn tableCRUD($ac, $tbl, $asAdmin?=false)</h2>
<p>对象型接口的入口。<br />
也可直接被调用，常与setParam一起使用, 提供一些定制的操作。</p>
<p class="param"><strong>@param $asAdmin</strong>  默认根据用户身份自动选择"AC_"类; 如果为true, 则以超级管理员身份调用，即使用"AC0_"类。</p>
<p>设置$asAdmin=true好处是对于超级管理员权限来说，即使未定义&quot;AC0_&quot;类，默认也可以访问所有内容。</p>
<p>假如有Rating（订单评价）对象，不想通过对象型接口来查询，而是通过函数型接口来定制输出，接口设计为：</p>
<pre><code>queryRating(storeId, cond?) -&gt; tbl(id, score, dscr, tm, orderDscr)

查询店铺storeId的订单评价。

应用逻辑：
- 按时间tm倒排序</code></pre>
<p>底层利用tableCRUD实现它，这样便于保留分页、参数cond/gres等特性:</p>
<pre><code>function api_queryRating()
{
    $storeId = mparam("storeId");

    // 定死输出内容。
    setParam("res", "id, score, dscr, tm, orderDscr");

    // 相当于AccessControl框架中调用 addCond，用Obj.query接口的内部参数cond2以保证用户还可以使用cond参数。
    setParam("cond2", ["o.storeId=$storeId"]); 

    // 定死排序条件
    setParam("orderby", "tm DESC");

    $ret = tableCRUD("query", "Rating", true);
    return $ret;
}</code></pre>
<p>注意：</p>
<ul>
<li>以上示例中的设计不可取，应使用标准对象接口来实现这个需求。</li>
</ul>
<p class="see"><strong>@see <a href="#setParam">setParam</a></strong> </p>
<p class="see"><strong>@see <a href="#callSvcInt">callSvcInt</a></strong> </p>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p></div>
<div class="block">
<h2 id="callSvcInt">@fn callSvcInt($ac)</h2>
<p>内部调用另一接口，获得返回值。如果要设置GET, POST参数，分别用</p>
<pre><code>setParam(key, value); // 设置get参数
// 或批量设置用 setParam({key =&gt; value});
$_POST[key] = value; // 设置post参数</code></pre>
<p>与callSvc不同的是，它不处理事务、不写ApiLog，不输出数据，更轻量；<br />
与tableCRUD不同的是，它支持函数型调用。</p>
<p class="see"><strong>@see <a href="#setParam">setParam</a></strong> </p>
<p class="see"><strong>@see <a href="#tableCRUD">tableCRUD</a></strong> </p>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p></div>
<div class="block">
<h2 id="callSvc">@fn callSvc($ac?, $urlParam?, $postParam?, $cleanCall?=false, $hideResult?=false)</h2>
<p>直接调用接口，返回数据。如果出错，将调用$GLOBALS['errorFn'] (缺省为errQuit).</p>
<p class="param"><strong>@param $cleanCall</strong>  Boolean. 如果为true, 则不使用现有的$_GET, $_POST等变量中的值。</p>
<p class="param"><strong>@param $hideResult</strong>  Boolean. 如果为true, 不输出结果。</p></div>
<div class="block">
<h2 id="AccessControl">@module AccessControl</h2><div class="toc"><p style="margin-left:0em"><a href="#AccessControl-1 基本权限控制">1 基本权限控制</a></p>
<p style="margin-left:0em"><a href="#AccessControl-2 虚拟字段">2 虚拟字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.1 关联字段">2.1 关联字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.2 关联字段依赖">2.2 关联字段依赖</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.3 计算字段">2.3 计算字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.4 子表压缩字段">2.4 子表压缩字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.5 自定义字段">2.5 自定义字段</a></p>
<p style="margin-left:0em"><a href="#AccessControl-3 子表">3 子表</a></p>
<p style="margin-left:0em"><a href="#AccessControl-4 操作完成回调">4 操作完成回调</a></p>
<p style="margin-left:0em"><a href="#AccessControl-5 其它">5 其它</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.1 编号自定义生成">5.1 编号自定义生成</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.2 缺省排序">5.2 缺省排序</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.3 缺省输出字段列表">5.3 缺省输出字段列表</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.4 最大每页数据条数">5.4 最大每页数据条数</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.5 虚拟表和视图">5.5 虚拟表和视图</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.6 query接口输出格式">5.6 query接口输出格式</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.7 distinct查询">5.7 distinct查询</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.8 枚举支持及自定义字段处理">5.8 枚举支持及自定义字段处理</a></p>
</div>
<p>对象型接口框架。<br />
AccessControl简写为AC，同时AC也表示自动补全(AutoComplete).</p>
<p>在设计文档中完成数据库设计后，通过添加AccessControl的继承类，可以很方便的提供诸如 {Obj}.query/add/get/set/del 这些对象型接口。</p>
<p>例如，设计文档中已定义订单对象(Ordr)的主表(Ordr)和订单日志子表(OrderLog)：</p>
<pre><code>@Ordr: id, userId, status, amount
@OrderLog: id, orderId, tm, dscr</code></pre>
<p>注意：之所以用对象和主表名用Ordr而不是Order词是避免与SQL关键字冲突。</p>
<p>有了表设计，订单的标准接口就已经自动生成好了：</p>
<pre><code>// 查询订单
Ordr.query() -&gt; tbl(id, userId, ...)
// 添加订单
Ordr.add()(userId=1, status='CR', amount=100) -&gt; id
// 查看订单
Ordr.get(id=1)
// 修改订单状态
Ordr.set(id=1)(status='PA')
// 删除订单
Ordr.del(id=1)</code></pre>
<p>但是，只有超级管理员登录后（例如从示例应用中的超级管理端登录后，web/adm.html），才有权限使用这些接口。</p>
<p>如果希望用户登录后，也可以使用这些接口，只要添加一个继承AccessControl的类，且命名为&quot;AC1_Ordr&quot;即可：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
}</code></pre>
<p>有了以上定义，在用户登录系统后，就可以使用上述和超级管理员一样的标准订单接口了。</p>
<p>说明：</p>
<p>类的命名规则为AC前缀加对象名（或主表名，因为对象名与主表名一致）。框架默认提供的前缀如下：</p>
<p class="key"><strong>@key <a id="AC_">AC_</a></strong>   游客权限(AUTH_GUEST)，如未定义则调用时报“无权操作”错误。</p>
<p class="key"><strong>@key <a id="AC0_">AC0_</a></strong>  超级管理员权限(AUTH_ADMIN)，如未定义，默认拥有所有权限。</p>
<p class="key"><strong>@key <a id="AC1_">AC1_</a></strong>   用户权限(AUTH_USER)，如未定义，则降级使用游客权限接口(AC_)。</p>
<p class="key"><strong>@key <a id="AC2_">AC2_</a></strong>   员工权限(AUTH_EMP/AUTH_MGR), 如未定义，报权限不足错误。</p>
<p>因而上例中命名为 &quot;AC1_Ordr&quot; 就表示用户登录后调用Ordr对象接口，将受该类控制。而这是个空的类，所以拥有一切操作权限。</p>
<p>框架为AUTH_ADMIN权限自动选择AC0_类，其它类可以通过函数 onCreateAC 进行自定义，仍未定义的框架使用AC_类。</p>
<p class="fn"><strong>@fn <a id="onCreateAC">onCreateAC</a></strong> ($obj)</p>
<p>需开发者在api.php中定义。<br />
根据对象名，返回权限控制类名，如 AC1<em>{$obj}。<br />
如果返回null, 则默认为 AC</em>{obj}</p>
<h4 id="AccessControl-1 基本权限控制">1 基本权限控制</h4>
<p class="var"><strong>@var <a id="AccessControl::$allowedAc">AccessControl::$allowedAc</a></strong> ?=["add", "get", "set", "del", "query"] 设定允许的操作，如不指定，则允许所有操作。</p>
<p class="var"><strong>@var <a id="AccessControl::$readonlyFields">AccessControl::$readonlyFields</a></strong>  ?=[]  (影响add/set) 字段列表，添加/更新时为这些字段填值无效（但不报错）。</p>
<p class="var"><strong>@var <a id="AccessControl::$readonlyFields2">AccessControl::$readonlyFields2</a></strong>  ?=[]  (影响set操作) 字段列表，更新时对这些字段填值无效。</p>
<p class="var"><strong>@var <a id="AccessControl::$hiddenFields">AccessControl::$hiddenFields</a></strong>  ?= []  (for get/query) 隐藏字段列表。默认表中所有字段都可返回。一些敏感字段不希望返回的可在此设置。</p>
<p class="var"><strong>@var <a id="AccessControl::$requiredFields">AccessControl::$requiredFields</a></strong>  ?=[] (for add/set) 字段列表。添加时必须填值；更新时不允许置空。</p>
<p class="var"><strong>@var <a id="AccessControl::$requiredFields2">AccessControl::$requiredFields2</a></strong>  ?=[] (for set) 字段列表。更新时不允许设置空。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onQuery">AccessControl::onQuery</a></strong> () (for get/query)  用于对查询条件进行设定。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onValidate">AccessControl::onValidate</a></strong> ()  (for add/set). 验证添加和更新时的字段，或做自动补全(AutoComplete)工作。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onValidateId">AccessControl::onValidateId</a></strong> () (for get/set/del) 用于对id字段进行检查。比如在del时检查用户是否有权操作该记录。</p>
<p>上节例子中，用户可以操作系统的所有订单。</p>
<p>现在我们到设计文档中，将接口API设计如下：</p>
<pre><code>== 订单接口 ==

添加订单：
Ordr.add()(amount) -&gt; id

查看订单：
Ordr.query() -&gt; tbl(id, userId, status, amount)
Ordr.get(id)

权限：AUTH_GUEST

应用逻辑
- 用户只能添加(add)、查看(get/query)订单，不可修改(set)、删除(del)订单
- 用户只能查看(get/query)属于自己的订单。
- 用户在添加订单时，必须设置amount字段，不必（也不允许）设置id, userId, status这些字段。
  服务器应将userId字段自动设置为该用户编号，status字段自动设置为"CR"（已创建）</code></pre>
<p>为实现以下逻辑，上面例子中代码可修改为：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $allowedAc = ["get", "query", "add"];
    protected $requiredFields = ["amount"];
    protected $readonlyFields = ["status", "userId"];

    protected function onQuery()
    {
        $userId = $_SESSION["uid"];
        $this-&gt;addCond("t0.userId={$userId}");
    }

    protected function onValidate()
    {
        if ($this-&gt;ac == "add") {
            $userId = $_SESSION["uid"];
            $_POST["userId"] = $userId;
            $_POST["status"] = "CR";
        }
    }
}</code></pre>
<p>说明：</p>
<ul>
<li>使用$allowedAc设定了该对象接口允许的操作。</li>
<li>使用$requiredFields与$readonlyFields设定了添加时必须指定或不可指定的字段。由于&quot;id&quot;字段默认就是不可添加/更新的，所以不必在这里指定。</li>
<li>在onQuery中，对用户可查看的订单做了限制：只允许访问自己的订单。这里通过添加了条件实现。<br />
$_SESSION[&quot;uid&quot;]是在用户登录后设置的，可参考login接口定义(api_login).</li>
<li>在onValidate中，对添加操作时的字段做自动补全。由于添加和更新都会走这个接口，所以用 $this-&gt;ac 判断只对添加操作时补全。<br />
由于添加和更新操作的具体字段都通过 $_POST 来传递，故直接设置 $_POST中的相应字段即可。</li>
</ul>
<h4 id="AccessControl-2 虚拟字段">2 虚拟字段</h4>
<p class="var"><strong>@var <a id="AccessControl::$vcolDefs">AccessControl::$vcolDefs</a></strong>  (for get/query) 定义虚拟字段</p>
<p>常用于展示关联表字段、统计字段等。<br />
在query,get操作中可以通过res参数指定需要返回的每个字段，这些字段可能是普通列名(col)/虚拟列名(vcol)/子对象(subobj)名。</p>
<h5 id="AccessControl-2.1 关联字段">2.1 关联字段</h5>
<p>例如，在订单列表中需要展示用户名字段。设计文档中定义接口：</p>
<pre><code>Ordr.query() -&gt; tbl(id, dscr, ..., userName?, userPhone?, createTm?)</code></pre>
<p>query接口的&quot;...&quot;之后就是虚拟字段。后缀&quot;?&quot;表示是非缺省字段，即必须在&quot;res&quot;参数中指定才会返回，如：</p>
<pre><code>Ordr.query(res="*,userName")</code></pre>
<p>在cond中可以直接使用虚拟字段，不管它是否在res中指定，如</p>
<pre><code>Ordr.query(cond="userName LIKE 'jian%'", res="id,dscr")</code></pre>
<p>通过设置$vcolDefs实现这些关联字段：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["u.name AS userName", "u.phone AS userPhone"],
            "join" =&gt; "INNER JOIN User u ON u.id=t0.userId",
            // "default" =&gt; false, // 指定true表示Ordr.query在不指定res时默认会返回该字段。一般不建议设置为true.
        ],
        [
            "res" =&gt; ["log_cr.tm AS createTm"],
            "join" =&gt; "LEFT JOIN OrderLog log_cr ON log_cr.action='CR' AND log_cr.orderId=t0.id",
        ]
    ]
}</code></pre>
<h5 id="AccessControl-2.2 关联字段依赖">2.2 关联字段依赖</h5>
<p>假设设计有“订单评价”对象，它会与“订单对象”相关联：</p>
<pre><code>@Rating: id, orderId, content</code></pre>
<p>表间的关系为：</p>
<pre><code>订单评价Rating(orderId) &lt;-&gt; 订单Ordr(userId) &lt;-&gt; 用户User</code></pre>
<p>现在要为Rating表增加关联字段 &quot;Ordr.dscr AS orderDscr&quot;, 以及&quot;User.name AS userName&quot;, 设计接口为：</p>
<pre><code>Rating.query() -&gt; tbl(id, orderId, content, ..., orderDscr?, userName?)
注意：userName字段不直接与Rating表关联，而是通过Ordr表桥接。</code></pre>
<p>实现时，只需在vcolDefs中使用require指定依赖字段：</p>
<pre><code>class AC1_Rating extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["o.dscr AS orderDscr", "o.userId"],
            "join" =&gt; "INNER JOIN Ordr o ON o.id=t0.orderId",
        ],
        [
            "res" =&gt; ["u.name AS userName"],
            "join" =&gt; "INNER JOIN User u ON o.userId=u.id",
            "require" =&gt; "userId", // *** 定义依赖，如果要用到res中的字段如userName，则自动添加userId字段引入的表关联。
            // 这里指向orderDscr也可以，一般习惯上指向关联的字段。
        ],
    ];
}</code></pre>
<p>使用require, 框架可自动将Ordr表作为中间表关联进来。<br />
如果没有require定义，以下调用</p>
<pre><code>Rating.query(res="*,orderDscr,userName")</code></pre>
<p>也不会出问题，因为在userName前指定了orderDscr，框架可自动引入相关表。而以下查询就会出问题：</p>
<pre><code>Rating.query(res="*,userName")
或
Rating.query(res="*,userName,orderDscr")</code></pre>
<h5 id="AccessControl-2.3 计算字段">2.3 计算字段</h5>
<p>示例：管理端应用在查询订单时，需要订单对象上有一个原价字段：</p>
<pre><code>Ordr.query() -&gt; tbl(..., amount2)
amount2:: 原价，通过OrderItem中每个项目重新计算累加得到，不考虑打折优惠。</code></pre>
<p>可实现为：</p>
<pre><code>class AC0_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["(SELECT SUM(qty*ifnull(price2,0)) FROM OrderItem WHERE orderId=t0.id) AS amount2"],
        ]
    ];
}</code></pre>
<h5 id="AccessControl-2.4 子表压缩字段">2.4 子表压缩字段</h5>
<p>除了使用<a href="#AccessControl::$subobj">子表</a>, 对于简单的情况，也可以设计为将子表压缩成一个虚拟字段，在Query操作时直接返回。</p>
<p>示例：OrderItem是Ordr对象的一个子表，现在想在查询Ordr对象列表时，返回OrderItem的相关信息。<br />
这就要把一张子表压缩成一个字段。我们使用List来描述这种压缩字段的格式：表中每行以&quot;,&quot;分隔，行中每个字段以&quot;:&quot;分隔。<br />
利用List，可将接口设计为：</p>
<pre><code>Ordr.query() -&gt; tbl(..., itemsInfo)
itemsInfo:: List(name, price, qty). 例如"洗车:25:1,换轮胎:380:2", 表示两行记录，每行3个字段。注意字段内容中不可出现":", ","这些分隔符。</code></pre>
<p>子表压缩是一种特殊的计算字段，可实现如下：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["(SELECT group_concat(concat(oi.name, ':', oi.price, ':', oi.qty)) FROM OrderItem oi WHERE oi.orderId=t0.id) itemsInfo"] 
        ],
        ...
    ]
}</code></pre>
<p>注意：计算字段，包括子表压缩字段都是很消耗性能的。</p>
<h5 id="AccessControl-2.5 自定义字段">2.5 自定义字段</h5>
<p>假设有张虚拟表Task, 它没有存储在数据库中, 另一张表UserTaskLog关联到它。在设计文档中定义如下:</p>
<pre><code>@UserTaskLog: id, userId, taskId
@Conf::$taskTable: id, type, name
(关联： UserTaskLog(taskId) &lt;-&gt; Conf::$taskTable )

提供查询接口：
UserTaskLog.query() -&gt; tbl(id, taskId, ..., taskName)
taskName:: 由关联表的taskTable.name字段得到。</code></pre>
<p>实现中，在代码中直接定义Task表：</p>
<pre><code>class Conf
{
    static $taskTable = [
        ["id" =&gt; 1, "type"=&gt;"invite", "name" =&gt; "邀请5个用户注册"],
        ["id" =&gt; 2, "type"=&gt;"invite", "name" =&gt; "邀请10个用户注册"],
    ];
}</code></pre>
<p>通过在vcolDefs的join属性指定一个函数，可以实现返回taskName字段：</p>
<pre><code>function getTaskName(&amp;$row)
{
    foreach (Conf::$taskTable as $task) {
        if ($row["taskId"] == $task["id"]) {
            $row["taskName"] = $task["name"];
        }
    }
}

class AC1_UserTaskLog extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["taskName"],
            "join" =&gt; getTaskName
        ]
    ];
}</code></pre>
<p>注意:</p>
<ul>
<li>自定义字段只限于对query/get的最终结果集进行操作</li>
<li>自定义字段不能用于设置cond条件.</li>
</ul>
<h4 id="AccessControl-3 子表">3 子表</h4>
<p class="var"><strong>@var <a id="AccessControl::$subobj">AccessControl::$subobj</a></strong>  (for get/query) 定义子表</p>
<p>subobj: { name =&gt; {sql, default, wantOne} }</p>
<p>设计接口：</p>
<pre><code>Ordr.get() -&gt; {id, ..., @orderLog}
orderLog:: {id, tm, dscr, ..., empName} 订单日志子表。</code></pre>
<p>实现：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $subobj = [
        "orderLog" =&gt; ["sql"=&gt;"SELECT ol.*, e.name AS empName FROM OrderLog ol LEFT JOIN Employee e ON ol.empId=e.id WHERE orderId=%d", "default"=&gt;false, "wantOne"=&gt;false],
    ];
}</code></pre>
<p>子表和虚拟字段类似，支持get/query操作，执行指定的SQL语句作为结果。结果以一个数组返回[{id, tm, ...}]。<br />
&quot;default&quot;选项与虚拟字段(vcolDefs)上的&quot;default&quot;选项一样，表示当未指定&quot;res&quot;参数时，是否默认返回该字段。<br />
如果指定wantOne=&gt;true, 则结果以一个对象返回即 {id, tm, ...}, 适用于主表与子表一对一的情况。</p>
<h4 id="AccessControl-4 操作完成回调">4 操作完成回调</h4>
<p class="fn"><strong>@fn <a id="AccessControl::onAfter">AccessControl::onAfter</a></strong> (&$ret)  (for all) 操作完成时的回调。可修改操作结果ret。</p>
<p>如果要对get/query结果中的每行字段进行设置，应重写回调 onHandleRow.<br />
有时使用 onAfterActions 就近添加逻辑更加方便。</p>
<p class="var"><strong>@var <a id="AccessControl::$onAfterActions">AccessControl::$onAfterActions</a></strong>  =[].  onAfter的替代方案，更易使用，便于与接近的逻辑写在一起。</p>
<p class="var"><strong>@var <a id="AccessControl::$id">AccessControl::$id</a></strong>   get/set/del时指定的id, 或add后返回的id.</p>
<p>例如，添加订单时，自动添加一条日志，可以用：</p>
<pre><code>protected function onValidate()
{
    if ($this-&gt;ac == "add") {
        ... 

        $this-&gt;onAfterActions[] = function () use ($logAction) {
            $orderId = $this-&gt;id;
            $sql = sprintf("INSERT INTO OrderLog (orderId, action, tm) VALUES ({$orderId},'CR','%s')", date('c'));
            execOne($sql);
        };
    }
}</code></pre>
<p class="fn"><strong>@fn <a id="AccessControl::onHandleRow">AccessControl::onHandleRow</a></strong> (&$rowData) (for get/query) 在onAfter之前运行，用于修改行中字段。</p>
<h4 id="AccessControl-5 其它">5 其它</h4>
<h5 id="AccessControl-5.1 编号自定义生成">5.1 编号自定义生成</h5>
<p class="fn"><strong>@fn <a id="AccessControl::onGenId">AccessControl::onGenId</a></strong> () (for add) 指定添加对象时生成的id. 缺省返回0表示自动生成.</p>
<h5 id="AccessControl-5.2 缺省排序">5.2 缺省排序</h5>
<p class="var"><strong>@var <a id="AccessControl::$defaultSort">AccessControl::$defaultSort</a></strong>  ?= "t0.id" (for query)指定缺省排序.</p>
<p>示例：Video对象默认按id倒序排列：</p>
<pre><code>class AC_Video extends AccessControl 
{
    protected $defaultSort = "t0.id DESC";
    ...
}</code></pre>
<h5 id="AccessControl-5.3 缺省输出字段列表">5.3 缺省输出字段列表</h5>
<p class="var"><strong>@var <a id="AccessControl::$defaultRes">AccessControl::$defaultRes</a></strong>  (for query)指定缺省输出字段列表. 如果不指定，则为 "t0.*" 加  default=true的虚拟字段</p>
<h5 id="AccessControl-5.4 最大每页数据条数">5.4 最大每页数据条数</h5>
<p class="fn"><strong>@fn <a id="AccessControl::getMaxPageSz">AccessControl::getMaxPageSz</a></strong> ()  (for query) 取最大每页数据条数。为非负整数。</p>
<p class="var"><strong>@var <a id="AccessControl::$maxPageSz">AccessControl::$maxPageSz</a></strong>  ?= 100 (for query) 指定最大每页数据条数。值为负数表示取PAGE_SZ_LIMIT值.</p>
<p>前端通过 {obj}.query(pagesz)来指定每页返回多少条数据，缺省是20条，最高不可超过100条。当指定为负数时，表示按最大允许值=min($maxPageSz, PAGE_SZ_LIMIT)返回。<br />
PAGE_SZ_LIMIT目前定为10000条。如果还不够，一定是应用设计有问题。</p>
<p>如果想返回每页超过100条数据，必须在后端设置，如：</p>
<pre><code>class MyObj extends AccessControl
{
    protected $maxPageSz = 1000; // 最大允许返回1000条
    // protected $maxPageSz = -1; // 最大允许返回 PAGE_SZ_LIMIT 条
}</code></pre>
<p class="var"><strong>@var <a id="PAGE_SZ_LIMIT">PAGE_SZ_LIMIT</a></strong>  =10000</p>
<h5 id="AccessControl-5.5 虚拟表和视图">5.5 虚拟表和视图</h5>
<p>假如要对ApiLog进行过滤，只查询管理端的写操作。实现以下接口：</p>
<pre><code>EmpLog.query() -&gt; tbl(id, tm, userId, ac, req, res, reqsz, ressz, empName?, empPhone?)</code></pre>
<p>一种办法可以在后台定义一个视图，如:</p>
<pre><code>CREATE VIEW EmpLog AS
SELECT t0.id, tm, userId, ac, req, res, reqsz, ressz, e.name empName, e.phone empPhone
FROM ApiLog t0
LEFT JOIN Employee e ON e.id=t0.userId
WHERE t0.app='emp-adm' AND t0.userId IS NOT NULL
ORDER BY t0.id DESC</code></pre>
<p>然后可将该视图当作表一样查询（但不可更新），如：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
}</code></pre>
<p>这样就可以实现上述接口了。</p>
<p>另一种办法是直接使用AccessControl创建虚拟表，代码如下：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
    protected $table = 'ApiLog';
    protected $defaultSort = "t0.id DESC";
    protected $defaultRes = "id, tm, userId, ac, req, res, reqsz, ressz, empName, empPhone";
    protected $vcolDefs = [
        [
            "res" =&gt; ["e.name AS empName", "e.phone AS empPhone"],
            "join" =&gt; "LEFT JOIN Employee e ON e.id=t0.userId"
        ]
    ];

    protected function onQuery() {
        $this-&gt;addCond("t0.app='emp-adm' and t0.userId IS NOT NULL");
    }
}</code></pre>
<p>与上例相比，它不仅无须在数据库中创建视图，还也可以进行更新。<br />
其要点是：</p>
<ul>
<li>重写 AccessControl::$table</li>
<li>重写 AccessControl::$defaultRes</li>
<li>用addCond添加缺省查询条件</li>
</ul>
<h5 id="AccessControl-5.6 query接口输出格式">5.6 query接口输出格式</h5>
<p>query接口支持fmt参数：</p>
<ul>
<li>list: 生成<code>{ @list, nextkey?, total? }</code>格式，而非缺省的 <code>{ @h, @d, nextkey?, total? }</code>格式</li>
<li>csv/txt/excel: 导出文件，注意为了避免分页，调用时可设置较大的pagesz值。
<ul>
<li>csv: 逗号分隔的文件，utf8编码。</li>
<li>excel: 逗号分隔的文件，gb18030编码以便excel可直接打开不会显示中文乱码。</li>
<li>txt: 制表分隔的文件, utf8编码。</li>
</ul></li>
</ul>
<p>TODO: 可加一个系统参数<code>_enc</code>表示输出编码的格式。</p>
<h5 id="AccessControl-5.7 distinct查询">5.7 distinct查询</h5>
<p>如果想生成<code>SELECT DISTINCT t0.a, ...</code>查询，<br />
当在AccessControl外部时，可以设置</p>
<pre><code>setParam("distinct", 1);</code></pre>
<p>如果是在AccessControl子类中，可以设置</p>
<pre><code>$this-&gt;sqlConf["distinct"] =1;</code></pre>
<h5 id="AccessControl-5.8 枚举支持及自定义字段处理">5.8 枚举支持及自定义字段处理</h5>
<p>(版本5.0)</p>
<p class="var"><strong>@var <a id="AccessControl::$enumFields">AccessControl::$enumFields</a></strong>  {field => map/fn($val) }支持处理枚举字段，或自定义处理。</p>
<p>作为比onHandleRow/onAfterActions等更易用的工具，enumFields可对返回字段做修正。例如，想要对返回的status字段做修正，如&quot;CR&quot;显示为&quot;Created&quot;，可设置：</p>
<pre><code>$enumFields["status"] = ["CR"=&gt;"Created", "CA"=&gt;"Cancelled"];</code></pre>
<p>也可以设置为自定义函数，如：</p>
<pre><code>$map = ["CR"=&gt;"Created", "CA"=&gt;"Cancelled"];
$enumFields["status"] = function($v) use ($map) {
    if (array_key_exists($v, $map))
        return $v . "-" . $map[$v];
    return $v;
};</code></pre>
<p>此外，枚举字段可直接由请求方通过res参数指定描述值，如：</p>
<pre><code>Ordr.query(res="id, status =CR:Created;CA:Cancelled")
或指定alias:
Ordr.query(res="id 编号, status 状态=CR:Created;CA:Cancelled")</code></pre></div>
<div class="block">
<h2 id="AccessControl::addRes">@fn AccessControl::addRes($res, $analyzeCol=true)</h2>
<p>添加列或计算列. </p>
<p>注意: </p>
<ul>
<li>analyzeCol=true时, addRes(&quot;col&quot;); -- (analyzeCol=true) 添加一列, 注意:如果列是一个虚拟列(在vcolDefs中有定义), 不能指定alias, 且vcolDefs中同一组Res中所有定义的列都会加入查询; 如果希望只加一列且能定义alias, 可调用addVCol函数.</li>
<li>addRes(&quot;col+1 as col1&quot;, false); -- 简单地新定义一个计算列, as可省略</li>
</ul>
<p class="see"><strong>@see <a href="#AccessControl::addCond">AccessControl::addCond</a></strong>  其中有示例</p>
<p class="see"><strong>@see <a href="#AccessControl::addVCol">AccessControl::addVCol</a></strong>  添加已定义的虚拟列。</p></div>
<div class="block">
<h2 id="AccessControl::addCond">@fn AccessControl::addCond($cond, $prepend=false)</h2>
<p class="param"><strong>@param $prepend</strong>  为true时将条件排到前面。</p>
<p>调用多次addCond时，多个条件会依次用&quot;AND&quot;连接起来。</p>
<p>添加查询条件。<br />
示例：假如设计有接口：</p>
<pre><code>Ordr.query(q?) -&gt; tbl(..., payTm?)
参数：
q:: 查询条件，值为"paid"时，查询10天内已付款的订单。且结果会多返回payTm/付款时间字段。</code></pre>
<p>实现时，在onQuery中检查参数&quot;q&quot;并定制查询条件：</p>
<pre><code>protected function onQuery()
{
    // 限制只能看用户自己的订单
    $uid = $_SESSION["uid"];
    $this-&gt;addCond("t0.userId=$uid");

    $q = param("q");
    if (isset($q) &amp;&amp; $q == "paid") {
        $validDate = date("Y-m-d", strtotime("-9 day"));
        $this-&gt;addRes("olpay.tm payTm");
        $this-&gt;addJoin("INNER JOIN OrderLog olpay ON olpay.orderId=t0.id");
        $this-&gt;addCond("olpay.action='PA' AND olpay.tm&gt;'$validDate'");
    }
}</code></pre>
<p class="see"><strong>@see <a href="#AccessControl::addRes">AccessControl::addRes</a></strong> </p>
<p class="see"><strong>@see <a href="#AccessControl::addJoin">AccessControl::addJoin</a></strong> </p></div>
<div class="block">
<h2 id="AccessControl::addJoin">@fn AccessControl::addJoin(joinCond)</h2>
<p>添加Join条件.</p>
<p class="see"><strong>@see <a href="#AccessControl::addCond">AccessControl::addCond</a></strong>  其中有示例</p></div>
<div class="block">
<h2 id="AccessControl::addVCol">@fn AccessControl::addVCol($col, $ignoreError=false, $alias=null)</h2>
<p class="param"><strong>@param $col</strong>  必须是一个英文词, 不允许"col as col1"形式; 该列必须在 vcolDefs 中已定义.</p>
<p class="param"><strong>@param $alias</strong>  列的别名。可以中文. 特殊字符"-"表示不加到最终res中(只添加join/cond等定义), 由addVColDef内部调用时使用.</p>
<p class="return"><strong>@return Boolean</strong>  T/F</p>
<p>用于AccessControl子类添加已在vcolDefs中定义的vcol. 一般应先考虑调用addRes(col)函数.</p>
<p class="see"><strong>@see <a href="#AccessControl::addRes">AccessControl::addRes</a></strong> </p></div>
<div style="text-align:center">Generated by jdcloud-gendoc</div>
</body>

</html>

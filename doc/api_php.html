<html>
<head>
<meta charset="utf-8">
<title>API参考 - 筋斗云服务端</title>
<style>
h3,h4,h5,h6 {
	font-size: 1em;
}

pre {
	border-left: 1px solid #ccc;
	margin: 0 1em;
	padding: 0 0.5em;
	tab-size:4;
}

code {
	font-family: "Courier New";
    padding: 0px 3px;
    display: inline-block;
}

.toc {
	margin: 2em;
}

.toc p {
	margin: 0.3em 0;
}

.block {
	border-bottom: 1px solid #ccc;
}

</style>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="doc.css" />
<script src="refdoc.js"></script>
</head>

<body>
<h1>API参考 - 筋斗云服务端</h1>
<div>最后更新：2019-03-15</div>
<div id="menu">
<h2>Modules</h2>
<div class="toc">
<p><a href="#app_fw">app_fw (module)</a></p>
<p><a href="#ext">ext (module)</a></p>
<p><a href="#api_fw">api_fw (module)</a></p>
<p><a href="#AccessControl">AccessControl (module)</a></p>
</div><hr>
<h2>Keywords</h2>
<div class="toc">
<p><a href="#$APP">$APP (var)</a></p>
<p><a href="#$BASE_DIR">$BASE_DIR (var)</a></p>
<p><a href="#$DBH">$DBH (var)</a></p>
<p><a href="#$X_RET_FN">$X_RET_FN (var)</a></p>
<p><a href="#AC0_">AC0_ (key)</a></p>
<p><a href="#AC1_">AC1_ (key)</a></p>
<p><a href="#AC2_">AC2_ (key)</a></p>
<p><a href="#AC_">AC_ (key)</a></p>
<p><a href="#AccessControl">AccessControl (module)</a></p>
<p><a href="#AccessControl::$allowedAc">AccessControl::$allowedAc (var)</a></p>
<p><a href="#AccessControl::$defaultRes">AccessControl::$defaultRes (var)</a></p>
<p><a href="#AccessControl::$defaultSort">AccessControl::$defaultSort (var)</a></p>
<p><a href="#AccessControl::$enumFields">AccessControl::$enumFields (var)</a></p>
<p><a href="#AccessControl::$hiddenFields">AccessControl::$hiddenFields (var)</a></p>
<p><a href="#AccessControl::$id">AccessControl::$id (var)</a></p>
<p><a href="#AccessControl::$maxPageSz">AccessControl::$maxPageSz (var)</a></p>
<p><a href="#AccessControl::$onAfterActions">AccessControl::$onAfterActions (var)</a></p>
<p><a href="#AccessControl::$readonlyFields">AccessControl::$readonlyFields (var)</a></p>
<p><a href="#AccessControl::$readonlyFields2">AccessControl::$readonlyFields2 (var)</a></p>
<p><a href="#AccessControl::$requiredFields">AccessControl::$requiredFields (var)</a></p>
<p><a href="#AccessControl::$requiredFields2">AccessControl::$requiredFields2 (var)</a></p>
<p><a href="#AccessControl::$subobj">AccessControl::$subobj (var)</a></p>
<p><a href="#AccessControl::$vcolDefs">AccessControl::$vcolDefs (var)</a></p>
<p><a href="#AccessControl::addCond">AccessControl::addCond (fn)</a></p>
<p><a href="#AccessControl::addJoin">AccessControl::addJoin (fn)</a></p>
<p><a href="#AccessControl::addRes">AccessControl::addRes (fn)</a></p>
<p><a href="#AccessControl::addVCol">AccessControl::addVCol (fn)</a></p>
<p><a href="#AccessControl::api_batchAdd">AccessControl::api_batchAdd (fn)</a></p>
<p><a href="#AccessControl::api_delIf">AccessControl::api_delIf (fn)</a></p>
<p><a href="#AccessControl::api_setIf">AccessControl::api_setIf (fn)</a></p>
<p><a href="#AccessControl::checkSetFields">AccessControl::checkSetFields (fn)</a></p>
<p><a href="#AccessControl::getMaxPageSz">AccessControl::getMaxPageSz (fn)</a></p>
<p><a href="#AccessControl::isFileExport">AccessControl::isFileExport (fn)</a></p>
<p><a href="#AccessControl::onAfter">AccessControl::onAfter (fn)</a></p>
<p><a href="#AccessControl::onGenId">AccessControl::onGenId (fn)</a></p>
<p><a href="#AccessControl::onHandleRow">AccessControl::onHandleRow (fn)</a></p>
<p><a href="#AccessControl::onQuery">AccessControl::onQuery (fn)</a></p>
<p><a href="#AccessControl::onValidate">AccessControl::onValidate (fn)</a></p>
<p><a href="#AccessControl::onValidateId">AccessControl::onValidateId (fn)</a></p>
<p><a href="#ApiLog::$lastId">ApiLog::$lastId (var)</a></p>
<p><a href="#AppBase">AppBase (class)</a></p>
<p><a href="#BatchAddLogic">BatchAddLogic (class)</a></p>
<p><a href="#BatchInsert">BatchInsert (class)</a></p>
<p><a href="#Conf">Conf (key)</a></p>
<p><a href="#ConfBase">ConfBase (class)</a></p>
<p><a href="#ConfBase::$enableApiLog">ConfBase::$enableApiLog (var)</a></p>
<p><a href="#ConfBase::onApiInit">ConfBase::onApiInit (fn)</a></p>
<p><a href="#ConfBase::onInitClient">ConfBase::onInitClient (fn)</a></p>
<p><a href="#DirectReturn">DirectReturn (class)</a></p>
<p><a href="#ExtFactory::getInstance">ExtFactory::getInstance (fn)</a></p>
<p><a href="#ExtFactory::getObj">ExtFactory::getObj (fn)</a></p>
<p><a href="#JDEvent">JDEvent (class)</a></p>
<p><a href="#JDEvent.on">JDEvent.on (fn)</a></p>
<p><a href="#JDEvent.trigger">JDEvent.trigger (fn)</a></p>
<p><a href="#JDPDO">JDPDO (class)</a></p>
<p><a href="#JDSingleton">JDSingleton (class)</a></p>
<p><a href="#JDSingletonImp">JDSingletonImp (class)</a></p>
<p><a href="#MapCol.$colMap">MapCol.$colMap (var)</a></p>
<p><a href="#MapCol.mapCol">MapCol.mapCol (key)</a></p>
<p><a href="#MapCol.mapSql">MapCol.mapSql (key)</a></p>
<p><a href="#MyException">MyException (class)</a></p>
<p><a href="#PAGE_SZ_LIMIT">PAGE_SZ_LIMIT (var)</a></p>
<p><a href="#P_DB">P_DB (key)</a></p>
<p><a href="#P_DBCRED">P_DBCRED (key)</a></p>
<p><a href="#P_DEBUG">P_DEBUG (key)</a></p>
<p><a href="#P_MOCK_MODE">P_MOCK_MODE (key)</a></p>
<p><a href="#P_SESSION_DIR">P_SESSION_DIR (key)</a></p>
<p><a href="#P_TEST_MODE">P_TEST_MODE (key)</a></p>
<p><a href="#P_URL_PATH">P_URL_PATH (key)</a></p>
<p><a href="#Plugins">Plugins (class)</a></p>
<p><a href="#Plugins::$map">Plugins::$map (var)</a></p>
<p><a href="#Plugins::add">Plugins::add (fn)</a></p>
<p><a href="#Plugins::exists">Plugins::exists (fn)</a></p>
<p><a href="#Q">Q (fn)</a></p>
<p><a href="#addLog">addLog (fn)</a></p>
<p><a href="#addToStr">addToStr (fn)</a></p>
<p><a href="#apiMain">apiMain (key)</a></p>
<p><a href="#api_async">api_async (fn)</a></p>
<p><a href="#api_checkIp">api_checkIp (fn)</a></p>
<p><a href="#api_fw">api_fw (module)</a></p>
<p><a href="#app_fw">app_fw (module)</a></p>
<p><a href="#arrCopy">arrCopy (fn)</a></p>
<p><a href="#arrayCmp">arrayCmp (fn)</a></p>
<p><a href="#callAsync">callAsync (fn)</a></p>
<p><a href="#callSvc">callSvc (fn)</a></p>
<p><a href="#callSvcInt">callSvcInt (fn)</a></p>
<p><a href="#checkAuth">checkAuth (fn)</a></p>
<p><a href="#conf.php">conf.php (key)</a></p>
<p><a href="#dbConfirmFn">dbConfirmFn (key)</a></p>
<p><a href="#dbInsert">dbInsert (fn)</a></p>
<p><a href="#dbUpdate">dbUpdate (fn)</a></p>
<p><a href="#dbconn">dbconn (fn)</a></p>
<p><a href="#enableAsync">enableAsync (key)</a></p>
<p><a href="#errQuit">errQuit (fn)</a></p>
<p><a href="#execOne">execOne (fn)</a></p>
<p><a href="#ext">ext (module)</a></p>
<p><a href="#getAppType">getAppType (fn)</a></p>
<p><a href="#getBaseUrl">getBaseUrl (fn)</a></p>
<p><a href="#getBcParam">getBcParam (fn)</a></p>
<p><a href="#getClientVersion">getClientVersion (fn)</a></p>
<p><a href="#getCred">getCred (fn)</a></p>
<p><a href="#getExt">getExt (fn)</a></p>
<p><a href="#getRsAsTable">getRsAsTable (alias)</a></p>
<p><a href="#handleExportFormat">handleExportFormat (fn)</a></p>
<p><a href="#hasPerm">hasPerm (fn)</a></p>
<p><a href="#hasSignFile">hasSignFile (fn)</a></p>
<p><a href="#httpCall">httpCall (fn)</a></p>
<p><a href="#httpCallAsync">httpCallAsync (fn)</a></p>
<p><a href="#inWhiteIpList">inWhiteIpList (fn)</a></p>
<p><a href="#isCLI">isCLI (fn)</a></p>
<p><a href="#isCLIServer">isCLIServer (fn)</a></p>
<p><a href="#isEqualCollection">isEqualCollection (fn)</a></p>
<p><a href="#isMockMode">isMockMode (fn)</a></p>
<p><a href="#logext">logext (fn)</a></p>
<p><a href="#logit">logit (alias)</a></p>
<p><a href="#logit">logit (fn)</a></p>
<p><a href="#makeUrl">makeUrl (fn)</a></p>
<p><a href="#mparam">mparam (fn)</a></p>
<p><a href="#myEncrypt">myEncrypt (fn)</a></p>
<p><a href="#noExecApi">noExecApi (key)</a></p>
<p><a href="#objarr2table">objarr2table (fn)</a></p>
<p><a href="#onCreateAC">onCreateAC (fn)</a></p>
<p><a href="#onGetPerms">onGetPerms (fn)</a></p>
<p><a href="#param">param (fn)</a></p>
<p><a href="#param_varr">param_varr (fn)</a></p>
<p><a href="#parseKvList">parseKvList (fn)</a></p>
<p><a href="#plugin">plugin (key)</a></p>
<p><a href="#plugin/index.php">plugin/index.php (key)</a></p>
<p><a href="#queryAll">queryAll (fn)</a></p>
<p><a href="#queryAllWithHeader">queryAllWithHeader (fn)</a></p>
<p><a href="#queryOne">queryOne (fn)</a></p>
<p><a href="#setBcParam">setBcParam (fn)</a></p>
<p><a href="#setParam">setParam (fn)</a></p>
<p><a href="#setParam">setParam (fn)</a></p>
<p><a href="#setRet">setRet (fn)</a></p>
<p><a href="#setServerRev">setServerRev (fn)</a></p>
<p><a href="#startsWith">startsWith (fn)</a></p>
<p><a href="#table2objarr">table2objarr (fn)</a></p>
<p><a href="#tableCRUD">tableCRUD (fn)</a></p>
<p><a href="#tmCols">tmCols (fn)</a></p>
<p><a href="#tobool">tobool (fn)</a></p>
<p><a href="#tryParseBool">tryParseBool (fn)</a></p>
<p><a href="#urlEncodeArr">urlEncodeArr (fn)</a></p>
<p><a href="#varr2objarr">varr2objarr (fn)</a></p>
<p><a href="#whiteIpList">whiteIpList (key)</a></p>
</div><hr>
</div>
<div class="block">
<h2 id="tobool">@fn tobool($s)</h2></div>
<div class="block">
<h2 id="tryParseBool">@fn tryParseBool($s, &$val)</h2>
<p>字符串转bool，支持&quot;0/1&quot;, &quot;true/false&quot;, &quot;yes/no&quot;, &quot;on/off&quot;.</p></div>
<div class="block">
<h2 id="startsWith">@fn startsWith($s, $pat)</h2></div>
<div class="block">
<h2 id="isCLI">@fn isCLI() </h2>
<p>command-line interface. e.g. run &quot;php x.php&quot;</p></div>
<div class="block">
<h2 id="isCLIServer">@fn isCLIServer() </h2>
<p>php built-in web server e.g. run &quot;php -S 0.0.0.0:8080&quot;</p></div>
<div class="block">
<h2 id="isEqualCollection">@fn isEqualCollection($col1, $col2)</h2></div>
<div class="block">
<h2 id="urlEncodeArr">@fn urlEncodeArr($params)</h2>
<p>e.g.</p>
<pre><code>urlEncodeArr(["a"=&gt;1, "b"=&gt;"hello"]) -&gt; a=1&amp;b=hello</code></pre></div>
<div class="block">
<h2 id="makeUrl">@fn makeUrl($ac, $params, $hash)</h2>
<p>e.g.</p>
<pre><code>$url = makeUrl("http://oliveche.com/jdcloud/api.php", ["p1"=&gt;"abc", "p2"=&gt;"333"])</code></pre></div>
<div class="block">
<h2 id="httpCall">@fn httpCall($url, $postParams =null, $opt={timeout?=5, @headers, %curlOpt={optName=>val} )</h2>
<p>请求URL，返回内容。<br />
默认使用GET请求，如果给定postParams，则使用POST请求。<br />
postParams可以是一个kv数组或字符串，也可以是一个文件名(以&quot;@&quot;开头，如&quot;@1.jpg&quot;)</p>
<p>如果请求失败，抛出E_SERVER异常。<br />
不检查http返回码。</p>
<p>示例：指定postParams, 默认以application/x-www-form-urlencoded格式提交。</p>
<pre><code>$data = [
    "name" =&gt; "xiaoming",
    "classId" =&gt; 100
];
// 注意headers的格式
$headers = [
    "Authorization: Basic dGVzdDp0ZXN0MTIz",
    "Cookie: extid=" . session_id()
];
$url = makeUrl("$baseUrl/$ac", $param);
$rv = httpCall($url, $data, ["headers" =&gt; $headers]);</code></pre>
<p>上例中在headers中用Authorization指定了登录信息，适合服务器需要登录的场景；<br />
同时主动指定了Cookie（Cookie名称需按服务端要求设置），以便与通过Session保持信息的服务器持续交互。<br />
（有的服务器不使用Cookie，而是在登录后通过返回token来标识，需要额外处理）</p>
<p>示例：调用第三方服务，登录并调用筋斗云后端</p>
<pre><code>function jdcloudCall($ac, $param=null, $postParam=null)
{
    $baseUrl = "http://localhost/jdcloud/api.php";
    $url = makeUrl("$baseUrl/$ac", $param);
    $rv = httpCall($url, $postParam, ["headers" =&gt; [
        // 模拟筋斗云用户端cookie
        "Cookie: userid=" . session_id()
    ]]);
    // 筋斗云协议格式：成功为[0, obj] 或 失败为[errCode, userMessage, internalMessage?]
    $ret = json_decode($rv);
    if ( $ret[0] !== 0 ) {
        throw new MyException(E_PARAM, $ret[2], $ret[1]);
    }
    return $ret[1];
}
// 如果是首次则登录
jdcloudCall("login", ["uname"=&gt;"12345678901", "pwd"=&gt;"1234"]);
// 保持会话，获取订单列表
$orders = jdcloudCall("Ordr.query");</code></pre>
<p>示例：提交application/json格式的内容</p>
<pre><code>// 用json_encode将数组变成字符串。避免被httpCall转成urlencoded格式。
$data = json_encode([
    "name" =&gt; "xiaoming",
    "classId" =&gt; 100
]);
$headers = [
    "Content-type: application/json",
    "Authorization: Basic dGVzdDp0ZXN0MTIz"
];
$GLOBALS["X_RET_STR"] = httpCall($url, $data, ["headers" =&gt; $headers]);
// 筋斗云：设置全局变量X_RET_STR可直接设置返回内容，避免再次被json编码。</code></pre>
<p>函数通过CURL实现，若需扩展功能，可以直接设置curlOpt选项（具体选项可查阅curl_setopt文档），如：</p>
<pre><code>$curlOpt = [
    // 设置代理
    CURLOPT_PROXY =&gt; '8.8.8.8',
    CURLOPT_PROXYPORT =&gt; 8080,

    // 通过UserAgent伪装其它浏览器
    CURLOPT_USERAGENT =&gt; 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36',

    // 返回结果包含HTTP HEADER部分。TODO: 提供简单的解析，如HTTP返回码、Response HTTP Header等。
    CURLOPT_HEADER =&gt; true
];
$rv = httpCall($url, $data, ["curlOpt" =&gt; $curlOpt]);</code></pre>
<p>如果CURL返回错误，可在此查阅错误码：<br />
<a href="http://curl.haxx.se/libcurl/c/libcurl-errors.html">http://curl.haxx.se/libcurl/c/libcurl-errors.html</a></p>
<p>出错及慢调用会记录到日志中，以下环境变量可控制日志记录：</p>
<pre><code># 默认情况下：日志记录到trace.log中，记录超过1s的慢调用
P_SLOW_CALL_LOG=trace
P_SLOW_CALL_VAL=1</code></pre>
<p class="see"><strong>@see <a href="#makeUrl">makeUrl</a></strong> </p></div>
<div class="block">
<h2 id="parseKvList">@fn parseKvList($kvListStr, $sep, $sep2)</h2>
<p>解析key-value列表字符串。如果出错抛出异常。<br />
示例：</p>
<pre><code>$map = parseKvList("CR:新创建;PA:已付款", ";", ":");
// map: {"CR": "新创建", "PA":"已付款"}</code></pre></div>
<div class="block">
<h2 id="arrayCmp">@fn arrayCmp($arr1, $arr2, $fnEq, $callback)</h2>
<p>比较两个数组的差异，常用于数据同步。<br />
两个数组中的数据应一一对应。<br />
比较的结果会回调 <code>$callback($e1, $e2)</code>，如果数据在两边都有，则e1, e2均非空，否则其中一个为空。</p>
<p>下面是一个示例，metaFields是设计字段列表，dbFields是实际数据库中的字段列表，现在要对比差异，</p>
<ul>
<li>如果字段在设计和实际表中都有，不做处理（或更新字段）</li>
<li>如果字段在设计中有，在实际表中没有，则添加字段</li>
<li>如果字段在设计中没有，而在实际表中有，则删除字段</li>
</ul>
<p>数据示例如下：</p>
<pre><code>$metaFields = [
    ["name"=&gt;"id", "type"=&gt;"int"],
    ["name"=&gt;"amount", "type"=&gt;"decimal"],
    ["name"=&gt;"dscr", "type"=&gt;"nvarchar"]
];
$dbFields = [
    ["Field"=&gt;"id", "Type"=&gt;"int(11)"],
    ["Field"=&gt;"total", "Type"=&gt;"decimal(19,2)"],
    ["Field"=&gt;"dscr", "Type"=&gt;"varchar(255)"]
];</code></pre>
<p>两边字段名相同可通过 <code>$meta["name"] === $dbField["Field"];</code>来判断。</p>
<pre><code>arrayCmp($metaFields, $dbFields, function ($meta, $dbField) {
    // 定义两边对应关系
    return $meta["name"] === $dbField["Field"];
}, function ($meta, $dbField) { // meta: {type, len, ...} 参考 FIELD_META_TYPE
    if ($meta === null) { // 在meta中没有，在dbField中有，则删除字段
        echo "DROP " . $dbField["Field"] . "\n";
    }
    else if ($dbField === null) { // 在meta中有，在dbField中没有，则添加字段
        echo "ADD " . $meta["name"] . "\n";
    }
    else {
        // 字段在两边都有
    }
});</code></pre></div>
<div class="block">
<h2 id="addToStr">@fn addToStr(&$str, $str1, $sep=',')</h2>
<p>添加字符串到str. str开始必须为null。</p>
<pre><code>$atts = null;
addToStr($atts, "100");
addToStr($atts, "200");
// $atts = "100,200"</code></pre></div>
<div class="block">
<h2 id="arrCopy">@fn arrCopy(&$dst, $src, $fields)</h2>
<p>将数组$src中指定字段复制到$dst中。<br />
数组$fields指定字段列表。如果字段复制后需要改名，可以以[$dstName, $srcName]这样的数组来表示。</p>
<p>示例：将workItem提取指定字段后插入数据库中：</p>
<pre><code>$workItem = ["repairWiId"=&gt;$id, "wiName"=&gt;$name, ...];
$wiData = ["orderId" =&gt; $orderId];
arrCopy($wiData, $workItem, [
    ["code", "repairWiId"], // 复制后改名，即 $wiData["code"] = $workItem["repairWiId"]
    "name",
    "saleWorkQty",
    ["addFlag", "isAdd"]
]);
dbInsert("WorkItem", $wiData);</code></pre></div>
<div class="block">
<h2 id="app_fw">@module app_fw</h2><div class="toc"><p style="margin-left:0em"><a href="#app_fw-1 通用函数">1 通用函数</a></p>
<p style="margin-left:0em"><a href="#app_fw-2 初始化配置">2 初始化配置</a></p>
<p style="margin-left:2em"><a href="#app_fw-2.1 数据库配置">2.1 数据库配置</a></p>
<p style="margin-left:0em"><a href="#app_fw-3 测试模式与调试等级">3 测试模式与调试等级</a></p>
<p style="margin-left:0em"><a href="#app_fw-4 模拟模式">4 模拟模式</a></p>
<p style="margin-left:0em"><a href="#app_fw-5 session管理">5 session管理</a></p>
<p style="margin-left:0em"><a href="#app_fw-6 应用框架">6 应用框架</a></p>
</div>
<p>筋斗云服务端通用应用框架。</p>
<h4 id="app_fw-1 通用函数">1 通用函数</h4>
<ul>
<li>
<p>获得指定类型参数</p>
<p class="see"><strong>@see <a href="#param">param</a> <a href="#mparam">mparam</a></strong> </p>
</li>
<li>
<p>数据库连接及操作</p>
<p class="see"><strong>@see <a href="#dbconn">dbconn</a> <a href="#execOne">execOne</a> <a href="#queryOne">queryOne</a> <a href="#queryAll">queryAll</a> <a href="#dbInsert">dbInsert</a> <a href="#dbUpdate">dbUpdate</a></strong> </p>
</li>
<li>错误处理设施
<p class="see"><strong>@see <a href="#MyException">MyException</a> <a href="#errQuit">errQuit</a></strong> </p></li>
</ul>
<h4 id="app_fw-2 初始化配置">2 初始化配置</h4>
<p>app_fw框架自动包含 $BASE_DIR/php/conf.user.php。</p>
<p>项目部署时的配置，一般用于定义环境变量、全局变量等，通常不添加入版本库，在项目实施时手工配置。</p>
<p>对于不变的全局配置，应在app.php中定义。</p>
<h5 id="app_fw-2.1 数据库配置">2.1 数据库配置</h5>
<p class="key"><strong>@key <a id="P_DB">P_DB</a></strong>  环境变量，指定DB类型与地址。</p>
<p class="key"><strong>@key <a id="P_DBCRED">P_DBCRED</a></strong>  环境变量，指定DB登录帐号</p>
<p>P_DB格式为：</p>
<pre><code>P_DB={主机名}/{数据库名}
或
P_DB={主机名}:{端口号}/{数据库名}</code></pre>
<p>例如：</p>
<pre><code>P_DB=localhost/myorder
P_DB=www.myserver.com:3306/myorder</code></pre>
<p>P_DBCRED格式为<code>{用户名}:{密码}</code>，或其base64编码后的值，如</p>
<pre><code>P_DBCRED=ganlan:1234
或
P_DBCRED=Z2FubGFuOjEyMzQ=</code></pre>
<p>此外，P_DB还试验性地支持SQLite数据库，直接指定以&quot;.db&quot;为扩展名的文件，以及P_DBTYPE即可，不需要P_DBCRED。例如：</p>
<pre><code>P_DBTYPE=sqlite
P_DB=../myorder.db</code></pre>
<p>连接SQLite数据库未做严格测试，不建议使用。</p>
<h4 id="app_fw-3 测试模式与调试等级">3 测试模式与调试等级</h4>
<p class="key"><strong>@key <a id="P_TEST_MODE">P_TEST_MODE</a></strong>  Integer。环境变量，允许测试模式。0-生产模式；1-测试模式；2-自动化回归测试模式(RTEST_MODE)</p>
<p class="key"><strong>@key <a id="P_DEBUG">P_DEBUG</a></strong>  Integer。环境变量，设置调试等级，值范围0-9。仅在测试模式下有效。</p>
<p>测试模式特点：</p>
<ul>
<li>输出的HTTP头中包含：<code>X-Daca-Test-Mode: 1</code></li>
<li>输出的JSON格式经过美化更易读，且可以显示更多调试信息。前端可通过在接口中添加<code>_debug</code>参数设置调试等级。<br />
如果想要查看本次调用涉及的SQL语句，可以用<code>_debug=9</code>。</li>
<li>某些用于测试的接口可以调用，例如execSql。因而十分危险，生产模式下一定不可误设置为测试模式。</li>
<li>可以使用模拟模式</li>
</ul>
<p>注意：v3.4版本起不允许客户端设置_test参数，且用环境变量P_TEST_MODE替代符号文件CFG_TEST_MODE和设置全局变量TEST_MODE.</p>
<p>在过去测试模式用于：可直接对生产环境进行测试且不影响生产环境，即部署后，在前端指定以测试模式连接，在后端为测试模式连接专用的测试数据库，且使用专用的cookie，实现与生产模式共用代码但互不影响。<br />
现已废弃这种用法，应搭建专用的测试环境用于测试开发。</p>
<p class="see"><strong>@see <a href="#addLog">addLog</a></strong> </p>
<h4 id="app_fw-4 模拟模式">4 模拟模式</h4>
<p class="key"><strong>@key <a id="P_MOCK_MODE">P_MOCK_MODE</a></strong>  Integer. 模拟模式. 值：0/1，或部分模拟，值为模块列表，如"wx,sms"，外部模块名称定义见ext.php.</p>
<p>对第三方系统依赖（如微信认证、支付宝支付、发送短信等），可通过设计Mock接口来模拟。</p>
<p>注意：v3.4版本起用环境变量P_MOCK_MODE替代符号文件CFG_MOCK_MODE/CFG_MOCK_T_MODE和设置全局变量MOCK_MODE，且模拟模式只允许在测试模式激活时才能使用。</p>
<p class="see"><strong>@see <a href="#ExtMock">ExtMock</a></strong> </p>
<h4 id="app_fw-5 session管理">5 session管理</h4>
<ul>
<li>应用的session名称为 &quot;{app}id&quot;, 如应用名为 &quot;user&quot;, 则session名为&quot;userid&quot;. 因而不同的应用同时调用服务端也不会冲突。</li>
<li>保存session文件的目录为 $BASE_DIR/session, 可使用环境变量P_SESSION_DIR重定义。</li>
<li>同一主机，不同URL下的session即使APP名相同，也不会相互冲突，因为框架会根据当前URL，设置cookie的有效路径。</li>
</ul>
<p class="key"><strong>@key <a id="P_SESSION_DIR">P_SESSION_DIR</a></strong>  ?= $BASE_DIR/session 环境变量，定义session文件存放路径。</p>
<p class="key"><strong>@key <a id="P_URL_PATH">P_URL_PATH</a></strong>  环境变量。项目的URL路径，如"/jdcloud", 用于定义cookie生效的作用域，也用于拼接相对URL路径。</p>
<p class="see"><strong>@see <a href="#getBaseUrl">getBaseUrl</a></strong> </p>
<p>PHP默认的session过期时间为1440s(24分钟)，每次在使用session时，以1/1000的概率检查过期。<br />
要配置它，可以应用程序的conf.user.php中设置，如：</p>
<pre><code>ini_set("session.gc_maxlifetime", "2592000"); // 30天过期</code></pre>
<p>测试时，想要到时间立即清除session，可以设置：</p>
<pre><code>ini_set("session.gc_probability", "1000"); // 1000/1000概率做回收。每次访问都回收，性能差，仅用于测试。</code></pre>
<h4 id="app_fw-6 应用框架">6 应用框架</h4>
<p>继承AppBase类，可实现提供符合BQP协议接口的模块。<a href="#api_fw">api_fw</a>框架就是使用它的一个典型例子。</p>
<p class="see"><strong>@see <a href="#AppBase">AppBase</a></strong> </p></div>
<div class="block">
<h2 id="$BASE_DIR">@var $BASE_DIR</h2>
<p>包含app_fw.php的主文件（如api.php）所在目录。常用于拼接子目录名。<br />
最后不带&quot;/&quot;.</p></div>
<div class="block">
<h2 id="$APP">@var $APP?=user</h2>
<p>客户端应用标识，默认为&quot;user&quot;.<br />
根据URL参数&quot;_app&quot;确定值。</p></div>
<div class="block">
<h2 id="param_varr">@fn param_varr($str, $type, $name)</h2>
<p>type的格式如&quot;i:n:b?:dt:tm?&quot;.</p>
<ul>
<li>每个词表示一个字段类型<br />
类型标识：i-Integer; n-Number/Double; b-Boolean(0/1); dt/tm-DateTime</li>
<li>后置&quot;?&quot;表示该参数可缺省。</li>
</ul></div>
<div class="block">
<h2 id="param">@fn param($name, $defVal?, $col?, $doHtmlEscape=true)</h2>
<p class="param"><strong>@param $col:</strong>  默认先取$_GET再取$_POST，"G" - 从$_GET中取; "P" - 从$_POST中取</p>
<p>$col也可以直接指定一个集合，如</p>
<pre><code>param($name, $defVal, $_REQUEST)</code></pre>
<p>获取名为$name的参数。<br />
$name中可以指定类型，返回值根据类型确定。如果该参数未定义或是空串，直接返回缺省值$defVal。</p>
<p>$name中指定类型的方式如下：</p>
<ul>
<li>名为&quot;id&quot;, 或以&quot;Id&quot;或&quot;/i&quot;结尾: int</li>
<li>以&quot;/b&quot;结尾: bool. 可接受的字符串值为: &quot;1&quot;/&quot;true&quot;/&quot;on&quot;/&quot;yes&quot;=&gt;true, &quot;0&quot;/&quot;false&quot;/&quot;off&quot;/&quot;no&quot; =&gt; false</li>
<li>以&quot;/dt&quot;: datetime, 仅有日期部分</li>
<li>以&quot;/tm&quot;结尾: datetime</li>
<li>以&quot;/n&quot;结尾: numeric/double</li>
<li>以&quot;/s&quot;结尾（缺省）: string. 缺省为防止XSS攻击会做html编码，如&quot;a&amp;b&quot;处理成&quot;a&amp;b&quot;，设置参数doHtmlEscape可禁用这个功能。</li>
<li>复杂类型：以&quot;/i+&quot;结尾: int array</li>
<li>复杂类型：以&quot;/js&quot;结尾: json object</li>
<li>复杂类型：List类型（以&quot;,&quot;分隔行，以&quot;:&quot;分隔列），类型定义如&quot;/i:n:b:dt:tm&quot; （列只支持简单类型，不可为复杂类型）</li>
</ul>
<p>示例：</p>
<pre><code>$id = param("id");
$svcId = param("svcId/i", 99);
$wantArray = param("wantArray/b", false);
$startTm = param("startTm/dt", time());</code></pre>
<p>List类型示例。参数&quot;items&quot;类型在文档中定义为list(id/Integer, qty/Double, dscr/String)，可用param(&quot;items/i:n:s&quot;)获取, 值如</p>
<pre><code>items=100:1:洗车,101:1:打蜡</code></pre>
<p>返回</p>
<pre><code>[ [ 100, 1.0, "洗车"], [101, 1.0, "打蜡"] ]</code></pre>
<p>如果某列可缺省，用&quot;?&quot;表示，如param(&quot;items/i:n?:s?&quot;)可获取值：</p>
<pre><code>items=100:1,101::打蜡</code></pre>
<p>返回</p>
<pre><code>[ [ 100, 1.0, null], [101, null, "打蜡"] ]</code></pre>
<p>TODO: 直接支持 param(&quot;items/(id,qty?/n,dscr?)&quot;), 添加param_objarr函数，去掉parseList函数。上例将返回</p>
<pre><code>[
    [ "id"=&gt;100, "qty"=&gt;1.0, dscr=&gt;null],
    [ "id"=&gt;101, "qty"=&gt;null, dscr=&gt;"打蜡"]
]</code></pre></div>
<div class="block">
<h2 id="mparam">@fn mparam($name, $col = null)</h2>
<p class="brief"><strong>@brief mandatory</strong>  param</p>
<p class="param"><strong>@param col</strong>  'G'-从URL参数即$_GET获取，'P'-从POST参数即$_POST获取。参见param函数同名参数。</p>
<p>$name可以是一个数组，表示至少有一个参数有值，这时返回每个参数的值。<br />
参考param函数，查看$name如何支持各种类型。</p>
<p>示例：</p>
<pre><code>$svcId = mparam("svcId");
$svcId = mparam("svcId/i");
$itts = mparam("itts/i+")
list($svcId, $itts) = mparam(["svcId", "itts/i+"]); # require one of the 2 params</code></pre></div>
<div class="block">
<h2 id="setParam">@fn setParam($k, $v)</h2>
<p class="fn"><strong>@fn <a id="setParam">setParam</a></strong> (@kv)</p>
<p>设置参数，其实是模拟客户端传入的参数。以便供tableCRUD等函数使用。</p>
<p>(v5.1)不建议使用，param函数已更新，现在直接设置$_GET,$_POST即可。</p>
<p>示例：</p>
<pre><code>setParam("cond", "name LIKE " . Q("%$name%"));
setParam([
    "fmt" =&gt; "list",
    "orderby" =&gt; "id DESC"
]);</code></pre>
<p class="see"><strong>@see <a href="#tableCRUD">tableCRUD</a></strong> </p></div>
<div class="block">
<h2 id="getBcParam">@fn getBcParam($name, $defVal=null)</h2>
<p class="fn"><strong>@fn <a id="setBcParam">setBcParam</a></strong> ($name, $value)</p>
<p>TODO: BC是什么？改名？</p>
<p>获取或设置特别的HTTP头部参数。</p></div>
<div class="block">
<h2 id="queryAllWithHeader">@fn queryAllWithHeader($sql, $wantArray=false)</h2>
<p class="alias"><strong>@alias <a id="getRsAsTable">getRsAsTable</a></strong> ($sql)</p>
<p>查询SQL，返回筋斗云table格式：{@h, @d}<br />
h是标题字段数组，d是数据行。<br />
即queryAll函数的带表格标题版本。</p>
<pre><code>$tbl = queryAllWithHeader("SELECT id, name FROM User");</code></pre>
<p>返回示例：</p>
<pre><code>[
    "h"=&gt;["id","name"],
    "d"=&gt;[ [1,"name1"], [2, "name2"]]
]</code></pre>
<p>如果查询结果为空，则返回：</p>
<pre><code>[ "h" =&gt; [], "d" =&gt; [] ];</code></pre>
<p>如果指定了参数$wantArray=true, 则返回二维数组，其中首行为标题行：</p>
<pre><code>$tbl = queryAllWithHeader("SELECT id, name FROM User", true);</code></pre>
<p>返回：</p>
<pre><code>[ ["id", "name"], [1, "name1"], [2, "name2"] ]</code></pre>
<p>如果查询结果为空，则返回:</p>
<pre><code>[ [], [] ]</code></pre>
<p class="see"><strong>@see <a href="#queryAll">queryAll</a></strong> </p></div>
<div class="block">
<h2 id="objarr2table">@fn objarr2table ($objarr, $fixedColCnt=null)</h2>
<p>将objarr格式转为table格式, 如：</p>
<pre><code>objarr2table(
    [
        ["id"=&gt;100, "name"=&gt;"A"],
        ["id"=&gt;101, "name"=&gt;"B"]
    ]
) -&gt; 
    [
        "h"=&gt;["id", "name"],
        "d"=&gt;[ 
            [100,"A"], 
            [101,"B"]
        ] 
    ]</code></pre>
<p>注意：</p>
<ul>
<li>objarr每行中列的顺序可以不一样，table列按首行顺序输出。</li>
<li>
<p>每行中列数可以不一样，这时可指定最少固定列数 $fixedColCnt, 而该列以后，将自动检查所有行决定是否加到header中。例：</p>
<p>objarr2table(<br />
[<br />
[&quot;id&quot;=&gt;100, &quot;name&quot;=&gt;&quot;A&quot;],<br />
[&quot;name&quot;=&gt;&quot;B&quot;, &quot;id&quot;=&gt;101, &quot;flag_v&quot;=&gt;1],<br />
[&quot;id&quot;=&gt;102, &quot;name&quot;=&gt;&quot;C&quot;, &quot;flag_r&quot;=&gt;1]<br />
], 2  // 2列固定<br />
) -&gt;<br />
[<br />
&quot;h&quot;=&gt;[&quot;id&quot;, &quot;name&quot;, &quot;flag_v&quot;, &quot;flag_r&quot;],<br />
&quot;d&quot;=&gt;[<br />
[100,&quot;A&quot;, null,null],<br />
[101,&quot;B&quot;, 1, null],<br />
[102,&quot;C&quot;, null, 1]<br />
]<br />
]</p>
</li>
</ul>
<p class="see"><strong>@see <a href="#table2objarr">table2objarr</a></strong> </p>
<p class="see"><strong>@see <a href="#varr2objarr">varr2objarr</a></strong> </p></div>
<div class="block">
<h2 id="table2objarr">@fn table2objarr</h2>
<p>将table格式转为 objarr, 如：</p>
<pre><code>table2objarr(
    [
        "h"=&gt;["id", "name"],
        "d"=&gt;[ 
            [100,"A"], 
            [101,"B"]
        ] 
    ]
) -&gt; [ ["id"=&gt;100, "name"=&gt;"A"], ["id"=&gt;101, "name"=&gt;"B"] ]</code></pre></div>
<div class="block">
<h2 id="varr2objarr">@fn varr2objarr</h2>
<p>将类型 varr (仅有值的二维数组, elem=[$col1, $col2] ) 转为 objarr (对象数组, elem={col1=&gt;cell1, col2=&gt;cell2})</p>
<p>例：</p>
<pre><code>varr2objarr(
    [ [100, "A"], [101, "B"] ], 
    ["id", "name"] )
-&gt; [ ["id"=&gt;100, "name"=&gt;"A"], ["id"=&gt;101, "name"=&gt;"B"] ]</code></pre></div>
<div class="block">
<h2 id="getCred">@fn getCred($cred) -> [user, pwd]</h2>
<p>$cred为&quot;{user}:{pwd}&quot;格式，支持使用base64编码。<br />
示例：</p>
<pre><code>list($user, $pwd) = getCred(getenv("P_ADMIN_CRED"));
if (! isset($user)) {
    // 未设置用户名密码
}</code></pre></div>
<div class="block">
<h2 id="dbconn">@fn dbconn($fnConfirm=$GLOBALS["dbConfirmFn"])</h2>
<p class="param"><strong>@param fnConfirm</strong>  fn(dbConnectionString), 如果返回false, 则程序中止退出。</p>
<p class="key"><strong>@key <a id="dbConfirmFn">dbConfirmFn</a></strong>  连接数据库前回调。</p>
<p>连接数据库</p>
<p>数据库由全局变量$DB(或环境变量P_DB）指定，格式可以为：</p>
<pre><code>host1/carsvc (无扩展名，表示某主机host1下的mysql数据库名；这时由 全局变量$DBCRED 或环境变量 P_DBCRED 指定用户名密码。

dir1/dir2/carsvc.db (以.db文件扩展名标识的文件路径，表示SQLITE数据库）</code></pre>
<p>环境变量 P_DBCRED 指定用户名密码，格式为 base64(dbuser:dbpwd).</p></div>
<div class="block">
<h2 id="Q">@fn Q($str, $dbh=$DBH)</h2>
<p>quote string</p>
<p>一般是把字符串如&quot;abc&quot;转成加单引号的形式&quot;'abc'&quot;. 适用于根据用户输入串拼接成SQL语句时，对输入串处理，避免SQL注入。</p>
<p>示例：</p>
<pre><code>$sql = sprintf("SELECT id FROM User WHERE uname=%s AND pwd=%s", Q(param("uname")), Q(param("pwd")));</code></pre></div>
<div class="block">
<h2 id="execOne">@fn execOne($sql, $getInsertId?=false)</h2>
<p class="param"><strong>@param $getInsertId</strong> ?=false 取INSERT语句执行后得到的id. 仅用于INSERT语句。</p>
<p>执行SQL语句，如INSERT, UPDATE等。执行SELECT语句请使用queryOne/queryAll.</p>
<pre><code>$token = mparam("token");
execOne("UPDATE Cinf SET appleDeviceToken=" . Q($token));</code></pre>
<p>注意：在拼接SQL语句时，对于传入的string类型参数，应使用Q函数进行转义，避免SQL注入攻击。</p>
<p>对于INSERT语句，设置参数$getInsertId=true, 可取新加入数据行的id. 例：</p>
<pre><code>$sql = sprintf("INSERT INTO Hongbao (userId, createTm, src, expireTm, vdays) VALUES ({$uid}, '%s', '{$src}', '%s', {$vdays})", date('c', $createTm), date('c', $expireTm));
$hongbaoId = execOne($sql, true);</code></pre>
<p>(v5.1) 简单的单表添加和更新记录建议优先使用dbInsert和dbUpdate函数，更易使用。<br />
上面两个例子，用dbInsert/dbUpdate函数，无须使用Q函数防注入，也无须考虑字段值是否要加引号：</p>
<pre><code>// 更新操作示例
$cnt = dbUpdate("Cinf", ["appleDeviceToken" =&gt; $token], "ALL");

// 插入操作示例
$hongbaoId = dbInsert("Hongbao", [
    "userId"=&gt;$uid,
    "createTm"=&gt;date(FMT_DT, $createTm),
    "src" =&gt; $src, ...
]);</code></pre>
<p class="see"><strong>@see <a href="#dbInsert">dbInsert</a> <a href="#dbUpdate">dbUpdate</a> <a href="#queryOne">queryOne</a></strong> </p></div>
<div class="block">
<h2 id="queryOne">@fn queryOne($sql, $assoc = false)</h2>
<p>执行查询语句，只返回一行数据，如果行中只有一列，则直接返回该列数值。<br />
如果查询不到，返回false.</p>
<p>示例：查询用户姓名与电话，默认返回值数组：</p>
<pre><code>$row = queryOne("SELECT name,phone FROM User WHERE id={$id}");
if ($row === false)
    throw new MyException(E_PARAM, "bad user id");
// $row = ["John", "13712345678"]</code></pre>
<p>也可返回关联数组:</p>
<pre><code>$row = queryOne("SELECT name,phone FROM User WHERE id={$id}", true);
if ($row === false)
    throw new MyException(E_PARAM, "bad user id");
// $row = ["name"=&gt;"John", "phone"=&gt;"13712345678"]</code></pre>
<p>当查询结果只有一列且assoc=false时，直接返回该数值。</p>
<pre><code>$phone = queryOne("SELECT phone FROM User WHERE id={$id}");
if ($phone === false)
    throw new MyException(E_PARAM, "bad user id");
// $phone = "13712345678"</code></pre>
<p class="see"><strong>@see <a href="#queryAll">queryAll</a></strong> </p></div>
<div class="block">
<h2 id="queryAll">@fn queryAll($sql, $assoc = false)</h2>
<p>执行查询语句，返回数组。<br />
如果查询失败，返回空数组。</p>
<p>默认返回值数组(varr):</p>
<pre><code>$rows = queryAll("SELECT name, phone FROM User");
if (count($rows) &gt; 0) {
    ...
}
// 值为：
$rows = [
    ["John", "13712345678"],
    ["Lucy", "13712345679"]
    ...
]
// 可转成table格式返回
return ["h"=&gt;["name", "phone"], "d"=&gt;$rows];</code></pre>
<p>也可以返回关联数组(objarr)，如：</p>
<pre><code>$rows = queryAll("SELECT name, phone FROM User", true);
if (count($rows) &gt; 0) {
    ...
}
// 值为：
$rows = [
    ["name"=&gt;"John", "phone"=&gt;"13712345678"],
    ["name"=&gt;"Lucy", "phone"=&gt;"13712345679"]
    ...
]
// 可转成table格式返回
return objarr2table($rows);</code></pre>
<p>queryAll支持执行返回多结果集的存储过程，这时返回的不是单一结果集，而是结果集的数组：</p>
<pre><code>$allRows = queryAll("call syncAll()");</code></pre>
<p class="see"><strong>@see <a href="#objarr2table">objarr2table</a></strong> </p></div>
<div class="block">
<h2 id="dbInsert">@fn dbInsert(table, kv) -> newId</h2>
<p>e.g. </p>
<pre><code>$orderId = dbInsert("Ordr", [
    "tm" =&gt; date(FMT_DT),
    "tm1" =&gt; dbExpr("now()"), // 使用dbExpr直接提供SQL表达式
    "amount" =&gt; 100,
    "dscr" =&gt; null // null字段会被忽略
]);</code></pre>
<p>如需高性能大批量插入数据，可以用BatchInsert</p>
<p class="see"><strong>@see <a href="#BatchInsert">BatchInsert</a></strong> </p></div>
<div class="block">
<h2 id="BatchInsert">@class BatchInsert</h2>
<p>大批量为某表添加记录，一次性提交。</p>
<pre><code>$bi = new BatchInsert($table, $headers, $opt=null);</code></pre>
<ul>
<li>headers: 列名数组(如[&quot;name&quot;,&quot;dscr&quot;])，或逗号分隔的字符串(如&quot;name,dscr&quot;)</li>
<li>opt.batchSize/i?=0: 指定批大小。0表示不限大小。</li>
<li>opt.useReplace/b?=false: 默认用&quot;INSERT INTO&quot;语句，设置为true则用&quot;REPLACE INFO&quot;语句。一般用于根据某unique index列添加或更新行。</li>
<li>
<p>opt.debug/b?=false: 如果设置为true, 只输出SQL语句，不插入数据库。</p>
<p>$bi-&gt;add($row);</p>
</li>
<li>row: 可以是值数组或关联数组。如果是值数组，必须与headers一一对应，比如[&quot;name1&quot;, &quot;dscr1&quot;]；<br />
如果是关联数组，按headers中字段自动取出值数组，这样关联数组中即使多一些字段也无影响，比如[&quot;name&quot;=&gt;&quot;name1&quot;, &quot;dscr&quot;=&gt;&quot;dscr1&quot;, &quot;notUsedCol&quot;=100]。</li>
</ul>
<p>示例：</p>
<pre><code>$bi = new BatchInsert("Syslog", "module,tm,content");
for ($i=0; $i&lt;10000; ++$i)
    $bi-&gt;add([$m, $tm, $content]);
$n = $bi-&gt;exec();</code></pre>
<p>如果担心一次请求数量过多，也可以指定批大小，如1000行提交一次：</p>
<pre><code>$opt = [
    "batchSize" =&gt;1000
]
$bi = new BatchInsert("Syslog", "module,tm,content", $opt);</code></pre>
<ul>
<li>opt: {batchSize/i, useReplace/b}</li>
</ul></div>
<div class="block">
<h2 id="dbUpdate">@fn dbUpdate(table, kv, id_or_cond?) -> cnt</h2>
<p class="param"><strong>@param id_or_cond</strong>  查询条件，如果是数值比如100或"100"，则当作条件"id=100"处理；否则直接作为查询表达式，比如"qty<0"；</p>
<p>为了安全，cond必须指定值，不可为空（避免因第三参数为空导致误更新全表!）。如果要对全表更新，可传递特殊值&quot;ALL&quot;，或用&quot;1=1&quot;之类条件。</p>
<p>e.g.</p>
<pre><code>// UPDATE Ordr SET ... WHERE id=100
$cnt = dbUpdate("Ordr", [
    "amount" =&gt; 30,
    "dscr" =&gt; "test dscr",
    "tm" =&gt; "null", // 用""或"null"对字段置空；用"empty"对字段置空串。
    "tm1" =&gt; null // null会被忽略
], 100);

// UPDATE Ordr SET tm=now() WHERE tm IS NULL
$cnt = dbUpdate("Ordr", [
    "tm" =&gt; dbExpr("now()")  // 使用dbExpr，表示是SQL表达式
], "tm IS NULL);

// 全表更新，没有条件。UPDATE Cinf SET appleDeviceToken={token}
$cnt = dbUpdate("Cinf", ["appleDeviceToken" =&gt; $token], "ALL");</code></pre></div>
<div class="block">
<h2 id="getBaseUrl">@fn getBaseUrl($wantHost = true)</h2>
<p>返回 $BASE_DIR 对应的网络路径（最后以&quot;/&quot;结尾），一般指api.php所在路径。<br />
如果指定了环境变量 P_BASE_URL(可在conf.user.php中设置), 则使用该变量。<br />
否则自动判断（如果有代理转发则可能不准）</p>
<p>例：</p>
<pre><code>getBaseUrl() -&gt; "http://myserver.com/myapp/"
getBaseUrl(false) -&gt; "/myapp/"</code></pre>
<p>注意：如果使用了反向代理等机制，该函数往往无法返回正确的值，<br />
例如 <a href="http://myserver.com/8081/myapp/api.php">http://myserver.com/8081/myapp/api.php</a> 被代理到 <a href="http://localhost:8081/myapp/api.php">http://localhost:8081/myapp/api.php</a><br />
getBaseUrl()默认返回 &quot;<a href="http://localhost:8081/myapp/">http://localhost:8081/myapp/</a>&quot; 是错误的，可以设置P_BASE_URL解决：</p>
<pre><code>putenv("P_BASE_URL=http://myserver.com/8081/myapp/");</code></pre>
<p class="see"><strong>@see <a href="#$BASE_DIR">$BASE_DIR</a></strong> </p></div>
<div class="block">
<h2 id="logit">@fn logit($s, $addHeader=true, $type="trace")</h2>
<p class="alias"><strong>@alias <a id="logit">logit</a></strong> ($s, $type)</p>
<p>记录日志。</p>
<p>默认到日志文件 $BASE_DIR/trace.log. 如果指定type=secure, 则写到 $BASE_DIR/secure.log.</p>
<p>可通过在线日志工具 tool/log.php 来查看日志。也可直接打开日志文件查看。</p></div>
<div class="block">
<h2 id="myEncrypt">@fn myEncrypt($string,$operation='E',$key='carsvc')</h2>
<p class="param"><strong>@param operation</strong>  'E': encrypt; 'D': decrypt</p>
<p>加密解密字符串</p>
<p>加密:</p>
<pre><code>$cipher = myEncrypt('hello, world!');
or
$cipher = myEncrypt('hello, world!','E','nowamagic');</code></pre>
<p>解密：</p>
<pre><code>$text = myEncrypt($cipher,'D','nowamagic');</code></pre>
<p>参数说明:<br />
$string   :需要加密解密的字符串<br />
$operation:判断是加密还是解密:E:加密   D:解密<br />
$key      :加密的钥匙(密匙);</p>
<p><a href="http://www.open-open.com/lib/view/open1388916054765.html">http://www.open-open.com/lib/view/open1388916054765.html</a></p></div>
<div class="block">
<h2 id="errQuit">@fn errQuit($code, $msg, $msg2 =null)</h2>
<p>生成html格式的错误信息并中止执行。<br />
默认地，只显示中文错误，双击可显示详细信息。<br />
例：</p>
<pre><code>errQuit(E_PARAM, "接口错误", "Unknown ac=`$ac`");</code></pre></div>
<div class="block">
<h2 id="addLog">@fn addLog($str, $logLevel=0)</h2>
<p>输出调试信息到前端。调试信息将出现在最终的JSON返回串中。<br />
如果只想输出调试信息到文件，不想让前端看到，应使用logit.</p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p></div>
<div class="block">
<h2 id="getAppType">@fn getAppType()</h2>
<p>根据应用标识($APP)获取应用类型(AppType)。注意：应用标识一般由前端应用通过URL参数&quot;_app&quot;传递给后端。<br />
不同的应用标识可以对应相同的应用类型，如应用标识&quot;emp&quot;, &quot;emp2&quot;, &quot;emp-adm&quot; 都表示应用类型&quot;emp&quot;，即 应用类型=应用标识自动去除尾部的数字或&quot;-xx&quot;部分。</p>
<p>不同的应用标识会使用不同的cookie名，因而即使用户同时操作多个应用，其session不会相互干扰。<br />
同样的应用类型将以相同的方式登录系统。</p>
<p class="see"><strong>@see <a href="#$APP">$APP</a></strong> </p></div>
<div class="block">
<h2 id="hasSignFile">@fn hasSignFile($f)</h2>
<p>检查应用根目录下($BASE_DIR)下是否存在标志文件。标志文件一般命名为&quot;CFG_XXX&quot;, 如&quot;CFG_MOCK_MODE&quot;等。</p></div>
<div class="block">
<h2 id="MyException">@class MyException($code, $internalMsg?, $outMsg?)</h2>
<p class="param"><strong>@param $internalMsg</strong>  String. 内部错误信息，前端不应处理。</p>
<p class="param"><strong>@param $outMsg</strong>  String. 错误信息。如果为空，则会自动根据$code填上相应的错误信息。</p>
<p>抛出错误，中断执行:</p>
<pre><code>throw new MyException(E_PARAM, "Bad Request - numeric param `$name`=`$ret`.", "需要数值型参数");</code></pre></div>
<div class="block">
<h2 id="DirectReturn">@class DirectReturn</h2>
<p>抛出该异常，可以中断执行直接返回，不显示任何错误。</p>
<p>例：API返回非BPQ协议标准数据，可以跳出setRet而直接返回：</p>
<pre><code>echo "return data";
throw new DirectReturn();</code></pre>
<p>例：返回指定数据后立即中断处理：</p>
<pre><code>setRet(0, ["id"=&gt;1]);
throw new DirectReturn();</code></pre></div>
<div class="block">
<h2 id="JDPDO">@class JDPDO</h2>
<p class="var"><strong>@var <a id="$DBH">$DBH</a></strong> </p>
<p>数据库类PDO增强。全局变量$DBH为默认数据库连接，dbconn,queryAll,execOne等数据库函数都使用它。</p>
<ul>
<li>在调试等级P_DEBUG=9时，将SQL日志输出到前端，即<code>addLog(sqlStr, DEBUG=9)</code>。</li>
<li>如果有符号文件CFG_CONN_POOL，则使用连接池（缺省不用）</li>
</ul>
<p>如果想忽略输出一条SQL日志，可以在调用SQL查询前设置skipLogCnt，如：</p>
<pre><code>global $DBH;
++ $DBH-&gt;skipLogCnt;  // 若要忽略两条就用 $DBH-&gt;skipLogCnt+=2
$DBH-&gt;exec('set names utf8'); // 也可以是queryOne/execOne等函数。</code></pre>
<p class="see"><strong>@see <a href="#queryAll">queryAll</a> <a href="#execOne">execOne</a> <a href="#dbconn">dbconn</a></strong> </p></div>
<div class="block">
<h2 id="AppBase">@class AppBase</h2>
<p>应用框架，用于提供符合BQP协议的接口。<br />
在onExec中返回协议数据；在onAfter中建议及时关闭DB.</p></div>
<div class="block">
<h2 id="JDSingleton">@class JDSingleton (trait)</h2>
<p>用于单件类，提供getInstance方法，例：</p>
<pre><code>class PluginCore
{
    use JDSingleton;
}</code></pre>
<p>则可以调用</p>
<pre><code>$pluginCore = PluginCore::getInstance();</code></pre></div>
<div class="block">
<h2 id="JDSingletonImp">@class JDSingletonImp (trait)</h2>
<p>用于单件基类，提供getInstance方法。<br />
使用时类名应以Base结尾，使用者可以重写该类，一般用于接口实现。例：</p>
<pre><code>class PayImpBase
{
    use JDSingletonImp;
}

// 使用者重写Base类的某些方法
class PayImp extends PayImpBase
{
}</code></pre>
<p>则可以调用</p>
<pre><code>$pay = PayImpBase::getInstance();
// 创建的是PayImp类。如果未定义PayImp类，则创建PayImpBase类，或是当Base类是abstract类时将抛出错误。</code></pre></div>
<div class="block">
<h2 id="JDEvent">@class JDEvent (trait)</h2>
<p>提供事件监听(on)与触发(trigger)方法，例：</p>
<pre><code>class PluginCore
{
    use JDEvent;

    // 提供事件"event1", 注释如下：
    /// @event PluginCore.event.event1($arg1, $arg2)
}</code></pre>
<p>则可以调用</p>
<pre><code>$pluginCore-&gt;on('event1', 'onEvent1');
$pluginCore-&gt;trigger('event1', [$arg1, $arg2]);

function onEvent1($arg1, $arg2)
{
}</code></pre></div>
<div class="block">
<h2 id="JDEvent.on">@fn JDEvent.on($ev, $fn)</h2></div>
<div class="block">
<h2 id="JDEvent.trigger">@fn JDEvent.trigger($ev, $args)</h2>
<p>返回最后次调用的返回值，false表示中止之后事件调用 </p>
<p>如果想在事件处理函数中返回复杂值，可使用$args传递，如下面返回一个数组：</p>
<pre><code>$obj-&gt;on('getResult', 'onGetResult');
$out = new stdclass();
$out-&gt;result = [];
$obj-&gt;trigger('getArray', [$out]);

function onGetResult($out)
{
    $out-&gt;result[] = 100;
}</code></pre></div>
<div class="block">
<h2 id="ext">@module ext 集成外部系统</h2>
<p>调用外部系统（如短信集成、微信集成等）将引入依赖，给开发和测试带来复杂性。<br />
筋斗云框架通过使用“模拟模式”(MOCK_MODE)，模拟这些外部功能，从而简化开发和测试。</p>
<p>对于一个简单的外部依赖，可以用函数isMockMode来分支。例如添加对象存储服务(OSS)支持，接口定义为：</p>
<pre><code>getOssParam() -&gt; {url, expire, dir, param={policy, OSSAccessKeyId, signature} }
模拟模式返回：
getOssParam() -&gt; {url="mock"}</code></pre>
<p>在实现时，先在ext.php中定义外部依赖类型，如Ext_Oss，然后实现函数：</p>
<pre><code>function api_getOssParam()
{
    if (isMockMode(Ext_Oss)) {
        return ["url"=&gt;"mock"];
    }
    // 实际实现代码 ...
}</code></pre>
<p>添加一个复杂的（如支持多个函数调用的）支持模拟的外部依赖，也则可以定义接口，步骤如下，以添加短信支持(SmsSupport)为例：</p>
<ul>
<li>定义一个新的类型，如Ext_SmsSupport.</li>
<li>定义接口，如 ISmsSupport.</li>
<li>在ExtMock类中模拟实现接口ISmsSupport中所有函数, 一般是调用logext()写日志到ext.log, 可以在tool/log.php中查看最近的ext日志。</li>
<li>定义一个类SmsSupport实现接口ISmsSupport，一般放在其它文件中实现(如sms.php)。</li>
<li>在onCreateExt中处理新类型Ext_SmsSupport, 创建实际接口对象。</li>
</ul>
<p>使用举例：</p>
<pre><code>$sms = getExt(Ext_SmsSupport);
$sms-&gt;sendSms(...);</code></pre>
<p>要激活模拟模式，应在conf.user.php中设置：</p>
<pre><code>putenv("P_TEST_MODE=1");
putenv("P_MOCK_MODE=1");

// 或者只开启部分模块的模拟：
// putenv("P_MOCK_MODE=sms,wx");</code></pre>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p></div>
<div class="block">
<h2 id="isMockMode">@fn isMockMode($extType)</h2>
<p>判断是否模拟某外部扩展模块。如果$extType为null，则只要处于MOCK_MODE就返回true.</p></div>
<div class="block">
<h2 id="ExtFactory::getInstance">@fn ExtFactory::getInstance()</h2>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p></div>
<div class="block">
<h2 id="ExtFactory::getObj">@fn ExtFactory::getObj($extType, $allowMock?=true)</h2>
<p>获取外部依赖对象。一般用getExt替代更简单。</p>
<p>示例：</p>
<pre><code>$sms = ExtFactory::getInstance()-&gt;getObj(Ext_SmsSupport);</code></pre>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p></div>
<div class="block">
<h2 id="getExt">@fn getExt($extType, $allowMock = true)</h2>
<p>用于取外部接口对象，如：</p>
<pre><code>$sms = getExt(Ext_SmsSupport);</code></pre></div>
<div class="block">
<h2 id="logext">@fn logext($s, $addHeader?=true)</h2>
<p>写日志到ext.log中，可在线打开tool/init.php查看。<br />
(logit默认写日志到trace.log中)</p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p></div>
<div class="block">
<h2 id="api_fw">@module api_fw</h2><div class="toc"><p style="margin-left:0em"><a href="#api_fw-1 函数型接口">1 函数型接口</a></p>
<p style="margin-left:0em"><a href="#api_fw-2 对象型接口">2 对象型接口</a></p>
<p style="margin-left:2em"><a href="#api_fw-2.1 标准对象接口">2.1 标准对象接口</a></p>
<p style="margin-left:2em"><a href="#api_fw-2.2 非标准对象接口">2.2 非标准对象接口</a></p>
<p style="margin-left:2em"><a href="#api_fw-2.3 RESTful风格接口">2.3 RESTful风格接口</a></p>
<p style="margin-left:0em"><a href="#api_fw-3 接口复用">3 接口复用</a></p>
<p style="margin-left:0em"><a href="#api_fw-4 常用操作">4 常用操作</a></p>
<p style="margin-left:0em"><a href="#api_fw-5 插件机制">5 插件机制</a></p>
</div>
<p>服务接口实现框架。</p>
<p>服务接口包含：</p>
<ul>
<li>函数型接口，如 &quot;login&quot;, &quot;getToken&quot;等, 一般实现在 api_functions.php中。</li>
<li>对象型接口，如 &quot;Ordr.query&quot;, &quot;User.get&quot; 等，一般实现在 api_objects.php中。</li>
</ul>
<h4 id="api_fw-1 函数型接口">1 函数型接口</h4>
<p>假设在文档有定义以下接口</p>
<pre><code>用户修改密码
chpwd(oldpwd, pwd) -&gt; {_token, _expire}

权限：AUTH_USER</code></pre>
<p>则在 api_functions.php 中创建该接口的实现：</p>
<pre><code>function api_chpwd()
{
    checkAuth(AUTH_USER);
    $oldPwd = mparam("oldpwd");
    $pwd = mparam("pwd");
    ...
    $ret = [
        "_token" =&gt; $token,
        "_expire" =&gt; $expire,
    ];
    return $ret;
}</code></pre>
<p>说明：</p>
<ul>
<li>函数名称一定要符合 &quot;api_{接口名}&quot; 的规范。接口名以小写字母开头。</li>
<li>使用checkAuth进行权限检查</li>
<li>返回符合接口定义的对象。最终后端框架将其转为JSON串，再由前端框架解析后传递给应用程序。</li>
</ul>
<p class="see"><strong>@see <a href="#checkAuth">checkAuth</a></strong> </p>
<p class="see"><strong>@see <a href="#mparam">mparam</a></strong>  取必选参数，如果缺少该参数则报错。</p>
<p class="see"><strong>@see <a href="#param">param</a></strong>  取可选参数，可指定缺省值。</p>
<h4 id="api_fw-2 对象型接口">2 对象型接口</h4>
<p class="see"><strong>@see <a href="#AccessControl">AccessControl</a></strong>  对象型接口框架。</p>
<h5 id="api_fw-2.1 标准对象接口">2.1 标准对象接口</h5>
<p>5个标准对象操作为：add, set, query, get, del。<br />
这些操作提供对象的基本增删改查(CRUD)以及列表查询、统计分析、导出等服务，称为通用对象接口。<br />
详细可参考BQP协议文档中的 <strong><a href="BQP.html#通用对象操作接口">通用对象操作接口</a></strong> 部分。</p>
<p>以下代码即为Ordr对象创建所有这些接口:</p>
<pre><code>class AC_Ordr extends AccessControl
{
}</code></pre>
<p><strong>[添加操作]</strong></p>
<pre><code>Obj.add()(POST fields...) -&gt; id
Obj.add(res)(POST fields...) -&gt; {fields...} (返回的字段由res参数指定)</code></pre>
<p>对象的属性通过POST请求内容给出，为一个个键值对。<br />
添加完成后，默认返回新对象的id, 如果想多返回其它字段，可设置res参数，如 </p>
<pre><code>Ordr.add()(status="CR", total=100) -&gt; 809
Ordr.add(res="id,status,total")(status="CR", total=100) -&gt; {id: 810, status:"CR", total: 100}</code></pre>
<p><strong>[更新操作]</strong></p>
<pre><code>Obj.set(id)(POST fields...)</code></pre>
<p>与add操作类似，对象属性的修改通过POST请求传递，而在URL参数中需要有id标识哪个对象。</p>
<p>示例：</p>
<pre><code>Obj.set(809)(status="PA", empId=10)</code></pre>
<p>如果要将某字段置空, 可以用空串或&quot;null&quot; (小写)。例如：</p>
<pre><code>Obj.set(809)(picId="", empId=null)
（实际传递参数的形式为 "picId=&amp;empId=null"）</code></pre>
<p>这两种方式都是将字段置NULL。<br />
如果要将字符串置空串(一般不建议使用)，可以用&quot;empty&quot;, 例如：</p>
<pre><code>Obj.set(809)(sn=empty)</code></pre>
<p>假如sn是数值类型，会导致其值为0或0.0。</p>
<p><strong>[获取对象操作]</strong></p>
<p>接口原型：</p>
<pre><code>Obj.get(id, res?) -&gt; {fields...}</code></pre>
<p>默认返回所有暴露的属性，通过res参数可以指定需要返回的字段。</p>
<p><strong>[删除操作]</strong></p>
<pre><code>Obj.del(id)</code></pre>
<p>根据id删除一个对象。</p>
<p><strong>[查询操作]</strong></p>
<pre><code>查询列表(默认压缩表格式)：
Obj.query(res?, cond?, distinct?=0) -&gt; tbl(fields...) = {nextkey?, total?, @h, @d}

查询列表 - 对象列表格式：
Obj.query(fmt=list, ...) -&gt; {nextkey?, total?, @list=[obj1, obj2...]}</code></pre>
<ul>
<li>
<p>res: String. 指定返回字段, 多个字段以逗号分隔，例如, res=&quot;field1,field2&quot;。<br />
在res中允许使用部分统计函数&quot;sum&quot;与&quot;count&quot;, 这时必须指定字段别名, 如&quot;count(id) cnt&quot;, &quot;sum(qty*price) total&quot;, &quot;count(distinct addr) addrCnt&quot;.</p>
</li>
<li>
<p>cond: String. 指定查询条件，语法可参照SQL语句的&quot;WHERE&quot;子句。例如：cond=&quot;field1&gt;100 AND field2='hello'&quot;, 注意使用UTF8+URL编码, 字符串值应加上单引号.<br />
(v5.1) 支持在GET/POST中同时传cond参数，且允许cond参数为数组。比如URL中：<code>cond[]=a=1&amp;cond[]=b=2</code>，在POST中：<code>cond=c=3</code>，则后端识别为 cond=&quot;a=1 AND b=2 AND c=3&quot;. 参数gcond也是一样。</p>
</li>
<li>
<p>orderby: String. 指定排序条件，语法可参照SQL语句的&quot;ORDER BY&quot;子句，例如：orderby=&quot;id desc&quot;，也可以多个排序：&quot;tm desc,status&quot; (按时间倒排，再按状态正排)</p>
</li>
<li>distinct: Boolean. 如果为1, 生成&quot;SELECT DISTINCT ...&quot;查询.</li>
</ul>
<p>返回字段:</p>
<ul>
<li>h/d: 两个数组。实际数据表的头信息(header)和数据行(data)，符合压缩表对象的格式。</li>
</ul>
<p>压缩表格式示例:</p>
<pre><code>{
    h: ["id", "name"],
    d: [[100, "myname1"], [200, "myname2"]]
}</code></pre>
<p>如果使用参数fmt=list, 则返回格式示例如下: </p>
<pre><code>{
    list: [{id: 100, name: "name1"}, {id: 101, name: "name2"}]
    nextkey: ...
}</code></pre>
<p><strong>[分页查询]</strong></p>
<pre><code>Obj.query(pagesz?=20, pagekey?) -&gt; {nextkey?, total?, @h, @d}
或
Obj.query(rows?=20, page?) -&gt; 同上</code></pre>
<ul>
<li>pagesz/rows: Integer. 这两个参数含义相同，均表示页大小，默认为20条数据。</li>
<li>pagekey: Integer. 一般首次查询时不填写（或填写0，表示需要返回总记录数即total字段），而下次查询时应根据上次调用时返回数据的&quot;nextkey&quot;字段来填写。</li>
<li>page: Integer. 指定页数, 从1开始. 用于兼容传统指定页数式的分页查询, 效率较低. 这时返回的nextkey一定为page+1或为空(表示没有下页), 且必返回total字段.</li>
</ul>
<p>返回字段:</p>
<ul>
<li>nextkey: Integer. 一个字符串, 供取下一页时填写参数&quot;pagekey&quot;。如果不存在该字段，则说明已经是最后一批数据。</li>
<li>total: Integer. 返回总记录数，仅当&quot;pagekey&quot;指定为0时返回; 或是使用&quot;page&quot;参数时也会返回该属性。</li>
</ul>
<p><strong>[分组统计]</strong></p>
<pre><code>Obj.query(gres, gcond?, ...) -&gt; tbl(fields...)</code></pre>
<ul>
<li>
<p>gres: String. 分组字段。如果设置了gres字段，则res参数中每项应该带统计函数，如&quot;sum(cnt) sum, count(id) userCnt&quot;.<br />
最终返回列为gres参数指定的列加上res参数指定的列; 如果res参数未指定，则只返回gres参数列。</p>
</li>
<li>gcond: String. (jdcloud-php扩展) 分组过滤条件(对照SQL HAVING子句).</li>
</ul>
<p><strong>[导出报表]</strong></p>
<pre><code>Obj.query(fmt=csv/txt/excel, ...) -&gt; 文件内容</code></pre>
<h5 id="api_fw-2.2 非标准对象接口">2.2 非标准对象接口</h5>
<p>v3.4支持非标准对象接口。实现Ordr.cancel接口：</p>
<pre><code>class AC2_Ordr extends AccessControl
{
    function api_cancel() {
    }
}</code></pre>
<p>非标准对象接口与与函数型接口写法类似，但AccessControl的众多回调函数对非标准对象接口无效。</p>
<h5 id="api_fw-2.3 RESTful风格接口">2.3 RESTful风格接口</h5>
<p>对象型接口支持仿RESTful风格的调用。<br />
标准CRUD操作：</p>
<pre><code>POST /Ordr
等价于Ordr.add

GET /Ordr
等价于Ordr.query

GET /Ordr/123
等价于Ordr.get?id=123

PATCH /Ordr/123
等价于Ordr.set?id=123

DELETE /Ordr/123
等价于Ordr.del?id=123</code></pre>
<p>非标准操作：(v5.1新增) 谓词使用GET或POST都可以</p>
<pre><code>POST /Ordr/123/cancel
等价于Ordr.cancel?id=123</code></pre>
<ul>
<li>URL中id位置可在action后面，也可没有，如 <code>/Ordr/cancel/123</code>, <code>/Ordr/cancel?id=123</code>均可。</li>
<li>也允许以此方式调用标准CRUD操作，如<code>GET /Ordr/get/123</code>即<code>Ordr.get?id=123</code> , <code>POST /Ordr/123/set</code>即<code>Ordr.set?id=123</code>等.</li>
</ul>
<p>注意以下与RESTful惯例不一致：</p>
<ul>
<li>对象（或称实体，Entity）首字母应大写。</li>
<li>返回数据与对象型调用完全一样，HTTP总返回200成功，不会通过HTTP状态码表示调用返回值。</li>
</ul>
<h4 id="api_fw-3 接口复用">3 接口复用</h4>
<p class="key"><strong>@key <a id="apiMain">apiMain</a></strong> () 服务入口函数</p>
<p class="key"><strong>@key <a id="noExecApi">noExecApi</a></strong>  全局变量，禁止apiMain执行服务</p>
<p>一般在接口服务文件api.php中定义公共变量和函数，包含所有接口，在其最后调用服务入口函数apiMain()。</p>
<p>如果某应用想包含api.php，以便使用其中的接口实现，可以用callSvc:</p>
<pre><code>// set_include_path(get_include_path() . PATH_SEPARATOR . "..");
$GLOBALS["noExecApi"] = true; // 在包含api.php前设置该变量，可禁止apiMain函数自动解析请求（CLI方式调用时默认就不解析请求，故也可以不设置该变量）。
require_once("api.php");
...
$GLOBALS["errorFn"] = function($code, $msg, $msg2=null) {...}
$ret = callSvc("genVoucher");
// 如果没有异常，返回数据；否则调用指定的errorFn函数(未指定则调用errQuit)</code></pre>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p>
<h4 id="api_fw-4 常用操作">4 常用操作</h4>
<p>错误处理</p>
<p class="see"><strong>@see <a href="#MyException">MyException</a></strong> </p>
<p>中断执行，直接返回</p>
<p class="see"><strong>@see <a href="#DirectReturn">DirectReturn</a></strong> </p>
<p>调试日志</p>
<p>可使用addLog输出调试信息而不破坏协议输出格式。</p>
<p class="see"><strong>@see <a href="#addLog">addLog</a></strong>  </p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p>
<h4 id="api_fw-5 插件机制">5 插件机制</h4>
<p>插件是包含数据库/接口/前端逻辑页设计、后端实现、前端逻辑页实现的模块。</p>
<p>其设计由插件目录/DESIGN.md定义，可由upgrade工具自动部署。</p>
<p class="key"><strong>@key <a id="plugin/index.php">plugin/index.php</a></strong>  插件配置</p>
<p>plugin/{pluginName}为插件目录。</p>
<p>plugin/index.php是插件配置文件，在后端应用框架函数apiMain中引入，内容示例如下：</p>
<pre><code>&lt;?php

Plugins::add("plugin1");
Plugins::add("plugin2", "plugin2/index.php"); // 指定插件主文件，如不指定，默认为"plugin2/plugin.php"</code></pre>
<p>表示当前应用使用两个插件&quot;plugin1&quot;和&quot;plugin2&quot;, 分别对应目录 plugin/plugin1和plugin/plugin2.</p>
<p class="see"><strong>@see <a href="#Plugins::add">Plugins::add</a></strong> </p>
<p class="key"><strong>@key <a id="plugin">plugin</a></strong>  插件定义</p>
<p>插件实现包括交互接口，以及插件API（后端调用接口），以优惠券插件&quot;coupon&quot;为例: (plugin/coupon/plugin.php)</p>
<pre><code>&lt;?php

// 可选：定义模块API，均使用静态变量或函数
class Coupon
{
    // use MapCol; // 如果要用mapCol/mapSql函数，则打开该trait.

    static $conf1; // 模块配置
    static function func1($arg1) // 模块公共接口
    {
        // 调用实现部分
        $imp = CouponImpBase::getInstance();
        $imp-&gt;genCoupons($src);
    }
}

// 模块实现依赖的接口。如果必须由外部实现，则使用abstract类及函数
abstract class CouponImpBase
{
    use JDSingletonImp;

    abstract function genCoupons($src);
}

// 实现函数型交互接口takeCoupon
function api_takeCoupon() {}

// 实现对象型交互接口 Coupon.query/get/set/del/add
class AC1_Coupon extends AccessControl {}

// 可选：返回前端配置
return [
    "js" =&gt; "m2/plugin.js", // 如果前端需要包含文件
];</code></pre>
<p>注意：</p>
<p>调用插件API函数：</p>
<pre><code>    Coupon::func1($arg1);</code></pre>
<p>交互接口应在插件设计文档(plugin/coupon/DESIGN.md)中定义原型。</p>
<p>插件依赖的接口应定义CouponImp类来实现，一般放在文件 php/class/CouponImp.php中自动加载。</p></div>
<div class="block">
<h2 id="$X_RET_FN">@var $X_RET_FN</h2>
<p>默认接口调用后输出筋斗云的<code>[0, data]</code>格式。<br />
若想修改返回格式，可设置该回调函数。</p>
<ul>
<li>如果返回对象，则输出json格式。</li>
<li>如果返回false，应自行用echo输出。注意API日志中仍记录筋斗云返回数据格式。</li>
</ul>
<p>示例：返回 <code>{code, data}</code>格式：</p>
<pre><code>global $X_RET_FN;
$X_RET_FN = function ($X_RET) {
    $ret = [
        "code" =&gt; $X_RET[0],
        "data" =&gt; $X_RET[1]
    ];
    if ($GLOBALS["TEST_MODE"])
        $ret["jdData"] = $X_RET;
    return $ret;
};</code></pre>
<p>示例：返回xml格式：</p>
<pre><code>global $X_RET_FN;
$X_RET_FN = function ($X_RET) {
    header("Content-Type: application/xml");
    echo "&lt;xml&gt;&lt;code&gt;$X_RET[0]&lt;/code&gt;&lt;data&gt;$_RET[1]&lt;/data&gt;&lt;/xml&gt;";
    return false;
};</code></pre></div>
<div class="block">
<h2 id="setRet">@fn setRet($code, $data?, $internalMsg?)</h2>
<p class="param"><strong>@param $code</strong>  Integer. 返回码, 0表示成功, 否则表示操作失败。</p>
<p class="param"><strong>@param $data</strong>  返回数据。</p>
<p class="param"><strong>@param $internalMsg</strong>  当返回错误时，作为额外调试信息返回。</p>
<p>设置返回数据，最终返回JSON格式数据为 [ code, data, internalMsg, debugInfo1, ...]<br />
其中按照BQP协议，前两项为必须，后面的内容一般仅用于调试，前端应用不应处理。</p>
<p>当成功时，返回数据可以是任何类型（根据API设计返回相应数据）。<br />
当失败时，为String类型错误信息。<br />
如果参数$data未指定，则操作成功时值为null（按BQP协议返回null表示客户端应忽略处理，一般无特定返回应指定$data=&quot;OK&quot;）；操作失败时使用默认错误信息。</p>
<p>调用完后，要返回的数据存储在全局数组 $X_RET 中，以JSON字符串形式存储在全局字符串 $X_RET_STR 中。<br />
注意：也可以直接设置$X_RET_STR为要返回的字符串，从而避免setRet函数对返回对象进行JSON序列化，如</p>
<pre><code>$GLOBALS["X_RET_STR"] = '{"id":100, "name":"aaa"}';
// 如果不想继续执行后面代码，可以自行调用：
setRet(0, "OK");
throw new DirectReturn();
// 最终返回字符串为 [0, {"id":100, "name":"aaa"}]</code></pre>
<p class="see"><strong>@see <a href="#$X_RET">$X_RET</a></strong> </p>
<p class="see"><strong>@see <a href="#$X_RET_STR">$X_RET_STR</a></strong> </p>
<p class="see"><strong>@see <a href="#$X_RET_FN">$X_RET_FN</a></strong> </p>
<p class="see"><strong>@see <a href="#$errorFn">$errorFn</a></strong> </p>
<p class="see"><strong>@see <a href="#errQuit">errQuit</a></strong> ()</p></div>
<div class="block">
<h2 id="setServerRev">@fn setServerRev()</h2>
<p>根据全局变量&quot;SERVER_REV&quot;或应用根目录下的文件&quot;revision.txt&quot;， 来设置HTTP响应头&quot;X-Daca-Server-Rev&quot;表示服务端版本信息（最多6位）。</p>
<p>客户端框架可本地缓存该版本信息，一旦发现不一致，可刷新应用。<br />
服务器可使用$GLOBALS[&quot;SERVER_REV&quot;]来取服务端版本号（6位）。</p></div>
<div class="block">
<h2 id="hasPerm">@fn hasPerm($perm)</h2>
<p>检查权限。perm可以是单个权限或多个权限，例：</p>
<pre><code>hasPerm(AUTH_USER); // 用户登录后可用
hasPerm(AUTH_USER | AUTH_EMP); // 用户或员工登录后可用</code></pre>
<p class="fn"><strong>@fn <a id="onGetPerms">onGetPerms</a></strong> ()</p>
<p>开发者需要定义该函数，用于返回所有检测到的权限。hasPerm函数依赖该函数。</p>
<p class="see"><strong>@see <a href="#checkAuth">checkAuth</a></strong> </p></div>
<div class="block">
<h2 id="checkAuth">@fn checkAuth($perm)</h2>
<p>用法与hasPerm类似，检查权限，如果不正确，则抛出错误，返回错误对象。</p>
<pre><code>checkPerm(AUTH_USER); // 必须用户登录后可用
checkPerm(AUTH_ADMIN | PERM_TEST_MODE); 要求必须管理员登录或测试模式才可用。</code></pre>
<p class="see"><strong>@see <a href="#hasPerm">hasPerm</a></strong> </p></div>
<div class="block">
<h2 id="getClientVersion">@fn getClientVersion()</h2>
<p>通过参数<code>_ver</code>或useragent字段获取客户端版本号。</p>
<p>@return: {type, ver, str}</p>
<ul>
<li>type: &quot;web&quot;-网页客户端; &quot;wx&quot;-微信客户端; &quot;a&quot;-安卓客户端; &quot;ios&quot;-苹果客户端</li>
</ul>
<p>e.g. {type: &quot;a&quot;, ver: 2, str: &quot;a/2&quot;}</p></div>
<div class="block">
<h2 id="tmCols">@fn tmCols($fieldName = "t0.tm")</h2>
<p>为查询添加时间维度单位: y,m,w,d,wd,h (年，月，周，日，周几，时)。</p>
<ul>
<li>wd: 1-7表示周一到周日</li>
<li>w: 一年中第一周，从该年第一个周一开始(mysql week函数模式7).</li>
</ul>
<p>示例：</p>
<pre><code>    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols() ];
    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols("t0.createTm") ];
    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols("log_cr.tm"), "require" =&gt; "createTm" ];</code></pre></div>
<div class="block">
<h2 id="ConfBase">@class ConfBase</h2>
<p>在conf.php中定义Conf类并继承ConfBase, 实现代码配置：</p>
<pre><code>class Conf extends ConfBase
{
}</code></pre>
<p class="key"><strong>@key <a id="Conf">Conf</a></strong>  项目易变逻辑</p>
<p class="key"><strong>@key <a id="conf.php">conf.php</a></strong>  项目易变逻辑</p>
<p>$BASE_DIR/conf.php中包含Conf类，用于定义易变的临时逻辑，例如数据库维护时报错提示，临时控制某个版本不能使用，遇到节假日休息提醒等等。</p>
<p>不变的全局配置应在app.php中定义。</p></div>
<div class="block">
<h2 id="ConfBase::$enableApiLog">@var ConfBase::$enableApiLog?=true</h2>
<p>设置为false可关闭ApiLog. 例：</p>
<pre><code>static $enableApiLog = false;</code></pre></div>
<div class="block">
<h2 id="ConfBase::onApiInit">@fn ConfBase::onApiInit()</h2>
<p>所有API执行时都会先走这里。</p>
<p>例：对所有API调用检查ios版本：</p>
<pre><code>static function onApiInit(&amp;$ac)
{
    $ver = getClientVersion();
    if ($ver["type"] == "ios" &amp;&amp; $ver["ver"]&lt;=15) {
        throw new MyException(E_FORBIDDEN, "unsupport ios client version", "您使用的版本太低，请升级后使用!");
    }
}</code></pre>
<p>例：ac换名字：</p>
<pre><code>static function onApiInit(&amp;$ac)
{
    if ($ac == "DFIS-BK_S001") {
        $ac = "DMS.workGroup";
    }
}</code></pre></div>
<div class="block">
<h2 id="ConfBase::onInitClient">@fn ConfBase::onInitClient(&$ret)</h2>
<p>客户端初始化应用时会调用initClient接口，返回plugins等信息。若要加上其它信息，可在这里扩展。</p>
<p>例：假如定义应用初始化接口为(plugins是框架默认返回的)：</p>
<pre><code>initClient(app) -&gt; {plugins, appName}</code></pre>
<p>实现：</p>
<pre><code>static function onInitClient(&amp;$ret)
{
    $app = mparam('app');
    $ret['appName'] = 'my-app';
}</code></pre></div>
<div class="block">
<h2 id="ApiLog::$lastId">@var ApiLog::$lastId</h2>
<p>取当前调用的ApiLog编号。</p></div>
<div class="block">
<h2 id="MapCol.$colMap">@var MapCol.$colMap</h2>
<p>%colMap = {tbl =&gt; [tblAlias, %cols]}<br />
cols = {col =&gt; colAlias}</p>
<p>先在插件接口文档DESIGN.md中声明本插件的数据库依赖：</p>
<pre><code>@see @Store: id, name, dscr
@see @Ordr: id</code></pre>
<p>配置定表名或列名对应（如果名称相同不必声明）</p>
<pre><code>Coupon::$colMap = [
    "Store" =&gt; ["MyStore", [
        "dscr" =&gt; "description"
    ]],
    "Ordr" =&gt; ["MyOrder"]
];</code></pre>
<p>在plugin实现时，使用mapCol/mapSql来使表名、列名可配置：</p>
<pre><code>class Coupon
{
    use MapCol;
}
$tbl = Coupon::mapCol("Store"); // $tbl="MyStore"
$tbl = Coupon::mapCol("User"); // $tbl="User" 未定义时，直接取原值
$col = Coupon::mapCol("Store.dscr"); // $col="description"
$col = Coupon::mapCol("Store.name"); // $col="name" 未定义时，直接取原值

$sql = $plugin-&gt;mapSql("SELECT s.id, s.{Store.name}, s.{Store.dscr} FROM {Store} s INNER JOIN {Ordr} o ON o.id=s.{Store.storeId}");
// $sql = "SELECT s.id, s.name, s.description FROM MyStore s INNER JOIN MyOrder o ON o.id=s.storeId"</code></pre>
<p class="key"><strong>@key <a id="MapCol.mapCol">MapCol.mapCol</a></strong> ($tbl, $col=null)</p>
<p class="key"><strong>@key <a id="MapCol.mapSql">MapCol.mapSql</a></strong> ($sql)</p></div>
<div class="block">
<h2 id="Plugins">@class Plugins</h2>
<p class="see"><strong>@see <a href="#plugin/index.php">plugin/index.php</a></strong> </p></div>
<div class="block">
<h2 id="Plugins::$map">@var Plugins::$map</h2>
<p>{ pluginName =&gt; %pluginCfg={js} }</p></div>
<div class="block">
<h2 id="Plugins::add">@fn Plugins::add($pluginName, $file?)</h2>
<p>添加模块或插件。<br />
$file为插件主文件，可返回一个插件配置。如果未指定，则自动找&quot;{pluginName}/{pluginName}.php&quot;) 或 &quot;{pluginName}/plugin.php&quot;文件。</p>
<p>以下旧的格式也兼容，现已不建议使用：</p>
<pre><code>Plugins::add($pluginNameArray)</code></pre>
<p class="see"><strong>@see <a href="#Plugins.$map">Plugins.$map</a></strong> </p></div>
<div class="block">
<h2 id="Plugins::exists">@fn Plugins::exists($pluginName)</h2></div>
<div class="block">
<h2 id="tableCRUD">@fn tableCRUD($ac, $tbl, $asAdmin?=false)</h2>
<p>对象型接口的入口。<br />
也可直接被调用，常与setParam一起使用, 提供一些定制的操作。</p>
<p class="param"><strong>@param $asAdmin</strong>  默认根据用户身份自动选择"AC_"类; 如果为true, 则以超级管理员身份调用，即使用"AC0_"类。</p>
<p>设置$asAdmin=true好处是对于超级管理员权限来说，即使未定义&quot;AC0_&quot;类，默认也可以访问所有内容。</p>
<p>假如有Rating（订单评价）对象，不想通过对象型接口来查询，而是通过函数型接口来定制输出，接口设计为：</p>
<pre><code>queryRating(storeId, cond?) -&gt; tbl(id, score, dscr, tm, orderDscr)

查询店铺storeId的订单评价。

应用逻辑：
- 按时间tm倒排序</code></pre>
<p>底层利用tableCRUD实现它，这样便于保留分页、参数cond/gres等特性:</p>
<pre><code>function api_queryRating()
{
    $storeId = mparam("storeId");

    // 定死输出内容。
    setParam("res", "id, score, dscr, tm, orderDscr");

    // 相当于AccessControl框架中调用 addCond，用Obj.query接口的内部参数cond2以保证用户还可以使用cond参数。
    setParam("cond2", ["o.storeId=$storeId"]); 

    // 定死排序条件
    setParam("orderby", "tm DESC");

    $ret = tableCRUD("query", "Rating", true);
    return $ret;
}</code></pre>
<p>注意：</p>
<ul>
<li>以上示例中的设计不可取，应使用标准对象接口来实现这个需求。</li>
</ul>
<p class="see"><strong>@see <a href="#setParam">setParam</a></strong> </p>
<p class="see"><strong>@see <a href="#callSvcInt">callSvcInt</a></strong> </p>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p></div>
<div class="block">
<h2 id="callSvcInt">@fn callSvcInt($ac)</h2>
<p>内部调用另一接口，获得返回值。如果要设置GET, POST参数，分别用</p>
<pre><code>setParam(key, value); // 设置get参数
// 或批量设置用 setParam({key =&gt; value});
$_POST[key] = value; // 设置post参数</code></pre>
<p>与callSvc不同的是，它不处理事务、不写ApiLog，不输出数据，更轻量；<br />
与tableCRUD不同的是，它支持函数型调用。</p>
<p class="see"><strong>@see <a href="#setParam">setParam</a></strong> </p>
<p class="see"><strong>@see <a href="#tableCRUD">tableCRUD</a></strong> </p>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p></div>
<div class="block">
<h2 id="inWhiteIpList">@fn inWhiteIpList()</h2>
<p>检查调用者是否在IP白名单中。配置项为whiteIpList。</p>
<p class="see"><strong>@see <a href="#whiteIpList">whiteIpList</a></strong> </p>
<p class="see"><strong>@see <a href="#api_checkIp">api_checkIp</a></strong> </p></div>
<div class="block">
<h2 id="api_checkIp">@fn api_checkIp()</h2>
<p class="key"><strong>@key <a id="whiteIpList">whiteIpList</a></strong>  白名单配置，默认值为"127.0.0.1"</p>
<p>可在conf.user.php中设置whiteIpList，如</p>
<pre><code>putenv("whiteIpList=115.238.59.110 127.0.0.1 ::1");</code></pre>
<p>要验证调用者是否在IP白名单中，不是白名单调用将直接抛错，可以调用</p>
<pre><code>api_checkIp();</code></pre>
<p>外部可直接调用接口checkIp测试，例如用JS：</p>
<pre><code>callSvr("checkIp");</code></pre>
<p class="see"><strong>@see <a href="#inWhiteIpList">inWhiteIpList</a></strong> </p></div>
<div class="block">
<h2 id="httpCallAsync">@fn httpCallAsync($url, $postParams=null)</h2>
<p>发起调用后立即返回，即用于发起异步调用。<br />
默认发起GET调用，如果postParams非空(可以为字符串、数值或数组)，则发起POST调用。</p>
<p>示例：</p>
<pre><code>httpCallAsync("/jdcloud/api.php?ac=async&amp;f=sendSms", [
    "phone" =&gt; "13712345678",
    "msg" =&gt; "验证码为1234"
]);</code></pre>
<p>TODO:目前只用于本机</p></div>
<div class="block">
<h2 id="callAsync">@fn callAsync($ac, $params)</h2>
<p class="key"><strong>@key <a id="enableAsync">enableAsync</a></strong>  配置异步调用</p>
<p>发起异步调用请求，然后立即返回。它使用如下接口：</p>
<pre><code>async(f)(params...)
其中params为JSON格式</code></pre>
<p>示例：让一个同步调用变成支持异步调用，以sendSms为例</p>
<pre><code>// 1. 设置已注册的异步调用函数。建议在api.php中设置。
$allowedAsyncCalls = ["sendSms"];

function sendSms($phone, $msg) {
    // 2. 为支持异步的函数加上判断分支
    if (getenv("enableAsync") === "1") {
        return callAsync('pushMsg', func_get_args());
    }

    // 同步调用
    return httpCall("...");
}

// 3. 在conf.user.php中配置开启异步支持。如果不配置则为同步调用，便于比较区别与调试。
// 打开异步调用支持, 依赖 P_BASE_URL 和 whiteIpList 设置
putenv("enableAsync=1");</code></pre>
<p class="see"><strong>@see <a href="#api_async">api_async</a></strong> </p></div>
<div class="block">
<h2 id="api_async">@fn api_async</h2>
<p>提供async接口，用于内部发起异步调用:</p>
<pre><code>async(f)(params...)
params为JSON格式。</code></pre>
<p>注意：要求调用者在IP白名单中，配置示例：</p>
<pre><code>putenv("whiteIpList=115.238.59.110 127.0.0.1 ::1");</code></pre>
<p class="see"><strong>@see <a href="#enableAsync">enableAsync</a></strong> </p>
<p class="see"><strong>@see <a href="#whiteIpList">whiteIpList</a></strong> </p></div>
<div class="block">
<h2 id="callSvc">@fn callSvc($ac?, $urlParam?, $postParam?, $cleanCall?=false, $hideResult?=false)</h2>
<p>直接调用接口，返回数据。如果出错，将调用$GLOBALS['errorFn'] (缺省为errQuit).</p>
<p class="param"><strong>@param $cleanCall</strong>  Boolean. 如果为true, 则不使用现有的$_GET, $_POST等变量中的值。</p>
<p class="param"><strong>@param $hideResult</strong>  Boolean. 如果为true, 不输出结果。</p></div>
<div class="block">
<h2 id="AccessControl">@module AccessControl</h2><div class="toc"><p style="margin-left:0em"><a href="#AccessControl-1 基本权限控制">1 基本权限控制</a></p>
<p style="margin-left:0em"><a href="#AccessControl-2 虚拟字段(VCol)">2 虚拟字段(VCol)</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.1 关联字段">2.1 关联字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.2 关联字段依赖">2.2 关联字段依赖</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.3 计算字段">2.3 计算字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.4 子表压缩字段">2.4 子表压缩字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.5 自定义字段">2.5 自定义字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.6 flags和props字段">2.6 flags和props字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.7 外部虚拟字段(ExtVCol)">2.7 外部虚拟字段(ExtVCol)</a></p>
<p style="margin-left:4em"><a href="#AccessControl-2.7.1 嵌套查询">2.7.1 嵌套查询</a></p>
<p style="margin-left:4em"><a href="#AccessControl-2.7.2 关联子查询优化">2.7.2 关联子查询优化</a></p>
<p style="margin-left:0em"><a href="#AccessControl-3 子表">3 子表</a></p>
<p style="margin-left:0em"><a href="#AccessControl-4 操作完成回调">4 操作完成回调</a></p>
<p style="margin-left:0em"><a href="#AccessControl-5 其它">5 其它</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.1 编号自定义生成">5.1 编号自定义生成</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.2 缺省排序">5.2 缺省排序</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.3 缺省输出字段列表">5.3 缺省输出字段列表</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.4 最大每页数据条数">5.4 最大每页数据条数</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.5 虚拟表和视图">5.5 虚拟表和视图</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.6 query接口输出格式">5.6 query接口输出格式</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.7 distinct查询">5.7 distinct查询</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.8 枚举支持及自定义字段处理">5.8 枚举支持及自定义字段处理</a></p>
<p style="margin-left:0em"><a href="#AccessControl-6 批量更新(setIf)和批量删除(delIf)">6 批量更新(setIf)和批量删除(delIf)</a></p>
</div>
<p>对象型接口框架。<br />
AccessControl简写为AC，同时AC也表示自动补全(AutoComplete).</p>
<p>在设计文档中完成数据库设计后，通过添加AccessControl的继承类，可以很方便的提供诸如 {Obj}.query/add/get/set/del 这些对象型接口。</p>
<p>例如，设计文档中已定义订单对象(Ordr)的主表(Ordr)和订单日志子表(OrderLog)：</p>
<pre><code>@Ordr: id, userId, status, amount
@OrderLog: id, orderId, tm, dscr</code></pre>
<p>注意：之所以用对象和主表名用Ordr而不是Order词是避免与SQL关键字冲突。</p>
<p>有了表设计，订单的标准接口就已经自动生成好了：</p>
<pre><code>// 查询订单
Ordr.query() -&gt; tbl(id, userId, ...)
// 添加订单
Ordr.add()(userId=1, status='CR', amount=100) -&gt; id
// 查看订单
Ordr.get(id=1)
// 修改订单状态
Ordr.set(id=1)(status='PA')
// 删除订单
Ordr.del(id=1)</code></pre>
<p>但是，只有超级管理员登录后（例如从示例应用中的超级管理端登录后，web/adm.html），才有权限使用这些接口。</p>
<p>如果希望用户登录后，也可以使用这些接口，只要添加一个继承AccessControl的类，且命名为&quot;AC1_Ordr&quot;即可：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
}</code></pre>
<p>有了以上定义，在用户登录系统后，就可以使用上述和超级管理员一样的标准订单接口了。</p>
<p>说明：</p>
<p>类的命名规则为AC前缀加对象名（或主表名，因为对象名与主表名一致）。框架默认提供的前缀如下：</p>
<p class="key"><strong>@key <a id="AC_">AC_</a></strong>   游客权限(AUTH_GUEST)，如未定义则调用时报“无权操作”错误。</p>
<p class="key"><strong>@key <a id="AC0_">AC0_</a></strong>  超级管理员权限(AUTH_ADMIN)，如未定义，默认拥有所有权限。</p>
<p class="key"><strong>@key <a id="AC1_">AC1_</a></strong>   用户权限(AUTH_USER)，如未定义，则降级使用游客权限接口(AC_)。</p>
<p class="key"><strong>@key <a id="AC2_">AC2_</a></strong>   员工权限(AUTH_EMP/AUTH_MGR), 如未定义，报权限不足错误。</p>
<p>因而上例中命名为 &quot;AC1_Ordr&quot; 就表示用户登录后调用Ordr对象接口，将受该类控制。而这是个空的类，所以拥有一切操作权限。</p>
<p>框架为AUTH_ADMIN权限自动选择AC0_类，其它类可以通过函数 onCreateAC 进行自定义，仍未定义的框架使用AC_类。</p>
<p class="fn"><strong>@fn <a id="onCreateAC">onCreateAC</a></strong> ($obj)</p>
<p>需开发者在api.php中定义。<br />
根据对象名，返回权限控制类名，如 AC1<em>{$obj}。<br />
如果返回null, 则默认为 AC</em>{obj}</p>
<h4 id="AccessControl-1 基本权限控制">1 基本权限控制</h4>
<p class="var"><strong>@var <a id="AccessControl::$allowedAc">AccessControl::$allowedAc</a></strong> ?=["add", "get", "set", "del", "query"] 设定允许的操作，如不指定，则允许所有操作。</p>
<p class="var"><strong>@var <a id="AccessControl::$readonlyFields">AccessControl::$readonlyFields</a></strong>  ?=[]  (影响add/set) 字段列表，添加/更新时为这些字段填值无效（但不报错）。</p>
<p class="var"><strong>@var <a id="AccessControl::$readonlyFields2">AccessControl::$readonlyFields2</a></strong>  ?=[]  (影响set操作) 字段列表，更新时对这些字段填值无效。</p>
<p class="var"><strong>@var <a id="AccessControl::$hiddenFields">AccessControl::$hiddenFields</a></strong>  ?= []  (for get/query) 隐藏字段列表。默认表中所有字段都可返回。一些敏感字段不希望返回的可在此设置。</p>
<p class="var"><strong>@var <a id="AccessControl::$requiredFields">AccessControl::$requiredFields</a></strong>  ?=[] (for add/set) 字段列表。添加时必须填值；更新时不允许置空。</p>
<p class="var"><strong>@var <a id="AccessControl::$requiredFields2">AccessControl::$requiredFields2</a></strong>  ?=[] (for set) 字段列表。更新时不允许设置空。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onQuery">AccessControl::onQuery</a></strong> () (for get/query)  用于对查询条件进行设定。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onValidate">AccessControl::onValidate</a></strong> ()  (for add/set). 验证添加和更新时的字段，或做自动补全(AutoComplete)工作。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onValidateId">AccessControl::onValidateId</a></strong> () (for get/set/del) 用于对id字段进行检查。比如在del时检查用户是否有权操作该记录。可在其中设置$this->id。</p>
<p>上节例子中，用户可以操作系统的所有订单。</p>
<p>现在我们到设计文档中，将接口API设计如下：</p>
<pre><code>== 订单接口 ==

添加订单：
Ordr.add()(amount) -&gt; id

查看订单：
Ordr.query() -&gt; tbl(id, userId, status, amount)
Ordr.get(id)

权限：AUTH_GUEST

应用逻辑
- 用户只能添加(add)、查看(get/query)订单，不可修改(set)、删除(del)订单
- 用户只能查看(get/query)属于自己的订单。
- 用户在添加订单时，必须设置amount字段，不必（也不允许）设置id, userId, status这些字段。
  服务器应将userId字段自动设置为该用户编号，status字段自动设置为"CR"（已创建）</code></pre>
<p>为实现以下逻辑，上面例子中代码可修改为：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $allowedAc = ["get", "query", "add"];
    protected $requiredFields = ["amount"];
    protected $readonlyFields = ["status", "userId"];

    protected function onQuery()
    {
        $userId = $_SESSION["uid"];
        $this-&gt;addCond("t0.userId={$userId}");
    }

    protected function onValidate()
    {
        if ($this-&gt;ac == "add") {
            $userId = $_SESSION["uid"];
            $_POST["userId"] = $userId;
            $_POST["status"] = "CR";
        }
    }
}</code></pre>
<p>说明：</p>
<ul>
<li>使用$allowedAc设定了该对象接口允许的操作。</li>
<li>使用$requiredFields与$readonlyFields设定了添加时必须指定或不可指定的字段。由于&quot;id&quot;字段默认就是不可添加/更新的，所以不必在这里指定。</li>
<li>在onQuery中，对用户可查看的订单做了限制：只允许访问自己的订单。这里通过添加了条件实现。<br />
$_SESSION[&quot;uid&quot;]是在用户登录后设置的，可参考login接口定义(api_login).</li>
<li>在onValidate中，对添加操作时的字段做自动补全。由于添加和更新都会走这个接口，所以用 $this-&gt;ac 判断只对添加操作时补全。<br />
由于添加和更新操作的具体字段都通过 $_POST 来传递，故直接设置 $_POST中的相应字段即可。</li>
</ul>
<h4 id="AccessControl-2 虚拟字段(VCol)">2 虚拟字段(VCol)</h4>
<p class="var"><strong>@var <a id="AccessControl::$vcolDefs">AccessControl::$vcolDefs</a></strong>  (for get/query) 定义虚拟字段</p>
<p>常用于展示关联表字段、统计字段等。<br />
在query,get操作中可以通过res参数指定需要返回的每个字段，这些字段可能是普通列名(col)/虚拟列名(vcol)/子对象(subobj)名。</p>
<h5 id="AccessControl-2.1 关联字段">2.1 关联字段</h5>
<p>例如，在订单列表中需要展示用户名字段。设计文档中定义接口：</p>
<pre><code>Ordr.query() -&gt; tbl(id, dscr, ..., userName?, userPhone?, createTm?)</code></pre>
<p>query接口的&quot;...&quot;之后就是虚拟字段。后缀&quot;?&quot;表示是非缺省字段，即必须在&quot;res&quot;参数中指定才会返回，如：</p>
<pre><code>Ordr.query(res="*,userName")</code></pre>
<p>在cond中可以直接使用虚拟字段，不管它是否在res中指定，如</p>
<pre><code>Ordr.query(cond="userName LIKE 'jian%'", res="id,dscr")</code></pre>
<p>通过设置$vcolDefs实现这些关联字段：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["u.name AS userName", "u.phone AS userPhone"],
            "join" =&gt; "INNER JOIN User u ON u.id=t0.userId",
            // "default" =&gt; false, // 指定true表示Ordr.query在不指定res时或res中以"*"开头时将默认会返回该字段。
        ],
        [
            "res" =&gt; ["log_cr.tm AS createTm"],
            "join" =&gt; "LEFT JOIN OrderLog log_cr ON log_cr.action='CR' AND log_cr.orderId=t0.id",
        ]
    ]
}</code></pre>
<ul>
<li>default: 默认虚拟字段，示例：&quot;<em>,picCnt&quot;表示返回t0表所有字段加默认虚拟字段，再加指定的picCnt字段；而&quot;t0.</em>,picCnt&quot;返回t0表的所有字段以及picCnt字段，不含默认虚拟字段；<br />
对移动端应用接口，尽量不使用default=true，让前端自由控制。对管理平台接口，列表页和详情对话框上均显示的虚拟字段设置为default=true比较方便，因为链接方式打开详情对话框时，只能直接调用&quot;Obj.query&quot;接口，不方便指定res参数。</li>
</ul>
<p>注意：如果需要在程序中引入某个关联表定义，可以调用addVCol显式指定，例如：</p>
<pre><code>$this-&gt;addVcol("userName"); // 在SQL语句中添加SELECT userName ... JOIN User
// 如果不想影响SELECT字段:
$this-&gt;addVcol("userName", false, "-"); // 只在SQL语句中添加 JOIN User</code></pre>
<h5 id="AccessControl-2.2 关联字段依赖">2.2 关联字段依赖</h5>
<p>假设设计有“订单评价”对象，它会与“订单对象”相关联：</p>
<pre><code>@Rating: id, orderId, content</code></pre>
<p>表间的关系为：</p>
<pre><code>订单评价Rating(orderId) &lt;-&gt; 订单Ordr(userId) &lt;-&gt; 用户User</code></pre>
<p>现在要为Rating表增加关联字段 &quot;Ordr.dscr AS orderDscr&quot;, 以及&quot;User.name AS userName&quot;, 设计接口为：</p>
<pre><code>Rating.query() -&gt; tbl(id, orderId, content, ..., orderDscr?, userName?)
注意：userName字段不直接与Rating表关联，而是通过Ordr表桥接。</code></pre>
<p>实现时，只需在vcolDefs中使用require指定依赖字段：</p>
<pre><code>class AC1_Rating extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["o.dscr AS orderDscr", "o.userId"],
            "join" =&gt; "INNER JOIN Ordr o ON o.id=t0.orderId",
        ],
        [
            "res" =&gt; ["u.name AS userName"],
            "join" =&gt; "INNER JOIN User u ON o.userId=u.id",
            "require" =&gt; "userId", // *** 定义依赖，如果要用到res中的字段如userName，则自动添加userId字段引入的表关联。
            // 这里指向orderDscr也可以，一般习惯上指向关联的字段。
        ],
    ];
}</code></pre>
<p>使用require, 框架可自动将Ordr表作为中间表关联进来。<br />
如果没有require定义，以下调用</p>
<pre><code>Rating.query(res="*,orderDscr,userName")</code></pre>
<p>也不会出问题，因为在userName前指定了orderDscr，框架可自动引入相关表。而以下查询就会出问题：</p>
<pre><code>Rating.query(res="*,userName")
或
Rating.query(res="*,userName,orderDscr")</code></pre>
<h5 id="AccessControl-2.3 计算字段">2.3 计算字段</h5>
<p>示例：管理端应用在查询订单时，需要订单对象上有一个原价字段：</p>
<pre><code>Ordr.query() -&gt; tbl(..., amount2)
amount2:: 原价，通过OrderItem中每个项目重新计算累加得到，不考虑打折优惠。</code></pre>
<p>可实现为：</p>
<pre><code>class AC0_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["(SELECT SUM(qty*ifnull(price2,0)) FROM OrderItem WHERE orderId=t0.id) AS amount2"],
        ]
    ];
}</code></pre>
<h5 id="AccessControl-2.4 子表压缩字段">2.4 子表压缩字段</h5>
<p>除了使用<a href="#AccessControl::$subobj">子表</a>, 对于简单的情况，也可以设计为将子表压缩成一个虚拟字段，在Query操作时直接返回。</p>
<p>示例：OrderItem是Ordr对象的一个子表，现在想在查询Ordr对象列表时，返回OrderItem的相关信息。<br />
这就要把一张子表压缩成一个字段。我们使用List来描述这种压缩字段的格式：表中每行以&quot;,&quot;分隔，行中每个字段以&quot;:&quot;分隔。<br />
利用List，可将接口设计为：</p>
<pre><code>Ordr.query() -&gt; tbl(..., itemsInfo)
itemsInfo:: List(name, price, qty). 例如"洗车:25:1,换轮胎:380:2", 表示两行记录，每行3个字段。注意字段内容中不可出现":", ","这些分隔符。</code></pre>
<p>子表压缩是一种特殊的计算字段，可实现如下：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["(SELECT group_concat(concat(oi.name, ':', oi.price, ':', oi.qty)) FROM OrderItem oi WHERE oi.orderId=t0.id) itemsInfo"] 
        ],
        ...
    ]
}</code></pre>
<p>注意：计算字段，包括子表压缩字段都是很消耗性能的。</p>
<h5 id="AccessControl-2.5 自定义字段">2.5 自定义字段</h5>
<p>假设有张虚拟表Task, 它没有存储在数据库中, 另一张表UserTaskLog关联到它。在设计文档中定义如下:</p>
<pre><code>@UserTaskLog: id, userId, taskId
@Conf::$taskTable: id, type, name
(关联： UserTaskLog(taskId) &lt;-&gt; Conf::$taskTable )

提供查询接口：
UserTaskLog.query() -&gt; tbl(id, taskId, ..., taskName)
taskName:: 由关联表的taskTable.name字段得到。</code></pre>
<p>实现中，在代码中直接定义Task表：</p>
<pre><code>class Conf
{
    static $taskTable = [
        ["id" =&gt; 1, "type"=&gt;"invite", "name" =&gt; "邀请5个用户注册"],
        ["id" =&gt; 2, "type"=&gt;"invite", "name" =&gt; "邀请10个用户注册"],
    ];
}</code></pre>
<p>通过在vcolDefs的join属性指定一个函数，可以实现返回taskName字段：</p>
<pre><code>function getTaskName(&amp;$row)
{
    foreach (Conf::$taskTable as $task) {
        if ($row["taskId"] == $task["id"]) {
            $row["taskName"] = $task["name"];
        }
    }
}

class AC1_UserTaskLog extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["taskName"],
            "join" =&gt; getTaskName
        ]
    ];
}</code></pre>
<p>注意:</p>
<ul>
<li>自定义字段只限于对query/get的最终结果集进行操作</li>
<li>自定义字段不能用于设置cond条件.</li>
</ul>
<h5 id="AccessControl-2.6 flags和props字段">2.6 flags和props字段</h5>
<p>（试验功能）<br />
框架支持两个特别的数据库字段flags和props，并可将它们拆解为flag_xxx或prop_xxx格式。<br />
例如，在订单表上定义：</p>
<pre><code>@Ordr: id, flags

- flags: EnumList(g-go-员工已出发, v-visited-已回访, r-reviewed-已人工校验过, i-imported-是自动导入的订单)。例如, 值"gv"表示有"g"标志和"v"标志。</code></pre>
<p>要查询已回访或未回访的订单，可以用：</p>
<pre><code>Ordr.query(cond="flag_v=1/0", res="id,flags") -&gt; tbl(id, flags, ..., flag_g?, flag_v?, ...)</code></pre>
<p>注意：返回字段将自动根据flags的值增加诸如flag_g这样的字段，值为0或1；但res参数中不可指定flag_v这样的虚拟字段。</p>
<p>要设置或清除已回访标志&quot;g&quot;，可以用：</p>
<pre><code>Ordr.set(id=1)(flag_g=1/0)</code></pre>
<p>注意：不可一次设置多个flag。如果需要这样，则应直接设置flags字段。</p>
<p>props字段与之类似，flags字段中一个标志是一个字母，而props字段的标志以一个词，因而多个标志以空格隔开。<br />
假设Ordr表中定义了props字段，且某条记录的值为&quot;go visited&quot;，则该记录返回字段会有 <code>{ prop_go:1, prop_visited:1 }</code></p>
<p>也可以进行设置和清除，并可与flags一起用，如：</p>
<pre><code>Ordr.set(id=1)(prop_go=1/0, flag_v=1/0)</code></pre>
<h5 id="AccessControl-2.7 外部虚拟字段(ExtVCol)">2.7 外部虚拟字段(ExtVCol)</h5>
<p>(v5.2) 增加“外部虚拟字段”用于创建嵌套查询。</p>
<h6 id="AccessControl-2.7.1 嵌套查询">2.7.1 嵌套查询</h6>
<p>示例：下面已定义y, m两个虚拟字段，现在基于y和m再创建新的虚拟字段ym，可以这样：</p>
<pre><code>$vcolDefs = [
    [
        "res" =&gt; ["year(tm) y", "month(tm) m"],
    ],
    [
        "res" =&gt; ["concat(y, '-', m) ym"],
        // 用isExt指定这是外部虚拟字段
        "isExt" =&gt; true,
        // 用require指定所有依赖的内层字段
        "require" =&gt; 'y,m'
    ]
]</code></pre>
<p>query/get接口生成的查询语句大致为：</p>
<pre><code>SELECT t0.*, concat(y, '-', m) ym
FROM (
    SELECT t0.id,year(tm) y,month(tm) m FROM ApiLog t0
    WHERE ...
) t0</code></pre>
<p>注意：即使在调用接口时用res参数指定了返回字段，外部虚拟字段依赖的内部字段也将返回。比如query(res=&quot;id,ym&quot;)返回<code>tbl(id,y,m,ym)</code>.</p>
<p>注意：设置require或res属性时，如果依赖的是表的字段，应加表名，如&quot;t0.tm, t1.name&quot;，如果是虚拟字段，则不加表名，如&quot;y,m&quot;。</p>
<p>注意：关于时间统计相关的虚拟字段，一般通过tmCols函数来指定：</p>
<pre><code>function __construct() {
    $this-&gt;vcolDefs[] = [ "res" =&gt; tmCols() ];
}</code></pre>
<h6 id="AccessControl-2.7.2 关联子查询优化">2.7.2 关联子查询优化</h6>
<p><strong>外部虚拟字段还常常用于优化SELECT语句中关联子查询性能。框架将自动识别关联子查询，并使用嵌套查询机制来优化性能。</strong></p>
<p>如果一个虚拟字段，它的res中定义有关联子查询，在query操作时可能性能很差，当：<br />
排序字段(orderby)不是主表字段；<br />
或orderby虽然是主表字段（甚至是索引），但查询引擎的查询计划不佳，也会导致特别慢。（这种情况下，测试时可强制指定索引，比如在from t0后加上force index(primary)，可以大幅优化。）</p>
<p>示例：对ApiLog表有虚拟字段sesCnt，它使用关联子查询，定义如下：</p>
<pre><code>$vcolDefs = [
    [
        // 可作为“外部虚拟字段”来优化
        "res" =&gt; ["(select count(*) from ApiLog t1 where t1.ses=t0.ses) sesCnt"]
    ],
    [
        // 普通虚拟字段，将在示例中用于orderby
        "res" =&gt; ["u.name AS userName", "u.phone AS userPhone"],
        "join" =&gt; "INNER JOIN User u ON u.id=t0.userId"
    ]
]</code></pre>
<p>未做优化时，query(orderby=userName)查询语句如下：</p>
<pre><code>SELECT t0.*, (select count(*) from ApiLog t1 where t1.ses=t0.ses) sesCnt
FROM ApiLog t0
JOIN User ...
ORDER BY u.name
LIMIT 0,20</code></pre>
<p>当ORDER-BY不是主表ApiLog的字段时，或虽然是主表字段但数据库的查询引擎判断失误（此处不可预料），<br />
都可能导致查询计划中将会把虚拟字段全部计算出来后再排序，导致巨慢。（实测2万行数据，查询20行数据需要16秒）</p>
<p>优化策略是使用嵌套查询，将sesCnt字段放到外层查询：</p>
<pre><code>SELECT t0.*, (select count(*) from ApiLog t1 where t1.ses=t0.ses) sesCnt
FROM (
    SELECT t0.*
    FROM ApiLog t0
    JOIN User ...
    ORDER BY u.name
    LIMIT 0,20
) t0</code></pre>
<p>这样只需要对最终结果20条数据计算虚拟字段。<br />
由于出现了外层和内层两层SQL，我们将外层的虚拟字段称为外部虚拟字段。</p>
<p>效果：ApiLog仅20000行数据，优化前查询一次16秒，优化后降低到0.2s。</p>
<p>注意：自动优化只处理res中只有一个元素且未指定join条件的情况，并且会自动识别出依赖内层t0.ses字段。<br />
如果自动处理或识别有误，可手工设置isExt和require属性，比如：</p>
<pre><code>[
    "res" =&gt; ["(select count(*) from ApiLog t1 where t1.ses=t0.ses and t0.userId is not null) sesCnt"],
    "isExt" =&gt; true,
    "require" =&gt; "t0.ses,t0.userId"
]</code></pre>
<p>上面require属性指定内层查询应暴露给外层的字段，如果有多个可用逗号分隔（自动优化只能处理一个）。<br />
注意res中的t0指的是内层查询的结果表，名称固定为t0; 而require中的表指的是内层查询内部的表。</p>
<p>注意：使用外部虚拟字段时，将导致require中的字段被添加到最终结果集。例如上面例子中的&quot;t0.ses,t0.userId&quot;字段会被添加到最终结果集。</p>
<p>注意：如果想禁止优化，可手工设置vcolDef的isExt属性为false：</p>
<pre><code>[
    "res" =&gt; ["(select count(*) from ApiLog t1 where t1.ses=t0.ses) sesCnt"],
    "isExt" =&gt; false
]</code></pre>
<h4 id="AccessControl-3 子表">3 子表</h4>
<p class="var"><strong>@var <a id="AccessControl::$subobj">AccessControl::$subobj</a></strong>  (for get/query) 定义子表</p>
<p>subobj: { name =&gt; {sql, default?=false, wantOne?=false, force?=false} }</p>
<p>设计接口：</p>
<pre><code>Ordr.get() -&gt; {id, ..., @orderLog}
orderLog:: {id, tm, dscr, ..., empName} 订单日志子表。</code></pre>
<p>实现：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $subobj = [
        "orderLog" =&gt; ["sql"=&gt;"SELECT ol.*, e.name AS empName FROM OrderLog ol LEFT JOIN Employee e ON ol.empId=e.id WHERE orderId=%d", "default"=&gt;false, "wantOne"=&gt;false],
    ];
}</code></pre>
<p>子表和虚拟字段类似，支持get/query操作，执行指定的SQL语句作为结果。结果以一个数组返回[{id, tm, ...}]。</p>
<ul>
<li>sql: 子表查询语句，其中应包含用&quot;field=%d&quot;这样语句来定义与主表id字段的关系。<br />
(v5.1)为了优化query接口，避免每一行分别查一次子表，查询语句会被改为&quot;field IN (...)&quot;的形式。</li>
<li>default: 与虚拟字段(vcolDefs)上的&quot;default&quot;选项一样，表示当&quot;res&quot;参数以&quot;<em>&quot;开头(比如`res=&quot;</em>,picCnt&quot;`)或未指定时，是否默认返回该字段。</li>
<li>wantOne: 如果为true, 则结果以一个对象返回即 {id, tm, ...}, 适用于主表与子表一对一的情况。</li>
<li>force: (v5.1) 如果sql中没有与主表的关联即没有包含&quot;field=%d&quot;，应指定force=true，否则在query接口中会当作语句错误。</li>
</ul>
<h4 id="AccessControl-4 操作完成回调">4 操作完成回调</h4>
<p class="fn"><strong>@fn <a id="AccessControl::onAfter">AccessControl::onAfter</a></strong> (&$ret)  (for all) 操作完成时的回调。可修改操作结果ret。</p>
<p>如果要对get/query结果中的每行字段进行设置，应重写回调 onHandleRow.<br />
有时使用 onAfterActions 就近添加逻辑更加方便。</p>
<p>注意：对于query接口，无论返回哪种格式（如默认的压缩表、或用fmt参数指定list/csv/txt/excel等格式），在onAfter或onAfterActions中都是对象数组的格式，如：</p>
<pre><code>[ [ "id"=&gt;100, "name"=&gt;"name1"], ["id"=&gt;101", "name"=&gt;"name2"], ... ]</code></pre>
<p class="var"><strong>@var <a id="AccessControl::$onAfterActions">AccessControl::$onAfterActions</a></strong>  =[].  onAfter的替代方案，更易使用，便于与接近的逻辑写在一起。</p>
<p class="var"><strong>@var <a id="AccessControl::$id">AccessControl::$id</a></strong>   get/set/del时指定的id, 或add后返回的id.</p>
<p>例如，添加订单时，自动添加一条日志，可以用：</p>
<pre><code>protected function onValidate()
{
    if ($this-&gt;ac == "add") {
        ... 
        // 可修改$ret
        $this-&gt;onAfterActions[] = function (&amp;$ret) use ($logAction) {
            $orderId = $this-&gt;id;
            dbInsert("OrderLog", [
                "orderId" =&gt; $orderId,
                "action" =&gt; "CR",
                "tm" =&gt; date(FMT_DT)  // 或用mysql表达式 ["now()"]
            ]);
        };
    }
}</code></pre>
<p>与onAfter类似，加到onAfterActions集合中的函数，如果要修改返回数据，只要在函数参数中声明<code>&amp;$ret</code>就可以修改它了。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onHandleRow">AccessControl::onHandleRow</a></strong> (&$rowData) (for get/query) 在onAfter之前运行，用于修改行中字段。</p>
<h4 id="AccessControl-5 其它">5 其它</h4>
<h5 id="AccessControl-5.1 编号自定义生成">5.1 编号自定义生成</h5>
<p class="fn"><strong>@fn <a id="AccessControl::onGenId">AccessControl::onGenId</a></strong> () (for add) 指定添加对象时生成的id. 缺省返回0表示自动生成.</p>
<p>示例：为避免ID暴露业务数据，可跳号生成ID，比如造成单量放大5-20倍的假象:</p>
<pre><code>protected function onGenId()
{
    $id = queryOne("SELECT MAX(id) FROM Ordr");
    return $id + rand(5, 20);
}</code></pre>
<p>这个示例在超大并发时可能会有ID重复的风险且性能不高，更好的方法是向一个ID生成器服务发起请求。</p>
<h5 id="AccessControl-5.2 缺省排序">5.2 缺省排序</h5>
<p class="var"><strong>@var <a id="AccessControl::$defaultSort">AccessControl::$defaultSort</a></strong>  ?= "t0.id" (for query)指定缺省排序.</p>
<p>示例：Video对象默认按id倒序排列：</p>
<pre><code>class AC_Video extends AccessControl 
{
    protected $defaultSort = "t0.id DESC";
    ...
}</code></pre>
<h5 id="AccessControl-5.3 缺省输出字段列表">5.3 缺省输出字段列表</h5>
<p class="var"><strong>@var <a id="AccessControl::$defaultRes">AccessControl::$defaultRes</a></strong>  (for query)指定缺省输出字段列表. 如果不指定，则为"*", 即 "t0.*" 加默认虚拟字段(指定default=true的字段)</p>
<h5 id="AccessControl-5.4 最大每页数据条数">5.4 最大每页数据条数</h5>
<p class="fn"><strong>@fn <a id="AccessControl::getMaxPageSz">AccessControl::getMaxPageSz</a></strong> ()  (for query) 取最大每页数据条数。为非负整数。</p>
<p class="var"><strong>@var <a id="AccessControl::$maxPageSz">AccessControl::$maxPageSz</a></strong>  ?= 1000 (for query) 指定最大每页数据条数。值为负数表示取PAGE_SZ_LIMIT值.</p>
<p>前端通过 {obj}.query(pagesz)来指定每页返回多少条数据，缺省是20条，最高不可超过100条。当指定为负数时，表示按最大允许值=min($maxPageSz, PAGE_SZ_LIMIT)返回。<br />
PAGE_SZ_LIMIT目前定为10000条。如果还不够，一定是应用设计有问题。</p>
<p>如果想返回每页超过100条数据，必须在后端设置，如：</p>
<pre><code>class MyObj extends AccessControl
{
    protected $maxPageSz = 2000; // 最大允许返回2000条
    // protected $maxPageSz = -1; // 最大允许返回 PAGE_SZ_LIMIT 条
}</code></pre>
<p class="var"><strong>@var <a id="PAGE_SZ_LIMIT">PAGE_SZ_LIMIT</a></strong>  =10000</p>
<h5 id="AccessControl-5.5 虚拟表和视图">5.5 虚拟表和视图</h5>
<p>假如要对ApiLog进行过滤，只查询管理端的写操作。实现以下接口：</p>
<pre><code>EmpLog.query() -&gt; tbl(id, tm, userId, ac, req, res, reqsz, ressz, empName?, empPhone?)</code></pre>
<p>一种办法可以在后台定义一个视图，如:</p>
<pre><code>CREATE VIEW EmpLog AS
SELECT t0.id, tm, userId, ac, req, res, reqsz, ressz, e.name empName, e.phone empPhone
FROM ApiLog t0
LEFT JOIN Employee e ON e.id=t0.userId
WHERE t0.app='emp-adm' AND t0.userId IS NOT NULL
ORDER BY t0.id DESC</code></pre>
<p>然后可将该视图当作表一样查询（但不可更新），如：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
}</code></pre>
<p>这样就可以实现上述接口了。</p>
<p>另一种办法是直接使用AccessControl创建虚拟表，代码如下：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
    protected $table = 'ApiLog';
    protected $defaultSort = "t0.id DESC";
    protected $defaultRes = "id, tm, userId, ac, req, res, reqsz, ressz, empName, empPhone";
    protected $vcolDefs = [
        [
            "res" =&gt; ["e.name AS empName", "e.phone AS empPhone"],
            "join" =&gt; "LEFT JOIN Employee e ON e.id=t0.userId"
        ]
    ];

    protected function onQuery() {
        $this-&gt;addCond("t0.app='emp-adm' and t0.userId IS NOT NULL");
    }
}</code></pre>
<p>与上例相比，它不仅无须在数据库中创建视图，还也可以进行更新。<br />
其要点是：</p>
<ul>
<li>重写 AccessControl::$table</li>
<li>重写 AccessControl::$defaultRes</li>
<li>用addCond添加缺省查询条件</li>
</ul>
<p>table也可以指定为子表(即视图)，例如上例也可以这样实现，省去onQuery中的实现：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
    // 注意：子查询要加括号括起来
    protected $table = "(SELECT * FROM ApiLog t0 WHERE t0.app='emp-adm' and t0.userId IS NOT NULL)";
    protected $defaultSort = "t0.id DESC";
    protected $defaultRes = "id, tm, userId, ac, req, res, reqsz, ressz, empName, empPhone";
    protected $vcolDefs = [
        [
            "res" =&gt; ["e.name AS empName", "e.phone AS empPhone"],
            "join" =&gt; "LEFT JOIN Employee e ON e.id=t0.userId"
        ]
    ];
}</code></pre>
<p>甚至可将整个SQL子查询封在table中：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
    protected $table = "(SELECT t0.id, tm, userId, ac, req, res, reqsz, ressz, e.name AS empName, e.phone AS empPhone </code></pre>
<p>FROM ApiLog t0<br />
LEFT JOIN Employee e ON e.id=t0.userId<br />
WHERE t0.app='user' and t0.userId IS NOT NULL<br />
ORDER BY t0.id DESC)&quot;;<br />
}</p>
<h5 id="AccessControl-5.6 query接口输出格式">5.6 query接口输出格式</h5>
<p>query接口支持fmt参数：</p>
<ul>
<li>list: 生成<code>{ @list, nextkey?, total? }</code>格式，而非缺省的 <code>{ @h, @d, nextkey?, total? }</code>格式</li>
<li>csv/txt/excel: 导出文件，注意为了避免分页，调用时可设置较大的pagesz值。
<ul>
<li>csv: 逗号分隔的文件，utf8编码。</li>
<li>excel: 逗号分隔的文件，gb18030编码以便excel可直接打开不会显示中文乱码。</li>
<li>txt: 制表分隔的文件, utf8编码。</li>
</ul></li>
</ul>
<p>TODO: 可加一个系统参数<code>_enc</code>表示输出编码的格式。</p>
<h5 id="AccessControl-5.7 distinct查询">5.7 distinct查询</h5>
<p>如果想生成<code>SELECT DISTINCT t0.a, ...</code>查询，<br />
当在AccessControl外部时，可以设置</p>
<pre><code>setParam("distinct", 1);</code></pre>
<p>如果是在AccessControl子类中，可以设置</p>
<pre><code>$this-&gt;sqlConf["distinct"] =1;</code></pre>
<h5 id="AccessControl-5.8 枚举支持及自定义字段处理">5.8 枚举支持及自定义字段处理</h5>
<p>(版本5.0)</p>
<p class="var"><strong>@var <a id="AccessControl::$enumFields">AccessControl::$enumFields</a></strong>  {field => map/fn($val) }支持处理枚举字段，或自定义处理。</p>
<p>作为比onHandleRow/onAfterActions等更易用的工具，enumFields可对返回字段做修正。例如，想要对返回的status字段做修正，如&quot;CR&quot;显示为&quot;Created&quot;，可设置：</p>
<pre><code>$this-&gt;enumFields["status"] = ["CR"=&gt;"Created", "CA"=&gt;"Cancelled"];</code></pre>
<p>也可以设置为自定义函数，如：</p>
<pre><code>$map = ["CR"=&gt;"Created", "CA"=&gt;"Cancelled"];
$this-&gt;enumFields["status"] = function($v) use ($map) {
    if (array_key_exists($v, $map))
        return $v . "-" . $map[$v];
    return $v;
};</code></pre>
<p>此外，枚举字段可直接由请求方通过res参数指定描述值，如：</p>
<pre><code>Ordr.query(res="id, status =CR:Created;CA:Cancelled")
或指定alias:
Ordr.query(res="id 编号, status 状态=CR:Created;CA:Cancelled")</code></pre>
<p>(版本5.1)<br />
设置enumFields也支持逗号分隔的枚举列表，比如字段值为&quot;CR,CA&quot;，实际可返回&quot;Created,Cancelled&quot;。</p>
<p>(v5.2) 导出文件时，处理字段格式</p>
<p>在导出报表时，常常需要处理字段格式，例如，虚拟子表字段inv定义为：<code>[{itemId,qty,itemName}]</code></p>
<pre><code>protected $subobj = [
    "inv" =&gt; ["sql"=&gt;"SELECT itemId,qty,i.name itemName FROM Inv LEFT JOIN Item i ON i.id=Inv.itemId WHERE couponId=%d"]
];</code></pre>
<p>默认导出文件时值会处理成 &quot;1000:1.00:商品1,1001:2.00:商品2&quot; 这种格式，现在希望导出格式如&quot;商品1,商品2(2件)&quot;，可处理该字段如下：<br />
(写在onQuery或onInit回调中均可)</p>
<pre><code>protected function onQuery() {
    if ($this-&gt;isFileExport()) {
        $this-&gt;enumFields["inv"] = function($v) {
            if (is_array($v)) {
                $v = join(',', array_map(function ($e) {
                    if ($e['qty'] != 1.0)
                        return $e['itemName'] . '(' . doubleval($e['qty']) . '件)';
                    else
                        return $e['itemName'];
                }, $v));
            }
            return $v;
        };
    }
}</code></pre>
<h4 id="AccessControl-6 批量更新(setIf)和批量删除(delIf)">6 批量更新(setIf)和批量删除(delIf)</h4>
<p>(v5.1) 以Ordr对象为例，要支持根据条件批量更新或删除：</p>
<pre><code>Ordr.setIf(cond)(field1=value1, field2=value2, ...)
Ordr.delIf(cond)</code></pre>
<p>在cond中，除了使用基本字段，还可以像query接口一样使用虚拟字段来查询，框架自动join相关表。</p>
<p>示例：对具有PERM_MGR权限的员工，登录后允许批量更新和批量删除：</p>
<pre><code>class AC2_Ordr extends AccessControl
{
    function api_delIf() {
        checkAuth(PERM_MGR);
        return parent::api_delIf();
    }
    function api_setIf() {
        checkAuth(PERM_MGR);
        $this-&gt;checkSetFields(["status", "cmt"]);
        return parent::api_setIf();
    }
}</code></pre>
<p>setIf接口会检测readonlyFields及readonlyFields2中定义的字段不可更新。<br />
也可以直接用checkSetFields指定哪些字段允许更新。</p></div>
<div class="block">
<h2 id="AccessControl::addRes">@fn AccessControl::addRes($res, $analyzeCol=true)</h2>
<p>定义新的虚拟字段，并添加到get/query接口的返回字段中。<br />
如果要引入已有的虚拟字段，应调用addVCol。</p>
<p>注意: </p>
<ul>
<li>analyzeCol=true时, 注册到对象的虚拟字段中。</li>
<li>addRes(&quot;col+1 as col1&quot;, false); -- 简单地新定义一个计算列, as可省略</li>
</ul>
<p class="see"><strong>@see <a href="#AccessControl::addCond">AccessControl::addCond</a></strong>  其中有示例</p>
<p class="see"><strong>@see <a href="#AccessControl::addVCol">AccessControl::addVCol</a></strong>  添加已定义的虚拟列。</p></div>
<div class="block">
<h2 id="AccessControl::addCond">@fn AccessControl::addCond($cond, $prepend=false, $fixUserQuery=false)</h2>
<p class="param"><strong>@param $prepend</strong>  为true时将条件排到前面。</p>
<p class="param"><strong>@param $fixUserQuery</strong>  设置为true，用于自动处理虚拟字段，这时不允许复杂查询。</p>
<p>调用多次addCond时，多个条件会依次用&quot;AND&quot;连接起来。</p>
<p>添加查询条件。<br />
示例：假如设计有接口：</p>
<pre><code>Ordr.query(q?) -&gt; tbl(..., payTm?)
参数：
q:: 查询条件，值为"paid"时，查询10天内已付款的订单。且结果会多返回payTm/付款时间字段。</code></pre>
<p>实现时，在onQuery中检查参数&quot;q&quot;并定制查询条件：</p>
<pre><code>protected function onQuery()
{
    // 限制只能看用户自己的订单
    $uid = $_SESSION["uid"];
    $this-&gt;addCond("t0.userId=$uid");

    $q = param("q");
    if (isset($q) &amp;&amp; $q == "paid") {
        $validDate = date("Y-m-d", strtotime("-9 day"));
        $this-&gt;addRes("olpay.tm payTm");
        $this-&gt;addJoin("INNER JOIN OrderLog olpay ON olpay.orderId=t0.id");
        $this-&gt;addCond("olpay.action='PA' AND olpay.tm&gt;'$validDate'");
    }
}</code></pre>
<p>上例在处理&quot;q&quot;参数时，临时引入了关联表。如果关联表已在vcolDefs中定义过，可以用addVCol直接引入：</p>
<pre><code>protected $vcolDefs = [
    [
        "res" =&gt; ["olpay.tm payTm"],
        "join" =&gt; "INNER JOIN OrderLog olpay ON olpay.orderId=t0.id"
    ]
];
protected function onQuery()
{
    $q = param("q");
    if (isset($q) &amp;&amp; $q == "paid") {
        $validDate = date("Y-m-d", strtotime("-9 day"));
        // 注意：要添加虚拟字段用addVCol，不是addRes
        $this-&gt;addVCol("payTm");
        // 注意：addCond中不可直接使用payTm，要用原始定义olpay.tm。(下面会讲怎样直接在cond中用payTm)
        $this-&gt;addCond("olpay.action='PA' AND olpay.tm&gt;'$validDate'");
    }
}</code></pre>
<p>关于fixUserQuery=true:</p>
<p>默认后端可以添加任何形式的SQL条件，但是如果其中含有虚拟字段，如果它尚未加到res查询结果中时，查询就会出错（无法识别这个字段）。<br />
设置fixUserQuery=true后，就会将该条件当作用户查询(UserQuery)来处理，即相当于query接口传入的cond字段，其中的虚拟字段会自动处理避免出错。<br />
但用户查询条件是受限的，比如不允许各种子查询，也不允许使用各种SQL函数（count/sum/avg等少量聚合函数除外）。</p>
<p>仍用上面示例：</p>
<pre><code>// 在cond中使用payTm虚拟字段，可自动解析和引入它的定义
$this-&gt;addCond("olpay.action='PA' AND payTm&gt;'$validDate'", false, true);</code></pre>
<p>这相当于调用：</p>
<pre><code>$this-&gt;addVCol("payTm", false, "-"); // 引入定义但并不加到SELECT字段中
$this-&gt;addCond("olpay.action='PA' AND olpay.tm&gt;'$validDate'");</code></pre>
<p class="see"><strong>@see <a href="#AccessControl::addRes">AccessControl::addRes</a></strong> </p>
<p class="see"><strong>@see <a href="#AccessControl::addJoin">AccessControl::addJoin</a></strong> </p></div>
<div class="block">
<h2 id="AccessControl::addJoin">@fn AccessControl::addJoin(joinCond)</h2>
<p>添加Join条件.</p>
<p class="see"><strong>@see <a href="#AccessControl::addCond">AccessControl::addCond</a></strong>  其中有示例</p></div>
<div class="block">
<h2 id="AccessControl::addVCol">@fn AccessControl::addVCol($col, $ignoreError=false, $alias=null)</h2>
<p class="param"><strong>@param $col</strong>  必须是一个英文词, 不允许"col as col1"形式; 该列必须在 vcolDefs 中已定义.</p>
<p class="param"><strong>@param $alias</strong>  列的别名。可以中文. 特殊字符"-"表示只添加join/cond等定义，并不将该字段加到输出字段中。</p>
<p class="return"><strong>@return Boolean</strong>  T/F</p>
<p>引入一个已有的虚拟字段及其相应关联表，例如之前在vcolDefs中定义过虚拟字段<code>createTm</code>:</p>
<pre><code>// 引入createTm定义及关联表，且在最终输出中添加createTm列
$this-&gt;addVCol("createTm"); 

// 只引入createTm字段的关联表，不影响最终输出字段
$this-&gt;addVCol("createTm", false, "-");</code></pre>
<p class="see"><strong>@see <a href="#AccessControl::addRes">AccessControl::addRes</a></strong> </p></div>
<div class="block">
<h2 id="AccessControl::checkSetFields">@fn AccessControl::checkSetFields($allowedFields)</h2>
<p>e.g.<br />
function onValidate()<br />
{<br />
if ($this-&gt;ac == &quot;set&quot;)<br />
$this-&gt;checkSetFields([&quot;status&quot;, &quot;cmt&quot;]);<br />
}</p></div>
<div class="block">
<h2 id="AccessControl::api_setIf">@fn AccessControl::api_setIf()</h2>
<p>批量更新。</p>
<p>setIf接口会检测readonlyFields及readonlyFields2中定义的字段不可更新。<br />
也可以直接用checkSetFields指定哪些字段允许更新。<br />
返回更新记录数。<br />
示例：</p>
<pre><code>class AC2_Ordr extends AccessControl {
    function api_setIf() {
        checkAuth(PERM_MGR);
        $this-&gt;checkSetFields(["status", "cmt"]);
        $empId = $_SESSION["empId"];
        $this-&gt;addCond("t0.empId=$empId");
        // $this-&gt;addJoin(...);
        return parent::api_setIf();
    }
}</code></pre></div>
<div class="block">
<h2 id="AccessControl::api_delIf">@fn AccessControl::api_delIf()</h2>
<p>批量删除。返回删除记录数。<br />
示例：</p>
<pre><code>class AC2_Ordr extends AccessControl {
    function api_delIf() {
        checkAuth(PERM_MGR);
        // $this-&gt;addCond(...);
        // $this-&gt;addJoin(...);
        return parent::api_delIf();
    }
}</code></pre></div>
<div class="block">
<h2 id="AccessControl::api_batchAdd">@fn AccessControl::api_batchAdd()</h2>
<p>批量添加（导入）。返回导入记录数cnt及编号列表idList</p>
<pre><code>Obj.batchAdd(title?)(...) -&gt; {cnt, @idList}</code></pre>
<p>在一个事务中执行，一行出错后立即失败返回，该行前面已导入的内容也会被取消（回滚）。</p>
<ul>
<li>title: List(fieldName). 指定标题行(即字段列表). 如果有该参数, 则忽略POST内容或文件中的标题行.<br />
如&quot;title=name,-,addr&quot;表示导入第一列name和第三列addr, 其中&quot;-&quot;表示忽略该列，不导入。</li>
</ul>
<p>支持两种方式上传：</p>
<ol>
<li>
<p>直接在HTTP POST中传输内容，数据格式为：首行为标题行(即字段名列表)，之后为实际数据行。<br />
行使用&quot;\n&quot;分隔, 列使用&quot;\t&quot;分隔.<br />
接口为：</p>
<p>{Obj}.batchAdd(title?)(标题行，数据行)<br />
(Content-Type=text/plain)</p>
</li>
</ol>
<p>前端JS调用示例：</p>
<pre><code>var data = "name\taddr\n" + "门店1\t地址1\n门店2\t地址2\n";
callSvr("Store.batchAdd", function (ret) {
    app_alert("成功导入" + ret.cnt + "条数据！");
}, data, {contentType:"text/plain"});</code></pre>
<p>或指定title参数:</p>
<pre><code>var data = "门店名\t地址\n" + "门店1\t地址1\n门店2\t地址2\n";
callSvr("Store.batchAdd", {title: "name,addr"}, function (ret) {
    app_alert("成功导入" + ret.cnt + "条数据！");
}, data, {contentType:"text/plain"});</code></pre>
<ol>
<li>标准csv/txt文件上传：</li>
</ol>
<p>上传的文件首行当作标题列，如果这一行不是后台要求的标题名称，可通过URL参数title重新定义。<br />
一般使用excel csv文件（编码一般为gbk），或txt文件（以&quot;\t&quot;分隔列）。<br />
接口为：</p>
<pre><code>{Obj}.batchAdd(title?)(csv/txt文件)
(Content-Type=multipart/form-data, 即html form默认传文件的格式)</code></pre>
<p>后端处理时, 将自动判断文本编码(utf-8或gbk).</p>
<p>前端HTML:</p>
<pre><code>&lt;input type="file" name="f" accept=".csv,.txt"&gt;</code></pre>
<p>前端JS示例：</p>
<pre><code>var fd = new FormData();
fd.append("file", frm.f.files[0]);
callSvr("Store.batchAdd", {title: "name,addr"}, function (ret) {
    app_alert("成功导入" + ret.cnt + "条数据！");
}, fd);</code></pre></div>
<div class="block">
<h2 id="handleExportFormat">@fn handleExportFormat($fmt, $arr, $fname)</h2>
<p>导出表到文件。</p>
<ul>
<li>fmt: csv-逗号分隔的文本; excel-使用gb18030编码的csv文本(excel可直接打开); txt-制表符分隔的文本。 </li>
<li>arr: 筋斗云表格格式({@h, @d}), 或二维数组表格格式。</li>
<li>fname: 导出的文件名</li>
</ul>
<p>示例：导出订单行及其明细等表，将多个查询结果拼成一个数组，导出excel-csv文件。</p>
<pre><code>class AC2_Ordr 
{
    function api_export()
    {
        $id = mparam("id");
        $tbl = queryAllWithHeader("SELECT t0.id 订单号, u.name 用户, u.phone 联系方式, t0.createTm 创建时间, t0.amount 金额
FROM Ordr t0
LEFT JOIN User u ON u.id=t0.userId
WHERE t0.id=$id", true);
        $tbl2 = queryAllWithHeader("SELECT name 商品, price 单价, qty 数量, spec 规格 FROM OrderItem WHERE orderId=$id", true);
        $tbl3 = queryAllWithHeader("SELECT name 名称, amount 金额 FROM OrderAmount WHERE orderId=$id", true);

        $arr = array_merge($tbl, [[], ["订单明细:"]], $tbl2, [[], ["金额调整:"]], $tbl3);

        $this-&gt;handleExportFormat("excel", $arr, "订单明细-$id");
    }
}</code></pre>
<p>注意：<code>[[], ["订单明细"]</code>表示插入两行，一个空行，另一个只有一列&quot;订单明细&quot;。</p>
<p>前端JS示例:</p>
<pre><code>var url = WUI.makeUrl("Ordr.export", {id: orderId});
window.open(url);</code></pre>
<p>导出示例：</p>
<pre><code>订单号 用户  联系方式    创建时间    金额
51343   王五555   "12345678901    "   2018/11/16 15:38    135

订单明细:               
商品  单价  数量  规格  
高压氧气管三胶二线   115 1   8MM 

金额调整:               
名称  金额          
运费  20</code></pre></div>
<div class="block">
<h2 id="AccessControl::isFileExport">@fn AccessControl::isFileExport()</h2>
<p>返回是否为导出文件请求。</p></div>
<div class="block">
<h2 id="BatchAddLogic">@class BatchAddLogic</h2>
<p>用于定制批量导入行为。<br />
示例，实现接口：</p>
<pre><code>Task.batchAdd(orderId, task1)(city, brand, vendorName, storeName)</code></pre>
<p>其中vendorName和storeName字段需要通过查阅修正为vendorId和storeId字段。</p>
<pre><code>class TaskBatchAddLogic extends BatchAddLogic
{
    protected $vendorCache = [];
    function __construct () {
        // 每个对象添加时都会用的字段，加在$this-&gt;params数组中
        $this-&gt;params["orderId"] = mparam("orderId", "G"); // mparam要求必须指定该字段
        $this-&gt;params["task1"] = param("task1", null, "G");
    }
    // $params为待添加数据，可在此修改，如用`$params["k1"]=val1`添加或更新字段，用unset($params["k1"])删除字段。
    // $row为原始行数据数组。
    function beforeAdd(&amp;$params, $row) {
        // vendorName -&gt; vendorId 将params数组中的venderName字段查阅Vendor表改成vendorId字段。如果查不到则报错。传入vendorCache数组来优化查询。
        translateKey($params, "vendorName", "vendorId", "SELECT id FROM Vendor WHERE name=%s", null, $this-&gt;vendorCache);
        // storeName -&gt; storeId 将params数组中的storeName字段查阅Store表改成storeId字段。如果查不到则自动以指定insert语句创建。
        translateKey($params, "storeName", "storeId", "SELECT id FROM Store WHERE name=%s", "INSERT INTO Store (name) VALUES (%s)");
    }
    // 处理原始标题行数据, $row1是通过title参数传入的标题数组，可能为空
    function onGetTitleRow($row, $row1) {
    }
}

class AC2_Task extends AC0_Task
{
    function api_batchAdd() {
        $this-&gt;batchAddLogic = new TaskBatchAddLogic();
        return parent::api_batchAdd();
    }
}</code></pre>
<p class="see"><strong>@see <a href="#api_batchAdd">api_batchAdd</a></strong> </p></div>
<div style="text-align:center">Generated by jdcloud-gendoc</div>
</body>

</html>

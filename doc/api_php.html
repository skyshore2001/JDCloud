<html>
<head>
<meta charset="utf-8">
<title>API参考 - 筋斗云服务端</title>
<style>
h3,h4,h5,h6 {
	font-size: 1em;
}

pre {
	border-left: 1px solid #ccc;
	margin: 0 1em;
	padding: 0 0.5em;
	tab-size:4;
}

code {
	font-family: "Courier New";
    padding: 0px 3px;
    display: inline-block;
}

.toc {
	margin: 2em;
}

.toc p {
	margin: 0.3em 0;
}

</style>
<link rel="stylesheet" href="style.css" />
</head>

<h1>API参考 - 筋斗云服务端</h1>
<div>最后更新：2017-02-05</div>
<h2>Modules</h2>
<div class="toc">
<p><a href="#app_fw">app_fw (module)</a></p>
<p><a href="#ext">ext (module)</a></p>
<p><a href="#api_fw">api_fw (module)</a></p>
<p><a href="#AccessControl">AccessControl (module)</a></p>
</div><hr>
<h2>Keywords</h2>
<div class="toc">
<p><a href="#$APP">$APP (var)</a></p>
<p><a href="#$BASE_DIR">$BASE_DIR (var)</a></p>
<p><a href="#AC0_">AC0_ (key)</a></p>
<p><a href="#AC1_">AC1_ (key)</a></p>
<p><a href="#AC2_">AC2_ (key)</a></p>
<p><a href="#AC_">AC_ (key)</a></p>
<p><a href="#AccessControl">AccessControl (module)</a></p>
<p><a href="#AccessControl::$allowedAc">AccessControl::$allowedAc (var)</a></p>
<p><a href="#AccessControl::$defaultRes">AccessControl::$defaultRes (var)</a></p>
<p><a href="#AccessControl::$defaultSort">AccessControl::$defaultSort (var)</a></p>
<p><a href="#AccessControl::$hiddenFields">AccessControl::$hiddenFields (var)</a></p>
<p><a href="#AccessControl::$id">AccessControl::$id (var)</a></p>
<p><a href="#AccessControl::$maxPageSz">AccessControl::$maxPageSz (var)</a></p>
<p><a href="#AccessControl::$onAfterActions">AccessControl::$onAfterActions (var)</a></p>
<p><a href="#AccessControl::$readonlyFields">AccessControl::$readonlyFields (var)</a></p>
<p><a href="#AccessControl::$readonlyFields2">AccessControl::$readonlyFields2 (var)</a></p>
<p><a href="#AccessControl::$requiredFields">AccessControl::$requiredFields (var)</a></p>
<p><a href="#AccessControl::$requiredFields2">AccessControl::$requiredFields2 (var)</a></p>
<p><a href="#AccessControl::$subobj">AccessControl::$subobj (var)</a></p>
<p><a href="#AccessControl::$vcolDefs">AccessControl::$vcolDefs (var)</a></p>
<p><a href="#AccessControl::addCond">AccessControl::addCond (fn)</a></p>
<p><a href="#AccessControl::addJoin">AccessControl::addJoin (fn)</a></p>
<p><a href="#AccessControl::addRes">AccessControl::addRes (fn)</a></p>
<p><a href="#AccessControl::addVCol">AccessControl::addVCol (fn)</a></p>
<p><a href="#AccessControl::getDefaultSort">AccessControl::getDefaultSort (fn)</a></p>
<p><a href="#AccessControl::getMaxPageSz">AccessControl::getMaxPageSz (fn)</a></p>
<p><a href="#AccessControl::onAfter">AccessControl::onAfter (fn)</a></p>
<p><a href="#AccessControl::onGenId">AccessControl::onGenId (fn)</a></p>
<p><a href="#AccessControl::onHandleRow">AccessControl::onHandleRow (fn)</a></p>
<p><a href="#AccessControl::onQuery">AccessControl::onQuery (fn)</a></p>
<p><a href="#AccessControl::onValidate">AccessControl::onValidate (fn)</a></p>
<p><a href="#AccessControl::onValidateId">AccessControl::onValidateId (fn)</a></p>
<p><a href="#AppBase">AppBase (class)</a></p>
<p><a href="#CFG_MOCK_MODE">CFG_MOCK_MODE (key)</a></p>
<p><a href="#CFG_MOCK_T_MODE">CFG_MOCK_T_MODE (key)</a></p>
<p><a href="#Conf">Conf (key)</a></p>
<p><a href="#ConfBase">ConfBase (class)</a></p>
<p><a href="#ConfBase::$enableApiLog">ConfBase::$enableApiLog (var)</a></p>
<p><a href="#ConfBase::onApiInit">ConfBase::onApiInit (fn)</a></p>
<p><a href="#ConfBase::onInitClient">ConfBase::onInitClient (fn)</a></p>
<p><a href="#DBG_LEVEL">DBG_LEVEL (var)</a></p>
<p><a href="#DirectReturn">DirectReturn (class)</a></p>
<p><a href="#ExtFactory::getObj">ExtFactory::getObj (fn)</a></p>
<p><a href="#ExtFactory::instance">ExtFactory::instance (fn)</a></p>
<p><a href="#JDEvent">JDEvent (class)</a></p>
<p><a href="#JDEvent.on">JDEvent.on (fn)</a></p>
<p><a href="#JDEvent.trigger">JDEvent.trigger (fn)</a></p>
<p><a href="#JDSingleton">JDSingleton (class)</a></p>
<p><a href="#MOCK_MODE">MOCK_MODE (var)</a></p>
<p><a href="#MyException">MyException (class)</a></p>
<p><a href="#PAGE_SZ_LIMIT">PAGE_SZ_LIMIT (var)</a></p>
<p><a href="#P_DB">P_DB (key)</a></p>
<p><a href="#P_DBCRED">P_DBCRED (key)</a></p>
<p><a href="#P_SESSION_DIR">P_SESSION_DIR (key)</a></p>
<p><a href="#P_URL_PATH">P_URL_PATH (key)</a></p>
<p><a href="#PluginBase">PluginBase (class)</a></p>
<p><a href="#PluginBase.$colMap">PluginBase.$colMap (var)</a></p>
<p><a href="#PluginBase.mapCol">PluginBase.mapCol (key)</a></p>
<p><a href="#PluginBase.mapSql">PluginBase.mapSql (key)</a></p>
<p><a href="#Plugins">Plugins (class)</a></p>
<p><a href="#Plugins::$map">Plugins::$map (var)</a></p>
<p><a href="#Plugins::add">Plugins::add (fn)</a></p>
<p><a href="#Plugins::exists">Plugins::exists (fn)</a></p>
<p><a href="#Plugins::getInstance">Plugins::getInstance (fn)</a></p>
<p><a href="#Q">Q (fn)</a></p>
<p><a href="#TEST_MODE">TEST_MODE (var)</a></p>
<p><a href="#addLog">addLog (fn)</a></p>
<p><a href="#api_fw">api_fw (module)</a></p>
<p><a href="#app_fw">app_fw (module)</a></p>
<p><a href="#callSvc">callSvc (fn)</a></p>
<p><a href="#conf.php">conf.php (key)</a></p>
<p><a href="#dbConfirmFn">dbConfirmFn (key)</a></p>
<p><a href="#dbconn">dbconn (fn)</a></p>
<p><a href="#errQuit">errQuit (fn)</a></p>
<p><a href="#execOne">execOne (fn)</a></p>
<p><a href="#ext">ext (module)</a></p>
<p><a href="#getAppType">getAppType (fn)</a></p>
<p><a href="#getBaseUrl">getBaseUrl (fn)</a></p>
<p><a href="#getCred">getCred (fn)</a></p>
<p><a href="#getExt">getExt (fn)</a></p>
<p><a href="#hasSignFile">hasSignFile (fn)</a></p>
<p><a href="#isCLI">isCLI (fn)</a></p>
<p><a href="#isCLIServer">isCLIServer (fn)</a></p>
<p><a href="#isEqualCollection">isEqualCollection (fn)</a></p>
<p><a href="#isMockMode">isMockMode (fn)</a></p>
<p><a href="#logext">logext (fn)</a></p>
<p><a href="#logit">logit (fn)</a></p>
<p><a href="#mparam">mparam (fn)</a></p>
<p><a href="#myEncrypt">myEncrypt (fn)</a></p>
<p><a href="#objarr2table">objarr2table (fn)</a></p>
<p><a href="#param">param (fn)</a></p>
<p><a href="#param_varr">param_varr (fn)</a></p>
<p><a href="#plugin.php">plugin.php (key)</a></p>
<p><a href="#plugin/index.php">plugin/index.php (key)</a></p>
<p><a href="#queryAll">queryAll (fn)</a></p>
<p><a href="#queryOne">queryOne (fn)</a></p>
<p><a href="#setParam">setParam (fn)</a></p>
<p><a href="#setRet">setRet (fn)</a></p>
<p><a href="#setServerRev">setServerRev (fn)</a></p>
<p><a href="#startsWith">startsWith (fn)</a></p>
<p><a href="#table2objarr">table2objarr (fn)</a></p>
<p><a href="#tableCRUD">tableCRUD (fn)</a></p>
<p><a href="#tobool">tobool (fn)</a></p>
<p><a href="#varr2objarr">varr2objarr (fn)</a></p>
</div><hr>
<h2 id="tobool">@fn tobool($s)</h2><hr>
<h2 id="startsWith">@fn startsWith($s, $pat)</h2><hr>
<h2 id="isCLI">@fn isCLI() </h2>
<p>command-line interface. e.g. run &quot;php x.php&quot;</p><hr>
<h2 id="isCLIServer">@fn isCLIServer() </h2>
<p>php built-in web server e.g. run &quot;php -S 0.0.0.0:8080&quot;</p><hr>
<h2 id="isEqualCollection">@fn isEqualCollection($col1, $col2)</h2><hr>
<h2 id="app_fw">@module app_fw</h2><div class="toc"><p style="margin-left:0em"><a href="#app_fw-1 通用函数">1 通用函数</a></p>
<p style="margin-left:0em"><a href="#app_fw-2 初始化配置">2 初始化配置</a></p>
<p style="margin-left:2em"><a href="#app_fw-2.1 数据库配置">2.1 数据库配置</a></p>
<p style="margin-left:0em"><a href="#app_fw-3 测试模式与调试等级">3 测试模式与调试等级</a></p>
<p style="margin-left:0em"><a href="#app_fw-4 模拟模式">4 模拟模式</a></p>
<p style="margin-left:0em"><a href="#app_fw-5 session管理">5 session管理</a></p>
<p style="margin-left:0em"><a href="#app_fw-6 应用框架">6 应用框架</a></p>
</div>
<p>筋斗云服务端通用应用框架。</p>
<h4 id="app_fw-1 通用函数">1 通用函数</h4>
<ul>
<li>
<p>获得指定类型参数</p>
<p class="see"><strong>@see <a href="#param">param</a> <a href="#mparam">mparam</a></strong> </p>
</li>
<li>
<p>数据库连接及操作</p>
<p class="see"><strong>@see <a href="#dbconn">dbconn</a> <a href="#execOne">execOne</a> <a href="#queryOne">queryOne</a> <a href="#queryAll">queryAll</a></strong> </p>
</li>
<li>错误处理设施
<p class="see"><strong>@see <a href="#MyException">MyException</a> <a href="#errQuit">errQuit</a></strong> </p></li>
</ul>
<h4 id="app_fw-2 初始化配置">2 初始化配置</h4>
<p>app_fw框架自动包含 $BASE_DIR/php/conf.user.php。</p>
<p>项目部署时的配置，一般用于定义环境变量、全局变量等，通常不添加入版本库，在项目实施时手工配置。</p>
<p>对于不变的全局配置，应在app.php中定义。</p>
<h5 id="app_fw-2.1 数据库配置">2.1 数据库配置</h5>
<p class="key"><strong>@key <a id="P_DB">P_DB</a></strong>  环境变量，指定DB类型与地址。</p>
<p class="key"><strong>@key <a id="P_DBCRED">P_DBCRED</a></strong>  环境变量，指定DB登录帐号</p>
<p>P_DB格式为：</p>
<pre><code>P_DB={主机名}/{数据库名}
或
P_DB={主机名}:{端口号}/{数据库名}</code></pre>
<p>例如：</p>
<pre><code>P_DB=localhost/myorder
P_DB=www.myserver.com:3306/myorder</code></pre>
<p>P_DBCRED格式为<code>{用户名}:{密码}</code>，或其base64编码后的值，如</p>
<pre><code>P_DBCRED=ganlan:1234
或
P_DBCRED=Z2FubGFuOjEyMzQ=</code></pre>
<p>此外，P_DB还支持SQLite数据库，直接指定以&quot;.db&quot;为扩展名的文件即可。例如：</p>
<pre><code>P_DB=../myorder.db</code></pre>
<h4 id="app_fw-3 测试模式与调试等级">3 测试模式与调试等级</h4>
<p class="var"><strong>@var <a id="TEST_MODE">TEST_MODE</a></strong>  Integer/Boolean. 0-生产模式；1-测试模式；2-自动化回归测试模式(RTEST_MODE)</p>
<p class="var"><strong>@var <a id="DBG_LEVEL">DBG_LEVEL</a></strong>  Integer. 调试等级。值范围0-9.</p>
<p>测试模式特点：</p>
<ul>
<li>通过在项目目录下放置文件 CFG_TEST_MODE，可强制使用测试模式。</li>
<li>通过URL请求参数 &quot;_test=1&quot;可以测试模式打开应用。</li>
<li>输出JSON内容更易读，且带调试信息。</li>
<li>一般建议测试模式下连接不同的数据库。可在conf.user.php中指定。</li>
</ul>
<p>用于在测试模式下输出调试信息。</p>
<ul>
<li>可通过URL请求参数指定，如&quot;_test=1&amp;_debug=1&quot;。</li>
<li>值为9时，可输出所有SQL调试日志。</li>
</ul>
<p class="see"><strong>@see <a href="#addLog">addLog</a></strong> </p>
<h4 id="app_fw-4 模拟模式">4 模拟模式</h4>
<p class="var"><strong>@var <a id="MOCK_MODE">MOCK_MODE</a></strong>  Boolean. 模拟模式. 值：0/1.</p>
<p class="key"><strong>@key <a id="CFG_MOCK_MODE">CFG_MOCK_MODE</a></strong>   符号文件，如文件存在则应用运行于模拟模式。</p>
<p class="key"><strong>@key <a id="CFG_MOCK_T_MODE">CFG_MOCK_T_MODE</a></strong>  符号文件，如文件存在且在测试模式下，应用运行于模拟模式。</p>
<p>对第三方系统依赖（如微信认证、支付宝支付、发送短信等），可通过设计Mock接口来模拟。</p>
<p class="see"><strong>@see <a href="#ExtMock">ExtMock</a></strong> </p>
<h4 id="app_fw-5 session管理">5 session管理</h4>
<ul>
<li>应用的session名称为 &quot;{app}id&quot;, 如应用名为 &quot;user&quot;, 则session名为&quot;userid&quot;. 因而不同的应用同时调用服务端也不会冲突。</li>
<li>保存session文件的目录为 $BASE_DIR/session, 可使用P_SESSION_DIR变量重定义。</li>
<li>测试模式下session名称为 &quot;t{app}id&quot;, 保存session文件的目录为 $BASE_DIR/session/t。如果定义了环境变量P_SESSION_DIR，则目录为 {P_SESSION_DIR}/t</li>
<li>同一主机，不同URL下的session即使APP名相同，也不会相互冲突，因为框架会根据当前URL，设置cookie的有效路径。</li>
</ul>
<p class="key"><strong>@key <a id="P_SESSION_DIR">P_SESSION_DIR</a></strong>  ?= $BASE_DIR/session 环境变量，定义session文件存放路径。</p>
<p class="key"><strong>@key <a id="P_URL_PATH">P_URL_PATH</a></strong>  环境变量。项目的URL路径，如"/jdcloud", 用于定义cookie生效的作用域，也用于拼接相对URL路径。</p>
<p class="see"><strong>@see <a href="#getBaseUrl">getBaseUrl</a></strong> </p>
<h4 id="app_fw-6 应用框架">6 应用框架</h4>
<p>继承AppBase类，可实现提供符合BQP协议接口的模块。<a href="#api_fw">api_fw</a>框架就是使用它的一个典型例子。</p>
<p class="see"><strong>@see <a href="#AppBase">AppBase</a></strong> </p><hr>
<h2 id="$BASE_DIR">@var $BASE_DIR</h2>
<p>包含app_fw.php的主文件（如api.php）所在目录。常用于拼接子目录名。<br />
最后不带&quot;/&quot;.</p><hr>
<h2 id="$APP">@var $APP?=user</h2>
<p>客户端应用标识，默认为&quot;user&quot;.<br />
根据URL参数&quot;_app&quot;确定值。</p><hr>
<h2 id="param_varr">@fn param_varr($str, $type, $name)</h2>
<p>type的格式如&quot;i:n:b?:dt:tm?&quot;.</p>
<ul>
<li>每个词表示一个字段类型<br />
类型标识：i-Integer; n-Number/Double; b-Boolean(0/1); dt/tm-DateTime</li>
<li>后置&quot;?&quot;表示该参数可缺省。</li>
</ul><hr>
<h2 id="param">@fn param($name, $defVal?, $col?=$_REQUEST)</h2>
<p class="param"><strong>@param $col:</strong>  key-value collection</p>
<p>获取名为$name的参数。<br />
$name中可以指定类型，返回值根据类型确定。如果该参数未定义或是空串，直接返回缺省值$defVal。</p>
<p>$name中指定类型的方式如下：</p>
<ul>
<li>名为&quot;id&quot;, 或以&quot;Id&quot;或&quot;/i&quot;结尾: int</li>
<li>以&quot;/b&quot;结尾: bool</li>
<li>以&quot;/dt&quot;或&quot;/tm&quot;结尾: datetime</li>
<li>以&quot;/n&quot;结尾: numeric/double</li>
<li>以&quot;/s&quot;结尾（缺省）: string</li>
<li>复杂类型：以&quot;/i+&quot;结尾: int array</li>
<li>复杂类型：以&quot;/js&quot;结尾: json object</li>
<li>复杂类型：List类型（以&quot;,&quot;分隔行，以&quot;:&quot;分隔列），类型定义如&quot;/i:n:b:dt:tm&quot; （列只支持简单类型，不可为复杂类型）</li>
</ul>
<p>示例：</p>
<pre><code>$id = param("id");
$svcId = param("svcId/i", 99);
$wantArray = param("wantArray/b", false);
$startTm = param("startTm/dt", time());</code></pre>
<p>List类型示例。参数&quot;items&quot;类型在文档中定义为list(id/Integer, qty/Double, dscr/String)，可用param(&quot;items/i:n:s&quot;)获取, 值如</p>
<pre><code>items=100:1:洗车,101:1:打蜡</code></pre>
<p>返回</p>
<pre><code>[ [ 100, 1.0, "洗车"], [101, 1.0, "打蜡"] ]</code></pre>
<p>如果某列可缺省，用&quot;?&quot;表示，如param(&quot;items/i:n?:s?&quot;)可获取值：</p>
<pre><code>items=100:1,101::打蜡</code></pre>
<p>返回</p>
<pre><code>[ [ 100, 1.0, null], [101, null, "打蜡"] ]</code></pre>
<p>TODO: 直接支持 param(&quot;items/(id,qty?/n,dscr?)&quot;), 添加param_objarr函数，去掉parseList函数。上例将返回</p>
<pre><code>[
    [ "id"=&gt;100, "qty"=&gt;1.0, dscr=&gt;null],
    [ "id"=&gt;101, "qty"=&gt;null, dscr=&gt;"打蜡"]
]</code></pre><hr>
<h2 id="mparam">@fn mparam($name, $col = $_REQUEST)</h2>
<p class="brief"><strong>@brief mandatory</strong>  param</p>
<p>$name可以是一个数组，表示至少有一个参数有值，这时返回每个参数的值。<br />
参考param函数，查看$name如何支持各种类型。</p>
<p>示例：</p>
<pre><code>$svcId = mparam("svcId");
$svcId = mparam("svcId/i");
$itts = mparam("itts/i+")
list($svcId, $itts) = mparam(["svcId", "itts/i+"]); # require one of the 2 params</code></pre><hr>
<h2 id="setParam">@fn setParam($k, $v)</h2>
<p>设置参数，其实是模拟客户端传入的参数。以便供tableCRUD等函数使用。</p>
<p class="see"><strong>@see <a href="#tableCRUD">tableCRUD</a></strong> </p><hr>
<h2 id="objarr2table">@fn objarr2table ($objarr, $fixedColCnt=null)</h2>
<p>将objarr格式转为table格式, 如：</p>
<pre><code>objarr2table(
    [
        ["id"=&gt;100, "name"=&gt;"A"],
        ["id"=&gt;101, "name"=&gt;"B"]
    ]
) -&gt; 
    [
        "h"=&gt;["id", "name"],
        "d"=&gt;[ 
            [100,"A"], 
            [101,"B"]
        ] 
    ]</code></pre>
<p>注意：</p>
<ul>
<li>objarr每行中列的顺序可以不一样，table列按首行顺序输出。</li>
<li>
<p>每行中列数可以不一样，这时可指定最少固定列数 $fixedColCnt, 而该列以后，将自动检查所有行决定是否加到header中。例：</p>
<p>objarr2table(<br />
[<br />
[&quot;id&quot;=&gt;100, &quot;name&quot;=&gt;&quot;A&quot;],<br />
[&quot;name&quot;=&gt;&quot;B&quot;, &quot;id&quot;=&gt;101, &quot;flag_v&quot;=&gt;1],<br />
[&quot;id&quot;=&gt;102, &quot;name&quot;=&gt;&quot;C&quot;, &quot;flag_r&quot;=&gt;1]<br />
], 2  // 2列固定<br />
) -&gt;<br />
[<br />
&quot;h&quot;=&gt;[&quot;id&quot;, &quot;name&quot;, &quot;flag_v&quot;, &quot;flag_r&quot;],<br />
&quot;d&quot;=&gt;[<br />
[100,&quot;A&quot;, null,null],<br />
[101,&quot;B&quot;, 1, null],<br />
[102,&quot;C&quot;, null, 1]<br />
]<br />
]</p>
</li>
</ul>
<p class="see"><strong>@see <a href="#table2objarr">table2objarr</a></strong> </p>
<p class="see"><strong>@see <a href="#varr2objarr">varr2objarr</a></strong> </p><hr>
<h2 id="table2objarr">@fn table2objarr</h2>
<p>将table格式转为 objarr, 如：</p>
<pre><code>table2objarr(
    [
        "h"=&gt;["id", "name"],
        "d"=&gt;[ 
            [100,"A"], 
            [101,"B"]
        ] 
    ]
) -&gt; [ ["id"=&gt;100, "name"=&gt;"A"], ["id"=&gt;101, "name"=&gt;"B"] ]</code></pre><hr>
<h2 id="varr2objarr">@fn varr2objarr</h2>
<p>将类型 varr (仅有值的二维数组, elem=[$col1, $col2] ) 转为 objarr (对象数组, elem={col1=&gt;cell1, col2=&gt;cell2})</p>
<p>例：</p>
<pre><code>varr2objarr(
    [ [100, "A"], [101, "B"] ], 
    ["id", "name"] )
-&gt; [ ["id"=&gt;100, "name"=&gt;"A"], ["id"=&gt;101, "name"=&gt;"B"] ]</code></pre><hr>
<h2 id="getCred">@fn getCred($cred) -> [user, pwd]</h2>
<p>$cred为&quot;{user}:{pwd}&quot;格式，支持使用base64编码。<br />
示例：</p>
<pre><code>list($user, $pwd) = getCred(getenv("P_ADMIN_CRED"));
if (! isset($user)) {
    // 未设置用户名密码
}</code></pre><hr>
<h2 id="dbconn">@fn dbconn($fnConfirm=$GLOBALS["dbConfirmFn"])</h2>
<p class="param"><strong>@param fnConfirm</strong>  fn(dbConnectionString), 如果返回false, 则程序中止退出。</p>
<p class="key"><strong>@key <a id="dbConfirmFn">dbConfirmFn</a></strong>  连接数据库前回调。</p>
<p>连接数据库</p>
<p>数据库由全局变量$DB(或环境变量P_DB）指定，格式可以为：</p>
<pre><code>host1/carsvc (无扩展名，表示某主机host1下的mysql数据库名；这时由 全局变量$DBCRED 或环境变量 P_DBCRED 指定用户名密码。

dir1/dir2/carsvc.db (以.db文件扩展名标识的文件路径，表示SQLITE数据库）</code></pre>
<p>环境变量 P_DBCRED 指定用户名密码，格式为 base64(dbuser:dbpwd).</p><hr>
<h2 id="Q">@fn Q($str, $dbh=$DBH)</h2>
<p>quote string</p>
<p>一般是把字符串如&quot;abc&quot;转成加单引号的形式&quot;'abc'&quot;. 适用于根据用户输入串拼接成SQL语句时，对输入串处理，避免SQL注入。</p>
<p>示例：</p>
<pre><code>$sql = sprintf("SELECT id FROM User WHERE uname=%s AND pwd=%s", Q(param("uname")), Q(param("pwd")));</code></pre><hr>
<h2 id="execOne">@fn execOne($sql, $getInsertId?=false)</h2>
<p class="param"><strong>@param $getInsertId</strong> ?=false 取INSERT语句执行后得到的id. 仅用于INSERT语句。</p>
<p>执行SQL语句，如INSERT, UPDATE等。执行SELECT语句请使用queryOne/queryAll.</p>
<pre><code>$token = mparam("token");
execOne("UPDATE cinf SET appleDeviceToken=" . Q($token));</code></pre>
<p>注意：在拼接SQL语句时，对于传入的string类型参数，应使用Q函数进行转义，避免SQL注入攻击。</p>
<p>对于INSERT语句，设置参数$getInsertId=true, 可取新加入数据行的id. 例：</p>
<pre><code>$sql = sprintf("INSERT INTO Hongbao (userId, createTm, src, expireTm, vdays) VALUES ({$uid}, '%s', '{$src}', '%s', {$vdays})", date('c', $createTm), date('c', $expireTm));
$hongbaoId = execOne($sql, true);</code></pre><hr>
<h2 id="queryOne">@fn queryOne($sql, $fetchMode = PDO::FETCH_NUM)</h2>
<p>执行查询语句，只返回一行数据，如果行中只有一列，则直接返回该列数值。<br />
如果执行失败，返回false.</p>
<p>示例：查询用户姓名与电话，默认返回值数组：</p>
<pre><code>$row = queryOne("SELECT name,phone FROM User WHERE id={$id}");
if ($row === false)
    throw new MyException(E_PARAM, "bad user id");
// $row = ["John", "13712345678"]</code></pre>
<p>也可返回关联数组:</p>
<pre><code>$row = queryOne("SELECT name,phone FROM User WHERE id={$id}", PDO::FETCH_ASSOC);
if ($row === false)
    throw new MyException(E_PARAM, "bad user id");
// $row = ["name"=&gt;"John", "phone"=&gt;"13712345678"]</code></pre>
<p>当查询结果只有一列时，直接返回该数值。</p>
<pre><code>$phone = queryOne("SELECT phone FROM User WHERE id={$id}");
if ($phone === false)
    throw new MyException(E_PARAM, "bad user id");
// $phone = "13712345678"</code></pre>
<p class="see"><strong>@see <a href="#queryAll">queryAll</a></strong> </p><hr>
<h2 id="queryAll">@fn queryAll($sql, $fetchMode = PDO::FETCH_NUM)</h2>
<p>执行查询语句，返回数组。<br />
如果查询失败，返回空数组。</p>
<p>默认返回值数组(varr):</p>
<pre><code>$rows = queryAll("SELECT name, phone FROM User");
if (count($rows) &gt; 0) {
    ...
}
// 值为：
$rows = [
    ["John", "13712345678"],
    ["Lucy", "13712345679"]
    ...
]
// 可转成table格式返回
return ["h"=&gt;["name", "phone"], "d"=&gt;$rows];</code></pre>
<p>也可以返回关联数组(objarr)，如：</p>
<pre><code>$rows = queryAll("SELECT name, phone FROM User", PDO::FETCH_ASSOC);
if (count($rows) &gt; 0) {
    ...
}
// 值为：
$rows = [
    ["name"=&gt;"John", "phone"=&gt;"13712345678"],
    ["name"=&gt;"Lucy", "phone"=&gt;"13712345679"]
    ...
]
// 可转成table格式返回
return objarr2table($rows);</code></pre>
<p class="see"><strong>@see <a href="#objarr2table">objarr2table</a></strong> </p><hr>
<h2 id="getBaseUrl">@fn getBaseUrl($wantHost = true)</h2>
<p>返回 $BASE_DIR 对应的网络路径（最后以&quot;/&quot;结尾）。<br />
如果指定了环境变量 P_URL_PATH（可在conf.user.php中设置）, 则根据该变量计算；否则自动判断（如果有符号链接可能不准）</p>
<p>例：</p>
<pre><code>P_URL_PATH = "/cheguanjia/" 或 P_URL_PATH = "/cheguanjia"</code></pre>
<p>则</p>
<pre><code>getBaseUrl() -&gt; "http://host/cheguanjia/"
getBaseUrl(false) -&gt; "/cheguanjia/"</code></pre>
<p class="see"><strong>@see <a href="#$BASE_DIR">$BASE_DIR</a></strong> </p><hr>
<h2 id="logit">@fn logit($s, $addHeader=true, $type="trace")</h2>
<p>记录日志。</p>
<p>默认到日志文件 $BASE_DIR/trace.log. 如果指定type=secure, 则写到 $BASE_DIR/secure.log.</p>
<p>可通过在线日志工具 tool/log.php 来查看日志。也可直接打开日志文件查看。</p><hr>
<h2 id="myEncrypt">@fn myEncrypt($string,$operation='E',$key='carsvc')</h2>
<p class="param"><strong>@param operation</strong>  'E': encrypt; 'D': decrypt</p>
<p>加密解密字符串</p>
<p>加密:</p>
<pre><code>$cipher = myEncrypt('hello, world!');
or
$cipher = myEncrypt('hello, world!','E','nowamagic');</code></pre>
<p>解密：</p>
<pre><code>$text = myEncrypt($cipher,'D','nowamagic');</code></pre>
<p>参数说明:<br />
$string   :需要加密解密的字符串<br />
$operation:判断是加密还是解密:E:加密   D:解密<br />
$key      :加密的钥匙(密匙);</p>
<p><a href="http://www.open-open.com/lib/view/open1388916054765.html">http://www.open-open.com/lib/view/open1388916054765.html</a></p><hr>
<h2 id="errQuit">@fn errQuit($code, $msg, $msg2 =null)</h2>
<p>生成html格式的错误信息并中止执行。<br />
默认地，只显示中文错误，双击可显示详细信息。<br />
例：</p>
<pre><code>errQuit(E_PARAM, "接口错误", "Unknown ac=`$ac`");</code></pre><hr>
<h2 id="addLog">@fn addLog($str, $logLevel=1)</h2>
<p>输出调试信息到前端。调试信息将出现在最终的JSON返回串中。<br />
如果只想输出调试信息到文件，不想让前端看到，应使用logit.</p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p><hr>
<h2 id="getAppType">@fn getAppType()</h2>
<p>根据应用标识($APP)获取应用类型(AppType)。注意：应用标识一般由前端应用通过URL参数&quot;_app&quot;传递给后端。<br />
不同的应用标识可以对应相同的应用类型，如应用标识&quot;emp&quot;, &quot;emp2&quot;, &quot;emp-adm&quot; 都表示应用类型&quot;emp&quot;，即 应用类型=应用标识自动去除尾部的数字或&quot;-xx&quot;部分。</p>
<p>不同的应用标识会使用不同的cookie名，因而即使用户同时操作多个应用，其session不会相互干扰。<br />
同样的应用类型将以相同的方式登录系统。</p>
<p class="see"><strong>@see <a href="#$APP">$APP</a></strong> </p><hr>
<h2 id="hasSignFile">@fn hasSignFile($f)</h2>
<p>检查应用根目录下($BASE_DIR)下是否存在标志文件。标志文件一般命名为&quot;CFG_XXX&quot;, 如&quot;CFG_MOCK_MODE&quot;等。</p><hr>
<h2 id="MyException">@class MyException($code, $internalMsg?, $outMsg?)</h2>
<p class="param"><strong>@param $internalMsg</strong>  String. 内部错误信息，前端不应处理。</p>
<p class="param"><strong>@param $outMsg</strong>  String. 错误信息。如果为空，则会自动根据$code填上相应的错误信息。</p>
<p>抛出错误，中断执行:</p>
<pre><code>throw new MyException(E_PARAM, "Bad Request - numeric param `$name`=`$ret`.", "需要数值型参数");</code></pre><hr>
<h2 id="DirectReturn">@class DirectReturn</h2>
<p>抛出该异常，可以中断执行直接返回，不显示任何错误。</p>
<p>例：API返回非BPQ协议标准数据，可以跳出setRet而直接返回：</p>
<pre><code>echo "return data";
throw new DirectReturn();</code></pre>
<p>例：返回指定数据后立即中断处理：</p>
<pre><code>setRet(0, ["id"=&gt;1]);
throw new DirectReturn();</code></pre><hr>
<h2 id="AppBase">@class AppBase</h2>
<p>应用框架，用于提供符合BQP协议的接口。<br />
在onExec中返回协议数据；在onAfter中建议及时关闭DB.</p><hr>
<h2 id="JDSingleton">@class JDSingleton (trait)</h2>
<p>用于单件类，提供getInstance方法，例：</p>
<pre><code>class PluginCore
{
    use JDSingleton;
}</code></pre>
<p>则可以调用</p>
<pre><code>$pluginCore = PluginCore::getInstance();</code></pre><hr>
<h2 id="JDEvent">@class JDEvent (trait)</h2>
<p>提供事件监听(on)与触发(trigger)方法，例：</p>
<pre><code>class PluginCore
{
    use JDEvent;

    // 提供事件"event1", 注释如下：
    /// @event PluginCore.event.event1($arg1, $arg2)
}</code></pre>
<p>则可以调用</p>
<pre><code>$pluginCore-&gt;on('event1', 'onEvent1');
$pluginCore-&gt;trigger('event1', [$arg1, $arg2]);

function onEvent1($arg1, $arg2)
{
}</code></pre><hr>
<h2 id="JDEvent.on">@fn JDEvent.on($ev, $fn)</h2><hr>
<h2 id="JDEvent.trigger">@fn JDEvent.trigger($ev, $args)</h2>
<p>返回最后次调用的返回值，false表示中止之后事件调用 </p>
<p>如果想在事件处理函数中返回复杂值，可使用$args传递，如下面返回一个数组：</p>
<pre><code>$obj-&gt;on('getResult', 'onGetResult');
$out = new stdclass();
$out-&gt;result = [];
$obj-&gt;trigger('getArray', [$out]);

function onGetResult($out)
{
    $out-&gt;result[] = 100;
}</code></pre><hr>
<h2 id="ext">@module ext 集成外部系统</h2>
<p>调用外部系统（如短信集成、微信集成等）将引入依赖，给开发和测试带来复杂性。<br />
筋斗云框架通过使用“模拟模式”(MOCK_MODE)，模拟这些外部功能，从而简化开发和测试。</p>
<p>对于一个简单的外部依赖，可以用函数isMockMode来分支。例如添加对象存储服务(OSS)支持，接口定义为：</p>
<pre><code>getOssParam() -&gt; {url, expire, dir, param={policy, OSSAccessKeyId, signature} }
模拟模式返回：
getOssParam() -&gt; {url="mock"}</code></pre>
<p>在实现时，先在ext.php中定义外部依赖类型，如Ext_Oss，然后实现函数：</p>
<pre><code>function api_getOssParam()
{
    if (isMockMode(Ext_Oss)) {
        return ["url"=&gt;"mock"];
    }
    // 实际实现代码 ...
}</code></pre>
<p>添加一个复杂的（如支持多个函数调用的）支持模拟的外部依赖，也则可以定义接口，步骤如下，以添加短信支持(SmsSupport)为例：</p>
<ul>
<li>定义一个新的类型，如Ext_SmsSupport.</li>
<li>定义接口，如 ISmsSupport.</li>
<li>在ExtMock类中模拟实现接口ISmsSupport中所有函数, 一般是调用logext()写日志到ext.log, 可以在tool/log.php中查看最近的ext日志。</li>
<li>定义一个类SmsSupport实现接口ISmsSupport，一般放在其它文件中实现(如sms.php)。</li>
<li>在onCreateExt中处理新类型Ext_SmsSupport, 创建实际接口对象。</li>
</ul>
<p>使用举例：</p>
<pre><code>$sms = getExt(Ext_SmsSupport);
$sms-&gt;sendSms(...);</code></pre>
<p>当在运行目录中放置了文件CFG_MOCK_MODE后，则不必依赖外部系统，也可模拟执行这些操作。</p>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p>
<p class="see"><strong>@see <a href="#CFG_MOCK_MODE">CFG_MOCK_MODE</a> <a href="#CFG_MOCK_T_MODE">CFG_MOCK_T_MODE</a> <a href="#MOCK_MODE">MOCK_MODE</a></strong> </p><hr>
<h2 id="isMockMode">@fn isMockMode($extType)</h2>
<p>判断是否模拟某外部扩展模块。如果$extType为null，则只要处于MOCK_MODE就返回true.</p><hr>
<h2 id="ExtFactory::instance">@fn ExtFactory::instance()</h2>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p><hr>
<h2 id="ExtFactory::getObj">@fn ExtFactory::getObj($extType, $allowMock?=true)</h2>
<p>获取外部依赖对象。一般用getExt替代更简单。</p>
<p>示例：</p>
<pre><code>$sms = ExtFactory::instance()-&gt;getObj(Ext_SmsSupport);</code></pre>
<p class="see"><strong>@see <a href="#getExt">getExt</a></strong> </p><hr>
<h2 id="getExt">@fn getExt($extType, $allowMock = true)</h2>
<p>用于取外部接口对象，如：</p>
<pre><code>$sms = getExt(Ext_SmsSupport);</code></pre><hr>
<h2 id="logext">@fn logext($s, $addHeader?=true)</h2>
<p>写日志到ext.log中，可在线打开tool/init.php查看。<br />
(logit默认写日志到trace.log中)</p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p><hr>
<h2 id="api_fw">@module api_fw</h2><div class="toc"><p style="margin-left:0em"><a href="#api_fw-1 函数型接口">1 函数型接口</a></p>
<p style="margin-left:0em"><a href="#api_fw-2 对象型接口">2 对象型接口</a></p>
<p style="margin-left:0em"><a href="#api_fw-3 接口复用">3 接口复用</a></p>
<p style="margin-left:0em"><a href="#api_fw-4 常用操作">4 常用操作</a></p>
<p style="margin-left:0em"><a href="#api_fw-5 插件机制">5 插件机制</a></p>
</div>
<p>服务接口实现框架。</p>
<p>服务接口包含：</p>
<ul>
<li>函数型接口，如 &quot;login&quot;, &quot;getToken&quot;等, 一般实现在 api_functions.php中。</li>
<li>对象型接口，如 &quot;Ordr.query&quot;, &quot;User.get&quot; 等，一般实现在 api_objects.php中。</li>
</ul>
<h4 id="api_fw-1 函数型接口">1 函数型接口</h4>
<p>假设在文档有定义以下接口</p>
<pre><code>用户修改密码
chpwd(oldpwd, pwd) -&gt; {_token, _expire}

权限：AUTH_USER</code></pre>
<p>则在 api_functions.php 中创建该接口的实现：</p>
<pre><code>function api_chpwd()
{
    checkAuth(AUTH_USER);
    $oldPwd = mparam("oldpwd");
    $pwd = mparam("pwd");
    ...
    $ret = [
        "_token" =&gt; $token,
        "_expire" =&gt; $expire,
    ];
    return $ret;
}</code></pre>
<p>说明：</p>
<ul>
<li>函数名称一定要符合 &quot;api_{接口名}&quot; 的规范。接口名以小写字母开头。</li>
<li>使用checkAuth进行权限检查</li>
<li>返回符合接口定义的对象。最终后端框架将其转为JSON串，再由前端框架解析后传递给应用程序。</li>
</ul>
<p class="see"><strong>@see <a href="#checkAuth">checkAuth</a></strong> </p>
<p class="see"><strong>@see <a href="#mparam">mparam</a></strong>  取必选参数，如果缺少该参数则报错。</p>
<p class="see"><strong>@see <a href="#param">param</a></strong>  取可选参数，可指定缺省值。</p>
<h4 id="api_fw-2 对象型接口">2 对象型接口</h4>
<p class="see"><strong>@see <a href="#AccessControl">AccessControl</a></strong>  对象型接口框架。</p>
<h4 id="api_fw-3 接口复用">3 接口复用</h4>
<p>api.php可以单独执行，也可直接被调用，如</p>
<pre><code>// set_include_path(get_include_path() . PATH_SEPARATOR . "..");
require_once("api.php");
...
$GLOBALS["errorFn"] = function($code, $msg, $msg2=null) {...}
$ret = callSvc("genVoucher");
// 如果没有异常，返回数据；否则调用指定的errorFn函数(未指定则调用errQuit)</code></pre>
<p class="see"><strong>@see <a href="#callSvc">callSvc</a></strong> </p>
<h4 id="api_fw-4 常用操作">4 常用操作</h4>
<p>错误处理</p>
<p class="see"><strong>@see <a href="#MyException">MyException</a></strong> </p>
<p>中断执行，直接返回</p>
<p class="see"><strong>@see <a href="#DirectReturn">DirectReturn</a></strong> </p>
<p>调试日志</p>
<p>可使用addLog输出调试信息而不破坏协议输出格式。</p>
<p class="see"><strong>@see <a href="#addLog">addLog</a></strong>  </p>
<p class="see"><strong>@see <a href="#logit">logit</a></strong> </p>
<h4 id="api_fw-5 插件机制">5 插件机制</h4>
<p class="key"><strong>@key <a id="plugin/index.php">plugin/index.php</a></strong>  插件配置</p>
<p>plugin/{pluginName}为插件目录。</p>
<p>plugin/index.php是插件配置文件，在后端应用框架函数apiMain中引入，内容示例如下：</p>
<pre><code>&lt;?php

Plugins::add([ "plugin1", "plugin2" ]);</code></pre>
<p>表示当前应用使用两个插件&quot;plugin1&quot;和&quot;plugin2&quot;, 分别对应目录 plugin/plugin1和plugin/plugin2.</p>
<p class="see"><strong>@see <a href="#Plugins::add">Plugins::add</a></strong> </p>
<p class="key"><strong>@key <a id="plugin.php">plugin.php</a></strong>  插件定义</p>
<p>插件实现在文件plugin/{pluginName}/plugin.php中，包括交互接口，以及插件API（后端调用接口），以优惠券插件&quot;coupon&quot;为例:</p>
<pre><code>&lt;?php

// 可选：定义插件API, 必须继承 PluginBase类
class PluginCoupon extends PluginBase
{
    // 声明插件API支持的事件, 如init, genCoupons事件：
    // @event PluginCoupon.event.init()
    // @event PluginCoupon.event.genCoupons($src)

    // 插件API函数
    // @fn PluginCoupon.func1($arg1)
    function func1($arg1)
    {
    }
}

// 实现函数型交互接口takeCoupon
function api_takeCoupon() {}

// 实现对象型交互接口 Coupon.query/get/set/del/add
class AC1_Coupon extends AccessControl {}

// 可选：返回插件配置
return [
    "js" =&gt; "m2/plugin.js", // 如果前端需要包含文件
    "class" =&gt; "PluginCoupon" // 如果提供插件内部接口
];</code></pre>
<p>注意：</p>
<ul>
<li>插件类必须继承PluginBase(包括单例、事件机制等方法)，它提供插件API，包括插件类提供的所有公共方法、属性和事件声明。<br />
应通过格式化注释(@fn, @event等)标识这些API。</li>
</ul>
<p>在插件内部获取插件实例可以用：</p>
<pre><code>    $plugin = PluginCoupon::getInstance();</code></pre>
<p>如果在插件外部则需要用：</p>
<pre><code>    $pluginCoupon = Plugins::getInstance('coupon');</code></pre>
<p>调用插件API函数：</p>
<pre><code>    $pluginCoupon-&gt;func1($arg1);</code></pre>
<p>监听或触发插件事件：</p>
<pre><code>    $pluginCoupon-&gt;on('init', 'onInit');
    $pluginCoupon-&gt;trigger('genCoupons', [$src]);</code></pre>
<p>事件命名规范与函数名相同，而事件处理函数的命名一般用&quot;on{事件名}&quot;.</p>
<p class="see"><strong>@see <a href="#PluginBase">PluginBase</a></strong> </p>
<ul>
<li>
<p>插件可以在构造函数__construct中初始化自身，例：</p>
<pre><code>// 可选的初始化过程, 注意使用private，保持单例特性（Singleton）
private function __construct()
{
    $this-&gt;trigger('init');
}</code></pre>
</li>
</ul>
<p>在应用初始化时（apiMain中），会创建所有插件类的实例（如果有的话）。</p>
<ul>
<li>交互接口应在插件设计文档(plugin/coupon/DESIGN.wiki)中定义原型。</li>
</ul><hr>
<h2 id="setRet">@fn setRet($code, $data?, $internalMsg?)</h2>
<p class="param"><strong>@param $code</strong>  Integer. 返回码, 0表示成功, 否则表示操作失败。</p>
<p class="param"><strong>@param $data</strong>  返回数据。</p>
<p class="param"><strong>@param $internalMsg</strong>  当返回错误时，作为额外调试信息返回。</p>
<p>设置返回数据，最终返回JSON格式数据为 [ code, data, internalMsg, debugInfo1, ...]<br />
其中按照BQP协议，前两项为必须，后面的内容一般仅用于调试，前端应用不应处理。</p>
<p>当成功时，返回数据可以是任何类型（根据API设计返回相应数据）。<br />
当失败时，为String类型错误信息。<br />
如果参数$data未指定，则操作成功时值为null（按BQP协议返回null表示客户端应忽略处理，一般无特定返回应指定$data=&quot;OK&quot;）；操作失败时使用默认错误信息。</p>
<p>调用完后，要返回的数据存储在全局数组 $X_RET 中，以JSON字符串形式存储在全局字符串 $X_RET_STR 中。<br />
注意：$X_RET_STR也可以在调用setRet前设置为要返回的字符串，从而避免setRet函数对返回对象进行JSON序列化，如</p>
<pre><code>$GLOBALS["X_RET_STR"] = "{id:100, name:'aaa'}";
setRet(0, "OK");
throw new DirectReturn();
// 最终返回字符串为 "[0, {id:100, name:'aaa'}]"</code></pre>
<p class="see"><strong>@see <a href="#$X_RET">$X_RET</a></strong> </p>
<p class="see"><strong>@see <a href="#$X_RET_STR">$X_RET_STR</a></strong> </p>
<p class="see"><strong>@see <a href="#$errorFn">$errorFn</a></strong> </p>
<p class="see"><strong>@see <a href="#errQuit">errQuit</a></strong> ()</p><hr>
<h2 id="setServerRev">@fn setServerRev()</h2>
<p>根据全局变量&quot;SERVER_REV&quot;或应用根目录下的文件&quot;revision.txt&quot;， 来设置HTTP响应头&quot;X-Daca-Server-Rev&quot;表示服务端版本信息（最多6位）。</p>
<p>客户端框架可本地缓存该版本信息，一旦发现不一致，可刷新应用。</p><hr>
<h2 id="ConfBase">@class ConfBase</h2>
<p>在conf.php中定义Conf类并继承ConfBase, 实现代码配置：</p>
<pre><code>class Conf extends ConfBase
{
}</code></pre>
<p class="key"><strong>@key <a id="Conf">Conf</a></strong>  项目易变逻辑</p>
<p class="key"><strong>@key <a id="conf.php">conf.php</a></strong>  项目易变逻辑</p>
<p>$BASE_DIR/conf.php中包含Conf类，用于定义易变的临时逻辑，例如数据库维护时报错提示，临时控制某个版本不能使用，遇到节假日休息提醒等等。</p>
<p>不变的全局配置应在app.php中定义。</p><hr>
<h2 id="ConfBase::$enableApiLog">@var ConfBase::$enableApiLog?=true</h2>
<p>设置为false可关闭ApiLog. 例：</p>
<pre><code>static $enableApiLog = false;</code></pre><hr>
<h2 id="ConfBase::onApiInit">@fn ConfBase::onApiInit()</h2>
<p>所有API执行时都会先走这里。</p>
<p>例：对所有API调用检查ios版本：</p>
<pre><code>static function onApiInit()
{
    $iosVer = getIosVersion();
    if ($iosVer !== false &amp;&amp; $iosVer&lt;=15) {
        throw new MyException(E_FORBIDDEN, "unsupport ios client version", "您使用的版本太低，请升级后使用!");
    }
}</code></pre><hr>
<h2 id="ConfBase::onInitClient">@fn ConfBase::onInitClient(&$ret)</h2>
<p>客户端初始化应用时会调用initClient接口，返回plugins等信息。若要加上其它信息，可在这里扩展。</p>
<p>例：假如定义应用初始化接口为(plugins是框架默认返回的)：</p>
<pre><code>initClient(app) -&gt; {plugins, appName}</code></pre>
<p>实现：</p>
<pre><code>static function onInitClient(&amp;$ret)
{
    $app = mparam('app');
    $ret['appName'] = 'my-app';
}</code></pre><hr>
<h2 id="PluginBase">@class PluginBase</h2>
<p>插件内部接口应继承该类, 它具有以下方法：</p>
<pre><code>static function getInstance();
funcion on($eventName, $eventHandler);
funcion trigger($eventName, array $args = []);</code></pre>
<p class="see"><strong>@see <a href="#JDSingleton">JDSingleton</a> <a href="#JDEvent">JDEvent</a></strong> </p>
<p class="see"><strong>@see <a href="#plugin/index.php">plugin/index.php</a></strong>  插件配置</p>
<p class="see"><strong>@see <a href="#plugin.php">plugin.php</a></strong>  插件定义</p><hr>
<h2 id="PluginBase.$colMap">@var PluginBase.$colMap</h2>
<p>%colMap = {tbl =&gt; [tblAlias, %cols]}<br />
cols = {col =&gt; colAlias}</p>
<p>先在插件接口文档DESIGN.wiki中声明本插件的数据库依赖：</p>
<pre><code>@see @Store: id, name, dscr
@see @Ordr: id</code></pre>
<p>在PluginCore::__construct中实现接口依赖，指定表名或列名对应（如果名称相同不必声明）</p>
<pre><code>function __construct() {
    $plugin1 = Plugins::getInstance('coupon');
    $plugin1-&gt;colMap = [
        "Store" =&gt; ["MyStore", [
            "dscr" =&gt; "description"
        ]],
        "Ordr" =&gt; ["MyOrder"]
    ];
}</code></pre>
<p>在plugin实现时，使用mapCol/mapSql来使表名、列名可配置：</p>
<pre><code>$plugin = PluginCoupon::getInstance();
$tbl = $plugin-&gt;mapCol("Store"); // $tbl="MyStore"
$tbl = $plugin-&gt;mapCol("User"); // $tbl="User" 未定义时，直接取原值
$col = $plugin-&gt;mapCol("Store.dscr"); // $col="description"
$col = $plugin-&gt;mapCol("Store.name"); // $col="name" 未定义时，直接取原值

$sql = $plugin-&gt;mapSql("SELECT s.id, s.{Store.name}, s.{Store.dscr} FROM {Store} s INNER JOIN {Ordr} o ON o.id=s.{Store.storeId}");
// $sql = "SELECT s.id, s.name, s.description FROM MyStore s INNER JOIN MyOrder o ON o.id=s.storeId"</code></pre>
<p class="key"><strong>@key <a id="PluginBase.mapCol">PluginBase.mapCol</a></strong> ($tbl, $col=null)</p>
<p class="key"><strong>@key <a id="PluginBase.mapSql">PluginBase.mapSql</a></strong> ($sql)</p><hr>
<h2 id="Plugins">@class Plugins</h2>
<p class="see"><strong>@see <a href="#plugin/index.php">plugin/index.php</a></strong> </p><hr>
<h2 id="Plugins::$map">@var Plugins::$map</h2><hr>
<h2 id="Plugins::add">@fn Plugins::add($plugins)</h2>
<p class="param"><strong>@param $plugins</strong>  ={ pluginName => {js, php, getInterface} }</p><hr>
<h2 id="Plugins::exists">@fn Plugins::exists($pluginName)</h2><hr>
<h2 id="Plugins::getInstance">@fn Plugins::getInstance($pluginName, $allowNull = false)</h2>
<p>获取插件类的实例，用于调用插件API。</p>
<p>假设有插件coupon, 一般可定义插件接口类 PluginCoupon如:</p>
<pre><code>class PluginCoupon extends PluginBase
{
}</code></pre>
<p>在插件内部，应直接调用 PluginCoupon::getInstance() 来获得插件实例。<br />
在插件外部才调用本函数。</p>
<p>注意：应通过在plugin.php最后返回的插件配置中指定插件类：</p>
<pre><code>[ 'class' =&gt; 'PluginCoupon' ]</code></pre>
<p>主应用作为特殊模块，名称为'core', 对应类为 PluginCore.</p><hr>
<h2 id="tableCRUD">@fn tableCRUD($ac, $tbl, $asAdmin?=false)</h2>
<p>对象型接口的入口。<br />
也可直接被调用，常与setParam一起使用, 提供一些定制的操作。</p>
<p class="param"><strong>@param $asAdmin</strong>  默认根据用户身份自动选择"AC_"类; 如果为true, 则以超级管理员身份调用，即使用"AC0_"类。</p>
<p>设置$asAdmin=true好处是对于超级管理员权限来说，即使未定义&quot;AC0_&quot;类，默认也可以访问所有内容。</p>
<p>假如有Rating（订单评价）对象，不想通过对象型接口来查询，而是通过函数型接口来定制输出，接口设计为：</p>
<pre><code>queryRating(storeId, cond?) -&gt; tbl(id, score, dscr, tm, orderDscr)

查询店铺storeId的订单评价。

应用逻辑：
- 按时间tm倒排序</code></pre>
<p>底层利用tableCRUD实现它，这样便于保留分页、参数cond/gres等特性:</p>
<pre><code>function api_queryRating()
{
    $storeId = mparam("storeId");

    // 定死输出内容。
    setParam("res", "id, score, dscr, tm, orderDscr");

    // 相当于AccessControl框架中调用 addCond，用Obj.query接口的内部参数cond2以保证用户还可以使用cond参数。
    setParam("cond2", ["o.storeId=$storeId"]); 

    // 定死排序条件
    setParam("orderby", "tm DESC");

    $ret = tableCRUD("query", "Rating", true);
    return $ret;
}</code></pre>
<p>注意：</p>
<ul>
<li>以上示例中的设计不可取，应使用标准对象接口来实现这个需求。</li>
</ul>
<p class="see"><strong>@see <a href="#setParam">setParam</a></strong> </p><hr>
<h2 id="AccessControl">@module AccessControl</h2><div class="toc"><p style="margin-left:0em"><a href="#AccessControl-1 基本权限控制">1 基本权限控制</a></p>
<p style="margin-left:0em"><a href="#AccessControl-2 虚拟字段">2 虚拟字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.1 关联字段">2.1 关联字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.2 关联字段依赖">2.2 关联字段依赖</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.3 计算字段">2.3 计算字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.4 子表压缩字段">2.4 子表压缩字段</a></p>
<p style="margin-left:2em"><a href="#AccessControl-2.5 自定义字段">2.5 自定义字段</a></p>
<p style="margin-left:0em"><a href="#AccessControl-3 子表">3 子表</a></p>
<p style="margin-left:0em"><a href="#AccessControl-4 操作完成回调">4 操作完成回调</a></p>
<p style="margin-left:0em"><a href="#AccessControl-5 其它">5 其它</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.1 编号自定义生成">5.1 编号自定义生成</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.2 缺省排序">5.2 缺省排序</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.3 缺省输出字段列表">5.3 缺省输出字段列表</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.4 最大每页数据条数">5.4 最大每页数据条数</a></p>
<p style="margin-left:2em"><a href="#AccessControl-5.5 虚拟表和视图">5.5 虚拟表和视图</a></p>
</div>
<p>对象型接口框架。<br />
AccessControl简写为AC，同时AC也表示自动补全(AutoComplete).</p>
<p>在设计文档中完成数据库设计后，通过添加AccessControl的继承类，可以很方便的提供诸如 {Obj}.query/add/get/set/del 这些对象型接口。</p>
<p>例如，设计文档中已定义订单对象(Ordr)的主表(Ordr)和订单日志子表(OrderLog)：</p>
<pre><code>@Ordr: id, userId, status, amount
@OrderLog: id, orderId, tm, dscr</code></pre>
<p>注意：之所以用对象和主表名用Ordr而不是Order词是避免与SQL关键字冲突。</p>
<p>有了表设计，订单的标准接口就已经自动生成好了：</p>
<pre><code>// 查询订单
Ordr.query() -&gt; tbl(id, userId, ...)
// 添加订单
Ordr.add()(userId=1, status='CR', amount=100) -&gt; id
// 查看订单
Ordr.get(id=1)
// 修改订单状态
Ordr.set(id=1)(status='PA')
// 删除订单
Ordr.del(id=1)</code></pre>
<p>但是，只有超级管理员登录后（例如从示例应用中的超级管理端登录后，web/adm.html），才有权限使用这些接口。</p>
<p>如果希望用户登录后，也可以使用这些接口，只要添加一个继承AccessControl的类，且命名为&quot;AC1_Ordr&quot;即可：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
}</code></pre>
<p>有了以上定义，在用户登录系统后，就可以使用上述和超级管理员一样的标准订单接口了。</p>
<p>说明：</p>
<p>类的命名规则为AC前缀加对象名（或主表名，因为对象名与主表名一致）。框架默认提供的前缀如下：</p>
<p class="key"><strong>@key <a id="AC_">AC_</a></strong>   游客权限(AUTH_GUEST)，如未定义则调用时报“无权操作”错误。</p>
<p class="key"><strong>@key <a id="AC0_">AC0_</a></strong>  超级管理员权限(AUTH_ADMIN)，如未定义，默认拥有所有权限。</p>
<p class="key"><strong>@key <a id="AC1_">AC1_</a></strong>   用户权限(AUTH_USER)，如未定义，则降级使用游客权限接口(AC_)。</p>
<p class="key"><strong>@key <a id="AC2_">AC2_</a></strong>   员工权限(AUTH_EMP/AUTH_MGR), 如未定义，报权限不足错误。</p>
<p>因而上例中命名为 &quot;AC1_Ordr&quot; 就表示用户登录后调用Ordr对象接口，将受该类控制。而这是个空的类，所以拥有一切操作权限。</p>
<p>框架为AUTH_ADMIN权限自动选择AC0_类，其它类可以通过函数 onCreateAC 进行自定义，仍未定义的框架使用AC_类。</p>
<p class="see"><strong>@see <a href="#onCreateAC">onCreateAC</a></strong> </p>
<h4 id="AccessControl-1 基本权限控制">1 基本权限控制</h4>
<p class="var"><strong>@var <a id="AccessControl::$allowedAc">AccessControl::$allowedAc</a></strong> ?=["add", "get", "set", "del", "query"] 设定允许的操作，如不指定，则允许所有操作。</p>
<p class="var"><strong>@var <a id="AccessControl::$readonlyFields">AccessControl::$readonlyFields</a></strong>  ?=[]  (影响add/set) 字段列表，添加/更新时为这些字段填值无效（但不报错）。</p>
<p class="var"><strong>@var <a id="AccessControl::$readonlyFields2">AccessControl::$readonlyFields2</a></strong>  ?=[]  (影响set操作) 字段列表，更新时对这些字段填值无效。</p>
<p class="var"><strong>@var <a id="AccessControl::$hiddenFields">AccessControl::$hiddenFields</a></strong>  ?= []  (for get/query) 隐藏字段列表。默认表中所有字段都可返回。一些敏感字段不希望返回的可在此设置。</p>
<p class="var"><strong>@var <a id="AccessControl::$requiredFields">AccessControl::$requiredFields</a></strong>  ?=[] (for add/set) 字段列表。添加时必须填值；更新时不允许置空。</p>
<p class="var"><strong>@var <a id="AccessControl::$requiredFields2">AccessControl::$requiredFields2</a></strong>  ?=[] (for set) 字段列表。更新时不允许设置空。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onQuery">AccessControl::onQuery</a></strong> () (for get/query)  用于对查询条件进行设定。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onValidate">AccessControl::onValidate</a></strong> ()  (for add/set). 验证添加和更新时的字段，或做自动补全(AutoComplete)工作。</p>
<p class="fn"><strong>@fn <a id="AccessControl::onValidateId">AccessControl::onValidateId</a></strong> () (for get/set/del) 用于对id字段进行检查。比如在del时检查用户是否有权操作该记录。</p>
<p>上节例子中，用户可以操作系统的所有订单。</p>
<p>现在我们到设计文档中，将接口API设计如下：</p>
<pre><code>== 订单接口 ==

添加订单：
Ordr.add()(amount) -&gt; id

查看订单：
Ordr.query() -&gt; tbl(id, userId, status, amount)
Ordr.get(id)

权限：AUTH_GUEST

应用逻辑
- 用户只能添加(add)、查看(get/query)订单，不可修改(set)、删除(del)订单
- 用户只能查看(get/query)属于自己的订单。
- 用户在添加订单时，必须设置amount字段，不必（也不允许）设置id, userId, status这些字段。
  服务器应将userId字段自动设置为该用户编号，status字段自动设置为"CR"（已创建）</code></pre>
<p>为实现以下逻辑，上面例子中代码可修改为：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $allowedAc = ["get", "query", "add"];
    protected $requiredFields = ["amount"];
    protected $readonlyFields = ["status", "userId"];

    protected function onQuery()
    {
        $userId = $_SESSION["uid"];
        $this-&gt;addCond("t0.userId={$userId}");
    }

    protected function onValidate()
    {
        if ($this-&gt;ac == "add") {
            $userId = $_SESSION["uid"];
            $_POST["userId"] = $userId;
            $_POST["status"] = "CR";
        }
    }
}</code></pre>
<p>说明：</p>
<ul>
<li>使用$allowedAc设定了该对象接口允许的操作。</li>
<li>使用$requiredFields与$readonlyFields设定了添加时必须指定或不可指定的字段。由于&quot;id&quot;字段默认就是不可添加/更新的，所以不必在这里指定。</li>
<li>在onQuery中，对用户可查看的订单做了限制：只允许访问自己的订单。这里通过添加了条件实现。<br />
$_SESSION[&quot;uid&quot;]是在用户登录后设置的，可参考login接口定义(api_login).</li>
<li>在onValidate中，对添加操作时的字段做自动补全。由于添加和更新都会走这个接口，所以用 $this-&gt;ac 判断只对添加操作时补全。<br />
由于添加和更新操作的具体字段都通过 $_POST 来传递，故直接设置 $_POST中的相应字段即可。</li>
</ul>
<h4 id="AccessControl-2 虚拟字段">2 虚拟字段</h4>
<p class="var"><strong>@var <a id="AccessControl::$vcolDefs">AccessControl::$vcolDefs</a></strong>  (for get/query) 定义虚拟字段</p>
<p>常用于展示关联表字段、统计字段等。<br />
在query,get操作中可以通过res参数指定需要返回的每个字段，这些字段可能是普通列名(col)/虚拟列名(vcol)/子对象(subobj)名。</p>
<h5 id="AccessControl-2.1 关联字段">2.1 关联字段</h5>
<p>例如，在订单列表中需要展示用户名字段。设计文档中定义接口：</p>
<pre><code>Ordr.query() -&gt; tbl(id, dscr, ..., userName?, userPhone?, createTm?)</code></pre>
<p>query接口的&quot;...&quot;之后就是虚拟字段。后缀&quot;?&quot;表示是非缺省字段，即必须在&quot;res&quot;参数中指定才会返回，如：</p>
<pre><code>Ordr.query(res="*,userName")</code></pre>
<p>在cond中可以直接使用虚拟字段，不管它是否在res中指定，如</p>
<pre><code>Ordr.query(cond="userName LIKE 'jian%'", res="id,dscr")</code></pre>
<p>通过设置$vcolDefs实现这些关联字段：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["u.name AS userName", "u.phone AS userPhone"],
            "join" =&gt; "INNER JOIN User u ON u.id=t0.userId",
            // "default" =&gt; false, // 指定true表示Ordr.query在不指定res时默认会返回该字段。一般不建议设置为true.
        ],
        [
            "res" =&gt; ["log_cr.tm AS createTm"],
            "join" =&gt; "LEFT JOIN OrderLog log_cr ON log_cr.action='CR' AND log_cr.orderId=t0.id",
        ]
    ]
}</code></pre>
<h5 id="AccessControl-2.2 关联字段依赖">2.2 关联字段依赖</h5>
<p>假设设计有“订单评价”对象，它会与“订单对象”相关联：</p>
<pre><code>@Rating: id, orderId, content</code></pre>
<p>表间的关系为：</p>
<pre><code>订单评价Rating(orderId) &lt;-&gt; 订单Ordr(userId) &lt;-&gt; 用户User</code></pre>
<p>现在要为Rating表增加关联字段 &quot;Ordr.dscr AS orderDscr&quot;, 以及&quot;User.name AS userName&quot;, 设计接口为：</p>
<pre><code>Rating.query() -&gt; tbl(id, orderId, content, ..., orderDscr?, userName?)
注意：userName字段不直接与Rating表关联，而是通过Ordr表桥接。</code></pre>
<p>实现时，只需在vcolDefs中使用require指定依赖字段：</p>
<pre><code>class AC1_Rating extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["o.dscr AS orderDscr", "o.userId"],
            "join" =&gt; "INNER JOIN Ordr o ON o.id=t0.orderId",
        ],
        [
            "res" =&gt; ["u.name AS userName"],
            "join" =&gt; "INNER JOIN User u ON o.userId=u.id",
            "require" =&gt; "userId", // *** 定义依赖，如果要用到res中的字段如userName，则自动添加userId字段引入的表关联。
            // 这里指向orderDscr也可以，一般习惯上指向关联的字段。
        ],
    ];
}</code></pre>
<p>使用require, 框架可自动将Ordr表作为中间表关联进来。<br />
如果没有require定义，以下调用</p>
<pre><code>Rating.query(res="*,orderDscr,userName")</code></pre>
<p>也不会出问题，因为在userName前指定了orderDscr，框架可自动引入相关表。而以下查询就会出问题：</p>
<pre><code>Rating.query(res="*,userName")
或
Rating.query(res="*,userName,orderDscr")</code></pre>
<h5 id="AccessControl-2.3 计算字段">2.3 计算字段</h5>
<p>示例：管理端应用在查询订单时，需要订单对象上有一个原价字段：</p>
<pre><code>Ordr.query() -&gt; tbl(..., amount2)
amount2:: 原价，通过OrderItem中每个项目重新计算累加得到，不考虑打折优惠。</code></pre>
<p>可实现为：</p>
<pre><code>class AC0_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["(SELECT SUM(qty*ifnull(price2,0)) FROM OrderItem WHERE orderId=t0.id) AS amount2"],
        ]
    ];
}</code></pre>
<h5 id="AccessControl-2.4 子表压缩字段">2.4 子表压缩字段</h5>
<p>除了使用<a href="#AccessControl::$subobj">子表</a>, 对于简单的情况，也可以设计为将子表压缩成一个虚拟字段，在Query操作时直接返回。</p>
<p>示例：OrderItem是Ordr对象的一个子表，现在想在查询Ordr对象列表时，返回OrderItem的相关信息。<br />
这就要把一张子表压缩成一个字段。我们使用List来描述这种压缩字段的格式：表中每行以&quot;,&quot;分隔，行中每个字段以&quot;:&quot;分隔。<br />
利用List，可将接口设计为：</p>
<pre><code>Ordr.query() -&gt; tbl(..., itemsInfo)
itemsInfo:: List(name, price, qty). 例如"洗车:25:1,换轮胎:380:2", 表示两行记录，每行3个字段。注意字段内容中不可出现":", ","这些分隔符。</code></pre>
<p>子表压缩是一种特殊的计算字段，可实现如下：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["(SELECT group_concat(concat(oi.name, ':', oi.price, ':', oi.qty)) FROM OrderItem oi WHERE oi.orderId=t0.id) itemsInfo"] 
        ],
        ...
    ]
}</code></pre>
<p>注意：计算字段，包括子表压缩字段都是很消耗性能的。</p>
<h5 id="AccessControl-2.5 自定义字段">2.5 自定义字段</h5>
<p>假设有张虚拟表Task, 它没有存储在数据库中, 另一张表UserTaskLog关联到它。在设计文档中定义如下:</p>
<pre><code>@UserTaskLog: id, userId, taskId
@Conf::$taskTable: id, type, name
(关联： UserTaskLog(taskId) &lt;-&gt; Conf::$taskTable )

提供查询接口：
UserTaskLog.query() -&gt; tbl(id, taskId, ..., taskName)
taskName:: 由关联表的taskTable.name字段得到。</code></pre>
<p>实现中，在代码中直接定义Task表：</p>
<pre><code>class Conf
{
    static $taskTable = [
        ["id" =&gt; 1, "type"=&gt;"invite", "name" =&gt; "邀请5个用户注册"],
        ["id" =&gt; 2, "type"=&gt;"invite", "name" =&gt; "邀请10个用户注册"],
    ];
}</code></pre>
<p>通过在vcolDefs的join属性指定一个函数，可以实现返回taskName字段：</p>
<pre><code>function getTaskName(&amp;$row)
{
    foreach (Conf::$taskTable as $task) {
        if ($row["taskId"] == $task["id"]) {
            $row["taskName"] = $task["name"];
        }
    }
}

class AC1_UserTaskLog extends AccessControl
{
    protected $vcolDefs = [
        [
            "res" =&gt; ["taskName"],
            "join" =&gt; getTaskName
        ]
    ];
}</code></pre>
<p>注意:</p>
<ul>
<li>自定义字段只限于对query/get的最终结果集进行操作</li>
<li>自定义字段不能用于设置cond条件.</li>
</ul>
<h4 id="AccessControl-3 子表">3 子表</h4>
<p class="var"><strong>@var <a id="AccessControl::$subobj">AccessControl::$subobj</a></strong>  (for get/query) 定义子表</p>
<p>设计接口：</p>
<pre><code>Ordr.get() -&gt; {id, ..., @orderLog}
orderLog:: {id, tm, dscr, ..., empName} 订单日志子表。</code></pre>
<p>实现：</p>
<pre><code>class AC1_Ordr extends AccessControl
{
    protected $subobj = [
        "orderLog" =&gt; ["sql"=&gt;"SELECT ol.*, e.name AS empName FROM OrderLog ol LEFT JOIN Employee e ON ol.empId=e.id WHERE orderId=%d", "wantOne"=&gt;false],
    ];
}</code></pre>
<p>子表一般通过get操作来获取，执行指定的SQL语句作为结果。结果以一个数组返回[{id, tm, ...}]，如果指定wantOne=&gt;true, 则结果以一个对象返回即 {id, tm, ...}, 适用于主表与子表一对一的情况。</p>
<p>通过在Query操作上指定参数{wantArray:1}也可以返回子表，但目前不支持分页等操作。</p>
<h4 id="AccessControl-4 操作完成回调">4 操作完成回调</h4>
<p class="fn"><strong>@fn <a id="AccessControl::onAfter">AccessControl::onAfter</a></strong> (&$ret)  (for all) 操作完成时的回调。可修改操作结果ret。</p>
<p>如果要对get/query结果中的每行字段进行设置，应重写回调 onHandleRow.<br />
有时使用 onAfterActions 就近添加逻辑更加方便。</p>
<p class="var"><strong>@var <a id="AccessControl::$onAfterActions">AccessControl::$onAfterActions</a></strong>  =[].  onAfter的替代方案，更易使用，便于与接近的逻辑写在一起。</p>
<p class="var"><strong>@var <a id="AccessControl::$id">AccessControl::$id</a></strong>   get/set/del时指定的id, 或add后返回的id.</p>
<p>例如，添加订单时，自动添加一条日志，可以用：</p>
<pre><code>protected function onValidate()
{
    if ($this-&gt;ac == "add") {
        ... 

        $this-&gt;onAfterActions[] = function () use ($logAction) {
            $orderId = $this-&gt;id;
            $sql = sprintf("INSERT INTO OrderLog (orderId, action, tm) VALUES ({$orderId},'CR','%s')", date('c'));
            execOne($sql);
        };
    }
}</code></pre>
<p class="fn"><strong>@fn <a id="AccessControl::onHandleRow">AccessControl::onHandleRow</a></strong> (&$rowData) (for get/query) 在onAfter之前运行，用于修改行中字段。</p>
<h4 id="AccessControl-5 其它">5 其它</h4>
<h5 id="AccessControl-5.1 编号自定义生成">5.1 编号自定义生成</h5>
<p class="fn"><strong>@fn <a id="AccessControl::onGenId">AccessControl::onGenId</a></strong> () (for add) 指定添加对象时生成的id. 缺省返回0表示自动生成.</p>
<h5 id="AccessControl-5.2 缺省排序">5.2 缺省排序</h5>
<p class="fn"><strong>@fn <a id="AccessControl::getDefaultSort">AccessControl::getDefaultSort</a></strong> ()  (for query)取缺省排序.</p>
<p class="var"><strong>@var <a id="AccessControl::$defaultSort">AccessControl::$defaultSort</a></strong>  ?= "t0.id" (for query)指定缺省排序.</p>
<p>示例：Video对象默认按id倒序排列：</p>
<pre><code>class AC_Video extends AccessControl 
{
    protected $defaultSort = "t0.id DESC";
    ...
}</code></pre>
<h5 id="AccessControl-5.3 缺省输出字段列表">5.3 缺省输出字段列表</h5>
<p class="var"><strong>@var <a id="AccessControl::$defaultRes">AccessControl::$defaultRes</a></strong>  (for query)指定缺省输出字段列表. 如果不指定，则为 "t0.*" 加  default=true的虚拟字段</p>
<h5 id="AccessControl-5.4 最大每页数据条数">5.4 最大每页数据条数</h5>
<p class="fn"><strong>@fn <a id="AccessControl::getMaxPageSz">AccessControl::getMaxPageSz</a></strong> ()  (for query) 取最大每页数据条数。为非负整数。</p>
<p class="var"><strong>@var <a id="AccessControl::$maxPageSz">AccessControl::$maxPageSz</a></strong>  ?= 100 (for query) 指定最大每页数据条数。值为负数表示取PAGE_SZ_LIMIT值.</p>
<p>前端通过 {obj}.query(_pagesz)来指定每页返回多少条数据，缺省是20条，最高不可超过100条。当指定为负数时，表示按最大允许值=min($maxPageSz, PAGE_SZ_LIMIT)返回。<br />
PAGE_SZ_LIMIT目前定为10000条。如果还不够，一定是应用设计有问题。</p>
<p>如果想返回每页超过100条数据，必须在后端设置，如：</p>
<pre><code>class MyObj extends AccessControl
{
    protected $maxPageSz = 1000; // 最大允许返回1000条
    // protected $maxPageSz = -1; // 最大允许返回 PAGE_SZ_LIMIT 条
}</code></pre>
<p class="var"><strong>@var <a id="PAGE_SZ_LIMIT">PAGE_SZ_LIMIT</a></strong>  =10000</p>
<h5 id="AccessControl-5.5 虚拟表和视图">5.5 虚拟表和视图</h5>
<p>假如要对ApiLog进行过滤，只查询管理端的写操作。实现以下接口：</p>
<pre><code>EmpLog.query() -&gt; tbl(id, tm, userId, ac, req, res, reqsz, ressz, empName?, empPhone?)</code></pre>
<p>一种办法可以在后台定义一个视图，如:</p>
<pre><code>CREATE VIEW EmpLog AS
SELECT t0.id, tm, userId, ac, req, res, reqsz, ressz, e.name empName, e.phone empPhone
FROM ApiLog t0
LEFT JOIN Employee e ON e.id=t0.userId
WHERE t0.app='emp-adm' AND t0.userId IS NOT NULL
ORDER BY t0.id DESC</code></pre>
<p>然后可将该视图当作表一样查询（但不可更新），如：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
}</code></pre>
<p>这样就可以实现上述接口了。</p>
<p>另一种办法是直接使用AccessControl创建虚拟表，代码如下：</p>
<pre><code>class AC2_EmpLog extends AccessControl 
{
    protected $allowedAc = ["query"];
    protected $table = 'ApiLog';
    protected $defaultSort = "t0.id DESC";
    protected $defaultRes = "id, tm, userId, ac, req, res, reqsz, ressz, empName, empPhone";
    protected $vcolDefs = [
        [
            "res" =&gt; ["e.name AS empName", "e.phone AS empPhone"],
            "join" =&gt; "LEFT JOIN Employee e ON e.id=t0.userId"
        ]
    ];

    protected function onQuery() {
        $this-&gt;addCond("t0.app='emp-adm' and t0.userId IS NOT NULL");
    }
}</code></pre>
<p>与上例相比，它不仅无须在数据库中创建视图，还也可以进行更新。<br />
其要点是：</p>
<ul>
<li>重写 AccessControl::$table</li>
<li>重写 AccessControl::$defaultRes</li>
<li>用addCond添加缺省查询条件</li>
</ul><hr>
<h2 id="AccessControl::addRes">@fn AccessControl::addRes($res, $analyzeCol=true)</h2>
<p>添加列或计算列. </p>
<p>注意: </p>
<ul>
<li>analyzeCol=true时, addRes(&quot;col&quot;); -- (analyzeCol=true) 添加一列, 注意:如果列是一个虚拟列(在vcolDefs中有定义), 不能指定alias, 且vcolDefs中同一组Res中所有定义的列都会加入查询; 如果希望只加一列且能定义alias, 可调用addVCol函数.</li>
<li>addRes(&quot;col+1 as col1&quot;, false); -- 简单地新定义一个计算列, as可省略</li>
</ul>
<p class="see"><strong>@see <a href="#AccessControl::addCond">AccessControl::addCond</a></strong>  其中有示例</p>
<p class="see"><strong>@see <a href="#AccessControl::addVCol">AccessControl::addVCol</a></strong>  添加已定义的虚拟列。</p><hr>
<h2 id="AccessControl::addCond">@fn AccessControl::addCond($cond, $prepend=false)</h2>
<p class="param"><strong>@param $prepend</strong>  为true时将条件排到前面。</p>
<p>调用多次addCond时，多个条件会依次用&quot;AND&quot;连接起来。</p>
<p>添加查询条件。<br />
示例：假如设计有接口：</p>
<pre><code>Ordr.query(q?) -&gt; tbl(..., payTm?)
参数：
q:: 查询条件，值为"paid"时，查询10天内已付款的订单。且结果会多返回payTm/付款时间字段。</code></pre>
<p>实现时，在onQuery中检查参数&quot;q&quot;并定制查询条件：</p>
<pre><code>protected function onQuery()
{
    // 限制只能看用户自己的订单
    $uid = $_SESSION["uid"];
    $this-&gt;addCond("t0.userId=$uid");

    $q = param("q");
    if (isset($q) &amp;&amp; $q == "paid") {
        $validDate = date("Y-m-d", strtotime("-9 day"));
        $this-&gt;addRes("olpay.tm payTm");
        $this-&gt;addJoin("INNER JOIN OrderLog olpay ON olpay.orderId=t0.id");
        $this-&gt;addCond("olpay.action='PA' AND olpay.tm&gt;'$validDate'");
    }
}</code></pre>
<p class="see"><strong>@see <a href="#AccessControl::addRes">AccessControl::addRes</a></strong> </p>
<p class="see"><strong>@see <a href="#AccessControl::addJoin">AccessControl::addJoin</a></strong> </p><hr>
<h2 id="AccessControl::addJoin">@fn AccessControl::addJoin(joinCond)</h2>
<p>添加Join条件.</p>
<p class="see"><strong>@see <a href="#AccessControl::addCond">AccessControl::addCond</a></strong>  其中有示例</p><hr>
<h2 id="AccessControl::addVCol">@fn AccessControl::addVCol($col, $ignoreError=false, $alias=null)</h2>
<p class="param"><strong>@param $col</strong>  必须是一个英文词, 不允许"col as col1"形式; 该列必须在 vcolDefs 中已定义.</p>
<p class="param"><strong>@param $alias</strong>  列的别名。可以中文. 特殊字符"-"表示不加到最终res中(只添加join/cond等定义), 由addVColDef内部调用时使用.</p>
<p class="return"><strong>@return Boolean</strong>  T/F</p>
<p>用于AccessControl子类添加已在vcolDefs中定义的vcol. 一般应先考虑调用addRes(col)函数.</p>
<p class="see"><strong>@see <a href="#AccessControl::addRes">AccessControl::addRes</a></strong> </p><hr>
<h2 id="callSvc">@fn callSvc($ac?, $urlParam?, $postParam?, $cleanCall?=false, $hideResult?=false)</h2>
<p>直接调用接口，返回数据。如果出错，将调用$GLOBALS['errorFn'] (缺省为errQuit).</p>
<p class="param"><strong>@param $cleanCall</strong>  Boolean. 如果为true, 则不使用现有的$_GET, $_POST等变量中的值。</p>
<p class="param"><strong>@param $hideResult</strong>  Boolean. 如果为true, 不输出结果。</p><hr>
<div style="text-align:center">Generated by jdcloud-gendoc</div>
</html>